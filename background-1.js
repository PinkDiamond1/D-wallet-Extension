LavaPack.loadBundle([
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-state-manager.js", {"../../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","../../../../shared/modules/random-id":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/random-id.js","../../../../shared/modules/transaction.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/transaction.utils.js","../../metamask-controller":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/metamask-controller.js","./lib/tx-state-history-helpers":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/tx-state-history-helpers.js","./lib/util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/lib/util.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","lodash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash/lodash.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-state-manager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _obsStore = require("@metamask/obs-store");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _lodash = require("lodash");

var _randomId = _interopRequireDefault(require("../../../../shared/modules/random-id"));

var _transaction = require("../../../../shared/constants/transaction");

var _metamaskController = require("../../metamask-controller");

var _transaction2 = require("../../../../shared/modules/transaction.utils");

var _txStateHistoryHelpers = require("./lib/tx-state-history-helpers");

var _util = require("./lib/util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * TransactionStatuses reimported from the shared transaction constants file
 * @typedef {__import__(
 *  '../../../../shared/constants/transaction'
 * ).TransactionStatusString} TransactionStatusString
 */

/**
 * @typedef {__import__('../../../../shared/constants/transaction').TxParams} TxParams
 */

/**
 * @typedef {__import__(
 *  '../../../../shared/constants/transaction'
 * ).TransactionMeta} TransactionMeta
 */

/**
 * @typedef {Object} TransactionState
 * @property {Record<string, TransactionMeta>} transactions - TransactionMeta
 *  keyed by the transaction's id.
 */

/**
 * TransactionStateManager is responsible for the state of a transaction and
 * storing the transaction. It also has some convenience methods for finding
 * subsets of transactions.
 * @param {Object} opts
 * @param {TransactionState} [opts.initState={ transactions: {} }] - initial
 *  transactions list keyed by id
 * @param {number} [opts.txHistoryLimit] - limit for how many finished
 *  transactions can hang around in state
 * @param {Function} opts.getNetwork - return network number
 * @class
 */
class TransactionStateManager extends _safeEventEmitter.default {
  constructor({
    initState,
    txHistoryLimit,
    getNetwork,
    getCurrentChainId
  }) {
    super();
    this.store = new _obsStore.ObservableStore(_objectSpread({
      transactions: {}
    }, initState));
    this.txHistoryLimit = txHistoryLimit;
    this.getNetwork = getNetwork;
    this.getCurrentChainId = getCurrentChainId;
  }
  /**
   * Generates a TransactionMeta object consisting of the fields required for
   * use throughout the extension. The argument here will override everything
   * in the resulting transaction meta.
   *
   * TODO: Don't overwrite everything?
   *
   * @param {Partial<TransactionMeta>} opts - the object to use when
   *  overwriting default keys of the TransactionMeta
   * @returns {TransactionMeta} the default txMeta object
   */


  generateTxMeta(opts = {}) {
    const netId = this.getNetwork();
    const chainId = this.getCurrentChainId();

    if (netId === 'loading') {
      throw new Error('MetaMask is having trouble connecting to the network');
    }

    let dappSuggestedGasFees = null; // If we are dealing with a transaction suggested by a dapp and not
    // an internally created metamask transaction, we need to keep record of
    // the originally submitted gasParams.

    if (opts.txParams && typeof opts.origin === 'string' && opts.origin !== 'metamask') {
      if (typeof opts.txParams.gasPrice !== 'undefined') {
        dappSuggestedGasFees = {
          gasPrice: opts.txParams.gasPrice
        };
      } else if (typeof opts.txParams.maxFeePerGas !== 'undefined' || typeof opts.txParams.maxPriorityFeePerGas !== 'undefined') {
        dappSuggestedGasFees = {
          maxPriorityFeePerGas: opts.txParams.maxPriorityFeePerGas,
          maxFeePerGas: opts.txParams.maxFeePerGas
        };
      }

      if (typeof opts.txParams.gas !== 'undefined') {
        dappSuggestedGasFees = _objectSpread(_objectSpread({}, dappSuggestedGasFees), {}, {
          gas: opts.txParams.gas
        });
      }
    }

    return _objectSpread({
      id: (0, _randomId.default)(),
      time: new Date().getTime(),
      status: _transaction.TRANSACTION_STATUSES.UNAPPROVED,
      metamaskNetworkId: netId,
      chainId,
      loadingDefaults: true,
      dappSuggestedGasFees
    }, opts);
  }
  /**
   * Get an object containing all unapproved transactions for the current
   * network. This is the only transaction fetching method that returns an
   * object, so it doesn't use getTransactions like everything else.
   *
   * @returns {Record<string, TransactionMeta>} Unapproved transactions keyed
   *  by id
   */


  getUnapprovedTxList() {
    const chainId = this.getCurrentChainId();
    const network = this.getNetwork();
    return (0, _lodash.pickBy)(this.store.getState().transactions, transaction => transaction.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network));
  }
  /**
   * Get all approved transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getApprovedTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.APPROVED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Get all pending transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getPendingTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.SUBMITTED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Get all confirmed transactions for the current network. If an address is
   * provided, the list will be further refined to only those transactions
   * originating from the supplied address.
   *
   * @param {string} [address] - hex prefixed address to find transactions for.
   * @returns {TransactionMeta[]} the filtered list of transactions
   */


  getConfirmedTransactions(address) {
    const searchCriteria = {
      status: _transaction.TRANSACTION_STATUSES.CONFIRMED
    };

    if (address) {
      searchCriteria.from = address;
    }

    return this.getTransactions({
      searchCriteria
    });
  }
  /**
   * Adds the txMeta to the list of transactions in the store.
   * if the list is over txHistoryLimit it will remove a transaction that
   * is in its final state.
   * it will also add the key `history` to the txMeta with the snap shot of
   * the original object
   * @param {TransactionMeta} txMeta - The TransactionMeta object to add.
   * @returns {TransactionMeta} The same TransactionMeta, but with validated
   *  txParams and transaction history.
   */


  addTransaction(txMeta) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = (0, _util.normalizeAndValidateTxParams)(txMeta.txParams, false);
    }

    this.once(`${txMeta.id}:signed`, () => {
      this.removeAllListeners(`${txMeta.id}:rejected`);
    });
    this.once(`${txMeta.id}:rejected`, () => {
      this.removeAllListeners(`${txMeta.id}:signed`);
    }); // initialize history

    txMeta.history = []; // capture initial snapshot of txMeta for history

    const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
    txMeta.history.push(snapshot);
    const transactions = this.getTransactions({
      filterToCurrentNetwork: false
    });
    const {
      txHistoryLimit
    } = this; // checks if the length of the tx history is longer then desired persistence
    // limit and then if it is removes the oldest confirmed or rejected tx.
    // Pending or unapproved transactions will not be removed by this
    // operation. For safety of presenting a fully functional transaction UI
    // representation, this function will not break apart transactions with the
    // same nonce, per network. Not accounting for transactions of the same
    // nonce and network combo can result in confusing or broken experiences
    // in the UI.
    //
    // TODO: we are already limiting what we send to the UI, and in the future
    // we will send UI only collected groups of transactions *per page* so at
    // some point in the future, this persistence limit can be adjusted. When
    // we do that I think we should figure out a better storage solution for
    // transaction history entries.

    const nonceNetworkSet = new Set();
    const txsToDelete = transactions.reverse().filter(tx => {
      const {
        nonce
      } = tx.txParams;
      const {
        chainId,
        metamaskNetworkId,
        status
      } = tx;
      const key = `${nonce}-${chainId !== null && chainId !== void 0 ? chainId : metamaskNetworkId}`;

      if (nonceNetworkSet.has(key)) {
        return false;
      } else if (nonceNetworkSet.size < txHistoryLimit - 1 || (0, _util.getFinalStates)().includes(status) === false) {
        nonceNetworkSet.add(key);
        return false;
      }

      return true;
    }).map(tx => tx.id);

    this._deleteTransactions(txsToDelete);

    this._addTransactionsToState([txMeta]);

    return txMeta;
  }
  /**
   * @param {number} txId
   * @returns {TransactionMeta} the txMeta who matches the given id if none found
   * for the network returns undefined
   */


  getTransaction(txId) {
    const {
      transactions
    } = this.store.getState();
    return transactions[txId];
  }
  /**
   * updates the txMeta in the list and adds a history entry
   * @param {Object} txMeta - the txMeta to update
   * @param {string} [note] - a note about the update for history
   */


  updateTransaction(txMeta, note) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = (0, _util.normalizeAndValidateTxParams)(txMeta.txParams, false);
    } // create txMeta snapshot for history


    const currentState = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta); // recover previous tx state obj

    const previousState = (0, _txStateHistoryHelpers.replayHistory)(txMeta.history); // generate history entry and add to history

    const entry = (0, _txStateHistoryHelpers.generateHistoryEntry)(previousState, currentState, note);

    if (entry.length) {
      txMeta.history.push(entry);
    } // commit txMeta to state


    const txId = txMeta.id;
    this.store.updateState({
      transactions: _objectSpread(_objectSpread({}, this.store.getState().transactions), {}, {
        [txId]: txMeta
      })
    });
  }
  /**
   * SearchCriteria can search in any key in TxParams or the base
   * TransactionMeta. This type represents any key on either of those two
   * types.
   * @typedef {TxParams[keyof TxParams] | TransactionMeta[keyof TransactionMeta]} SearchableKeys
   */

  /**
   * Predicates can either be strict values, which is shorthand for using
   * strict equality, or a method that receives he value of the specified key
   * and returns a boolean.
   * @typedef {(v: unknown) => boolean | unknown} FilterPredicate
   */

  /**
   * Retrieve a list of transactions from state. By default this will return
   * the full list of Transactions for the currently selected chain/network.
   * Additional options can be provided to change what is included in the final
   * list.
   *
   * @param opts - options to change filter behavior
   * @param {Record<SearchableKeys, FilterPredicate>} [opts.searchCriteria] -
   *  an object with keys that match keys in TransactionMeta or TxParams, and
   *  values that are predicates. Predicates can either be strict values,
   *  which is shorthand for using strict equality, or a method that receives
   *  the value of the specified key and returns a boolean. The transaction
   *  list will be filtered to only those items that the predicate returns
   *  truthy for. **HINT**: `err: undefined` is like looking for a tx with no
   *  err. so you can also search txs that don't have something as well by
   *  setting the value as undefined.
   * @param {TransactionMeta[]} [opts.initialList] - If provided the filtering
   *  will occur on the provided list. By default this will be the full list
   *  from state sorted by time ASC.
   * @param {boolean} [opts.filterToCurrentNetwork=true] - Filter transaction
   *  list to only those that occurred on the current chain or network.
   *  Defaults to true.
   * @param {number} [opts.limit] - limit the number of transactions returned
   *  to N unique nonces.
   * @returns {TransactionMeta[]} The TransactionMeta objects that all provided
   *  predicates return truthy for.
   */


  getTransactions({
    searchCriteria = {},
    initialList,
    filterToCurrentNetwork = true,
    limit
  } = {}) {
    const chainId = this.getCurrentChainId();
    const network = this.getNetwork(); // searchCriteria is an object that might have values that aren't predicate
    // methods. When providing any other value type (string, number, etc), we
    // consider this shorthand for "check the value at key for strict equality
    // with the provided value". To conform this object to be only methods, we
    // mapValues (lodash) such that every value on the object is a method that
    // returns a boolean.

    const predicateMethods = (0, _lodash.mapValues)(searchCriteria, predicate => {
      return typeof predicate === 'function' ? predicate : v => v === predicate;
    }); // If an initial list is provided we need to change it back into an object
    // first, so that it matches the shape of our state. This is done by the
    // lodash keyBy method. This is the edge case for this method, typically
    // initialList will be undefined.

    const transactionsToFilter = initialList ? (0, _lodash.keyBy)(initialList, 'id') : this.store.getState().transactions; // Combine sortBy and pickBy to transform our state object into an array of
    // matching transactions that are sorted by time.

    const filteredTransactions = (0, _lodash.sortBy)((0, _lodash.pickBy)(transactionsToFilter, transaction => {
      // default matchesCriteria to the value of transactionMatchesNetwork
      // when filterToCurrentNetwork is true.
      if (filterToCurrentNetwork && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network) === false) {
        return false;
      } // iterate over the predicateMethods keys to check if the transaction
      // matches the searchCriteria


      for (const [key, predicate] of Object.entries(predicateMethods)) {
        // We return false early as soon as we know that one of the specified
        // search criteria do not match the transaction. This prevents
        // needlessly checking all criteria when we already know the criteria
        // are not fully satisfied. We check both txParams and the base
        // object as predicate keys can be either.
        if (key in transaction.txParams) {
          if (predicate(transaction.txParams[key]) === false) {
            return false;
          }
        } else if (predicate(transaction[key]) === false) {
          return false;
        }
      }

      return true;
    }), 'time');

    if (limit !== undefined) {
      // We need to have all transactions of a given nonce in order to display
      // necessary details in the UI. We use the size of this set to determine
      // whether we have reached the limit provided, thus ensuring that all
      // transactions of nonces we include will be sent to the UI.
      const nonces = new Set();
      const txs = []; // By default, the transaction list we filter from is sorted by time ASC.
      // To ensure that filtered results prefers the newest transactions we
      // iterate from right to left, inserting transactions into front of a new
      // array. The original order is preserved, but we ensure that newest txs
      // are preferred.

      for (let i = filteredTransactions.length - 1; i > -1; i--) {
        const txMeta = filteredTransactions[i];
        const {
          nonce
        } = txMeta.txParams;

        if (!nonces.has(nonce)) {
          if (nonces.size < limit) {
            nonces.add(nonce);
          } else {
            continue;
          }
        } // Push transaction into the beginning of our array to ensure the
        // original order is preserved.


        txs.unshift(txMeta);
      }

      return txs;
    }

    return filteredTransactions;
  }
  /**
   * Update status of the TransactionMeta with provided id to 'rejected'.
   * After setting the status, the TransactionMeta is deleted from state.
   *
   * TODO: Should we show historically rejected transactions somewhere in the
   * UI? Seems like it could be valuable for information purposes. Of course
   * only after limit issues are reduced.
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusRejected(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.REJECTED);

    this._deleteTransaction(txId);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'unapproved'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusUnapproved(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.UNAPPROVED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'approved'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusApproved(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.APPROVED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'signed'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusSigned(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.SIGNED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'submitted'
   * and sets the 'submittedTime' property with the current Unix epoch time.
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusSubmitted(txId) {
    const txMeta = this.getTransaction(txId);
    txMeta.submittedTime = new Date().getTime();
    this.updateTransaction(txMeta, 'txStateManager - add submitted time stamp');

    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.SUBMITTED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'confirmed'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusConfirmed(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.CONFIRMED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'dropped'
   *
   * @param {number} txId - the target TransactionMeta's Id
   */


  setTxStatusDropped(txId) {
    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.DROPPED);
  }
  /**
   * Update status of the TransactionMeta with provided id to 'failed' and put
   * the error on the TransactionMeta object.
   *
   * @param {number} txId - the target TransactionMeta's Id
   * @param {Error} err - error object
   */


  setTxStatusFailed(txId, err) {
    var _error$message;

    const error = err || new Error('Internal metamask failure');
    const txMeta = this.getTransaction(txId);
    txMeta.err = {
      message: ((_error$message = error.message) === null || _error$message === void 0 ? void 0 : _error$message.toString()) || error.toString(),
      rpc: error.value,
      stack: error.stack
    };
    this.updateTransaction(txMeta, 'transactions:tx-state-manager#fail - add error');

    this._setTransactionStatus(txId, _transaction.TRANSACTION_STATUSES.FAILED);
  }
  /**
   * Removes all transactions for the given address on the current network,
   * preferring chainId for comparison over networkId.
   *
   * @param {string} address - hex string of the from address on the txParams
   *  to remove
   */


  wipeTransactions(address) {
    // network only tx
    const {
      transactions
    } = this.store.getState();
    const network = this.getNetwork();
    const chainId = this.getCurrentChainId(); // Update state

    this.store.updateState({
      transactions: (0, _lodash.omitBy)(transactions, transaction => transaction.txParams.from === address && (0, _transaction2.transactionMatchesNetwork)(transaction, chainId, network))
    });
  }
  /**
   * Filters out the unapproved transactions from state
   */


  clearUnapprovedTxs() {
    this.store.updateState({
      transactions: (0, _lodash.omitBy)(this.store.getState().transactions, transaction => transaction.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED)
    });
  } //
  //           PRIVATE METHODS
  //

  /**
   * Updates a transaction's status in state, and then emits events that are
   * subscribed to elsewhere. See below for best guesses on where and how these
   * events are received.
   * @param {number} txId - the TransactionMeta Id
   * @param {TransactionStatusString} status - the status to set on the
   *  TransactionMeta
   * @emits txMeta.id:txMeta.status - every time a transaction's status changes
   *  we emit the change passing along the id. This does not appear to be used
   *  outside of this file, which only listens to this to unsubscribe listeners
   *  of :rejected and :signed statuses when the inverse status changes. Likely
   *  safe to drop.
   * @emits tx:status-update - every time a transaction's status changes we
   *  emit this event and pass txId and status. This event is subscribed to in
   *  the TransactionController and re-broadcast by the TransactionController.
   *  It is used internally within the TransactionController to try and update
   *  pending transactions on each new block (from blockTracker). It's also
   *  subscribed to in metamask-controller to display a browser notification on
   *  confirmed or failed transactions.
   * @emits txMeta.id:finished - When a transaction moves to a finished state
   *  this event is emitted, which is used in the TransactionController to pass
   *  along details of the transaction to the dapp that suggested them. This
   *  pattern is replicated across all of the message managers and can likely
   *  be supplemented or replaced by the ApprovalController.
   * @emits updateBadge - When the number of transactions changes in state,
   *  the badge in the browser extension bar should be updated to reflect the
   *  number of pending transactions. This particular emit doesn't appear to
   *  bubble up anywhere that is actually used. TransactionController emits
   *  this *anytime the state changes*, so this is probably superfluous.
   */


  _setTransactionStatus(txId, status) {
    const txMeta = this.getTransaction(txId);

    if (!txMeta) {
      return;
    }

    txMeta.status = status;

    try {
      this.updateTransaction(txMeta, `txStateManager: setting status to ${status}`);
      this.emit(`${txMeta.id}:${status}`, txId);
      this.emit(`tx:status-update`, txId, status);

      if ([_transaction.TRANSACTION_STATUSES.SUBMITTED, _transaction.TRANSACTION_STATUSES.REJECTED, _transaction.TRANSACTION_STATUSES.FAILED].includes(status)) {
        this.emit(`${txMeta.id}:finished`, txMeta);
      }

      this.emit(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE);
    } catch (error) {
      _loglevel.default.error(error);
    }
  }
  /**
   * Adds one or more transactions into state. This is not intended for
   * external use.
   *
   * @private
   * @param {TransactionMeta[]} transactions - the list of transactions to save
   */


  _addTransactionsToState(transactions) {
    this.store.updateState({
      transactions: transactions.reduce((result, newTx) => {
        result[newTx.id] = newTx;
        return result;
      }, this.store.getState().transactions)
    });
  }
  /**
   * removes one transaction from state. This is not intended for external use.
   *
   * @private
   * @param {number} targetTransactionId - the transaction to delete
   */


  _deleteTransaction(targetTransactionId) {
    const {
      transactions
    } = this.store.getState();
    delete transactions[targetTransactionId];
    this.store.updateState({
      transactions
    });
  }
  /**
   * removes multiple transaction from state. This is not intended for external use.
   *
   * @private
   * @param {number[]} targetTransactionIds - the transactions to delete
   */


  _deleteTransactions(targetTransactionIds) {
    const {
      transactions
    } = this.store.getState();
    targetTransactionIds.forEach(transactionId => {
      delete transactions[transactionId];
    });
    this.store.updateState({
      transactions
    });
  }

}

exports.default = TransactionStateManager;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/tx-state-manager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/pending-tx-tracker.js", {"../../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","ethjs-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethjs-query/lib/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/pending-tx-tracker.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _safeEventEmitter = _interopRequireDefault(require("safe-event-emitter"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethjsQuery = _interopRequireDefault(require("ethjs-query"));

var _transaction = require("../../../../shared/constants/transaction");

/**

  Event emitter utility class for tracking the transactions as they<br>
  go from a pending state to a confirmed (mined in a block) state<br>
<br>
  As well as continues broadcast while in the pending state
<br>
@param {Object} config - non optional configuration object consists of:
    @param {Object} config.provider - A network provider.
    @param {Object} config.nonceTracker - see nonce tracker
    @param {Function} config.getPendingTransactions - a function for getting an array of transactions,
    @param {Function} config.publishTransaction - a async function for publishing raw transactions,

@class
*/
class PendingTransactionTracker extends _safeEventEmitter.default {
  /**
   * We wait this many blocks before emitting a 'tx:dropped' event
   *
   * This is because we could be talking to a node that is out of sync.
   *
   * @type {number}
   */

  /**
   * A map of transaction hashes to the number of blocks we've seen
   * since first considering it dropped
   *
   * @type {Map<String, number>}
   */
  constructor(config) {
    super();
    (0, _defineProperty2.default)(this, "DROPPED_BUFFER_COUNT", 3);
    (0, _defineProperty2.default)(this, "droppedBlocksBufferByHash", new Map());
    this.query = config.query || new _ethjsQuery.default(config.provider);
    this.nonceTracker = config.nonceTracker;
    this.getPendingTransactions = config.getPendingTransactions;
    this.getCompletedTransactions = config.getCompletedTransactions;
    this.publishTransaction = config.publishTransaction;
    this.approveTransaction = config.approveTransaction;
    this.confirmTransaction = config.confirmTransaction;
  }
  /**
    checks the network for signed txs and releases the nonce global lock if it is
  */


  async updatePendingTxs() {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock();

    try {
      const pendingTxs = this.getPendingTransactions();
      await Promise.all(pendingTxs.map(txMeta => this._checkPendingTx(txMeta)));
    } catch (err) {
      _loglevel.default.error('PendingTransactionTracker - Error updating pending transactions');

      _loglevel.default.error(err);
    }

    nonceGlobalLock.releaseLock();
  }
  /**
   * Resubmits each pending transaction
   * @param {string} blockNumber - the latest block number in hex
   * @emits tx:warning
   * @returns {Promise<void>}
   */


  async resubmitPendingTxs(blockNumber) {
    const pending = this.getPendingTransactions();

    if (!pending.length) {
      return;
    }

    for (const txMeta of pending) {
      try {
        await this._resubmitTx(txMeta, blockNumber);
      } catch (err) {
        var _err$value, _err$value$message;

        const errorMessage = ((_err$value = err.value) === null || _err$value === void 0 ? void 0 : (_err$value$message = _err$value.message) === null || _err$value$message === void 0 ? void 0 : _err$value$message.toLowerCase()) || err.message.toLowerCase();
        const isKnownTx = // geth
        errorMessage.includes('replacement transaction underpriced') || errorMessage.includes('known transaction') || // parity
        errorMessage.includes('gas price too low to replace') || errorMessage.includes('transaction with the same hash was already imported') || // other
        errorMessage.includes('gateway timeout') || errorMessage.includes('nonce too low'); // ignore resubmit warnings, return early

        if (isKnownTx) {
          return;
        } // encountered real error - transition to error state


        txMeta.warning = {
          error: errorMessage,
          message: 'There was an error when resubmitting this transaction.'
        };
        this.emit('tx:warning', txMeta, err);
      }
    }
  }
  /**
   * Attempts to resubmit the given transaction with exponential backoff
   *
   * Will only attempt to retry the given tx every {@code 2**(txMeta.retryCount)} blocks.
   *
   * @param {Object} txMeta - the transaction metadata
   * @param {string} latestBlockNumber - the latest block number in hex
   * @returns {Promise<string|undefined>} the tx hash if retried
   * @emits tx:block-update
   * @emits tx:retry
   * @private
   */


  async _resubmitTx(txMeta, latestBlockNumber) {
    if (!txMeta.firstRetryBlockNumber) {
      this.emit('tx:block-update', txMeta, latestBlockNumber);
    }

    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber;
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16);
    const retryCount = txMeta.retryCount || 0; // Exponential backoff to limit retries at publishing (capped at ~15 minutes between retries)

    if (txBlockDistance < Math.min(50, Math.pow(2, retryCount))) {
      return undefined;
    } // Only auto-submit already-signed txs:


    if (!('rawTx' in txMeta)) {
      return this.approveTransaction(txMeta.id);
    }

    const {
      rawTx
    } = txMeta;
    const txHash = await this.publishTransaction(rawTx); // Increment successful tries:

    this.emit('tx:retry', txMeta);
    return txHash;
  }
  /**
   * Query the network to see if the given {@code txMeta} has been included in a block
   * @param {Object} txMeta - the transaction metadata
   * @returns {Promise<void>}
   * @emits tx:confirmed
   * @emits tx:dropped
   * @emits tx:failed
   * @emits tx:warning
   * @private
   */


  async _checkPendingTx(txMeta) {
    const txHash = txMeta.hash;
    const txId = txMeta.id; // Only check submitted txs

    if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED) {
      return;
    } // extra check in case there was an uncaught error during the
    // signature and submission process


    if (!txHash) {
      const noTxHashErr = new Error('We had an error while submitting this transaction, please try again.');
      noTxHashErr.name = 'NoTxHashError';
      this.emit('tx:failed', txId, noTxHashErr);
      return;
    }

    if (await this._checkIfNonceIsTaken(txMeta)) {
      this.emit('tx:dropped', txId);
      return;
    }

    try {
      const transactionReceipt = await this.query.getTransactionReceipt(txHash);

      if (transactionReceipt !== null && transactionReceipt !== void 0 && transactionReceipt.blockNumber) {
        const {
          baseFeePerGas,
          timestamp: blockTimestamp
        } = await this.query.getBlockByHash(transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockHash, false);
        this.emit('tx:confirmed', txId, transactionReceipt, baseFeePerGas, blockTimestamp);
        return;
      }
    } catch (err) {
      txMeta.warning = {
        error: err.message,
        message: 'There was a problem loading this transaction.'
      };
      this.emit('tx:warning', txMeta, err);
      return;
    }

    if (await this._checkIfTxWasDropped(txMeta)) {
      this.emit('tx:dropped', txId);
    }
  }
  /**
   * Checks whether the nonce in the given {@code txMeta} is behind the network nonce
   *
   * @param {Object} txMeta - the transaction metadata
   * @returns {Promise<boolean>}
   * @private
   */


  async _checkIfTxWasDropped(txMeta) {
    const {
      hash: txHash,
      txParams: {
        nonce,
        from
      }
    } = txMeta;
    const networkNextNonce = await this.query.getTransactionCount(from);

    if (parseInt(nonce, 16) >= networkNextNonce.toNumber()) {
      return false;
    }

    if (!this.droppedBlocksBufferByHash.has(txHash)) {
      this.droppedBlocksBufferByHash.set(txHash, 0);
    }

    const currentBlockBuffer = this.droppedBlocksBufferByHash.get(txHash);

    if (currentBlockBuffer < this.DROPPED_BUFFER_COUNT) {
      this.droppedBlocksBufferByHash.set(txHash, currentBlockBuffer + 1);
      return false;
    }

    this.droppedBlocksBufferByHash.delete(txHash);
    return true;
  }
  /**
   * Checks whether the nonce in the given {@code txMeta} is correct against the local set of transactions
   * @param {Object} txMeta - the transaction metadata
   * @returns {Promise<boolean>}
   * @private
   */


  async _checkIfNonceIsTaken(txMeta) {
    const address = txMeta.txParams.from;
    const completed = this.getCompletedTransactions(address);
    return completed.some( // This is called while the transaction is in-flight, so it is possible that the
    // list of completed transactions now includes the transaction we were looking at
    // and if that is the case, don't consider the transaction to have taken its own nonce
    other => !(other.id === txMeta.id) && other.txParams.nonce === txMeta.txParams.nonce);
  }

}

exports.default = PendingTransactionTracker;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/transactions/pending-tx-tracker.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/enums.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WALLET_PREFIX = exports.NOTIFICATION_NAMES = exports.LOG_METHOD_TYPES = exports.LOG_LIMIT = exports.LOG_IGNORE_METHODS = void 0;
const WALLET_PREFIX = 'wallet_';
exports.WALLET_PREFIX = WALLET_PREFIX;
const NOTIFICATION_NAMES = {
  accountsChanged: 'metamask_accountsChanged',
  unlockStateChanged: 'metamask_unlockStateChanged',
  chainChanged: 'metamask_chainChanged'
};
exports.NOTIFICATION_NAMES = NOTIFICATION_NAMES;
const LOG_IGNORE_METHODS = ['wallet_registerOnboarding', 'wallet_watchAsset'];
exports.LOG_IGNORE_METHODS = LOG_IGNORE_METHODS;
const LOG_METHOD_TYPES = {
  restricted: 'restricted',
  internal: 'internal'
};
/**
 * The permission activity log size limit.
 */

exports.LOG_METHOD_TYPES = LOG_METHOD_TYPES;
const LOG_LIMIT = 100;
exports.LOG_LIMIT = LOG_LIMIT;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/enums.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/background-api.js", {"../../../../shared/constants/permissions":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/permissions.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/background-api.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPermissionBackgroundApiMethods = getPermissionBackgroundApiMethods;

var _permissions = require("../../../../shared/constants/permissions");

function getPermissionBackgroundApiMethods(permissionController) {
  return {
    addPermittedAccount: (origin, account) => {
      const existing = permissionController.getCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts);

      if (existing.value.includes(account)) {
        throw new Error(`eth_accounts permission for origin "${origin}" already permits account "${account}".`);
      }

      permissionController.updateCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts, [...existing.value, account]);
    },
    removePermittedAccount: (origin, account) => {
      const existing = permissionController.getCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts);

      if (!existing.value.includes(account)) {
        throw new Error(`eth_accounts permission for origin "${origin}" already does not permit account "${account}".`);
      }

      const remainingAccounts = existing.value.filter(existingAccount => existingAccount !== account);

      if (remainingAccounts.length === 0) {
        permissionController.revokePermission(origin, _permissions.RestrictedMethods.eth_accounts);
      } else {
        permissionController.updateCaveat(origin, _permissions.RestrictedMethods.eth_accounts, _permissions.CaveatTypes.restrictReturnedAccounts, remainingAccounts);
      }
    },
    requestAccountsPermissionWithId: async origin => {
      const [, {
        id
      }] = await permissionController.requestPermissions({
        origin
      }, {
        eth_accounts: {}
      });
      return id;
    }
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/background-api.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/selectors.js", {"../../../../shared/constants/permissions":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/permissions.js","reselect":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/reselect/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/selectors.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPermittedAccountsByOrigin = exports.getChangedAccounts = void 0;

var _reselect = require("reselect");

var _permissions = require("../../../../shared/constants/permissions");

/**
 * This file contains selectors for PermissionController selector event
 * subscriptions, used to detect whenever a subject's accounts change so that
 * we can notify the subject via the `accountsChanged` provider event.
 */

/**
 * @param {Record<string, Record<string, unknown>>} state - The
 * PermissionController state.
 * @returns {Record<string, unknown>} The PermissionController subjects.
 */
const getSubjects = state => state.subjects;
/**
 * Get the permitted accounts for each subject, keyed by origin.
 * The values of the returned map are immutable values from the
 * PermissionController state.
 *
 * @returns {Map<string, string[]>} The current origin:accounts[] map.
 */


const getPermittedAccountsByOrigin = (0, _reselect.createSelector)(getSubjects, subjects => {
  return Object.values(subjects).reduce((originToAccountsMap, subject) => {
    var _subject$permissions, _subject$permissions$;

    const caveat = (_subject$permissions = subject.permissions) === null || _subject$permissions === void 0 ? void 0 : (_subject$permissions$ = _subject$permissions.eth_accounts) === null || _subject$permissions$ === void 0 ? void 0 : _subject$permissions$.caveats.find(({
      type
    }) => type === _permissions.CaveatTypes.restrictReturnedAccounts);

    if (caveat) {
      originToAccountsMap.set(subject.origin, caveat.value);
    }

    return originToAccountsMap;
  }, new Map());
});
/**
 * Given the current and previous exposed accounts for each PermissionController
 * subject, returns a new map containing all accounts that have changed.
 * The values of each map must be immutable values directly from the
 * PermissionController state, or an empty array instantiated in this
 * function.
 *
 * @param {Map<string, string[]>} newAccountsMap - The new origin:accounts[] map.
 * @param {Map<string, string[]>} [previousAccountsMap] - The previous origin:accounts[] map.
 * @returns {Map<string, string[]>} The origin:accounts[] map of changed accounts.
 */

exports.getPermittedAccountsByOrigin = getPermittedAccountsByOrigin;

const getChangedAccounts = (newAccountsMap, previousAccountsMap) => {
  if (previousAccountsMap === undefined) {
    return newAccountsMap;
  }

  const changedAccounts = new Map();

  if (newAccountsMap === previousAccountsMap) {
    return changedAccounts;
  }

  const newOrigins = new Set([...newAccountsMap.keys()]);

  for (const origin of previousAccountsMap.keys()) {
    var _newAccountsMap$get;

    const newAccounts = (_newAccountsMap$get = newAccountsMap.get(origin)) !== null && _newAccountsMap$get !== void 0 ? _newAccountsMap$get : []; // The values of these maps are references to immutable values, which is why
    // a strict equality check is enough for diffing. The values are either from
    // PermissionController state, or an empty array initialized in the previous
    // call to this function. `newAccountsMap` will never contain any empty
    // arrays.

    if (previousAccountsMap.get(origin) !== newAccounts) {
      changedAccounts.set(origin, newAccounts);
    }

    newOrigins.delete(origin);
  } // By now, newOrigins is either empty or contains some number of previously
  // unencountered origins, and all of their accounts have "changed".


  for (const origin of newOrigins.keys()) {
    changedAccounts.set(origin, newAccountsMap.get(origin));
  }

  return changedAccounts;
};

exports.getChangedAccounts = getChangedAccounts;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/selectors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/caveat-mutators.js", {"../../../../shared/constants/permissions":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/permissions.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/caveat-mutators.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CaveatMutatorFactories = void 0;

var _snapControllers = require("@metamask/snap-controllers");

var _permissions = require("../../../../shared/constants/permissions");

/**
 * Factories that construct caveat mutator functions that are passed to
 * PermissionController.updatePermissionsByCaveat.
 */
const CaveatMutatorFactories = {
  [_permissions.CaveatTypes.restrictReturnedAccounts]: {
    removeAccount
  }
};
/**
 * Removes the target account from the value arrays of all
 * `restrictReturnedAccounts` caveats. No-ops if the target account is not in
 * the array, and revokes the parent permission if it's the only account in
 * the array.
 *
 * @param {string} targetAccount - The address of the account to remove from
 * all accounts permissions.
 * @param {string[]} existingAccounts - The account address array from the
 * account permissions.
 */

exports.CaveatMutatorFactories = CaveatMutatorFactories;

function removeAccount(targetAccount, existingAccounts) {
  const newAccounts = existingAccounts.filter(address => address !== targetAccount);

  if (newAccounts.length === existingAccounts.length) {
    return {
      operation: _snapControllers.CaveatMutatorOperation.noop
    };
  } else if (newAccounts.length > 0) {
    return {
      operation: _snapControllers.CaveatMutatorOperation.updateValue,
      value: newAccounts
    };
  }

  return {
    operation: _snapControllers.CaveatMutatorOperation.revokePermission
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/caveat-mutators.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/permission-log.js", {"../../../../shared/constants/permissions":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/permissions.js","./enums":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/enums.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","fast-safe-stringify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-safe-stringify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/permission-log.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PermissionLogController = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _obsStore = require("@metamask/obs-store");

var _fastSafeStringify = _interopRequireDefault(require("fast-safe-stringify"));

var _permissions = require("../../../../shared/constants/permissions");

var _enums = require("./enums");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Controller with middleware for logging requests and responses to restricted
 * and permissions-related methods.
 */
class PermissionLogController {
  /**
   * @param {{ restrictedMethods: Set<string>, initState: Record<string, unknown> }} options - Options bag.
   */
  constructor({
    restrictedMethods,
    initState
  }) {
    this.restrictedMethods = restrictedMethods;
    this.store = new _obsStore.ObservableStore(_objectSpread({
      permissionHistory: {},
      permissionActivityLog: []
    }, initState));
  }
  /**
   * Get the restricted method activity log.
   *
   * @returns {Array<Object>} The activity log.
   */


  getActivityLog() {
    return this.store.getState().permissionActivityLog;
  }
  /**
   * Update the restricted method activity log.
   *
   * @param {Array<Object>} logs - The new activity log array.
   */


  updateActivityLog(logs) {
    this.store.updateState({
      permissionActivityLog: logs
    });
  }
  /**
   * Get the permission history log.
   *
   * @returns {Object} The permissions history log.
   */


  getHistory() {
    return this.store.getState().permissionHistory;
  }
  /**
   * Update the permission history log.
   *
   * @param {Object} history - The new permissions history log object.
   */


  updateHistory(history) {
    this.store.updateState({
      permissionHistory: history
    });
  }
  /**
   * Updates the exposed account history for the given origin.
   * Sets the 'last seen' time to Date.now() for the given accounts.
   * Does **not** update the 'lastApproved' time for the permission itself.
   * Returns if the accounts array is empty.
   *
   * @param {string} origin - The origin that the accounts are exposed to.
   * @param {Array<string>} accounts - The accounts.
   */


  updateAccountsHistory(origin, accounts) {
    if (accounts.length === 0) {
      return;
    }

    const accountToTimeMap = getAccountToTimeMap(accounts, Date.now());
    this.commitNewHistory(origin, {
      eth_accounts: {
        accounts: accountToTimeMap
      }
    });
  }
  /**
   * Create a permissions log middleware. Records permissions activity and history:
   *
   * Activity: requests and responses for restricted and most wallet_ methods.
   *
   * History: for each origin, the last time a permission was granted, including
   * which accounts were exposed, if any.
   *
   * @returns {JsonRpcEngineMiddleware} The permissions log middleware.
   */


  createMiddleware() {
    return (req, res, next, _end) => {
      let activityEntry, requestedMethods;
      const {
        origin,
        method
      } = req;
      const isInternal = method.startsWith(_enums.WALLET_PREFIX); // we only log certain methods

      if (!_enums.LOG_IGNORE_METHODS.includes(method) && (isInternal || this.restrictedMethods.has(method))) {
        activityEntry = this.logRequest(req, isInternal);

        if (method === `${_enums.WALLET_PREFIX}requestPermissions`) {
          // get the corresponding methods from the requested permissions so
          // that we can record permissions history
          requestedMethods = this.getRequestedMethods(req);
        }
      } else if (method === 'eth_requestAccounts') {
        // eth_requestAccounts is a special case; we need to extract the accounts
        // from it
        activityEntry = this.logRequest(req, isInternal);
        requestedMethods = ['eth_accounts'];
      } else {
        // no-op
        next();
        return;
      } // call next with a return handler for capturing the response


      next(cb => {
        const time = Date.now();
        this.logResponse(activityEntry, res, time);

        if (requestedMethods && !res.error && res.result) {
          // any permissions or accounts changes will be recorded on the response,
          // so we only log permissions history here
          this.logPermissionsHistory(requestedMethods, origin, res.result, time, method === 'eth_requestAccounts');
        }

        cb();
      });
    };
  }
  /**
   * Creates and commits an activity log entry, without response data.
   *
   * @param {Object} request - The request object.
   * @param {boolean} isInternal - Whether the request is internal.
   */


  logRequest(request, isInternal) {
    const activityEntry = {
      id: request.id,
      method: request.method,
      methodType: isInternal ? _enums.LOG_METHOD_TYPES.internal : _enums.LOG_METHOD_TYPES.restricted,
      origin: request.origin,
      request: (0, _fastSafeStringify.default)(request, null, 2),
      requestTime: Date.now(),
      response: null,
      responseTime: null,
      success: null
    };
    this.commitNewActivity(activityEntry);
    return activityEntry;
  }
  /**
   * Adds response data to an existing activity log entry.
   * Entry assumed already committed (i.e., in the log).
   *
   * @param {Object} entry - The entry to add a response to.
   * @param {Object} response - The response object.
   * @param {number} time - Output from Date.now()
   */


  logResponse(entry, response, time) {
    if (!entry || !response) {
      return;
    }

    entry.response = (0, _fastSafeStringify.default)(response, null, 2);
    entry.responseTime = time;
    entry.success = !response.error;
  }
  /**
   * Commit a new entry to the activity log.
   * Removes the oldest entry from the log if it exceeds the log limit.
   *
   * @param {Object} entry - The activity log entry.
   */


  commitNewActivity(entry) {
    const logs = this.getActivityLog(); // add new entry to end of log

    logs.push(entry); // remove oldest log if exceeding size limit

    if (logs.length > _enums.LOG_LIMIT) {
      logs.shift();
    }

    this.updateActivityLog(logs);
  }
  /**
   * Create new permissions history log entries, if any, and commit them.
   *
   * @param {Array<string>} requestedMethods - The method names corresponding to the requested permissions.
   * @param {string} origin - The origin of the permissions request.
   * @param {Array<IOcapLdCapability} result - The permissions request response.result.
   * @param {string} time - The time of the request, i.e. Date.now().
   * @param {boolean} isEthRequestAccounts - Whether the permissions request was 'eth_requestAccounts'.
   */


  logPermissionsHistory(requestedMethods, origin, result, time, isEthRequestAccounts) {
    let accounts, newEntries;

    if (isEthRequestAccounts) {
      accounts = result;
      const accountToTimeMap = getAccountToTimeMap(accounts, time);
      newEntries = {
        eth_accounts: {
          accounts: accountToTimeMap,
          lastApproved: time
        }
      };
    } else {
      // Records new "lastApproved" times for the granted permissions, if any.
      // Special handling for eth_accounts, in order to record the time the
      // accounts were last seen or approved by the origin.
      newEntries = result.map(perm => {
        if (perm.parentCapability === 'eth_accounts') {
          accounts = this.getAccountsFromPermission(perm);
        }

        return perm.parentCapability;
      }).reduce((acc, method) => {
        // all approved permissions will be included in the response,
        // not just the newly requested ones
        if (requestedMethods.includes(method)) {
          if (method === 'eth_accounts') {
            const accountToTimeMap = getAccountToTimeMap(accounts, time);
            acc[method] = {
              lastApproved: time,
              accounts: accountToTimeMap
            };
          } else {
            acc[method] = {
              lastApproved: time
            };
          }
        }

        return acc;
      }, {});
    }

    if (Object.keys(newEntries).length > 0) {
      this.commitNewHistory(origin, newEntries);
    }
  }
  /**
   * Commit new entries to the permissions history log.
   * Merges the history for the given origin, overwriting existing entries
   * with the same key (permission name).
   *
   * @param {string} origin - The requesting origin.
   * @param {Object} newEntries - The new entries to commit.
   */


  commitNewHistory(origin, newEntries) {
    // a simple merge updates most permissions
    const history = this.getHistory();

    const newOriginHistory = _objectSpread(_objectSpread({}, history[origin]), newEntries); // eth_accounts requires special handling, because of information
    // we store about the accounts


    const existingEthAccountsEntry = history[origin] && history[origin].eth_accounts;
    const newEthAccountsEntry = newEntries.eth_accounts;

    if (existingEthAccountsEntry && newEthAccountsEntry) {
      // we may intend to update just the accounts, not the permission
      // itself
      const lastApproved = newEthAccountsEntry.lastApproved || existingEthAccountsEntry.lastApproved; // merge old and new eth_accounts history entries

      newOriginHistory.eth_accounts = {
        lastApproved,
        accounts: _objectSpread(_objectSpread({}, existingEthAccountsEntry.accounts), newEthAccountsEntry.accounts)
      };
    }

    history[origin] = newOriginHistory;
    this.updateHistory(history);
  }
  /**
   * Get all requested methods from a permissions request.
   *
   * @param {Object} request - The request object.
   * @returns {Array<string>} The names of the requested permissions.
   */


  getRequestedMethods(request) {
    if (!request.params || !request.params[0] || typeof request.params[0] !== 'object' || Array.isArray(request.params[0])) {
      return null;
    }

    return Object.keys(request.params[0]);
  }
  /**
   * Get the permitted accounts from an eth_accounts permissions object.
   * Returns an empty array if the permission is not eth_accounts.
   *
   * @param {Object} perm - The permissions object.
   * @returns {Array<string>} The permitted accounts.
   */


  getAccountsFromPermission(perm) {
    if (perm.parentCapability !== 'eth_accounts' || !perm.caveats) {
      return [];
    }

    const accounts = new Set();

    for (const caveat of perm.caveats) {
      if (caveat.type === _permissions.CaveatTypes.restrictReturnedAccounts && Array.isArray(caveat.value)) {
        for (const value of caveat.value) {
          accounts.add(value);
        }
      }
    }

    return [...accounts];
  }

} // helper functions

/**
 * Get a map from account addresses to the given time.
 *
 * @param {Array<string>} accounts - An array of addresses.
 * @param {number} time - A time, e.g. Date.now().
 * @returns {Object} A string:number map of addresses to time.
 */


exports.PermissionLogController = PermissionLogController;

function getAccountToTimeMap(accounts, time) {
  return accounts.reduce((acc, account) => _objectSpread(_objectSpread({}, acc), {}, {
    [account]: time
  }), {});
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/permission-log.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/specifications.js", {"../../../../shared/constants/permissions":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/permissions.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/specifications.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unrestrictedMethods = exports.getPermissionSpecifications = exports.getCaveatSpecifications = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _snapControllers = require("@metamask/snap-controllers");

var _permissions = require("../../../../shared/constants/permissions");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This file contains the specifications of the permissions and caveats
 * that are recognized by our permission system. See the PermissionController
 * README in @metamask/snap-controllers for details.
 */

/**
 * The "keys" of all of permissions recognized by the PermissionController.
 * Permission keys and names have distinct meanings in the permission system.
 */
const PermissionKeys = Object.freeze(_objectSpread({}, _permissions.RestrictedMethods));
/**
 * Factory functions for all caveat types recognized by the
 * PermissionController.
 */

const CaveatFactories = Object.freeze({
  [_permissions.CaveatTypes.restrictReturnedAccounts]: accounts => {
    return {
      type: _permissions.CaveatTypes.restrictReturnedAccounts,
      value: accounts
    };
  }
});
/**
 * A PreferencesController identity object.
 *
 * @typedef {Object} Identity
 * @property {string} address - The address of the identity.
 * @property {string} name - The name of the identity.
 * @property {number} [lastSelected] - Unix timestamp of when the identity was
 * last selected in the UI.
 */

/**
 * Gets the specifications for all caveats that will be recognized by the
 * PermissionController.
 *
 * @param {{
 *   getIdentities: () => Record<string, Identity>,
 * }} options - Options bag.
 */

const getCaveatSpecifications = ({
  getIdentities
}) => {
  return {
    [_permissions.CaveatTypes.restrictReturnedAccounts]: {
      type: _permissions.CaveatTypes.restrictReturnedAccounts,
      decorator: (method, caveat) => {
        return async args => {
          const result = await method(args);
          return result.filter(account => caveat.value.includes(account)).slice(0, 1);
        };
      },
      validator: (caveat, _origin, _target) => validateCaveatAccounts(caveat.value, getIdentities)
    }
  };
};
/**
 * Gets the specifications for all permissions that will be recognized by the
 * PermissionController.
 *
 * @param {{
 *   getAllAccounts: () => Promise<string[]>,
 *   getIdentities: () => Record<string, Identity>,
 * }} options - Options bag.
 * @param options.getAllAccounts - A function that returns all Ethereum accounts
 * in the current MetaMask instance.
 * @param options.getIdentities - A function that returns the
 * `PreferencesController` identity objects for all Ethereum accounts in the
 * current MetaMask instance.
 */


exports.getCaveatSpecifications = getCaveatSpecifications;

const getPermissionSpecifications = ({
  getAllAccounts,
  getIdentities
}) => {
  return {
    [PermissionKeys.eth_accounts]: {
      targetKey: PermissionKeys.eth_accounts,
      allowedCaveats: [_permissions.CaveatTypes.restrictReturnedAccounts],
      factory: (permissionOptions, requestData) => {
        if (Array.isArray(permissionOptions.caveats)) {
          throw new Error(`${PermissionKeys.eth_accounts} error: Received unexpected caveats. Any permitted caveats will be added automatically.`);
        } // This value will be further validated as part of the caveat.


        if (!requestData.approvedAccounts) {
          throw new Error(`${PermissionKeys.eth_accounts} error: No approved accounts specified.`);
        }

        return (0, _snapControllers.constructPermission)(_objectSpread(_objectSpread({}, permissionOptions), {}, {
          caveats: [CaveatFactories[_permissions.CaveatTypes.restrictReturnedAccounts](requestData.approvedAccounts)]
        }));
      },
      methodImplementation: async _args => {
        const accounts = await getAllAccounts();
        const identities = getIdentities();
        return accounts.sort((firstAddress, secondAddress) => {
          if (!identities[firstAddress]) {
            throw new Error(`Missing identity for address: "${firstAddress}".`);
          } else if (!identities[secondAddress]) {
            throw new Error(`Missing identity for address: "${secondAddress}".`);
          } else if (identities[firstAddress].lastSelected === identities[secondAddress].lastSelected) {
            return 0;
          } else if (identities[firstAddress].lastSelected === undefined) {
            return 1;
          } else if (identities[secondAddress].lastSelected === undefined) {
            return -1;
          }

          return identities[secondAddress].lastSelected - identities[firstAddress].lastSelected;
        });
      },
      validator: (permission, _origin, _target) => {
        const {
          caveats
        } = permission;

        if (!caveats || caveats.length !== 1 || caveats[0].type !== _permissions.CaveatTypes.restrictReturnedAccounts) {
          throw new Error(`${PermissionKeys.eth_accounts} error: Invalid caveats. There must be a single caveat of type "${_permissions.CaveatTypes.restrictReturnedAccounts}".`);
        }
      }
    }
  };
};
/**
 * Validates the accounts associated with a caveat. In essence, ensures that
 * the accounts value is an array of non-empty strings, and that each string
 * corresponds to a PreferencesController identity.
 *
 * @param {string[]} accounts - The accounts associated with the caveat.
 * @param {() => Record<string, Identity>} getIdentities - Gets all
 * PreferencesController identities.
 */


exports.getPermissionSpecifications = getPermissionSpecifications;

function validateCaveatAccounts(accounts, getIdentities) {
  if (!Array.isArray(accounts) || accounts.length === 0) {
    throw new Error(`${PermissionKeys.eth_accounts} error: Expected non-empty array of Ethereum addresses.`);
  }

  const identities = getIdentities();
  accounts.forEach(address => {
    if (!address || typeof address !== 'string') {
      throw new Error(`${PermissionKeys.eth_accounts} error: Expected an array of Ethereum addresses. Received: "${address}".`);
    }

    if (!identities[address]) {
      throw new Error(`${PermissionKeys.eth_accounts} error: Received unrecognized address: "${address}".`);
    }
  });
}
/**
 * All unrestricted methods recognized by the PermissionController.
 * Unrestricted methods are ignored by the permission system, but every
 * JSON-RPC request seen by the permission system must correspond to a
 * restricted or unrestricted method, or the request will be rejected with a
 * "method not found" error.
 */


const unrestrictedMethods = Object.freeze(['eth_blockNumber', 'eth_call', 'eth_chainId', 'eth_coinbase', 'eth_decrypt', 'eth_estimateGas', 'eth_feeHistory', 'eth_gasPrice', 'eth_getBalance', 'eth_getBlockByHash', 'eth_getBlockByNumber', 'eth_getBlockTransactionCountByHash', 'eth_getBlockTransactionCountByNumber', 'eth_getCode', 'eth_getEncryptionPublicKey', 'eth_getFilterChanges', 'eth_getFilterLogs', 'eth_getLogs', 'eth_getProof', 'eth_getStorageAt', 'eth_getTransactionByBlockHashAndIndex', 'eth_getTransactionByBlockNumberAndIndex', 'eth_getTransactionByHash', 'eth_getTransactionCount', 'eth_getTransactionReceipt', 'eth_getUncleByBlockHashAndIndex', 'eth_getUncleByBlockNumberAndIndex', 'eth_getUncleCountByBlockHash', 'eth_getUncleCountByBlockNumber', 'eth_getWork', 'eth_hashrate', 'eth_mining', 'eth_newBlockFilter', 'eth_newFilter', 'eth_newPendingTransactionFilter', 'eth_protocolVersion', 'eth_sendRawTransaction', 'eth_sendTransaction', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v1', 'eth_signTypedData_v3', 'eth_signTypedData_v4', 'eth_submitHashrate', 'eth_submitWork', 'eth_syncing', 'eth_uninstallFilter', 'metamask_getProviderState', 'metamask_watchAsset', 'net_listening', 'net_peerCount', 'net_version', 'personal_ecRecover', 'personal_sign', 'wallet_watchAsset', 'web3_clientVersion', 'web3_sha3']);
exports.unrestrictedMethods = unrestrictedMethods;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/permissions/specifications.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/index.js", {"./package.json":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/package.json","@segment/loosely-validate-event":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@segment/loosely-validate-event/index.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","axios":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/index.js","axios-retry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/index.js","lodash.isstring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isstring/index.js","md5":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/md5/md5.js","ms":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ms/index.js","remove-trailing-slash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/remove-trailing-slash/index.js","uuid/v4":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/index.js
      return function (require, module, exports) {
(function (process){(function (){
'use strict'

const assert = require('assert')
const removeSlash = require('remove-trailing-slash')
const looselyValidate = require('@segment/loosely-validate-event')
const axios = require('axios')
const axiosRetry = require('axios-retry')
const ms = require('ms')
const uuid = require('uuid/v4')
const md5 = require('md5')
const version = require('./package.json').version
const isString = require('lodash.isstring')

const setImmediate = global.setImmediate || process.nextTick.bind(process)
const noop = () => {}

class Analytics {
  /**
   * Initialize a new `Analytics` with your Segment project's `writeKey` and an
   * optional dictionary of `options`.
   *
   * @param {String} writeKey
   * @param {Object} [options] (optional)
   *   @property {Number} flushAt (default: 20)
   *   @property {Number} flushInterval (default: 10000)
   *   @property {String} host (default: 'https://api.segment.io')
   *   @property {Boolean} enable (default: true)
   */

  constructor (writeKey, options) {
    options = options || {}

    assert(writeKey, 'You must pass your Segment project\'s write key.')

    this.queue = []
    this.writeKey = writeKey
    this.host = removeSlash(options.host || 'https://api.segment.io')
    this.timeout = options.timeout || false
    this.flushAt = Math.max(options.flushAt, 1) || 20
    this.flushInterval = options.flushInterval || 10000
    this.flushed = false
    Object.defineProperty(this, 'enable', {
      configurable: false,
      writable: false,
      enumerable: true,
      value: typeof options.enable === 'boolean' ? options.enable : true
    })
    this.axiosClient = axios.create()
    axiosRetry(this.axiosClient, {
      retries: options.retryCount || 3,
      retryCondition: this._isErrorRetryable,
      retryDelay: axiosRetry.exponentialDelay
    })
  }

  _validate (message, type) {
    try {
      looselyValidate(message, type)
    } catch (e) {
      if (e.message === 'Your message must be < 32kb.') {
        console.log('Your message must be < 32kb. This is currently surfaced as a warning to allow clients to update. Versions released after August 1, 2018 will throw an error instead. Please update your code before then.', message)
        return
      }
      throw e
    }
  }

  /**
   * Send an identify `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  identify (message, callback) {
    this._validate(message, 'identify')
    this.enqueue('identify', message, callback)
    return this
  }

  /**
   * Send a group `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  group (message, callback) {
    this._validate(message, 'group')
    this.enqueue('group', message, callback)
    return this
  }

  /**
   * Send a track `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  track (message, callback) {
    this._validate(message, 'track')
    this.enqueue('track', message, callback)
    return this
  }

  /**
   * Send a page `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  page (message, callback) {
    this._validate(message, 'page')
    this.enqueue('page', message, callback)
    return this
  }

  /**
   * Send a screen `message`.
   *
   * @param {Object} message
   * @param {Function} fn (optional)
   * @return {Analytics}
   */

  screen (message, callback) {
    this._validate(message, 'screen')
    this.enqueue('screen', message, callback)
    return this
  }

  /**
   * Send an alias `message`.
   *
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  alias (message, callback) {
    this._validate(message, 'alias')
    this.enqueue('alias', message, callback)
    return this
  }

  /**
   * Add a `message` of type `type` to the queue and
   * check whether it should be flushed.
   *
   * @param {String} type
   * @param {Object} message
   * @param {Function} [callback] (optional)
   * @api private
   */

  enqueue (type, message, callback) {
    callback = callback || noop

    if (!this.enable) {
      return setImmediate(callback)
    }

    message = Object.assign({}, message)
    message.type = type
    message.context = Object.assign({
      library: {
        name: 'analytics-node',
        version
      }
    }, message.context)

    message._metadata = Object.assign({
      nodeVersion: process.versions.node
    }, message._metadata)

    if (!message.timestamp) {
      message.timestamp = new Date()
    }

    if (!message.messageId) {
      // We md5 the messaage to add more randomness. This is primarily meant
      // for use in the browser where the uuid package falls back to Math.random()
      // which is not a great source of randomness.
      // Borrowed from analytics.js (https://github.com/segment-integrations/analytics.js-integration-segmentio/blob/a20d2a2d222aeb3ab2a8c7e72280f1df2618440e/lib/index.js#L255-L256).
      message.messageId = `node-${md5(JSON.stringify(message))}-${uuid()}`
    }

    // Historically this library has accepted strings and numbers as IDs.
    // However, our spec only allows strings. To avoid breaking compatibility,
    // we'll coerce these to strings if they aren't already.
    if (message.anonymousId && !isString(message.anonymousId)) {
      message.anonymousId = JSON.stringify(message.anonymousId)
    }
    if (message.userId && !isString(message.userId)) {
      message.userId = JSON.stringify(message.userId)
    }

    this.queue.push({ message, callback })

    if (!this.flushed) {
      this.flushed = true
      this.flush()
      return
    }

    if (this.queue.length >= this.flushAt) {
      this.flush()
    }

    if (this.flushInterval && !this.timer) {
      this.timer = setTimeout(this.flush.bind(this), this.flushInterval)
    }
  }

  /**
   * Flush the current queue
   *
   * @param {Function} [callback] (optional)
   * @return {Analytics}
   */

  flush (callback) {
    callback = callback || noop

    if (!this.enable) {
      return setImmediate(callback)
    }

    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }

    if (!this.queue.length) {
      return setImmediate(callback)
    }

    const items = this.queue.splice(0, this.flushAt)
    const callbacks = items.map(item => item.callback)
    const messages = items.map(item => item.message)

    const data = {
      batch: messages,
      timestamp: new Date(),
      sentAt: new Date()
    }

    const done = err => {
      callbacks.forEach(callback => callback(err))
      callback(err, data)
    }

    // Don't set the user agent if we're not on a browser. The latest spec allows
    // the User-Agent header (see https://fetch.spec.whatwg.org/#terminology-headers
    // and https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader),
    // but browsers such as Chrome and Safari have not caught up.
    const headers = {}
    if (typeof window === 'undefined') {
      headers['user-agent'] = `analytics-node/${version}`
    }

    const req = {
      method: 'POST',
      url: `${this.host}/v1/batch`,
      auth: {
        username: this.writeKey
      },
      data,
      headers
    }

    if (this.timeout) {
      req.timeout = typeof this.timeout === 'string' ? ms(this.timeout) : this.timeout
    }

    this.axiosClient(req)
      .then(() => done())
      .catch(err => {
        if (err.response) {
          const error = new Error(err.response.statusText)
          return done(error)
        }

        done(err)
      })
  }

  _isErrorRetryable (error) {
    // Retry Network Errors.
    if (axiosRetry.isNetworkError(error)) {
      return true
    }

    if (!error.response) {
      // Cannot determine if the request can be retried
      return false
    }

    // Retry Server Errors (5xx).
    if (error.response.status >= 500 && error.response.status <= 599) {
      return true
    }

    // Retry if rate limited.
    if (error.response.status === 429) {
      return true
    }

    return false
  }
}

module.exports = Analytics

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"analytics-node",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/thirdparty.js", {"./index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/index.js","aes-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/aes-js/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","scryptsy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/scryptsy/lib/scrypt.js","utf8":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/utf8/utf8.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/thirdparty.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Wallet = require('./index.js');
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var scryptsy = require('scryptsy');
var utf8 = require('utf8');
var aesjs = require('aes-js');
var Buffer = require('safe-buffer').Buffer;

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Thirdparty = {};

/*
 * opts:
 * - digest - digest algorithm, defaults to md5
 * - count - hash iterations
 * - keysize - desired key size
 * - ivsize - desired IV size
 *
 * Algorithm form https://www.openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html
 *
 * FIXME: not optimised at all
 */
function evp_kdf(data, salt, opts) {
  // eslint-disable-line
  // A single EVP iteration, returns `D_i`, where block equlas to `D_(i-1)`
  function iter(block) {
    var hash = crypto.createHash(opts.digest || 'md5');
    hash.update(block);
    hash.update(data);
    hash.update(salt);
    block = hash.digest();

    for (var i = 1; i < (opts.count || 1); i++) {
      hash = crypto.createHash(opts.digest || 'md5');
      hash.update(block);
      block = hash.digest();
    }

    return block;
  }

  var keysize = opts.keysize || 16;
  var ivsize = opts.ivsize || 16;

  var ret = [];

  var i = 0;
  while (Buffer.concat(ret).length < keysize + ivsize) {
    ret[i] = iter(i === 0 ? Buffer.alloc(0) : ret[i - 1]);
    i++;
  }

  var tmp = Buffer.concat(ret);

  return {
    key: tmp.slice(0, keysize),
    iv: tmp.slice(keysize, keysize + ivsize)
  };
}

// http://stackoverflow.com/questions/25288311/cryptojs-aes-pattern-always-ends-with
function decodeCryptojsSalt(input) {
  var ciphertext = Buffer.from(input, 'base64');
  if (ciphertext.slice(0, 8).toString() === 'Salted__') {
    return {
      salt: ciphertext.slice(8, 16),
      ciphertext: ciphertext.slice(16)
    };
  } else {
    return {
      ciphertext: ciphertext
    };
  }
}

/*
 * This wallet format is created by https://github.com/SilentCicero/ethereumjs-accounts
 * and used on https://www.myetherwallet.com/
 */
Thirdparty.fromEtherWallet = function (input, password) {
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var privKey;
  if (!json.locked) {
    if (json.private.length !== 64) {
      throw new Error('Invalid private key length');
    }

    privKey = Buffer.from(json.private, 'hex');
  } else {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }
    if (password.length < 7) {
      throw new Error('Password must be at least 7 characters');
    }

    // the "encrypted" version has the low 4 bytes
    // of the hash of the address appended
    var cipher = json.encrypted ? json.private.slice(0, 128) : json.private;

    // decode openssl ciphertext + salt encoding
    cipher = decodeCryptojsSalt(cipher);

    if (!cipher.salt) {
      throw new Error('Unsupported EtherWallet key format');
    }

    // derive key/iv using OpenSSL EVP as implemented in CryptoJS
    var evp = evp_kdf(Buffer.from(password), cipher.salt, { keysize: 32, ivsize: 16 });

    var decipher = crypto.createDecipheriv('aes-256-cbc', evp.key, evp.iv);
    privKey = runCipherBuffer(decipher, Buffer.from(cipher.ciphertext));

    // NOTE: yes, they've run it through UTF8
    privKey = Buffer.from(utf8.decode(privKey.toString()), 'hex');
  }

  var wallet = new Wallet(privKey);

  if (wallet.getAddressString() !== json.address) {
    throw new Error('Invalid private key or address');
  }

  return wallet;
};

Thirdparty.fromEtherCamp = function (passphrase) {
  return new Wallet(ethUtil.keccak256(Buffer.from(passphrase)));
};

Thirdparty.fromKryptoKit = function (entropy, password) {
  function kryptoKitBrokenScryptSeed(buf) {
    // js-scrypt calls `Buffer.from(String(salt), 'utf8')` on the seed even though it is a buffer
    //
    // The `buffer`` implementation used does the below transformation (doesn't matches the current version):
    // https://github.com/feross/buffer/blob/67c61181b938b17d10dbfc0a545f713b8bd59de8/index.js

    function decodeUtf8Char(str) {
      try {
        return decodeURIComponent(str);
      } catch (err) {
        return String.fromCharCode(0xFFFD); // UTF 8 invalid char
      }
    }

    var res = '';
    var tmp = '';

    for (var i = 0; i < buf.length; i++) {
      if (buf[i] <= 0x7F) {
        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
        tmp = '';
      } else {
        tmp += '%' + buf[i].toString(16);
      }
    }

    return Buffer.from(res + decodeUtf8Char(tmp));
  }

  if (entropy[0] === '#') {
    entropy = entropy.slice(1);
  }

  var type = entropy[0];
  entropy = entropy.slice(1);

  var privKey;
  if (type === 'd') {
    privKey = ethUtil.sha256(Buffer.from(entropy));
  } else if (type === 'q') {
    if (typeof password !== 'string') {
      throw new Error('Password required');
    }

    var encryptedSeed = ethUtil.sha256(Buffer.from(entropy.slice(0, 30)));
    var checksum = entropy.slice(30, 46);

    var salt = kryptoKitBrokenScryptSeed(encryptedSeed);
    var aesKey = scryptsy(Buffer.from(password, 'utf8'), salt, 16384, 8, 1, 32);

    /* FIXME: try to use `crypto` instead of `aesjs`
     // NOTE: ECB doesn't use the IV, so it can be anything
    var decipher = crypto.createDecipheriv("aes-256-ecb", aesKey, Buffer.from(0))
     // FIXME: this is a clear abuse, but seems to match how ECB in aesjs works
    privKey = Buffer.concat([
      decipher.update(encryptedSeed).slice(0, 16),
      decipher.update(encryptedSeed).slice(0, 16),
    ])
    */

    /* eslint-disable new-cap */
    var decipher = new aesjs.ModeOfOperation.ecb(aesKey);
    /* eslint-enable new-cap */
    /* decrypt returns an Uint8Array, perhaps there is a better way to concatenate */
    privKey = Buffer.concat([Buffer.from(decipher.decrypt(encryptedSeed.slice(0, 16))), Buffer.from(decipher.decrypt(encryptedSeed.slice(16, 32)))]);

    if (checksum.length > 0) {
      if (checksum !== ethUtil.sha256(ethUtil.sha256(privKey)).slice(0, 8).toString('hex')) {
        throw new Error('Failed to decrypt input - possibly invalid passphrase');
      }
    }
  } else {
    throw new Error('Unsupported or invalid entropy type');
  }

  return new Wallet(privKey);
};

Thirdparty.fromQuorumWallet = function (passphrase, userid) {
  assert(passphrase.length >= 10);
  assert(userid.length >= 10);

  var seed = passphrase + userid;
  seed = crypto.pbkdf2Sync(seed, seed, 2000, 32, 'sha256');

  return new Wallet(seed);
};

module.exports = Thirdparty;
      };
    };
  }
}, {package:"ethereumjs-wallet",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/thirdparty.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/index.js", {"bs58check":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58check/index.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js","randombytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/randombytes/browser.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","scryptsy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/scryptsy/lib/scrypt.js","uuid/v4":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Buffer = require('safe-buffer').Buffer;
var ethUtil = require('ethereumjs-util');
var crypto = require('crypto');
var randomBytes = require('randombytes');
var scryptsy = require('scryptsy');
var uuidv4 = require('uuid/v4');
var bs58check = require('bs58check');

function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}

function runCipherBuffer(cipher, data) {
  return Buffer.concat([cipher.update(data), cipher.final()]);
}

var Wallet = function Wallet(priv, pub) {
  if (priv && pub) {
    throw new Error('Cannot supply both a private and a public key to the constructor');
  }

  if (priv && !ethUtil.isValidPrivate(priv)) {
    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
  }

  if (pub && !ethUtil.isValidPublic(pub)) {
    throw new Error('Invalid public key');
  }

  this._privKey = priv;
  this._pubKey = pub;
};

Object.defineProperty(Wallet.prototype, 'privKey', {
  get: function get() {
    assert(this._privKey, 'This is a public key only wallet');
    return this._privKey;
  }
});

Object.defineProperty(Wallet.prototype, 'pubKey', {
  get: function get() {
    if (!this._pubKey) {
      this._pubKey = ethUtil.privateToPublic(this.privKey);
    }
    return this._pubKey;
  }
});

Wallet.generate = function (icapDirect) {
  if (icapDirect) {
    var max = new ethUtil.BN('088f924eeceeda7fe92e1f5b0fffffffffffffff', 16);
    while (true) {
      var privKey = randomBytes(32);
      if (new ethUtil.BN(ethUtil.privateToAddress(privKey)).lte(max)) {
        return new Wallet(privKey);
      }
    }
  } else {
    return new Wallet(randomBytes(32));
  }
};

Wallet.generateVanityAddress = function (pattern) {
  if ((typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) !== 'object') {
    pattern = new RegExp(pattern);
  }

  while (true) {
    var privKey = randomBytes(32);
    var address = ethUtil.privateToAddress(privKey);

    if (pattern.test(address.toString('hex'))) {
      return new Wallet(privKey);
    }
  }
};

Wallet.prototype.getPrivateKey = function () {
  return this.privKey;
};

Wallet.prototype.getPrivateKeyString = function () {
  return ethUtil.bufferToHex(this.getPrivateKey());
};

Wallet.prototype.getPublicKey = function () {
  return this.pubKey;
};

Wallet.prototype.getPublicKeyString = function () {
  return ethUtil.bufferToHex(this.getPublicKey());
};

Wallet.prototype.getAddress = function () {
  return ethUtil.publicToAddress(this.pubKey);
};

Wallet.prototype.getAddressString = function () {
  return ethUtil.bufferToHex(this.getAddress());
};

Wallet.prototype.getChecksumAddressString = function () {
  return ethUtil.toChecksumAddress(this.getAddressString());
};

// https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
Wallet.prototype.toV3 = function (password, opts) {
  assert(this._privKey, 'This is a public key only wallet');

  opts = opts || {};
  var salt = opts.salt || randomBytes(32);
  var iv = opts.iv || randomBytes(16);

  var derivedKey;
  var kdf = opts.kdf || 'scrypt';
  var kdfparams = {
    dklen: opts.dklen || 32,
    salt: salt.toString('hex')
  };

  if (kdf === 'pbkdf2') {
    kdfparams.c = opts.c || 262144;
    kdfparams.prf = 'hmac-sha256';
    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');
  } else if (kdf === 'scrypt') {
    // FIXME: support progress reporting callback
    kdfparams.n = opts.n || 262144;
    kdfparams.r = opts.r || 8;
    kdfparams.p = opts.p || 1;
    derivedKey = scryptsy(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else {
    throw new Error('Unsupported kdf');
  }

  var cipher = crypto.createCipheriv(opts.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);
  if (!cipher) {
    throw new Error('Unsupported cipher');
  }

  var ciphertext = runCipherBuffer(cipher, this.privKey);

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), Buffer.from(ciphertext, 'hex')]));

  return {
    version: 3,
    id: uuidv4({ random: opts.uuid || randomBytes(16) }),
    address: this.getAddress().toString('hex'),
    crypto: {
      ciphertext: ciphertext.toString('hex'),
      cipherparams: {
        iv: iv.toString('hex')
      },
      cipher: opts.cipher || 'aes-128-ctr',
      kdf: kdf,
      kdfparams: kdfparams,
      mac: mac.toString('hex')
    }
  };
};

Wallet.prototype.getV3Filename = function (timestamp) {
  /*
   * We want a timestamp like 2016-03-15T17-11-33.007598288Z. Date formatting
   * is a pain in Javascript, everbody knows that. We could use moment.js,
   * but decide to do it manually in order to save space.
   *
   * toJSON() returns a pretty close version, so let's use it. It is not UTC though,
   * but does it really matter?
   *
   * Alternative manual way with padding and Date fields: http://stackoverflow.com/a/7244288/4964819
   *
   */
  var ts = timestamp ? new Date(timestamp) : new Date();

  return ['UTC--', ts.toJSON().replace(/:/g, '-'), '--', this.getAddress().toString('hex')].join('');
};

Wallet.prototype.toV3String = function (password, opts) {
  return JSON.stringify(this.toV3(password, opts));
};

Wallet.fromPublicKey = function (pub, nonStrict) {
  if (nonStrict) {
    pub = ethUtil.importPublic(pub);
  }
  return new Wallet(null, pub);
};

Wallet.fromExtendedPublicKey = function (pub) {
  assert(pub.slice(0, 4) === 'xpub', 'Not an extended public key');
  pub = bs58check.decode(pub).slice(45);
  // Convert to an Ethereum public key
  return Wallet.fromPublicKey(pub, true);
};

Wallet.fromPrivateKey = function (priv) {
  return new Wallet(priv);
};

Wallet.fromExtendedPrivateKey = function (priv) {
  assert(priv.slice(0, 4) === 'xprv', 'Not an extended private key');
  var tmp = bs58check.decode(priv);
  assert(tmp[45] === 0, 'Invalid extended private key');
  return Wallet.fromPrivateKey(tmp.slice(46));
};

// https://github.com/ethereum/go-ethereum/wiki/Passphrase-protected-key-store-spec
Wallet.fromV1 = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  if (json.Version !== '1') {
    throw new Error('Not a V1 wallet');
  }

  if (json.Crypto.KeyHeader.Kdf !== 'scrypt') {
    throw new Error('Unsupported key derivation scheme');
  }

  var kdfparams = json.Crypto.KeyHeader.KdfParams;
  var derivedKey = scryptsy(Buffer.from(password), Buffer.from(json.Crypto.Salt, 'hex'), kdfparams.N, kdfparams.R, kdfparams.P, kdfparams.DkLen);

  var ciphertext = Buffer.from(json.Crypto.CipherText, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));

  if (mac.toString('hex') !== json.Crypto.MAC) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv('aes-128-cbc', ethUtil.keccak256(derivedKey.slice(0, 16)).slice(0, 16), Buffer.from(json.Crypto.IV, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

Wallet.fromV3 = function (input, password, nonStrict) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(nonStrict ? input.toLowerCase() : input);

  if (json.version !== 3) {
    throw new Error('Not a V3 wallet');
  }

  var derivedKey;
  var kdfparams;
  if (json.crypto.kdf === 'scrypt') {
    kdfparams = json.crypto.kdfparams;

    // FIXME: support progress reporting callback
    derivedKey = scryptsy(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
  } else if (json.crypto.kdf === 'pbkdf2') {
    kdfparams = json.crypto.kdfparams;

    if (kdfparams.prf !== 'hmac-sha256') {
      throw new Error('Unsupported parameters to PBKDF2');
    }

    derivedKey = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');
  } else {
    throw new Error('Unsupported key derivation scheme');
  }

  var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');

  var mac = ethUtil.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
  if (mac.toString('hex') !== json.crypto.mac) {
    throw new Error('Key derivation failed - possibly wrong passphrase');
  }

  var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));
  var seed = runCipherBuffer(decipher, ciphertext);

  return new Wallet(seed);
};

/*
 * Based on https://github.com/ethereum/pyethsaletool/blob/master/pyethsaletool.py
 * JSON fields: encseed, ethaddr, btcaddr, email
 */
Wallet.fromEthSale = function (input, password) {
  assert(typeof password === 'string');
  var json = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' ? input : JSON.parse(input);

  var encseed = Buffer.from(json.encseed, 'hex');

  // key derivation
  var derivedKey = crypto.pbkdf2Sync(password, password, 2000, 32, 'sha256').slice(0, 16);

  // seed decoding (IV is first 16 bytes)
  // NOTE: crypto (derived from openssl) when used with aes-*-cbc will handle PKCS#7 padding internally
  //       see also http://stackoverflow.com/a/31614770/4964819
  var decipher = crypto.createDecipheriv('aes-128-cbc', derivedKey, encseed.slice(0, 16));
  var seed = runCipherBuffer(decipher, encseed.slice(16));

  var wallet = new Wallet(ethUtil.keccak256(seed));
  if (wallet.getAddress().toString('hex') !== json.ethaddr) {
    throw new Error('Decoded key mismatch - possibly wrong passphrase');
  }
  return wallet;
};

module.exports = Wallet;
      };
    };
  }
}, {package:"ethereumjs-wallet",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/network.js", {"../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","../../../../shared/modules/fetch-with-timeout":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/fetch-with-timeout.js","../../../../shared/modules/network.utils":"/home/clarisco/Desktop/metamask-extension-develop/shared/modules/network.utils.js","./createInfuraClient":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createInfuraClient.js","./createJsonRpcClient":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createJsonRpcClient.js","./createMetamaskMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createMetamaskMiddleware.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/obs-store/dist/index.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","eth-json-rpc-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js","eth-query":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-query/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","loglevel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/loglevel/lib/loglevel.js","swappable-obj-proxy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/network.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NETWORK_EVENTS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("assert");

var _events = _interopRequireDefault(require("events"));

var _obsStore = require("@metamask/obs-store");

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _swappableObjProxy = require("swappable-obj-proxy");

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _network = require("../../../../shared/constants/network");

var _time = require("../../../../shared/constants/time");

var _network2 = require("../../../../shared/modules/network.utils");

var _fetchWithTimeout = _interopRequireDefault(require("../../../../shared/modules/fetch-with-timeout"));

var _createMetamaskMiddleware = _interopRequireDefault(require("./createMetamaskMiddleware"));

var _createInfuraClient = _interopRequireDefault(require("./createInfuraClient"));

var _createJsonRpcClient = _interopRequireDefault(require("./createJsonRpcClient"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const env = process.env.METAMASK_ENV;
const fetchWithTimeout = (0, _fetchWithTimeout.default)(_time.SECOND * 30);
let defaultProviderConfigOpts;

if (process.env.IN_TEST) {
  defaultProviderConfigOpts = {
    type: _network.NETWORK_TYPE_RPC,
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    nickname: 'Localhost 8545'
  };
} else if (true || env === 'test') {
  defaultProviderConfigOpts = {
    type: _network.RINKEBY,
    chainId: _network.RINKEBY_CHAIN_ID
  };
} else {
  defaultProviderConfigOpts = {
    type: _network.MAINNET,
    chainId: _network.MAINNET_CHAIN_ID
  };
}

const defaultProviderConfig = _objectSpread({
  ticker: 'ETH'
}, defaultProviderConfigOpts);

const defaultNetworkDetailsState = {
  EIPS: {
    1559: undefined
  }
};
const NETWORK_EVENTS = {
  // Fired after the actively selected network is changed
  NETWORK_DID_CHANGE: 'networkDidChange',
  // Fired when the actively selected network *will* change
  NETWORK_WILL_CHANGE: 'networkWillChange',
  // Fired when Infura returns an error indicating no support
  INFURA_IS_BLOCKED: 'infuraIsBlocked',
  // Fired when not using an Infura network or when Infura returns no error, indicating support
  INFURA_IS_UNBLOCKED: 'infuraIsUnblocked'
};
exports.NETWORK_EVENTS = NETWORK_EVENTS;

class NetworkController extends _events.default {
  constructor(opts = {}) {
    super(); // create stores

    this.providerStore = new _obsStore.ObservableStore(opts.provider || _objectSpread({}, defaultProviderConfig));
    this.previousProviderStore = new _obsStore.ObservableStore(this.providerStore.getState());
    this.networkStore = new _obsStore.ObservableStore('loading'); // We need to keep track of a few details about the current network
    // Ideally we'd merge this.networkStore with this new store, but doing so
    // will require a decent sized refactor of how we're accessing network
    // state. Currently this is only used for detecting EIP 1559 support but
    // can be extended to track other network details.

    this.networkDetails = new _obsStore.ObservableStore(opts.networkDetails || _objectSpread({}, defaultNetworkDetailsState));
    this.store = new _obsStore.ComposedStore({
      provider: this.providerStore,
      previousProviderStore: this.previousProviderStore,
      network: this.networkStore,
      networkDetails: this.networkDetails
    }); // provider and block tracker

    this._provider = null;
    this._blockTracker = null; // provider and block tracker proxies - because the network changes

    this._providerProxy = null;
    this._blockTrackerProxy = null;
    this.on(NETWORK_EVENTS.NETWORK_DID_CHANGE, this.lookupNetwork);
  }
  /**
   * Sets the Infura project ID
   *
   * @param {string} projectId - The Infura project ID
   * @throws {Error} if the project ID is not a valid string
   * @return {void}
   */


  setInfuraProjectId(projectId) {
    if (!projectId || typeof projectId !== 'string') {
      throw new Error('Invalid Infura project ID');
    }

    this._infuraProjectId = projectId;
  }

  initializeProvider(providerParams) {
    this._baseProviderParams = providerParams;
    const {
      type,
      rpcUrl,
      chainId
    } = this.getProviderConfig();

    this._configureProvider({
      type,
      rpcUrl,
      chainId
    });

    this.lookupNetwork();
  } // return the proxies so the references will always be good


  getProviderAndBlockTracker() {
    const provider = this._providerProxy;
    const blockTracker = this._blockTrackerProxy;
    return {
      provider,
      blockTracker
    };
  }
  /**
   * Method to return the latest block for the current network
   * @returns {Object} Block header
   */


  getLatestBlock() {
    return new Promise((resolve, reject) => {
      const {
        provider
      } = this.getProviderAndBlockTracker();
      const ethQuery = new _ethQuery.default(provider);
      ethQuery.sendAsync({
        method: 'eth_getBlockByNumber',
        params: ['latest', false]
      }, (err, block) => {
        if (err) {
          return reject(err);
        }

        return resolve(block);
      });
    });
  }
  /**
   * Method to check if the block header contains fields that indicate EIP 1559
   * support (baseFeePerGas).
   * @returns {Promise<boolean>} true if current network supports EIP 1559
   */


  async getEIP1559Compatibility() {
    const {
      EIPS
    } = this.networkDetails.getState();

    if (EIPS[1559] !== undefined) {
      return EIPS[1559];
    }

    const latestBlock = await this.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.setNetworkEIPSupport(1559, supportsEIP1559);
    return supportsEIP1559;
  }

  verifyNetwork() {
    // Check network when restoring connectivity:
    if (this.isNetworkLoading()) {
      this.lookupNetwork();
    }
  }

  getNetworkState() {
    return this.networkStore.getState();
  }

  setNetworkState(network) {
    this.networkStore.putState(network);
  }
  /**
   * Set EIP support indication in the networkDetails store
   * @param {number} EIPNumber - The number of the EIP to mark support for
   * @param {boolean} isSupported - True if the EIP is supported
   */


  setNetworkEIPSupport(EIPNumber, isSupported) {
    this.networkDetails.updateState({
      EIPS: {
        [EIPNumber]: isSupported
      }
    });
  }
  /**
   * Reset EIP support to default (no support)
   */


  clearNetworkDetails() {
    this.networkDetails.putState(_objectSpread({}, defaultNetworkDetailsState));
  }

  isNetworkLoading() {
    return this.getNetworkState() === 'loading';
  }

  lookupNetwork() {
    // Prevent firing when provider is not defined.
    if (!this._provider) {
      _loglevel.default.warn('NetworkController - lookupNetwork aborted due to missing provider');

      return;
    }

    const chainId = this.getCurrentChainId();

    if (!chainId) {
      _loglevel.default.warn('NetworkController - lookupNetwork aborted due to missing chainId');

      this.setNetworkState('loading'); // keep network details in sync with network state

      this.clearNetworkDetails();
      return;
    } // Ping the RPC endpoint so we can confirm that it works


    const ethQuery = new _ethQuery.default(this._provider);
    const initialNetwork = this.getNetworkState();
    const {
      type
    } = this.getProviderConfig();

    const isInfura = _network.INFURA_PROVIDER_TYPES.includes(type);

    if (isInfura) {
      this._checkInfuraAvailability(type);
    } else {
      this.emit(NETWORK_EVENTS.INFURA_IS_UNBLOCKED);
    }

    ethQuery.sendAsync({
      method: 'net_version'
    }, (err, networkVersion) => {
      const currentNetwork = this.getNetworkState();

      if (initialNetwork === currentNetwork) {
        if (err) {
          this.setNetworkState('loading'); // keep network details in sync with network state

          this.clearNetworkDetails();
          return;
        }

        this.setNetworkState(networkVersion); // look up EIP-1559 support

        this.getEIP1559Compatibility();
      }
    });
  }

  getCurrentChainId() {
    var _NETWORK_TYPE_TO_ID_M;

    const {
      type,
      chainId: configChainId
    } = this.getProviderConfig();
    return ((_NETWORK_TYPE_TO_ID_M = _network.NETWORK_TYPE_TO_ID_MAP[type]) === null || _NETWORK_TYPE_TO_ID_M === void 0 ? void 0 : _NETWORK_TYPE_TO_ID_M.chainId) || configChainId;
  }

  setRpcTarget(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs) {
    _assert.strict.ok((0, _network2.isPrefixedFormattedHexString)(chainId), `Invalid chain ID "${chainId}": invalid hex string.`);

    _assert.strict.ok((0, _network2.isSafeChainId)(parseInt(chainId, 16)), `Invalid chain ID "${chainId}": numerical value greater than max safe value.`);

    this.setProviderConfig({
      type: _network.NETWORK_TYPE_RPC,
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
  }

  async setProviderType(type) {
    _assert.strict.notStrictEqual(type, _network.NETWORK_TYPE_RPC, `NetworkController - cannot call "setProviderType" with type "${_network.NETWORK_TYPE_RPC}". Use "setRpcTarget"`);

    _assert.strict.ok(_network.INFURA_PROVIDER_TYPES.includes(type), `Unknown Infura provider type "${type}".`);

    const {
      chainId
    } = _network.NETWORK_TYPE_TO_ID_MAP[type];
    this.setProviderConfig({
      type,
      rpcUrl: '',
      chainId,
      ticker: 'ETH',
      nickname: ''
    });
  }

  resetConnection() {
    this.setProviderConfig(this.getProviderConfig());
  }
  /**
   * Sets the provider config and switches the network.
   */


  setProviderConfig(config) {
    this.previousProviderStore.updateState(this.getProviderConfig());
    this.providerStore.updateState(config);

    this._switchNetwork(config);
  }

  rollbackToPreviousProvider() {
    const config = this.previousProviderStore.getState();
    this.providerStore.updateState(config);

    this._switchNetwork(config);
  }

  getProviderConfig() {
    return this.providerStore.getState();
  }

  getNetworkIdentifier() {
    const provider = this.providerStore.getState();
    return provider.type === _network.NETWORK_TYPE_RPC ? provider.rpcUrl : provider.type;
  } //
  // Private
  //


  async _checkInfuraAvailability(network) {
    const rpcUrl = `https://${network}.infura.io/v3/${this._infuraProjectId}`;
    let networkChanged = false;
    this.once(NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {
      networkChanged = true;
    });

    try {
      const response = await fetchWithTimeout(rpcUrl, {
        method: 'POST',
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: 'eth_blockNumber',
          params: [],
          id: 1
        })
      });

      if (networkChanged) {
        return;
      }

      if (response.ok) {
        this.emit(NETWORK_EVENTS.INFURA_IS_UNBLOCKED);
      } else {
        const responseMessage = await response.json();

        if (networkChanged) {
          return;
        }

        if (responseMessage.error === _network.INFURA_BLOCKED_KEY) {
          this.emit(NETWORK_EVENTS.INFURA_IS_BLOCKED);
        }
      }
    } catch (err) {
      _loglevel.default.warn(`MetaMask - Infura availability check failed`, err);
    }
  }

  _switchNetwork(opts) {
    // Indicate to subscribers that network is about to change
    this.emit(NETWORK_EVENTS.NETWORK_WILL_CHANGE); // Set loading state

    this.setNetworkState('loading'); // Reset network details

    this.clearNetworkDetails(); // Configure the provider appropriately

    this._configureProvider(opts); // Notify subscribers that network has changed


    this.emit(NETWORK_EVENTS.NETWORK_DID_CHANGE, opts.type);
  }

  _configureProvider({
    type,
    rpcUrl,
    chainId
  }) {
    // infura type-based endpoints
    const isInfura = _network.INFURA_PROVIDER_TYPES.includes(type);

    if (isInfura) {
      this._configureInfuraProvider(type, this._infuraProjectId); // url-based rpc endpoints

    } else if (type === _network.NETWORK_TYPE_RPC) {
      this._configureStandardProvider(rpcUrl, chainId);
    } else {
      throw new Error(`NetworkController - _configureProvider - unknown type "${type}"`);
    }
  }

  _configureInfuraProvider(type, projectId) {
    _loglevel.default.info('NetworkController - configureInfuraProvider', type);

    const networkClient = (0, _createInfuraClient.default)({
      network: type,
      projectId
    });

    this._setNetworkClient(networkClient);
  }

  _configureStandardProvider(rpcUrl, chainId) {
    _loglevel.default.info('NetworkController - configureStandardProvider', rpcUrl);

    const networkClient = (0, _createJsonRpcClient.default)({
      rpcUrl,
      chainId
    });

    this._setNetworkClient(networkClient);
  }

  _setNetworkClient({
    networkMiddleware,
    blockTracker
  }) {
    const metamaskMiddleware = (0, _createMetamaskMiddleware.default)(this._baseProviderParams);
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    engine.push(metamaskMiddleware);
    engine.push(networkMiddleware);
    const provider = (0, _ethJsonRpcMiddleware.providerFromEngine)(engine);

    this._setProviderAndBlockTracker({
      provider,
      blockTracker
    });
  }

  _setProviderAndBlockTracker({
    provider,
    blockTracker
  }) {
    // update or initialize proxies
    if (this._providerProxy) {
      this._providerProxy.setTarget(provider);
    } else {
      this._providerProxy = (0, _swappableObjProxy.createSwappableProxy)(provider);
    }

    if (this._blockTrackerProxy) {
      this._blockTrackerProxy.setTarget(blockTracker);
    } else {
      this._blockTrackerProxy = (0, _swappableObjProxy.createEventEmitterProxy)(blockTracker, {
        eventFilter: 'skipInternal'
      });
    } // set new provider and blockTracker


    this._provider = provider;
    this._blockTracker = blockTracker;
  }

}

exports.default = NetworkController;


}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/network.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/node_modules/hdkey/lib/hdkey.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","coinstring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/lib/coinstring.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/node_modules/hdkey/lib/hdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
}, {package:"hdkey",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-trezor-keyring/node_modules/hdkey/lib/hdkey.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js","./env/node":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/index.js","./types":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/index.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
var _exportNames = {};
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _constants[key]) return;
  exports[key] = _constants[key];
});

var _node = require("./env/node");

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var TrezorConnect = {
  manifest: _node.manifest,
  init: _node.init,
  getSettings: _node.getSettings,
  on: function on(type, fn) {
    _node.eventEmitter.on(type, fn);
  },
  off: function off(type, fn) {
    _node.eventEmitter.removeListener(type, fn);
  },
  removeAllListeners: function removeAllListeners() {
    _node.eventEmitter.removeAllListeners();
  },
  uiResponse: _node.uiResponse,
  // methods
  blockchainGetAccountBalanceHistory: function blockchainGetAccountBalanceHistory(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetAccountBalanceHistory'
    }, params));
  },
  blockchainGetCurrentFiatRates: function blockchainGetCurrentFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetCurrentFiatRates'
    }, params));
  },
  blockchainGetFiatRatesForTimestamps: function blockchainGetFiatRatesForTimestamps(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetFiatRatesForTimestamps'
    }, params));
  },
  blockchainDisconnect: function blockchainDisconnect(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainDisconnect'
    }, params));
  },
  blockchainEstimateFee: function blockchainEstimateFee(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainEstimateFee'
    }, params));
  },
  blockchainGetTransactions: function blockchainGetTransactions(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainGetTransactions'
    }, params));
  },
  blockchainSetCustomBackend: function blockchainSetCustomBackend(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSetCustomBackend'
    }, params));
  },
  blockchainSubscribe: function blockchainSubscribe(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSubscribe'
    }, params));
  },
  blockchainSubscribeFiatRates: function blockchainSubscribeFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainSubscribeFiatRates'
    }, params));
  },
  blockchainUnsubscribe: function blockchainUnsubscribe(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainUnsubscribe'
    }, params));
  },
  blockchainUnsubscribeFiatRates: function blockchainUnsubscribeFiatRates(params) {
    return (0, _node.call)(_objectSpread({
      method: 'blockchainUnsubscribeFiatRates'
    }, params));
  },
  customMessage: function customMessage(params) {
    return (0, _node.customMessage)(params);
  },
  requestLogin: function requestLogin(params) {
    return (0, _node.requestLogin)(params);
  },
  cardanoGetAddress: function cardanoGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'cardanoGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  cardanoGetNativeScriptHash: function cardanoGetNativeScriptHash(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoGetNativeScriptHash'
    }, params));
  },
  cardanoGetPublicKey: function cardanoGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoGetPublicKey'
    }, params));
  },
  cardanoSignTransaction: function cardanoSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cardanoSignTransaction'
    }, params));
  },
  cipherKeyValue: function cipherKeyValue(params) {
    return (0, _node.call)(_objectSpread({
      method: 'cipherKeyValue'
    }, params));
  },
  composeTransaction: function composeTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'composeTransaction'
    }, params));
  },
  debugLinkDecision: function debugLinkDecision(params) {
    return (0, _node.call)(_objectSpread({
      method: 'debugLinkDecision'
    }, params));
  },
  debugLinkGetState: function debugLinkGetState(params) {
    return (0, _node.call)(_objectSpread({
      method: 'debugLinkGetState'
    }, params));
  },
  ethereumGetAddress: function ethereumGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'ethereumGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  ethereumGetPublicKey: function ethereumGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumGetPublicKey'
    }, params));
  },
  ethereumSignMessage: function ethereumSignMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignMessage'
    }, params));
  },
  ethereumSignTransaction: function ethereumSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumSignTransaction'
    }, params));
  },
  ethereumVerifyMessage: function ethereumVerifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'ethereumVerifyMessage'
    }, params));
  },
  getAccountInfo: function getAccountInfo(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getAccountInfo'
    }, params));
  },
  getAddress: function getAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'getAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  getDeviceState: function getDeviceState(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getDeviceState'
    }, params));
  },
  getFeatures: function getFeatures(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getFeatures'
    }, params));
  },
  getPublicKey: function getPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getPublicKey'
    }, params));
  },
  liskGetAddress: function liskGetAddress() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskGetPublicKey: function liskGetPublicKey() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskSignMessage: function liskSignMessage() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskSignTransaction: function liskSignTransaction() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  liskVerifyMessage: function liskVerifyMessage() {
    return (0, _node.call)({
      method: 'liskDeprecated'
    });
  },
  nemGetAddress: function nemGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'nemGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  nemSignTransaction: function nemSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'nemSignTransaction'
    }, params));
  },
  pushTransaction: function pushTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'pushTransaction'
    }, params));
  },
  rippleGetAddress: function rippleGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'rippleGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  rippleSignTransaction: function rippleSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'rippleSignTransaction'
    }, params));
  },
  signMessage: function signMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'signMessage'
    }, params));
  },
  signTransaction: function signTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'signTransaction'
    }, params));
  },
  stellarGetAddress: function stellarGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'stellarGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  stellarSignTransaction: function stellarSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'stellarSignTransaction'
    }, params));
  },
  tezosGetAddress: function tezosGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'tezosGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  tezosGetPublicKey: function tezosGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'tezosGetPublicKey'
    }, params));
  },
  tezosSignTransaction: function tezosSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'tezosSignTransaction'
    }, params));
  },
  eosGetPublicKey: function eosGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'eosGetPublicKey'
    }, params));
  },
  eosSignTransaction: function eosSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'eosSignTransaction'
    }, params));
  },
  binanceGetAddress: function binanceGetAddress(params) {
    var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
    return (0, _node.call)(_objectSpread(_objectSpread({
      method: 'binanceGetAddress'
    }, params), {}, {
      useEventListener: useEventListener
    }));
  },
  binanceGetPublicKey: function binanceGetPublicKey(params) {
    return (0, _node.call)(_objectSpread({
      method: 'binanceGetPublicKey'
    }, params));
  },
  binanceSignTransaction: function binanceSignTransaction(params) {
    return (0, _node.call)(_objectSpread({
      method: 'binanceSignTransaction'
    }, params));
  },
  verifyMessage: function verifyMessage(params) {
    return (0, _node.call)(_objectSpread({
      method: 'verifyMessage'
    }, params));
  },
  resetDevice: function resetDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'resetDevice'
    }, params));
  },
  wipeDevice: function wipeDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'wipeDevice'
    }, params));
  },
  applyFlags: function applyFlags(params) {
    return (0, _node.call)(_objectSpread({
      method: 'applyFlags'
    }, params));
  },
  applySettings: function applySettings(params) {
    return (0, _node.call)(_objectSpread({
      method: 'applySettings'
    }, params));
  },
  backupDevice: function backupDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'backupDevice'
    }, params));
  },
  changePin: function changePin(params) {
    return (0, _node.call)(_objectSpread({
      method: 'changePin'
    }, params));
  },
  firmwareUpdate: function firmwareUpdate(params) {
    return (0, _node.call)(_objectSpread({
      method: 'firmwareUpdate'
    }, params));
  },
  recoveryDevice: function recoveryDevice(params) {
    return (0, _node.call)(_objectSpread({
      method: 'recoveryDevice'
    }, params));
  },
  getCoinInfo: function getCoinInfo(params) {
    return (0, _node.call)(_objectSpread({
      method: 'getCoinInfo'
    }, params));
  },
  rebootToBootloader: function rebootToBootloader(params) {
    return (0, _node.call)(_objectSpread({
      method: 'rebootToBootloader'
    }, params));
  },
  dispose: _node.dispose,
  cancel: _node.cancel,
  renderWebUSBButton: _node.renderWebUSBButton,
  disableWebUSB: _node.disableWebUSB
};
var _default = TrezorConnect;
exports["default"] = _default;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/hdkey/lib/hdkey.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","coinstring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/lib/coinstring.js","crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypto-browserify/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/hdkey/lib/hdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
}, {package:"hdkey",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/hdkey/lib/hdkey.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-abi/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js","tweetnacl":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl/nacl-fast.js","tweetnacl-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/tweetnacl-util/nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/index.js
      return function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



      };
    };
  }
}, {package:"eth-sig-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerAsMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerAsMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-cache.js", {"./utils/cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCacheForPayload(_payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(payload, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        // lookup payload in block cache
        const identifier = (0, cache_1.cacheIdentifierForPayload)(payload, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(payload, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(payload, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = (0, cache_1.cacheIdentifierForPayload)(payload, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(payload) {
        // check request method
        if (!(0, cache_1.canCache)(payload)) {
            return false;
        }
        // check blockTag
        const blockTag = (0, cache_1.blockTagForPayload)(payload);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(payload, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (payload.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache,
    };
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = (0, cache_1.cacheTypeForPayload)(req);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        let blockTag = (0, cache_1.blockTagForPayload)(req);
        if (!blockTag) {
            blockTag = 'latest';
        }
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-cache.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-tracker-inspector.js", {"json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        if (!((_a = res.result) === null || _a === void 0 ? void 0 : _a.blockNumber)) {
            return undefined;
        }
        if (typeof res.result.blockNumber === 'string') {
            // if number is higher, suggest block-tracker check for a new block
            const blockNumber = Number.parseInt(res.result.blockNumber, 16);
            // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
            const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
            if (blockNumber > currentBlockNumber) {
                await blockTracker.checkForLatestBlock();
            }
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-tracker-inspector.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/inflight-cache.js", {"./utils/cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js","clone":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/clone/clone.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/inflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = (0, cache_1.cacheIdentifierForPayload)(req);
        // if not cacheable, skip
        if (!cacheId) {
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = (0, clone_1.default)(handledRes.result);
            res.error = (0, clone_1.default)(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/inflight-cache.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/fetch.js", {"btoa":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","node-fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/browser-resolve/empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/fetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/* eslint-disable node/global-require,@typescript-eslint/no-require-imports */
const fetch = global.fetch || require('node-fetch');
const btoa = global.btoa || require('btoa');
/* eslint-enable node/global-require,@typescript-eslint/no-require-imports */
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
function createFetchMiddleware({ rpcUrl, originHttpHeaderKey, }) {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/fetch.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromMiddleware.js", {"./providerFromEngine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromEngine.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const providerFromEngine_1 = require("./providerFromEngine");
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = (0, providerFromEngine_1.providerFromEngine)(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=providerFromMiddleware.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/retryOnEmpty.js", {"./utils/cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js","clone":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/clone/clone.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","pify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/pify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/retryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const cache_1 = require("./utils/cache");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            return next();
        }
        // create child request with specific block-ref
        const childRequest = (0, clone_1.default)(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            const attemptResponse = await (0, pify_1.default)(provider.sendAsync).call(provider, childRequest);
            // verify result
            if (emptyValues.includes(attemptResponse)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return next();
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            await timeout(1000);
        }
    }
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/retryOnEmpty.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref.js", {"./utils/cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js","clone":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/clone/clone.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","pify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/pify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const cache_1 = require("./utils/cache");
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        // create child request with specific block-ref
        const childRequest = (0, clone_1.default)(req);
        if (childRequest.params) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        const childRes = await (0, pify_1.default)(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return next();
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromEngine.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
function providerFromEngine(engine) {
    const provider = new safe_event_emitter_1.default();
    // handle both rpc send methods
    provider.sendAsync = engine.handle.bind(engine);
    provider.send = (req, callback) => {
        if (typeof callback !== 'function') {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            provider.emit('data', null, message);
        });
    }
    return provider;
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=providerFromEngine.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/providerFromEngine.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref-rewrite.js", {"./utils/cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, _res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (req.params) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/block-ref-rewrite.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/wallet.js", {"eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","eth-sig-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/eth-sig-util/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/wallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return (0, json_rpc_engine_1.createScaffoldMiddleware)({
        // account lookups
        eth_accounts: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupAccounts),
        eth_coinbase: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(sendTransaction),
        eth_signTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(signTransaction),
        // message signatures
        eth_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(ethSign),
        eth_signTypedData: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedData),
        eth_signTypedData_v3: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV3),
        eth_signTypedData_v4: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV4),
        personal_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(personalSign),
        eth_getEncryptionPublicKey: (0, json_rpc_engine_1.createAsyncMiddleware)(encryptionPublicKey),
        eth_decrypt: (0, json_rpc_engine_1.createAsyncMiddleware)(decryptMessage),
        personal_ecRecover: (0, json_rpc_engine_1.createAsyncMiddleware)(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { sig: signature, data: message });
        const signerAddress = sigUtil.recoverPersonalSignature(msgParams);
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' && address.length > 0) {
            // ensure address is included in provided accounts
            const accounts = await getAccounts(req);
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/wallet.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/node_modules/bignumber.js/bignumber.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/node_modules/bignumber.js/bignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.0.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                    // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',      // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on ±Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and ±Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to ±Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = ±Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return ±0, else return ±Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, ±Infinity or ±0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return ±Infinity if either is ±Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return ±0 if either is ±0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return ±Infinity if either ±Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) i = g1, g1 = g2, g2 = i, len -= i;

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
}, {package:"bignumber.js",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-lattice-keyring/node_modules/bignumber.js/bignumber.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/index.js", {"./src/client":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/client.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/index.js
      return function (require, module, exports) {
const Client = require('./src/client');

module.exports = {
  Client,
};

      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js", {"./SubjectMetadataController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SubjectMetadataController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/index.js", {"./SnapController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SnapController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/index.js", {"./ExternalResourceController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ExternalResourceController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/index.js", {"./ExecutionEnvironmentService":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js","./WebWorkerExecutionEnvironmentService":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ExecutionEnvironmentService"), exports);
__exportStar(require("./WebWorkerExecutionEnvironmentService"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/index.js", {"./Caveat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js","./Permission":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js","./PermissionController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js","./rpc-methods":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.permissionRpcMethods = void 0;
__exportStar(require("./Caveat"), exports);
__exportStar(require("./Permission"), exports);
__exportStar(require("./PermissionController"), exports);
__exportStar(require("./utils"), exports);
// TODO: Move these to the appropriate package
exports.permissionRpcMethods = __importStar(require("./rpc-methods"));
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.development.js", {"@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","@keystonehq/base-eth-keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/index.js","@keystonehq/bc-ur-registry-eth":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var baseEthKeyring = require('@keystonehq/base-eth-keyring');
var events = require('events');
var obsStore = require('@metamask/obs-store');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');
var tx = require('@ethereumjs/tx');
var rlp = _interopDefault(require('rlp'));

class MetamaskInteractionProvider extends events.EventEmitter {
  constructor() {
    super();

    this.readCryptoHDKeyOrCryptoAccount = () => {
      return new Promise((resolve, reject) => {
        this.memStore.updateState({
          sync: {
            reading: true
          }
        });
        this.on('keystone-sync_success-hdkey', cbor => {
          const cryptoHDKey = bcUrRegistryEth.CryptoHDKey.fromCBOR(Buffer.from(cbor, 'hex'));
          this.resetState();
          resolve(cryptoHDKey);
        });
        this.on('keystone-sync_success-account', cbor => {
          const cryptoAccount = bcUrRegistryEth.CryptoAccount.fromCBOR(Buffer.from(cbor, 'hex'));
          this.resetState();
          resolve(cryptoAccount);
        });
        this.on('keystone-sync_cancel', () => {
          this.resetState();
          reject(new Error('KeystoneError#sync_cancel. Sync process canceled, please retry'));
        });
      });
    };

    this.submitCryptoHDKey = cbor => {
      this.emit('keystone-sync_success-hdkey', cbor);
    };

    this.submitCryptoAccount = cbor => {
      this.emit('keystone-sync_success-account', cbor);
    };

    this.cancelSync = () => {
      this.emit('keystone-sync_cancel');
    };

    this.requestSignature = (signRequest, requestTitle, requestDescription) => {
      return new Promise((resolve, reject) => {
        const ur = signRequest.toUR();
        const requestIdBuffer = signRequest.getRequestId();
        const requestId = uuid.stringify(requestIdBuffer);
        const signPayload = {
          requestId,
          payload: {
            type: ur.type,
            cbor: ur.cbor.toString('hex')
          },
          title: requestTitle,
          description: requestDescription
        };
        this.memStore.updateState({
          sign: {
            request: signPayload
          }
        });
        this.once(`${requestId}-signed`, cbor => {
          const ethSignature = bcUrRegistryEth.ETHSignature.fromCBOR(Buffer.from(cbor, 'hex'));
          this.resetState();
          resolve(ethSignature);
        });
        this.once(`${requestId}-canceled`, () => {
          this.resetState();
          reject(new Error('KeystoneError#Tx_canceled. Signing canceled, please retry'));
        });
      });
    };

    this.submitSignature = (requestId, cbor) => {
      this.emit(`${requestId}-signed`, cbor);
    };

    this.cancelRequestSignature = () => {
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.memStore.updateState({
          sign: {}
        });
        this.emit(`${requestId}-canceled`);
      }
    };

    this.resetState = () => {
      this.memStore.updateState({
        sync: {
          reading: false
        },
        sign: {}
      });
    };

    if (MetamaskInteractionProvider.instance) {
      return MetamaskInteractionProvider.instance;
    }

    this.memStore = new obsStore.ObservableStore({
      sync: {
        reading: false
      },
      sign: {},
      _version: 1
    });
    MetamaskInteractionProvider.instance = this;
  }

}

class MetaMaskKeyring extends baseEthKeyring.BaseKeyring {
  constructor(opts) {
    super(opts);

    this.getInteraction = () => {
      return new MetamaskInteractionProvider();
    };

    this.getMemStore = () => {
      return this.getInteraction().memStore;
    };

    this.removeAccount = address => {
      if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new Error(`Address ${address} not found in this keyring`);
      }

      this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
    };

    this.forgetDevice = () => {
      //common props
      this.page = 0;
      this.perPage = 5;
      this.accounts = [];
      this.currentAccount = 0;
      this.name = 'QR Hardware';
      this.initialized = false; //hd props;

      this.xfp = '';
      this.xpub = '';
      this.hdPath = '';
      this.indexes = {};
      this.hdk = undefined; //pubkey props;

      this.paths = {};
    };

    this.submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;
    this.submitCryptoAccount = this.getInteraction().submitCryptoAccount;
    this.submitSignature = this.getInteraction().submitSignature;
    this.cancelSync = this.getInteraction().cancelSync;
    this.cancelSignRequest = this.getInteraction().cancelRequestSignature;

    if (MetaMaskKeyring.instance) {
      MetaMaskKeyring.instance.deserialize(opts);
      return MetaMaskKeyring.instance;
    }

    MetaMaskKeyring.instance = this;
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = rlp.encode(tx$1.getMessageToSign(false));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx$1.type;
    const transaction = tx.TransactionFactory.fromTxData(txJson, {
      common: tx$1.common
    });
    return transaction;
  }

}
MetaMaskKeyring.type = baseEthKeyring.BaseKeyring.type;

exports.MetaMaskKeyring = MetaMaskKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.development.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.production.min.js", {"@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ethereumjs/tx/dist.browser/index.js","@keystonehq/base-eth-keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/index.js","@keystonehq/bc-ur-registry-eth":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("@keystonehq/base-eth-keyring"),s=require("events"),n=require("@metamask/obs-store"),i=require("@keystonehq/bc-ur-registry-eth"),r=require("uuid"),c=require("@ethereumjs/tx"),o=(e=require("rlp"))&&"object"==typeof e&&"default"in e?e.default:e;class a extends s.EventEmitter{constructor(){if(super(),this.readCryptoHDKeyOrCryptoAccount=()=>new Promise((e,t)=>{this.memStore.updateState({sync:{reading:!0}}),this.on("keystone-sync_success-hdkey",t=>{const s=i.CryptoHDKey.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_success-account",t=>{const s=i.CryptoAccount.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_cancel",()=>{this.resetState(),t(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"))})}),this.submitCryptoHDKey=e=>{this.emit("keystone-sync_success-hdkey",e)},this.submitCryptoAccount=e=>{this.emit("keystone-sync_success-account",e)},this.cancelSync=()=>{this.emit("keystone-sync_cancel")},this.requestSignature=(e,t,s)=>new Promise((n,c)=>{const o=e.toUR(),a=e.getRequestId(),h=r.stringify(a),u={requestId:h,payload:{type:o.type,cbor:o.cbor.toString("hex")},title:t,description:s};this.memStore.updateState({sign:{request:u}}),this.once(h+"-signed",e=>{const t=i.ETHSignature.fromCBOR(Buffer.from(e,"hex"));this.resetState(),n(t)}),this.once(h+"-canceled",()=>{this.resetState(),c(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"))})}),this.submitSignature=(e,t)=>{this.emit(e+"-signed",t)},this.cancelRequestSignature=()=>{const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.memStore.updateState({sign:{}}),this.emit(t+"-canceled")}},this.resetState=()=>{this.memStore.updateState({sync:{reading:!1},sign:{}})},a.instance)return a.instance;this.memStore=new n.ObservableStore({sync:{reading:!1},sign:{},_version:1}),a.instance=this}}class h extends t.BaseKeyring{constructor(e){if(super(e),this.getInteraction=()=>new a,this.getMemStore=()=>this.getInteraction().memStore,this.removeAccount=e=>{if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())},this.forgetDevice=()=>{this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.name="QR Hardware",this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.indexes={},this.hdk=void 0,this.paths={}},this.submitCryptoHDKey=this.getInteraction().submitCryptoHDKey,this.submitCryptoAccount=this.getInteraction().submitCryptoAccount,this.submitSignature=this.getInteraction().submitSignature,this.cancelSync=this.getInteraction().cancelSync,this.cancelSignRequest=this.getInteraction().cancelRequestSignature,h.instance)return h.instance.deserialize(e),h.instance;h.instance=this}async signTransaction(e,t){const s=0===t.type?i.DataType.transaction:i.DataType.typedTransaction;let n;n=0===t.type?o.encode(t.getMessageToSign(!1)):t.getMessageToSign(!1);const a=await this._pathFromAddress(e),h=t.common.chainId(),u=r.v4(),y=i.EthSignRequest.constructETHRequest(n,s,a,this.xfp,u,h),{r:g,s:m,v:d}=await this.requestSignature(u,y,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),p=t.toJSON();return p.v=d,p.s=m,p.r=g,p.type=t.type,c.TransactionFactory.fromTxData(p,{common:t.common})}}h.type=t.BaseKeyring.type,exports.MetaMaskKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/dist/metamask-airgapped-keyring.cjs.production.min.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/development/mock-3box.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/development/mock-3box.js
      return function (require, module, exports) {
"use strict";

function delay(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

async function loadFromMock3Box(key) {
  const res = await window.fetch(`http://localhost:8889?key=${key}`);
  const text = await res.text();
  return text.length ? JSON.parse(text) : null;
}

async function saveToMock3Box(key, newDataAtKey) {
  const res = await window.fetch('http://localhost:8889', {
    method: 'POST',
    body: JSON.stringify({
      key,
      data: newDataAtKey
    })
  });
  return res.text();
}

class Mock3Box {
  static openBox(address) {
    this.address = address;
    return Promise.resolve({
      onSyncDone: cb => {
        setTimeout(cb, 200);
      },
      openSpace: async (spaceName, config) => {
        const {
          onSyncDone
        } = config;
        this.spaceName = spaceName;
        setTimeout(onSyncDone, 150);
        await delay(50);
        return {
          private: {
            get: async key => {
              await delay(50);
              const res = await loadFromMock3Box(`${this.address}-${this.spaceName}-${key}`);
              return res;
            },
            set: async (key, data) => {
              await saveToMock3Box(`${this.address}-${this.spaceName}-${key}`, data);
              await delay(50);
              return null;
            }
          }
        };
      },
      logout: () => undefined
    });
  }

  static async getConfig(address) {
    const backup = await loadFromMock3Box(`${address}-metamask-metamaskBackup`);
    return backup ? {
      spaces: {
        metamask: {}
      }
    } : {};
  }

}

module.exports = Mock3Box;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/development/mock-3box.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createMetamaskMiddleware.js", {"./middleware/pending":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/middleware/pending.js","eth-json-rpc-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createMetamaskMiddleware.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMetamaskMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _pending = require("./middleware/pending");

function createMetamaskMiddleware({
  version,
  getAccounts,
  processTransaction,
  processEthSignMessage,
  processTypedMessage,
  processTypedMessageV3,
  processTypedMessageV4,
  processPersonalMessage,
  processDecryptMessage,
  processEncryptionPublicKey,
  getPendingNonce,
  getPendingTransactionByHash
}) {
  const metamaskMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([(0, _jsonRpcEngine.createScaffoldMiddleware)({
    eth_syncing: false,
    web3_clientVersion: `MetaMask/v${version}`
  }), (0, _ethJsonRpcMiddleware.createWalletMiddleware)({
    getAccounts,
    processTransaction,
    processEthSignMessage,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processDecryptMessage,
    processEncryptionPublicKey
  }), (0, _pending.createPendingNonceMiddleware)({
    getPendingNonce
  }), (0, _pending.createPendingTxMiddleware)({
    getPendingTransactionByHash
  })]);
  return metamaskMiddleware;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createMetamaskMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3box.js", {"./3id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/index.js","./api":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/api.js","./config.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js","./privateStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/privateStore.js","./publicStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/publicStore.js","./space":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/space.js","./utils/id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/id.js","./utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","./verified":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/verified.js","3box-orbitdb-plugins":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/index.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/slicedToArray":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/slicedToArray.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/index.js","orbit-db":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/OrbitDB.js","orbit-db-access-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/index.js","orbit-db-pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/index.js","store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/dist/store.legacy.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3box.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var localstorage = require('store');

var IPFS = require('ipfs');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client
// const { createProxyClient } = require('ipfs-postmsg-proxy')


var AccessControllers = require('orbit-db-access-controllers');

var _require = require('3box-orbitdb-plugins'),
    LegacyIPFS3BoxAccessController = _require.LegacyIPFS3BoxAccessController,
    ThreadAccessController = _require.ThreadAccessController,
    ModeratorAccessController = _require.ModeratorAccessController;

AccessControllers.addAccessController({
  AccessController: LegacyIPFS3BoxAccessController
});
AccessControllers.addAccessController({
  AccessController: ThreadAccessController
});
AccessControllers.addAccessController({
  AccessController: ModeratorAccessController
});

var ThreeId = require('./3id');

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var Space = require('./space');

var utils = require('./utils/index');

var idUtils = require('./utils/id');

var config = require('./config.js');

var API = require('./api');

var ACCOUNT_TYPES = {
  ethereum: 'ethereum',
  ethereumEOA: 'ethereum-eoa'
};
var ADDRESS_SERVER_URL = config.address_server_url;
var PINNING_NODE = config.pinning_node;
var PINNING_ROOM = config.pinning_room; // const IFRAME_STORE_VERSION = '0.0.3'
// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`

var IPFS_OPTIONS = config.ipfs_options;
var ORBITDB_OPTS = config.orbitdb_options;
var globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise

/*
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const iframe = document.createElement('iframe')
  iframe.src = IFRAME_STORE_URL
  iframe.style = 'width:0; height:0; border:0; border:none !important'

  iframeLoadedPromise = new Promise((resolve, reject) => {
    iframe.onload = () => { resolve() }
  })

  document.body.appendChild(iframe)
  // Create proxy clients that talks to the iframe
  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)
  ipfsProxy = createProxyClient({ postMessage })
  cacheProxy = OrbitDBCacheProxy({ postMessage })
} */

var Box =
/*#__PURE__*/
function () {
  /**
   * Please use the **openBox** method to instantiate a 3Box
   */
  function Box(threeId, ethereumProvider, ipfs) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Box);
    this._3id = threeId;
    this._web3provider = ethereumProvider;
    this._ipfs = ipfs;
    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;

    this._onSyncDoneCB = function () {};

    this._boxSynced = false;
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    this["private"] = null;
    /**
     * @property {Verified} verified        check and create verifications
     */

    this.verified = new Verified(this);
    /**
     * @property {Object} spaces            an object containing all open spaces indexed by their name.
     */

    this.spaces = {}; // local store of all pinning server pubsub messages seen related to spaces

    this.spacesPubSubMessages = {};
  }

  (0, _createClass2["default"])(Box, [{
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        var _this = this;

        var opts,
            rootStoreName,
            key,
            rootStoreAddress,
            onNewPeer,
            _ref2,
            _ref3,
            pubStoreAddress,
            privStoreAddress,
            syncPromises,
            hasResponse,
            spaceMessageFilterActive,
            filterTimeSet,
            onMessageRes,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                rootStoreName = this._3id.muportFingerprint + '.root';
                this.pinningNode = opts.pinningNode || PINNING_NODE;

                this._ipfs.swarm.connect(this.pinningNode, function () {});

                _context3.t0 = OrbitDB;
                _context3.t1 = this._ipfs;
                _context3.t2 = opts.orbitPath;
                _context3.next = 9;
                return this._3id.getOdbId();

              case 9:
                _context3.t3 = _context3.sent;
                _context3.t4 = {
                  directory: _context3.t2,
                  identity: _context3.t3
                };
                _context3.next = 13;
                return _context3.t0.createInstance.call(_context3.t0, _context3.t1, _context3.t4);

              case 13:
                this._orbitdb = _context3.sent;
                // , { cache })
                globalOrbitDB = this._orbitdb;
                key = this._3id.getKeyringBySpaceName(rootStoreName).getPublicKeys(true).signingKey;
                _context3.next = 18;
                return this._orbitdb.feed(rootStoreName, _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                }));

              case 18:
                this._rootStore = _context3.sent;
                rootStoreAddress = this._rootStore.address.toString();
                _context3.t5 = Pubsub;
                _context3.t6 = this._ipfs;
                _context3.next = 24;
                return this._ipfs.id();

              case 24:
                _context3.t7 = _context3.sent.id;
                this._pubsub = new _context3.t5(_context3.t6, _context3.t7);

                onNewPeer =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee(topic, peer) {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (peer === _this.pinningNode.split('/').pop()) {
                              _this._pubsub.publish(PINNING_ROOM, {
                                type: 'PIN_DB',
                                odbAddress: rootStoreAddress,
                                did: _this.DID
                              });
                            }

                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function onNewPeer(_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                this["public"] = new PublicStore(this._orbitdb, this._3id.muportFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this), this._3id);
                this["private"] = new PrivateStore(this._orbitdb, this._3id.muportFingerprint + '.private', this._ensurePinningNodeConnected.bind(this), this._3id);
                _context3.next = 31;
                return Promise.all([this["public"]._load(), this["private"]._load()]);

              case 31:
                _ref2 = _context3.sent;
                _ref3 = (0, _slicedToArray2["default"])(_ref2, 2);
                pubStoreAddress = _ref3[0];
                privStoreAddress = _ref3[1];
                syncPromises = [];
                hasResponse = {}; // Filters and store space related messages for 3secs, the best effort
                // simple approach, until refactor

                spaceMessageFilterActive = true;
                filterTimeSet = false;

                onMessageRes =
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee2(topic, data) {
                    var promises;
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!filterTimeSet) {
                              filterTimeSet = true;
                              setTimeout(function () {
                                spaceMessageFilterActive = false;
                              }, 3000);
                            }

                            if (!(data.type === 'HAS_ENTRIES')) {
                              _context2.next = 12;
                              break;
                            }

                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {
                              syncPromises.push(_this["private"]._sync(data.numEntries));
                              hasResponse[privStoreAddress] = true;
                            }

                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {
                              syncPromises.push(_this["public"]._sync(data.numEntries));
                              hasResponse[pubStoreAddress] = true;
                            }

                            if (spaceMessageFilterActive && data.odbAddress.includes('space') === true) {
                              _this.spacesPubSubMessages[data.odbAddress] = data;
                            }

                            if (!(syncPromises.length === 2)) {
                              _context2.next = 12;
                              break;
                            }

                            promises = syncPromises;
                            syncPromises = [];
                            _context2.next = 10;
                            return Promise.all(promises);

                          case 10:
                            _this._boxSynced = true;

                            _this._onSyncDoneCB(); // this._pubsub.unsubscribe(PINNING_ROOM)


                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function onMessageRes(_x4, _x5) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);

                _context3.next = 43;
                return this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);

              case 43:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _load() {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_createRootStore",
    value: function () {
      var _createRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(rootStoreAddress, privOdbAddress, pubOdbAddress) {
        var _this2 = this;

        var entries, pinAddressLinks;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._rootStore.load();

              case 2:
                _context5.next = 4;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 4:
                entries = _context5.sent;

                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === pubOdbAddress;
                })) {
                  _context5.next = 8;
                  break;
                }

                _context5.next = 8;
                return this._rootStore.add({
                  odbAddress: pubOdbAddress
                });

              case 8:
                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === privOdbAddress;
                })) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this._rootStore.add({
                  odbAddress: privOdbAddress
                });

              case 11:
                this._publishRootStore(rootStoreAddress);

                pinAddressLinks =
                /*#__PURE__*/
                function () {
                  var _ref5 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4() {
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            // Filter for address-links, get CID, and get to pin it
                            entries.filter(function (entry) {
                              return entry.payload.value.type === 'address-link';
                            }).map(function (entry) {
                              _this2._ipfs.dag.get(entry.payload.value.data);
                            });

                          case 1:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function pinAddressLinks() {
                    return _ref5.apply(this, arguments);
                  };
                }();

                pinAddressLinks();

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _createRootStore(_x6, _x7, _x8) {
        return _createRootStore2.apply(this, arguments);
      }

      return _createRootStore;
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.addressServer      URL of the Address Server
     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object
     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "openSpace",

    /**
     * Opens the space with the given name in the users 3Box
     *
     * @param     {String}            name                    The name of the space
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node
     * @return    {Space}                                     the Space instance for the given space name
     */
    value: function () {
      var _openSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(name) {
        var opts,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (this.spaces[name]) {
                  _context6.next = 23;
                  break;
                }

                this.spaces[name] = new Space(name, this._3id, this._orbitdb, this._rootStore, this._ensurePinningNodeConnected.bind(this));
                _context6.prev = 3;
                opts = Object.assign({
                  numEntriesMessages: this.spacesPubSubMessages
                }, opts);
                _context6.next = 7;
                return this.spaces[name].open(opts);

              case 7:
                _context6.next = 9;
                return this.isAddressLinked();

              case 9:
                if (_context6.sent) {
                  _context6.next = 11;
                  break;
                }

                this.linkAddress();

              case 11:
                _context6.next = 21;
                break;

              case 13:
                _context6.prev = 13;
                _context6.t0 = _context6["catch"](3);
                delete this.spaces[name];

                if (!_context6.t0.message.includes('User denied message signature.')) {
                  _context6.next = 20;
                  break;
                }

                throw new Error('User denied space consent.');

              case 20:
                throw new Error('An error occured while opening space: ', _context6.t0.message);

              case 21:
                _context6.next = 24;
                break;

              case 23:
                if (opts.onSyncDone) {
                  // since the space is already open we can call onSyncDone directly
                  opts.onSyncDone();
                }

              case 24:
                return _context6.abrupt("return", this.spaces[name]);

              case 25:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[3, 13]]);
      }));

      function openSpace(_x9) {
        return _openSpace.apply(this, arguments);
      }

      return openSpace;
    }()
    /**
     * Sets the callback function that will be called once when the db is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     */

  }, {
    key: "onSyncDone",
    value: function onSyncDone(syncDone) {
      this._onSyncDoneCB = syncDone;

      if (this._boxSynced) {
        this._onSyncDoneCB();
      }
    }
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(rootStoreAddress) {
        var addressToken;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._3id.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context7.sent;
                _context7.prev = 3;
                _context7.next = 6;
                return utils.fetchJson(this._serverUrl + '/odbAddress', {
                  address_token: addressToken
                });

              case 6:
                _context7.next = 12;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);

                if (_context7.t0.statusCode) {
                  _context7.next = 12;
                  break;
                }

                throw new Error(_context7.t0);

              case 12:
                return _context7.abrupt("return", true);

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8]]);
      }));

      function _publishRootStore(_x10) {
        return _publishRootStore2.apply(this, arguments);
      }

      return _publishRootStore;
    }()
    /**
     * @property {String} DID        the DID of the user
     */

  }, {
    key: "linkAddress",

    /**
     * Creates a proof that links an ethereum address to the 3Box account of the user. If given proof, it will simply be added to the root store.
     *
     * @param     {Object}    [link]                         Optional link object with type or proof
     * @param     {String}    [link.type='ethereum-eoa']     The type of link (default 'ethereum')
     * @param     {Object}    [link.proof]                   Proof object, should follow [spec](https://github.com/3box/3box/blob/master/3IPs/3ip-5.md)
     */
    value: function () {
      var _linkAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var link,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                link = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                if (!link.proof) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 4;
                return this._writeAddressLink(link.proof);

              case 4:
                return _context8.abrupt("return");

              case 5:
                if (!(!link.type || link.type === ACCOUNT_TYPES.ethereumEOA)) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 8;
                return this._linkProfile();

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function linkAddress() {
        return _linkAddress.apply(this, arguments);
      }

      return linkAddress;
    }()
  }, {
    key: "linkAccount",
    value: function () {
      var _linkAccount = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9() {
        var type,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                type = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('linkAccount: deprecated, please use linkAddress going forward');
                _context9.next = 4;
                return this.linkAddress(type);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function linkAccount() {
        return _linkAccount.apply(this, arguments);
      }

      return linkAccount;
    }()
    /**
     * Remove given address link, returns true if successful
     *
     * @param     {String}   address      address that is linked
     */

  }, {
    key: "removeAddressLink",
    value: function () {
      var _removeAddressLink = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(address) {
        var linkExist, payload, oneHour, deleteToken;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                address = address.toLowerCase();
                _context10.next = 3;
                return this.isAddressLinked({
                  address: address
                });

              case 3:
                linkExist = _context10.sent;

                if (linkExist) {
                  _context10.next = 6;
                  break;
                }

                throw new Error('removeAddressLink: link for given address does not exist');

              case 6:
                payload = {
                  address: address,
                  type: "delete-address-link"
                };
                oneHour = 60 * 60;
                _context10.next = 10;
                return this._3id.signJWT(payload, {
                  expiresIn: oneHour
                });

              case 10:
                deleteToken = _context10.sent;
                _context10.prev = 11;
                _context10.next = 14;
                return utils.fetchJson(this._serverUrl + '/linkdelete', {
                  delete_token: deleteToken
                });

              case 14:
                _context10.next = 20;
                break;

              case 16:
                _context10.prev = 16;
                _context10.t0 = _context10["catch"](11);

                if (_context10.t0.statusCode) {
                  _context10.next = 20;
                  break;
                }

                throw new Error(_context10.t0);

              case 20:
                _context10.next = 22;
                return this._deleteAddressLink(address);

              case 22:
                return _context10.abrupt("return", true);

              case 23:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[11, 16]]);
      }));

      function removeAddressLink(_x11) {
        return _removeAddressLink.apply(this, arguments);
      }

      return removeAddressLink;
    }()
    /**
     * Checks if there is a proof that links an external account to the 3Box account of the user. If not params given and any link exists, returns true
     *
     * @param     {Object}    [query]            Optional object with address and/or type.
     * @param     {String}    [query.type]       Does the given type of link exist
     * @param     {String}    [query.address]    Is the given adressed linked
     */

  }, {
    key: "isAddressLinked",
    value: function () {
      var _isAddressLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var query,
            links,
            linksQuery,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                query = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};
                if (query.address) query.address = query.address.toLowerCase();
                _context11.next = 4;
                return this._readAddressLinks();

              case 4:
                links = _context11.sent;
                linksQuery = links.find(function (link) {
                  var res = query.address ? link.address === query.address : true;
                  return query.type ? res && link.type === query.type : res;
                });
                return _context11.abrupt("return", Boolean(linksQuery));

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function isAddressLinked() {
        return _isAddressLinked.apply(this, arguments);
      }

      return isAddressLinked;
    }()
  }, {
    key: "isAccountLinked",
    value: function () {
      var _isAccountLinked = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        var type,
            _args12 = arguments;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                type = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : ACCOUNT_TYPES.ethereumEOA;
                console.warn('isAccountLinked: deprecated, please use isAddressLinked going forward');
                return _context12.abrupt("return", this.isAddressLinked(type));

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function isAccountLinked() {
        return _isAccountLinked.apply(this, arguments);
      }

      return isAccountLinked;
    }()
    /**
     * Lists address links associated with this 3Box
     *
     * @return    {Array}                        An array of link objects
     */

  }, {
    key: "listAddressLinks",
    value: function () {
      var _listAddressLinks = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._readAddressLinks();

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", entries.reduce(function (list, entry) {
                  var item = Object.assign({}, entry);
                  item.linkId = item.entry.hash;
                  delete item.entry;
                  return item;
                }, []));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function listAddressLinks() {
        return _listAddressLinks.apply(this, arguments);
      }

      return listAddressLinks;
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14() {
        var address, linkData, did, consent;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                address = this._3id.managementAddress;
                _context14.next = 3;
                return this._readAddressLink(address);

              case 3:
                linkData = _context14.sent;

                if (linkData) {
                  _context14.next = 19;
                  break;
                }

                did = this.DID;
                _context14.prev = 6;
                _context14.next = 9;
                return utils.getLinkConsent(address, did, this._web3provider);

              case 9:
                consent = _context14.sent;
                _context14.next = 16;
                break;

              case 12:
                _context14.prev = 12;
                _context14.t0 = _context14["catch"](6);
                console.log(_context14.t0);
                throw new Error('Link consent message must be signed before adding data, to link address to store');

              case 16:
                linkData = {
                  version: 1,
                  type: ACCOUNT_TYPES.ethereumEOA,
                  message: consent.msg,
                  signature: consent.sig,
                  timestamp: consent.timestamp
                };
                _context14.next = 19;
                return this._writeAddressLink(linkData);

              case 19:
                _context14.next = 21;
                return this["public"].get('proof_did');

              case 21:
                if (_context14.sent) {
                  _context14.next = 29;
                  break;
                }

                _context14.t1 = this["public"];
                _context14.next = 25;
                return this._3id.signJWT();

              case 25:
                _context14.t2 = _context14.sent;
                _context14.t3 = {
                  noLink: true
                };
                _context14.next = 29;
                return _context14.t1.set.call(_context14.t1, 'proof_did', _context14.t2, _context14.t3);

              case 29:
                // Send consentSignature to 3box-address-server to link profile with ethereum address
                utils.fetchJson(this._serverUrl + '/link', linkData)["catch"](console.error);

              case 30:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[6, 12]]);
      }));

      function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      }

      return _linkProfile;
    }()
  }, {
    key: "_writeAddressLink",
    value: function () {
      var _writeAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(proof) {
        var data, linkExist, link;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._ipfs.dag.put(proof);

              case 2:
                data = _context15.sent.toBaseEncodedString();
                _context15.next = 5;
                return this._linkCIDExists(data);

              case 5:
                linkExist = _context15.sent;

                if (!linkExist) {
                  _context15.next = 8;
                  break;
                }

                return _context15.abrupt("return");

              case 8:
                link = {
                  type: 'address-link',
                  data: data
                };
                _context15.next = 11;
                return this._rootStore.add(link);

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _writeAddressLink(_x12) {
        return _writeAddressLink2.apply(this, arguments);
      }

      return _writeAddressLink;
    }()
  }, {
    key: "_linkCIDExists",
    value: function () {
      var _linkCIDExists2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(cid) {
        var entries, linkEntries;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context16.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                return _context16.abrupt("return", linkEntries.find(function (entry) {
                  return entry.data === cid;
                }));

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function _linkCIDExists(_x13) {
        return _linkCIDExists2.apply(this, arguments);
      }

      return _linkCIDExists;
    }()
  }, {
    key: "_deleteAddressLink",
    value: function () {
      var _deleteAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(address) {
        var link;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                address = address.toLowerCase();
                _context17.next = 3;
                return this._readAddressLink(address);

              case 3:
                link = _context17.sent;

                if (link) {
                  _context17.next = 6;
                  break;
                }

                throw new Error('_deleteAddressLink: link for given address does not exist');

              case 6:
                return _context17.abrupt("return", this._rootStore.remove(link.entry.hash));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _deleteAddressLink(_x14) {
        return _deleteAddressLink2.apply(this, arguments);
      }

      return _deleteAddressLink;
    }()
  }, {
    key: "_readAddressLinks",
    value: function () {
      var _readAddressLinks2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var _this3 = this;

        var entries, linkEntries, resolveLinks;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context19.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === 'address-link';
                });
                resolveLinks = linkEntries.map(
                /*#__PURE__*/
                function () {
                  var _ref6 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee18(entry) {
                    var obj;
                    return _regenerator["default"].wrap(function _callee18$(_context18) {
                      while (1) {
                        switch (_context18.prev = _context18.next) {
                          case 0:
                            _context18.next = 2;
                            return _this3._ipfs.dag.get(entry.payload.value.data);

                          case 2:
                            obj = _context18.sent.value;

                            if (obj.address) {
                              _context18.next = 7;
                              break;
                            }

                            _context18.next = 6;
                            return utils.recoverPersonalSign(obj.message, obj.signature);

                          case 6:
                            obj.address = _context18.sent;

                          case 7:
                            obj.entry = entry;
                            return _context18.abrupt("return", obj);

                          case 9:
                          case "end":
                            return _context18.stop();
                        }
                      }
                    }, _callee18);
                  }));

                  return function (_x15) {
                    return _ref6.apply(this, arguments);
                  };
                }());
                return _context19.abrupt("return", Promise.all(resolveLinks));

              case 6:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _readAddressLinks() {
        return _readAddressLinks2.apply(this, arguments);
      }

      return _readAddressLinks;
    }()
  }, {
    key: "_readAddressLink",
    value: function () {
      var _readAddressLink2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee20(address) {
        var links;
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                address = address.toLowerCase();
                _context20.next = 3;
                return this._readAddressLinks();

              case 3:
                links = _context20.sent;
                return _context20.abrupt("return", links.find(function (link) {
                  return link.address.toLowerCase() === address;
                }));

              case 5:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _readAddressLink(_x16) {
        return _readAddressLink2.apply(this, arguments);
      }

      return _readAddressLink;
    }()
  }, {
    key: "_ensurePinningNodeConnected",
    value: function () {
      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee21(odbAddress, isThread) {
        var _this4 = this;

        var roomPeers, rootStoreAddress;
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this._ipfs.pubsub.peers(odbAddress);

              case 2:
                roomPeers = _context21.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this4.pinningNode.split('/').pop();
                })) {
                  this._ipfs.swarm.connect(this.pinningNode, function () {});

                  rootStoreAddress = this._rootStore.address.toString();

                  if (isThread) {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'SYNC_DB',
                      odbAddress: odbAddress,
                      thread: true
                    });
                  } else {
                    this._pubsub.publish(PINNING_ROOM, {
                      type: 'PIN_DB',
                      odbAddress: rootStoreAddress
                    });
                  }
                }

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _ensurePinningNodeConnected(_x17, _x18) {
        return _ensurePinningNodeConnected2.apply(this, arguments);
      }

      return _ensurePinningNodeConnected;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee22() {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context22.next = 4;
                return this._pubsub.disconnect();

              case 4:
                globalOrbitDB = null;

              case 5:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee23() {
        var address;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.close();

              case 2:
                this._3id.logout();

                address = this._3id.managementAddress;
                localstorage.remove('linkConsent_' + address);

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }, {
    key: "DID",
    get: function get() {
      return this._3id.muportDID;
    }
  }], [{
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee24(address) {
        var opts,
            metadata,
            profile,
            normalizedAddress,
            _args24 = arguments;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                opts = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {};
                metadata = opts.metadata;
                opts = Object.assign({
                  useCacheService: true
                }, opts);

                if (!opts.useCacheService) {
                  _context24.next = 9;
                  break;
                }

                _context24.next = 6;
                return API.getProfile(address, opts.profileServer, {
                  metadata: metadata
                });

              case 6:
                profile = _context24.sent;
                _context24.next = 15;
                break;

              case 9:
                if (!metadata) {
                  _context24.next = 11;
                  break;
                }

                throw new Error('getting metadata is not yet supported outside of the API');

              case 11:
                normalizedAddress = address.toLowerCase();
                _context24.next = 14;
                return this._getProfileOrbit(normalizedAddress, opts);

              case 14:
                profile = _context24.sent;

              case 15:
                return _context24.abrupt("return", profile);

              case 16:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getProfile(_x19) {
        return _getProfile.apply(this, arguments);
      }

      return getProfile;
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee25(addressArray) {
        var opts,
            _args25 = arguments;
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                opts = _args25.length > 1 && _args25[1] !== undefined ? _args25[1] : {};
                return _context25.abrupt("return", API.getProfiles(addressArray, opts));

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function getProfiles(_x20) {
        return _getProfiles.apply(this, arguments);
      }

      return getProfiles;
    }()
    /**
     * Get the public data in a space of a given address with the given name
     *
     * @param     {String}    address                 An ethereum address
     * @param     {String}    name                    A space name
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the public space data
     */

  }, {
    key: "getSpace",
    value: function () {
      var _getSpace = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee26(address, name) {
        var opts,
            _args26 = arguments;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                opts = _args26.length > 2 && _args26[2] !== undefined ? _args26[2] : {};
                return _context26.abrupt("return", API.getSpace(address, name, opts.profileServer, opts));

              case 2:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26);
      }));

      function getSpace(_x21, _x22) {
        return _getSpace.apply(this, arguments);
      }

      return getSpace;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    space                   The name of the space the thread is in
     * @param     {String}    name                    The name of the thread
     * @param     {String}    firstModerator          The DID (or ethereum address) of the first moderator
     * @param     {Boolean}   members                 True if only members are allowed to post
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThread",
    value: function () {
      var _getThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee27(space, name, firstModerator, members) {
        var opts,
            _args27 = arguments;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                opts = _args27.length > 4 && _args27[4] !== undefined ? _args27[4] : {};
                return _context27.abrupt("return", API.getThread(space, name, firstModerator, members, opts));

              case 2:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function getThread(_x23, _x24, _x25, _x26) {
        return _getThread.apply(this, arguments);
      }

      return getThread;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    address                 The orbitdb-address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThreadByAddress",
    value: function () {
      var _getThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee28(address) {
        var opts,
            _args28 = arguments;
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                opts = _args28.length > 1 && _args28[1] !== undefined ? _args28[1] : {};
                return _context28.abrupt("return", API.getThreadByAddress(address, opts));

              case 2:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28);
      }));

      function getThreadByAddress(_x27) {
        return _getThreadByAddress.apply(this, arguments);
      }

      return getThreadByAddress;
    }()
    /**
     * Get the configuration of a users 3Box
     *
     * @param     {String}    address                 The ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee29(address) {
        var opts,
            _args29 = arguments;
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                opts = _args29.length > 1 && _args29[1] !== undefined ? _args29[1] : {};
                return _context29.abrupt("return", API.getConfig(address, opts));

              case 2:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function getConfig(_x28) {
        return _getConfig.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     * Get the names of all spaces a user has
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            an array with all spaces as strings
     */

  }, {
    key: "listSpaces",
    value: function () {
      var _listSpaces = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee30(address) {
        var opts,
            _args30 = arguments;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                opts = _args30.length > 1 && _args30[1] !== undefined ? _args30[1] : {};
                return _context30.abrupt("return", API.listSpaces(address, opts.profileServer));

              case 2:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function listSpaces(_x29) {
        return _listSpaces.apply(this, arguments);
      }

      return listSpaces;
    }()
  }, {
    key: "_getProfileOrbit",
    value: function () {
      var _getProfileOrbit2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee32(address) {
        var opts,
            rootStoreAddress,
            usingGlobalIPFS,
            ipfs,
            orbitdb,
            cache,
            pinningNode,
            publicStore,
            rootStore,
            readyPromise,
            profileEntry,
            profile,
            closeAll,
            _args32 = arguments;
        return _regenerator["default"].wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                opts = _args32.length > 1 && _args32[1] !== undefined ? _args32[1] : {};

                if (!idUtils.isMuportDID(address)) {
                  _context32.next = 3;
                  break;
                }

                throw new Error('DID are supported in the cached version only');

              case 3:
                _context32.next = 5;
                return API.getRootStoreAddress(address.toLowerCase(), opts.addressServer);

              case 5:
                rootStoreAddress = _context32.sent;
                usingGlobalIPFS = false; // let usingGlobalOrbitDB = false

                if (!globalIPFS) {
                  _context32.next = 12;
                  break;
                }

                ipfs = globalIPFS;
                usingGlobalIPFS = true;
                _context32.next = 15;
                break;

              case 12:
                _context32.next = 14;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 14:
                ipfs = _context32.sent;

              case 15:
                if (globalOrbitDB) {
                  orbitdb = globalOrbitDB;
                  usingGlobalIPFS = true;
                } else {
                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {
                    cache: cache
                  });
                }

                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode, function () {});
                publicStore = new PublicStore(orbitdb);

                if (!rootStoreAddress) {
                  _context32.next = 41;
                  break;
                }

                _context32.next = 22;
                return orbitdb.open(rootStoreAddress);

              case 22:
                rootStore = _context32.sent;
                readyPromise = new Promise(function (resolve, reject) {
                  rootStore.events.on('ready', resolve);
                });
                rootStore.load();
                _context32.next = 27;
                return readyPromise;

              case 27:
                if (rootStore.iterator({
                  limit: -1
                }).collect().length) {
                  _context32.next = 30;
                  break;
                }

                _context32.next = 30;
                return new Promise(function (resolve, reject) {
                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {
                    if (num === max) {
                      rootStore.events.on('replicated', resolve);
                    }
                  });
                });

              case 30:
                profileEntry = rootStore.iterator({
                  limit: -1
                }).collect().find(function (entry) {
                  return entry.payload.value.odbAddress.split('.')[1] === 'public';
                });
                _context32.next = 33;
                return publicStore._load(profileEntry.payload.value.odbAddress);

              case 33:
                _context32.next = 35;
                return publicStore._sync();

              case 35:
                profile = publicStore.all();

                closeAll =
                /*#__PURE__*/
                function () {
                  var _ref7 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee31() {
                    return _regenerator["default"].wrap(function _callee31$(_context31) {
                      while (1) {
                        switch (_context31.prev = _context31.next) {
                          case 0:
                            _context31.next = 2;
                            return rootStore.close();

                          case 2:
                            _context31.next = 4;
                            return publicStore.close();

                          case 4:
                            // if (!usingGlobalOrbitDB) await orbitdb.stop()
                            if (!usingGlobalIPFS) {} // await ipfs.stop()


                          case 5:
                          case "end":
                            return _context31.stop();
                        }
                      }
                    }, _callee31);
                  }));

                  return function closeAll() {
                    return _ref7.apply(this, arguments);
                  };
                }(); // close but don't wait for it


                closeAll();
                return _context32.abrupt("return", profile);

              case 41:
                return _context32.abrupt("return", null);

              case 42:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32);
      }));

      function _getProfileOrbit(_x30) {
        return _getProfileOrbit2.apply(this, arguments);
      }

      return _getProfileOrbit;
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee33(query) {
        var opts,
            _args33 = arguments;
        return _regenerator["default"].wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                opts = _args33.length > 1 && _args33[1] !== undefined ? _args33[1] : {};
                return _context33.abrupt("return", API.profileGraphQL(query, opts.graphqlServer));

              case 2:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33);
      }));

      function profileGraphQL(_x31) {
        return _profileGraphQL.apply(this, arguments);
      }

      return profileGraphQL;
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object, received from the `getProfile` function
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee34(profile) {
        return _regenerator["default"].wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                return _context34.abrupt("return", API.getVerifiedAccounts(profile));

              case 1:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34);
      }));

      function getVerifiedAccounts(_x32) {
        return _getVerifiedAccounts.apply(this, arguments);
      }

      return getVerifiedAccounts;
    }()
    /**
     * Opens the 3Box associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {String}            opts.contentSignature   A signature, provided by a client of 3box using the private keys associated with the given address, of the 3box consent message
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee35(address, ethereumProvider) {
        var opts,
            ipfs,
            _3id,
            box,
            _args35 = arguments;

        return _regenerator["default"].wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                opts = _args35.length > 2 && _args35[2] !== undefined ? _args35[2] : {};
                _context35.t0 = globalIPFS;

                if (_context35.t0) {
                  _context35.next = 6;
                  break;
                }

                _context35.next = 5;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 5:
                _context35.t0 = _context35.sent;

              case 6:
                ipfs = _context35.t0;
                globalIPFS = ipfs;
                _context35.next = 10;
                return ThreeId.getIdFromEthAddress(address, ethereumProvider, ipfs, opts);

              case 10:
                _3id = _context35.sent;
                box = new Box(_3id, ethereumProvider, ipfs, opts);
                _context35.next = 14;
                return box._load(opts);

              case 14:
                return _context35.abrupt("return", box);

              case 15:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35);
      }));

      function openBox(_x33, _x34) {
        return _openBox.apply(this, arguments);
      }

      return openBox;
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return ThreeId.isLoggedIn(address);
    }
  }]);
  return Box;
}();

function initIPFS(_x35, _x36, _x37) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee36(ipfs, iframeStore, ipfsOptions) {
    return _regenerator["default"].wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')
            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');

            if (!ipfs) {
              _context36.next = 5;
              break;
            }

            return _context36.abrupt("return", ipfs);

          case 5:
            return _context36.abrupt("return", new Promise(function (resolve, reject) {
              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);
              ipfs.on('error', function (error) {
                console.error(error);
                reject(error);
              });
              ipfs.on('ready', function () {
                return resolve(ipfs);
              });
            }));

          case 6:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));
  return _initIPFS.apply(this, arguments);
}

Box.idUtils = idUtils;
module.exports = Box;
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3box.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/createMethodMiddleware.js", {"../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","./handlers":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/index.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@metamask/rpc-methods":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/index.js","@metamask/snap-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/createMethodMiddleware.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMethodMiddleware;

var _snapControllers = require("@metamask/snap-controllers");

var _rpcMethods = require("@metamask/rpc-methods");

var _ethRpcErrors = require("eth-rpc-errors");

var _network = require("../../../../shared/constants/network");

var _handlers = _interopRequireDefault(require("./handlers"));

const allHandlers = [..._handlers.default, ..._snapControllers.permissionRpcMethods.handlers];
const handlerMap = allHandlers.reduce((map, handler) => {
  for (const methodName of handler.methodNames) {
    map.set(methodName, handler);
  }

  return map;
}, new Map());
/**
 * Creates a json-rpc-engine middleware of RPC method implementations.
 *
 * Handlers consume functions that hook into the background, and only depend
 * on their signatures, not e.g. controller internals.
 *
 * @param {Record<string, unknown>} hooks - Required "hooks" into our
 * controllers.
 * @returns {(req: Object, res: Object, next: Function, end: Function) => void}
 */

function createMethodMiddleware(hooks) {
  return async function methodMiddleware(req, res, next, end) {
    // Reject unsupported methods.
    if (_network.UNSUPPORTED_RPC_METHODS.has(req.method)) {
      return end(_ethRpcErrors.ethErrors.rpc.methodNotSupported());
    }

    const handler = handlerMap.get(req.method);

    if (handler) {
      const {
        implementation,
        hookNames
      } = handler;

      try {
        // Implementations may or may not be async, so we must await them.
        return await implementation(req, res, next, end, (0, _rpcMethods.selectHooks)(hooks, hookNames));
      } catch (error) {
        return end(error);
      }
    }

    return next();
  };
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/createMethodMiddleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/duplex.js", {"./core":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/core.js","./helpers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/helpers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/duplex.js
      return function (require, module, exports) {
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var helpers_1 = require("./helpers");
var core_1 = require("./core");
/* export all core functions and types */
var core_2 = require("./core");
exports.applyOperation = core_2.applyOperation;
exports.applyPatch = core_2.applyPatch;
exports.applyReducer = core_2.applyReducer;
exports.getValueByPointer = core_2.getValueByPointer;
exports.validate = core_2.validate;
exports.validator = core_2.validator;
/* export some helpers */
var helpers_2 = require("./helpers");
exports.JsonPatchError = helpers_2.PatchError;
exports.deepClone = helpers_2._deepClone;
exports.escapePathComponent = helpers_2.escapePathComponent;
exports.unescapePathComponent = helpers_2.unescapePathComponent;
var beforeDict = new WeakMap();
var Mirror = /** @class */ (function () {
    function Mirror(obj) {
        this.observers = new Map();
        this.obj = obj;
    }
    return Mirror;
}());
var ObserverInfo = /** @class */ (function () {
    function ObserverInfo(callback, observer) {
        this.callback = callback;
        this.observer = observer;
    }
    return ObserverInfo;
}());
function getMirror(obj) {
    return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
}
/**
 * Detach an observer from an object
 */
function unobserve(root, observer) {
    observer.unobserve();
}
exports.unobserve = unobserve;
/**
 * Observes changes made to an object, which can then be retrieved using generate
 */
function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
        mirror = new Mirror(obj);
        beforeDict.set(obj, mirror);
    }
    else {
        var observerInfo = getObserverFromMirror(mirror, callback);
        observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
        return observer;
    }
    observer = {};
    mirror.value = helpers_1._deepClone(obj);
    if (callback) {
        observer.callback = callback;
        observer.next = null;
        var dirtyCheck = function () {
            generate(observer);
        };
        var fastCheck = function () {
            clearTimeout(observer.next);
            observer.next = setTimeout(dirtyCheck);
        };
        if (typeof window !== 'undefined') { //not Node
            window.addEventListener('mouseup', fastCheck);
            window.addEventListener('keyup', fastCheck);
            window.addEventListener('mousedown', fastCheck);
            window.addEventListener('keydown', fastCheck);
            window.addEventListener('change', fastCheck);
        }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function () {
        generate(observer);
        clearTimeout(observer.next);
        removeObserverFromMirror(mirror, observer);
        if (typeof window !== 'undefined') {
            window.removeEventListener('mouseup', fastCheck);
            window.removeEventListener('keyup', fastCheck);
            window.removeEventListener('mousedown', fastCheck);
            window.removeEventListener('keydown', fastCheck);
            window.removeEventListener('change', fastCheck);
        }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
}
exports.observe = observe;
/**
 * Generate an array of patches from an observer
 */
function generate(observer, invertible) {
    if (invertible === void 0) { invertible = false; }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
        core_1.applyPatch(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
        observer.patches = [];
        if (observer.callback) {
            observer.callback(temp);
        }
    }
    return temp;
}
exports.generate = generate;
// Dirty check if obj is different from mirror, generate patches and update mirror
function _generate(mirror, obj, patches, path, invertible) {
    if (obj === mirror) {
        return;
    }
    if (typeof obj.toJSON === "function") {
        obj = obj.toJSON();
    }
    var newKeys = helpers_1._objectKeys(obj);
    var oldKeys = helpers_1._objectKeys(mirror);
    var changed = false;
    var deleted = false;
    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
    for (var t = oldKeys.length - 1; t >= 0; t--) {
        var key = oldKeys[t];
        var oldVal = mirror[key];
        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
            var newVal = obj[key];
            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
                _generate(oldVal, newVal, patches, path + "/" + helpers_1.escapePathComponent(key), invertible);
            }
            else {
                if (oldVal !== newVal) {
                    changed = true;
                    if (invertible) {
                        patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
                    }
                    patches.push({ op: "replace", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });
                }
            }
        }
        else if (Array.isArray(mirror) === Array.isArray(obj)) {
            if (invertible) {
                patches.push({ op: "test", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(oldVal) });
            }
            patches.push({ op: "remove", path: path + "/" + helpers_1.escapePathComponent(key) });
            deleted = true; // property has been deleted
        }
        else {
            if (invertible) {
                patches.push({ op: "test", path: path, value: mirror });
            }
            patches.push({ op: "replace", path: path, value: obj });
            changed = true;
        }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
        return;
    }
    for (var t = 0; t < newKeys.length; t++) {
        var key = newKeys[t];
        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {
            patches.push({ op: "add", path: path + "/" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });
        }
    }
}
/**
 * Create an array of patches from the differences in two objects
 */
function compare(tree1, tree2, invertible) {
    if (invertible === void 0) { invertible = false; }
    var patches = [];
    _generate(tree1, tree2, patches, '', invertible);
    return patches;
}
exports.compare = compare;
/**
 * Default export for backwards compat
 */
// import just to re-export as default
var core = require("./core");
var helpers_3 = require("./helpers");
exports.default = __assign({}, core, { 
    // duplex
    unobserve: unobserve,
    observe: observe,
    generate: generate,
    compare: compare,
    // helpers
    JsonPatchError: helpers_3.PatchError, deepClone: helpers_1._deepClone, escapePathComponent: helpers_1.escapePathComponent,
    unescapePathComponent: helpers_3.unescapePathComponent });

      };
    };
  }
}, {package:"fast-json-patch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/duplex.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/helpers.js", {"cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/helpers.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

      };
    };
  }
}, {package:"@ensdomains/content-hash",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/helpers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/constants.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/index.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js","web-encoding":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js
      return function (require, module, exports) {
// @ts-check
/* eslint-disable guard-for-in */
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const { TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
const codes = {}

for (const key in names) {
  codes[names[key]] = key
}
exports.names = names
exports.codes = Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  const buffer = Buffer.isBuffer(hash)
    ? hash
    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

  return buffer.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? textDecoder.decode(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }
  let buf = Buffer.isBuffer(bytes)
    ? bytes
    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  const buffer = Buffer.alloc(hash.length + len.length + digest.length)
  buffer.set(hash, 0)
  buffer.set(len, hash.length)
  buffer.set(digest, hash.length + len.length)
  return buffer
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Buffer}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
}

      };
    };
  }
}, {package:"multihashes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/profiles.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js","js-base64":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-base64/base64.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/profiles.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@ensdomains/content-hash",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/src/profiles.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/constants.js","./int-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/int-table.js","./print":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/print.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js","./varint-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/varint-table.js","uint8arrays/concat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/concat.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/index.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const varint = require('varint')
const intTable = require('./int-table')
const codecNameToCodeVarint = require('./varint-table')
const util = require('./util')
const uint8ArrayConcat = require('uint8arrays/concat')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  const code = varint.decode(prefixedData)
  const codecName = intTable.get(code)
  if (codecName === undefined) {
    throw new Error(`Code ${code} not found`)
  }
  return codecName
}

/**
 * Get the name of the codec.
 *
 * @param {CodecNumber} codec
 * @returns {CodecName|undefined}
 */
function getName (codec) {
  return intTable.get(codec)
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecNumber}
 */
function getNumber (name) {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return varint.decode(code)
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecNumber}
 */
function getCode (prefixedData) {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} codecName
 * @returns {Uint8Array}
 */
function getCodeVarint (codecName) {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecNumber} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')

// Human friendly names for printing, e.g. in error messages
const print = require('./print')

module.exports = {
  addPrefix,
  rmPrefix,
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  print,
  ...constants
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/package.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/package.json
      return function (require, module, exports) {
module.exports={
  "name": "analytics-node",
  "version": "3.4.0-beta.3",
  "description": "The hassle-free way to integrate analytics into any Node.js application",
  "license": "MIT",
  "repository": "segmentio/analytics-node",
  "author": {
    "name": "Segment",
    "email": "tools+npm@segment.com",
    "url": "https://segment.com"
  },
  "engines": {
    "node": ">=4"
  },
  "size-limit": [
    {
      "limit": "25 KB",
      "path": "index.js"
    }
  ],
  "scripts": {
    "circle-lint": ".buildscript/circle.sh",
    "dependencies": "yarn",
    "size": "size-limit",
    "test": "standard && nyc ava --timeout=20s&& .buildscript/e2e.sh",
    "report-coverage": "nyc report --reporter=lcov > coverage.lcov && codecov",
    "np": "np --no-publish",
    "release": "yarn run np"
  },
  "files": [
    "index.js"
  ],
  "keywords": [
    "analytics",
    "stats",
    "segment.io",
    "segmentio",
    "segment",
    "client",
    "driver"
  ],
  "dependencies": {
    "@segment/loosely-validate-event": "^2.0.0",
    "axios": "^0.19.2",
    "axios-retry": "^3.0.2",
    "lodash.isstring": "^4.0.1",
    "md5": "^2.2.1",
    "ms": "^2.0.0",
    "remove-trailing-slash": "^0.1.0",
    "uuid": "^3.2.1"
  },
  "devDependencies": {
    "ava": "^0.25.0",
    "basic-auth": "^2.0.1",
    "body-parser": "^1.17.1",
    "codecov": "^3.0.0",
    "commander": "^2.9.0",
    "delay": "^4.2.0",
    "express": "^4.15.2",
    "husky": "^3.0.4",
    "nyc": "^14.1.1",
    "pify": "^4.0.1",
    "sinon": "^7.3.2",
    "size-limit": "^1.3.5",
    "snyk": "^1.171.1",
    "standard": "^12.0.1"
  }
}

      };
    };
  }
}, {package:"analytics-node",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/package.json",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/remove-trailing-slash/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/remove-trailing-slash/index.js
      return function (require, module, exports) {

/**
 * Remove trailing slashes from the given `str`
 *
 * @api public
 * @param {String} str
 * @return {String}
 */
exports = module.exports = function (str) {
  return String(str).replace(exports.expr, '');
};

/**
 * Expose the regex
 *
 * @api private
 * @type {RegExp}
 */
exports.expr = /\/+$/;

      };
    };
  }
}, {package:"remove-trailing-slash",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/remove-trailing-slash/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ms/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ms/index.js
      return function (require, module, exports) {
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

      };
    };
  }
}, {package:"ms",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ms/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isstring/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isstring/index.js
      return function (require, module, exports) {
/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;

      };
    };
  }
}, {package:"lodash.isstring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/lodash.isstring/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/v4.js", {"./lib/bytesToUuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/bytesToUuid.js","./lib/rng":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/v4.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/md5/md5.js", {"charenc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/charenc/charenc.js","crypt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypt/crypt.js","is-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/md5/md5.js
      return function (require, module, exports) {
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      isBuffer = require('is-buffer'),
      bin = require('charenc').bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

      };
    };
  }
}, {package:"md5",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/md5/md5.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@segment/loosely-validate-event/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","component-type":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-type/index.js","join-component":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/join-component/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@segment/loosely-validate-event/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var type = require('component-type')
var join = require('join-component')
var assert = require('assert')

// Segment messages can be a maximum of 32kb.
var MAX_SIZE = 32 << 10

module.exports = looselyValidateEvent

/**
 * Validate an event.
 */

function looselyValidateEvent (event, type) {
  validateGenericEvent(event)
  type = type || event.type
  assert(type, 'You must pass an event type.')
  switch (type) {
    case 'track':
      return validateTrackEvent(event)
    case 'group':
      return validateGroupEvent(event)
    case 'identify':
      return validateIdentifyEvent(event)
    case 'page':
      return validatePageEvent(event)
    case 'screen':
      return validateScreenEvent(event)
    case 'alias':
      return validateAliasEvent(event)
    default:
      assert(0, 'Invalid event type: "' + type + '"')
  }
}

/**
 * Validate a "track" event.
 */

function validateTrackEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
  assert(event.event, 'You must pass an "event".')
}

/**
 * Validate a "group" event.
 */

function validateGroupEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
  assert(event.groupId, 'You must pass a "groupId".')
}

/**
 * Validate a "identify" event.
 */

function validateIdentifyEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate a "page" event.
 */

function validatePageEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate a "screen" event.
 */

function validateScreenEvent (event) {
  assert(event.anonymousId || event.userId, 'You must pass either an "anonymousId" or a "userId".')
}

/**
 * Validate an "alias" event.
 */

function validateAliasEvent (event) {
  assert(event.userId, 'You must pass a "userId".')
  assert(event.previousId, 'You must pass a "previousId".')
}

/**
 * Validation rules.
 */

var genericValidationRules = {
  anonymousId: [ 'string', 'number' ],
  category: 'string',
  context: 'object',
  event: 'string',
  groupId: [ 'string', 'number' ],
  integrations: 'object',
  name: 'string',
  previousId: [ 'string', 'number' ],
  timestamp: 'date',
  userId: [ 'string', 'number' ],
  type: 'string'
}

/**
 * Validate an event object.
 */

function validateGenericEvent (event) {
  assert(type(event) === 'object', 'You must pass a message object.')
  var json = JSON.stringify(event)
  // Strings are variable byte encoded, so json.length is not sufficient.
  assert(Buffer.byteLength(json, 'utf8') < MAX_SIZE, 'Your message must be < 32kb.')

  for (var key in genericValidationRules) {
    var val = event[key]
    if (!val) continue
    var rule = genericValidationRules[key]
    if (type(rule) !== 'array') {
      rule = [ rule ]
    }
    var a = rule[0] === 'object' ? 'an' : 'a'
    assert(
      rule.some(function (e) { return type(val) === e }),
      '"' + key + '" must be ' + a + ' ' + join(rule, 'or') + '.'
    )
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@segment/loosely-validate-event",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@segment/loosely-validate-event/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/index.js", {"./lib/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/index.js
      return function (require, module, exports) {
module.exports = require('./lib/index').default;
      };
    };
  }
}, {package:"axios-retry",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/index.js", {"./lib/axios":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/axios.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/index.js
      return function (require, module, exports) {
module.exports = require('./lib/axios');
      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js", {"./account":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/account.js","./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/constants.js","./hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js","./object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/object.js","./secp256k1v3-adapter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js","./signature":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/signature.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.secp256k1 = exports.rlp = exports.BN = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
exports.secp256k1 = secp256k1;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
exports.BN = BN;
var rlp = require("rlp");
exports.rlp = rlp;
Object.assign(exports, ethjsUtil);
/**
 * Constants
 */
__exportStar(require("./constants"), exports);
/**
 * Public-key cryptography (secp256k1) and addresses
 */
__exportStar(require("./account"), exports);
/**
 * Hash functions
 */
__exportStar(require("./hash"), exports);
/**
 * ECDSA signature
 */
__exportStar(require("./signature"), exports);
/**
 * Utilities for manipulating Buffers, byte arrays, etc.
 */
__exportStar(require("./bytes"), exports);
/**
 * Function for definining properties on an object
 */
__exportStar(require("./object"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/scryptsy/lib/scrypt.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","pbkdf2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pbkdf2/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/scryptsy/lib/scrypt.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var pbkdf2Sync = require('pbkdf2').pbkdf2Sync

var MAX_VALUE = 0x7fffffff

// N = Cpu cost, r = Memory cost, p = parallelization cost
function scrypt (key, salt, N, r, p, dkLen, progressCallback) {
  if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')

  if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')
  if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')

  var XY = new Buffer(256 * r)
  var V = new Buffer(128 * r * N)

  // pseudo global
  var B32 = new Int32Array(16) // salsa20_8
  var x = new Int32Array(16) // salsa20_8
  var _X = new Buffer(64) // blockmix_salsa8

  // pseudo global
  var B = pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256')

  var tickCallback
  if (progressCallback) {
    var totalOps = p * N * 2
    var currentOp = 0

    tickCallback = function () {
      ++currentOp

      // send progress notifications once every 1,000 ops
      if (currentOp % 1000 === 0) {
        progressCallback({
          current: currentOp,
          total: totalOps,
          percent: (currentOp / totalOps) * 100.0
        })
      }
    }
  }

  for (var i = 0; i < p; i++) {
    smix(B, i * 128 * r, r, N, V, XY)
  }

  return pbkdf2Sync(key, B, 1, dkLen, 'sha256')

  // all of these functions are actually moved to the top
  // due to function hoisting

  function smix (B, Bi, r, N, V, XY) {
    var Xi = 0
    var Yi = 128 * r
    var i

    B.copy(XY, Xi, Bi, Bi + Yi)

    for (i = 0; i < N; i++) {
      XY.copy(V, i * Yi, Xi, Xi + Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    for (i = 0; i < N; i++) {
      var offset = Xi + (2 * r - 1) * 64
      var j = XY.readUInt32LE(offset) & (N - 1)
      blockxor(V, j * Yi, XY, Xi, Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    XY.copy(B, Bi, Xi, Xi + Yi)
  }

  function blockmix_salsa8 (BY, Bi, Yi, r) {
    var i

    arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64)

    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64)
      salsa20_8(_X)
      arraycopy(_X, 0, BY, Yi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64)
    }
  }

  function R (a, b) {
    return (a << b) | (a >>> (32 - b))
  }

  function salsa20_8 (B) {
    var i

    for (i = 0; i < 16; i++) {
      B32[i] = (B[i * 4 + 0] & 0xff) << 0
      B32[i] |= (B[i * 4 + 1] & 0xff) << 8
      B32[i] |= (B[i * 4 + 2] & 0xff) << 16
      B32[i] |= (B[i * 4 + 3] & 0xff) << 24
      // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js
    }

    arraycopy(B32, 0, x, 0, 16)

    for (i = 8; i > 0; i -= 2) {
      x[ 4] ^= R(x[ 0] + x[12], 7)
      x[ 8] ^= R(x[ 4] + x[ 0], 9)
      x[12] ^= R(x[ 8] + x[ 4], 13)
      x[ 0] ^= R(x[12] + x[ 8], 18)
      x[ 9] ^= R(x[ 5] + x[ 1], 7)
      x[13] ^= R(x[ 9] + x[ 5], 9)
      x[ 1] ^= R(x[13] + x[ 9], 13)
      x[ 5] ^= R(x[ 1] + x[13], 18)
      x[14] ^= R(x[10] + x[ 6], 7)
      x[ 2] ^= R(x[14] + x[10], 9)
      x[ 6] ^= R(x[ 2] + x[14], 13)
      x[10] ^= R(x[ 6] + x[ 2], 18)
      x[ 3] ^= R(x[15] + x[11], 7)
      x[ 7] ^= R(x[ 3] + x[15], 9)
      x[11] ^= R(x[ 7] + x[ 3], 13)
      x[15] ^= R(x[11] + x[ 7], 18)
      x[ 1] ^= R(x[ 0] + x[ 3], 7)
      x[ 2] ^= R(x[ 1] + x[ 0], 9)
      x[ 3] ^= R(x[ 2] + x[ 1], 13)
      x[ 0] ^= R(x[ 3] + x[ 2], 18)
      x[ 6] ^= R(x[ 5] + x[ 4], 7)
      x[ 7] ^= R(x[ 6] + x[ 5], 9)
      x[ 4] ^= R(x[ 7] + x[ 6], 13)
      x[ 5] ^= R(x[ 4] + x[ 7], 18)
      x[11] ^= R(x[10] + x[ 9], 7)
      x[ 8] ^= R(x[11] + x[10], 9)
      x[ 9] ^= R(x[ 8] + x[11], 13)
      x[10] ^= R(x[ 9] + x[ 8], 18)
      x[12] ^= R(x[15] + x[14], 7)
      x[13] ^= R(x[12] + x[15], 9)
      x[14] ^= R(x[13] + x[12], 13)
      x[15] ^= R(x[14] + x[13], 18)
    }

    for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i]

    for (i = 0; i < 16; i++) {
      var bi = i * 4
      B[bi + 0] = (B32[i] >> 0 & 0xff)
      B[bi + 1] = (B32[i] >> 8 & 0xff)
      B[bi + 2] = (B32[i] >> 16 & 0xff)
      B[bi + 3] = (B32[i] >> 24 & 0xff)
      // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js
    }
  }

  // naive approach... going back to loop unrolling may yield additional performance
  function blockxor (S, Si, D, Di, len) {
    for (var i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i]
    }
  }
}

function arraycopy (src, srcPos, dest, destPos, length) {
  if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {
    src.copy(dest, destPos, srcPos, srcPos + length)
  } else {
    while (length--) {
      dest[destPos++] = src[srcPos++]
    }
  }
}

module.exports = scrypt

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"scryptsy",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/scryptsy/lib/scrypt.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js", {"./lib/bytesToUuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js","./lib/rng":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js
      return function (require, module, exports) {
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/v4.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/index.js", {"./createEventEmitterProxy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createEventEmitterProxy.js","./createSwappableProxy":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createSwappableProxy.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/index.js
      return function (require, module, exports) {
const createSwappableProxy = require('./createSwappableProxy')
const createEventEmitterProxy = require('./createEventEmitterProxy')

module.exports = {
  createSwappableProxy,
  createEventEmitterProxy,
}

      };
    };
  }
}, {package:"swappable-obj-proxy",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createJsonRpcClient.js", {"../../../../shared/constants/time":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/time.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","eth-block-tracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/index.js","eth-json-rpc-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createJsonRpcClient.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createJsonRpcClient;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethBlockTracker = require("eth-block-tracker");

var _time = require("../../../../shared/constants/time");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const inTest = process.env.IN_TEST;
const blockTrackerOpts = inTest ? {
  pollingInterval: _time.SECOND
} : {};

const getTestMiddlewares = () => {
  return inTest ? [createEstimateGasDelayTestMiddleware()] : [];
};

function createJsonRpcClient({
  rpcUrl,
  chainId
}) {
  const fetchMiddleware = (0, _ethJsonRpcMiddleware.createFetchMiddleware)({
    rpcUrl
  });
  const blockProvider = (0, _ethJsonRpcMiddleware.providerFromMiddleware)(fetchMiddleware);
  const blockTracker = new _ethBlockTracker.PollingBlockTracker(_objectSpread(_objectSpread({}, blockTrackerOpts), {}, {
    provider: blockProvider
  }));
  const networkMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([...getTestMiddlewares(), createChainIdMiddleware(chainId), (0, _ethJsonRpcMiddleware.createBlockRefRewriteMiddleware)({
    blockTracker
  }), (0, _ethJsonRpcMiddleware.createBlockCacheMiddleware)({
    blockTracker
  }), (0, _ethJsonRpcMiddleware.createInflightCacheMiddleware)(), (0, _ethJsonRpcMiddleware.createBlockTrackerInspectorMiddleware)({
    blockTracker
  }), fetchMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === 'eth_chainId') {
      res.result = chainId;
      return end();
    }

    return next();
  };
}
/**
 * For use in tests only.
 * Adds a delay to `eth_estimateGas` calls.
 */


function createEstimateGasDelayTestMiddleware() {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, _, next) => {
    if (req.method === 'eth_estimateGas') {
      await new Promise(resolve => setTimeout(resolve, _time.SECOND * 2));
    }

    return next();
  });
}

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createJsonRpcClient.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createInfuraClient.js", {"../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","eth-block-tracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/index.js","eth-json-rpc-infura":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-infura/src/index.js","eth-json-rpc-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createInfuraClient.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createInfuraClient;

var _jsonRpcEngine = require("json-rpc-engine");

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethJsonRpcInfura = _interopRequireDefault(require("eth-json-rpc-infura"));

var _ethBlockTracker = require("eth-block-tracker");

var _network = require("../../../../shared/constants/network");

function createInfuraClient({
  network,
  projectId
}) {
  const infuraMiddleware = (0, _ethJsonRpcInfura.default)({
    network,
    projectId,
    maxAttempts: 5,
    source: 'metamask'
  });
  const infuraProvider = (0, _ethJsonRpcMiddleware.providerFromMiddleware)(infuraMiddleware);
  const blockTracker = new _ethBlockTracker.PollingBlockTracker({
    provider: infuraProvider
  });
  const networkMiddleware = (0, _jsonRpcEngine.mergeMiddleware)([createNetworkAndChainIdMiddleware({
    network
  }), (0, _ethJsonRpcMiddleware.createBlockCacheMiddleware)({
    blockTracker
  }), (0, _ethJsonRpcMiddleware.createInflightCacheMiddleware)(), (0, _ethJsonRpcMiddleware.createBlockRefMiddleware)({
    blockTracker,
    provider: infuraProvider
  }), (0, _ethJsonRpcMiddleware.createRetryOnEmptyMiddleware)({
    blockTracker,
    provider: infuraProvider
  }), (0, _ethJsonRpcMiddleware.createBlockTrackerInspectorMiddleware)({
    blockTracker
  }), infuraMiddleware]);
  return {
    networkMiddleware,
    blockTracker
  };
}

function createNetworkAndChainIdMiddleware({
  network
}) {
  if (!_network.NETWORK_TYPE_TO_ID_MAP[network]) {
    throw new Error(`createInfuraClient - unknown network "${network}"`);
  }

  const {
    chainId,
    networkId
  } = _network.NETWORK_TYPE_TO_ID_MAP[network];
  return (0, _jsonRpcEngine.createScaffoldMiddleware)({
    eth_chainId: chainId,
    net_version: networkId
  });
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/createInfuraClient.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/lib/coinstring.js", {"bs58":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/node_modules/bs58/lib/bs58.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hash/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/lib/coinstring.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var base58 = require('bs58')
var createHash = require('create-hash')

function encode (payload, version) {
  if (Array.isArray(payload) || payload instanceof Uint8Array) {
    payload = new Buffer(payload)
  }

  var buf
  if (version != null) {
    if (typeof version === 'number') {
      version = new Buffer([version])
    }
    buf = Buffer.concat([version, payload])
  } else {
    buf = payload
  }

  var checksum = sha256x2(buf).slice(0, 4)
  var result = Buffer.concat([buf, checksum])
  return base58.encode(result)
}

function decode (base58str, version) {
  var arr = base58.decode(base58str)
  var buf = new Buffer(arr)
  var versionLength

  if (version == null) {
    versionLength = 0
  } else {
    if (typeof version === 'number') version = new Buffer([version])

    versionLength = version.length
    var versionCompare = buf.slice(0, versionLength)
    if (versionCompare.toString('hex') !== version.toString('hex')) {
      throw new Error('Invalid version')
    }
  }

  var checksum = buf.slice(-4)
  var endPos = buf.length - 4
  var bytes = buf.slice(0, endPos)

  var newChecksum = sha256x2(bytes).slice(0, 4)
  if (checksum.toString('hex') !== newChecksum.toString('hex')) {
    throw new Error('Invalid checksum')
  }

  return bytes.slice(versionLength)
}

function isValid (base58str, version) {
  try {
    decode(base58str, version)
  } catch (e) {
    return false
  }

  return true
}

function createEncoder (version) {
  return function (payload) {
    return encode(payload, version)
  }
}

function createDecoder (version) {
  return function (base58str) {
    return decode(base58str, version)
  }
}

function createValidator (version) {
  return function (base58str) {
    return isValid(base58str, version)
  }
}

function sha256x2 (buffer) {
  var sha = createHash('sha256').update(buffer).digest()
  return createHash('sha256').update(sha).digest()
}

module.exports = {
  encode: encode,
  decode: decode,
  isValid: isValid,
  createEncoder: createEncoder,
  createDecoder: createDecoder,
  createValidator: createValidator
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"coinstring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/lib/coinstring.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/index.js", {"./account":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/account.js","./api":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/api.js","./backend/blockchain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/blockchain.js","./backend/transactions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/transactions.js","./events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/events.js","./misc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/misc.js","./networks/binance":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/binance.js","./networks/bitcoin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/bitcoin.js","./networks/cardano":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/cardano.js","./networks/coinInfo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/coinInfo.js","./networks/eos":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/eos.js","./networks/ethereum":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ethereum.js","./networks/nem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/nem.js","./networks/ripple":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ripple.js","./networks/stellar":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/stellar.js","./networks/tezos":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/tezos.js","./params":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/params.js","./trezor/device":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/device.js","./trezor/management":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/management.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/index.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;

var _api = require("./api");

Object.keys(_api).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _api[key]) return;
  exports[key] = _api[key];
});

var _events = require("./events");

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _events[key]) return;
  exports[key] = _events[key];
});

var _misc = require("./misc");

Object.keys(_misc).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _misc[key]) return;
  exports[key] = _misc[key];
});

var _params = require("./params");

Object.keys(_params).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _params[key]) return;
  exports[key] = _params[key];
});

var _account = require("./account");

Object.keys(_account).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _account[key]) return;
  exports[key] = _account[key];
});

var _device = require("./trezor/device");

Object.keys(_device).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _device[key]) return;
  exports[key] = _device[key];
});

var _management = require("./trezor/management");

Object.keys(_management).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _management[key]) return;
  exports[key] = _management[key];
});

var _bitcoin = require("./networks/bitcoin");

Object.keys(_bitcoin).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _bitcoin[key]) return;
  exports[key] = _bitcoin[key];
});

var _binance = require("./networks/binance");

Object.keys(_binance).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _binance[key]) return;
  exports[key] = _binance[key];
});

var _cardano = require("./networks/cardano");

Object.keys(_cardano).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cardano[key]) return;
  exports[key] = _cardano[key];
});

var _coinInfo = require("./networks/coinInfo");

Object.keys(_coinInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _coinInfo[key]) return;
  exports[key] = _coinInfo[key];
});

var _eos = require("./networks/eos");

Object.keys(_eos).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _eos[key]) return;
  exports[key] = _eos[key];
});

var _ethereum = require("./networks/ethereum");

Object.keys(_ethereum).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ethereum[key]) return;
  exports[key] = _ethereum[key];
});

var _nem = require("./networks/nem");

Object.keys(_nem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _nem[key]) return;
  exports[key] = _nem[key];
});

var _ripple = require("./networks/ripple");

Object.keys(_ripple).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ripple[key]) return;
  exports[key] = _ripple[key];
});

var _stellar = require("./networks/stellar");

Object.keys(_stellar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _stellar[key]) return;
  exports[key] = _stellar[key];
});

var _tezos = require("./networks/tezos");

Object.keys(_tezos).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _tezos[key]) return;
  exports[key] = _tezos[key];
});

var _blockchain = require("./backend/blockchain");

Object.keys(_blockchain).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _blockchain[key]) return;
  exports[key] = _blockchain[key];
});

var _transactions = require("./backend/transactions");

Object.keys(_transactions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _transactions[key]) return;
  exports[key] = _transactions[key];
});
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js", {"./blockchain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/blockchain.js","./cardano":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/cardano.js","./device":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/device.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/errors.js","./iframe":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/iframe.js","./network":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/network.js","./popup":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/popup.js","./transport":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/transport.js","./ui":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/ui.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CARDANO = exports.UI = exports.TRANSPORT = exports.POPUP = exports.NETWORK = exports.IFRAME = exports.ERRORS = exports.DEVICE = exports.BLOCKCHAIN = exports.BLOCKCHAIN_EVENT = exports.RESPONSE_EVENT = exports.TRANSPORT_EVENT = exports.DEVICE_EVENT = exports.UI_EVENT = exports.CORE_EVENT = void 0;

var BLOCKCHAIN = _interopRequireWildcard(require("./blockchain"));

exports.BLOCKCHAIN = BLOCKCHAIN;

var DEVICE = _interopRequireWildcard(require("./device"));

exports.DEVICE = DEVICE;

var ERRORS = _interopRequireWildcard(require("./errors"));

exports.ERRORS = ERRORS;

var IFRAME = _interopRequireWildcard(require("./iframe"));

exports.IFRAME = IFRAME;

var NETWORK = _interopRequireWildcard(require("./network"));

exports.NETWORK = NETWORK;

var POPUP = _interopRequireWildcard(require("./popup"));

exports.POPUP = POPUP;

var TRANSPORT = _interopRequireWildcard(require("./transport"));

exports.TRANSPORT = TRANSPORT;

var UI = _interopRequireWildcard(require("./ui"));

exports.UI = UI;

var CARDANO = _interopRequireWildcard(require("./cardano"));

exports.CARDANO = CARDANO;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var CORE_EVENT = 'CORE_EVENT';
exports.CORE_EVENT = CORE_EVENT;
var UI_EVENT = 'UI_EVENT';
exports.UI_EVENT = UI_EVENT;
var DEVICE_EVENT = 'DEVICE_EVENT';
exports.DEVICE_EVENT = DEVICE_EVENT;
var TRANSPORT_EVENT = 'TRANSPORT_EVENT';
exports.TRANSPORT_EVENT = TRANSPORT_EVENT;
var RESPONSE_EVENT = 'RESPONSE_EVENT';
exports.RESPONSE_EVENT = RESPONSE_EVENT;
var BLOCKCHAIN_EVENT = 'BLOCKCHAIN_EVENT';
exports.BLOCKCHAIN_EVENT = BLOCKCHAIN_EVENT;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/index.js", {"../../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js","../../data/ConnectSettings":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/data/ConnectSettings.js","../../iframe/builder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/builder.js","../../message":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/index.js","../../message/builder":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/builder.js","../../popup/PopupManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/PopupManager.js","../../types":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/index.js","../../utils/debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/debug.js","../../webusb/button":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/webusb/button.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.disableWebUSB = exports.requestLogin = exports.customMessage = exports.getSettings = exports.renderWebUSBButton = exports.uiResponse = exports.call = exports.init = exports.cancel = exports.dispose = exports.manifest = exports.eventEmitter = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _events = _interopRequireDefault(require("events"));

var _PopupManager = _interopRequireDefault(require("../../popup/PopupManager"));

var iframe = _interopRequireWildcard(require("../../iframe/builder"));

var _button = _interopRequireDefault(require("../../webusb/button"));

var _message = require("../../message");

var _builder2 = require("../../message/builder");

var _ConnectSettings = require("../../data/ConnectSettings");

var _debug = require("../../utils/debug");

var _constants = require("../../constants");

var $T = _interopRequireWildcard(require("../../types"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var eventEmitter = new _events["default"]();
exports.eventEmitter = eventEmitter;

var _log = (0, _debug.initLog)('[trezor-connect.js]');

var _settings;

var _popupManager;

var initPopupManager = function initPopupManager() {
  var pm = new _PopupManager["default"](_settings);
  pm.on(_constants.POPUP.CLOSED, function (error) {
    iframe.postMessage({
      type: _constants.POPUP.CLOSED,
      payload: error ? {
        error: error
      } : null
    }, false);
  });
  return pm;
};

var manifest = function manifest(data) {
  _settings = (0, _ConnectSettings.parse)({
    manifest: data
  });
};

exports.manifest = manifest;

var dispose = function dispose() {
  eventEmitter.removeAllListeners();
  iframe.dispose();

  if (_popupManager) {
    _popupManager.close();
  }
};

exports.dispose = dispose;

var cancel = function cancel(error) {
  if (_popupManager) {
    _popupManager.emit(_constants.POPUP.CLOSED, error);
  }
}; // handle message received from iframe


exports.cancel = cancel;

var handleMessage = function handleMessage(messageEvent) {
  // ignore messages from domain other then iframe origin
  if (messageEvent.origin !== iframe.origin) return;
  var message = (0, _message.parseMessage)(messageEvent.data);
  var event = message.event,
      type = message.type,
      payload = message.payload;
  var id = message.id || 0;

  _log.log('handleMessage', message);

  switch (event) {
    case _constants.RESPONSE_EVENT:
      if (iframe.messagePromises[id]) {
        // resolve message promise (send result of call method)
        iframe.messagePromises[id].resolve({
          id: id,
          success: message.success,
          payload: payload
        });
        delete iframe.messagePromises[id];
      } else {
        _log.warn("Unknown message id " + id);
      }

      break;

    case _constants.DEVICE_EVENT:
      // pass DEVICE event up to html
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload); // DEVICE_EVENT also emit single events (connect/disconnect...)

      break;

    case _constants.TRANSPORT_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.BLOCKCHAIN_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.UI_EVENT:
      if (type === _constants.IFRAME.BOOTSTRAP) {
        iframe.clearTimeout();
        break;
      }

      if (type === _constants.IFRAME.LOADED) {
        iframe.initPromise.resolve();
      }

      if (type === _constants.IFRAME.ERROR) {
        iframe.initPromise.reject(payload.error);
      } // pass UI event up


      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    default:
      _log.log('Undefined message', event, messageEvent);

  }
};

var init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (settings === void 0) {
              settings = {};
            }

            if (!iframe.instance) {
              _context.next = 3;
              break;
            }

            throw _constants.ERRORS.TypedError('Init_AlreadyInitialized');

          case 3:
            if (!_settings) {
              _settings = (0, _ConnectSettings.parse)(settings);
            }

            if (_settings.manifest) {
              _context.next = 6;
              break;
            }

            throw _constants.ERRORS.TypedError('Init_ManifestMissing');

          case 6:
            if (!_settings.lazyLoad) {
              _context.next = 9;
              break;
            }

            // reset "lazyLoad" after first use
            _settings.lazyLoad = false;
            return _context.abrupt("return");

          case 9:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _log.enabled = !!_settings.debug;
            window.addEventListener('message', handleMessage);
            window.addEventListener('unload', dispose);
            _context.next = 15;
            return iframe.init(_settings);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var call = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params) {
    var response;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!iframe.instance && !iframe.timeout)) {
              _context2.next = 15;
              break;
            }

            // init popup with lazy loading before iframe initialization
            _settings = (0, _ConnectSettings.parse)(_settings);

            if (_settings.manifest) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

          case 4:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _popupManager.request(true); // auto init with default settings


            _context2.prev = 6;
            _context2.next = 9;
            return init(_settings);

          case 9:
            _context2.next = 15;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](6);

            if (_popupManager) {
              // Catch fatal iframe errors (not loading)
              if (['Init_IframeBlocked', 'Init_IframeTimeout'].includes(_context2.t0.code)) {
                _popupManager.postMessage((0, _builder2.UiMessage)(_constants.UI.IFRAME_FAILURE));
              } else {
                _popupManager.close();
              }
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t0));

          case 15:
            if (!iframe.timeout) {
              _context2.next = 17;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

          case 17:
            if (!iframe.error) {
              _context2.next = 19;
              break;
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(iframe.error));

          case 19:
            // request popup window it might be used in the future
            if (_settings.popup && _popupManager) {
              _popupManager.request();
            } // post message to iframe


            _context2.prev = 20;
            _context2.next = 23;
            return iframe.postMessage({
              type: _constants.IFRAME.CALL,
              payload: params
            });

          case 23:
            response = _context2.sent;

            if (!response) {
              _context2.next = 27;
              break;
            }

            if (!response.success && response.payload.code !== 'Device_CallInProgress' && _popupManager) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", response);

          case 27:
            if (_popupManager) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_NoResponse')));

          case 31:
            _context2.prev = 31;
            _context2.t1 = _context2["catch"](20);

            _log.error('__call error', _context2.t1);

            if (_popupManager) {
              _popupManager.close();
            }

            return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t1));

          case 36:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[6, 11], [20, 31]]);
  }));

  return function call(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

exports.call = call;

var customMessageResponse = function customMessageResponse(payload) {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: _constants.UI.CUSTOM_MESSAGE_RESPONSE,
    payload: payload
  });
};

var uiResponse = function uiResponse(response) {
  var type = response.type,
      payload = response.payload;
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: type,
    payload: payload
  });
};

exports.uiResponse = uiResponse;

var renderWebUSBButton = function renderWebUSBButton(className) {
  (0, _button["default"])(className, _settings.webusbSrc, iframe.origin);
};

exports.renderWebUSBButton = renderWebUSBButton;

var getSettings = function getSettings() {
  if (!iframe.instance) {
    return Promise.resolve((0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_NotInitialized')));
  }

  return call({
    method: 'getSettings'
  });
};

exports.getSettings = getSettings;

var customMessage = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(params) {
    var callback, customMessageListener, response;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(typeof params.callback !== 'function')) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_CustomMessage_Callback')));

          case 2:
            // TODO: set message listener only if iframe is loaded correctly
            callback = params.callback;

            customMessageListener = /*#__PURE__*/function () {
              var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === _constants.UI.CUSTOM_MESSAGE_REQUEST)) {
                          _context3.next = 6;
                          break;
                        }

                        _context3.next = 4;
                        return callback(data.payload);

                      case 4:
                        payload = _context3.sent;

                        if (payload) {
                          customMessageResponse(payload);
                        } else {
                          customMessageResponse({
                            message: 'release'
                          });
                        }

                      case 6:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function customMessageListener(_x4) {
                return _ref4.apply(this, arguments);
              };
            }();

            window.addEventListener('message', customMessageListener, false);
            _context4.next = 7;
            return call(_objectSpread(_objectSpread({
              method: 'customMessage'
            }, params), {}, {
              callback: null
            }));

          case 7:
            response = _context4.sent;
            window.removeEventListener('message', customMessageListener);
            return _context4.abrupt("return", response);

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function customMessage(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

exports.customMessage = customMessage;

var requestLogin = /*#__PURE__*/function () {
  var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(params) {
    var callback, loginChallengeListener, response;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(typeof params.callback === 'function')) {
              _context6.next = 9;
              break;
            }

            callback = params.callback; // TODO: set message listener only if iframe is loaded correctly

            loginChallengeListener = /*#__PURE__*/function () {
              var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === _constants.UI.LOGIN_CHALLENGE_REQUEST)) {
                          _context5.next = 12;
                          break;
                        }

                        _context5.prev = 2;
                        _context5.next = 5;
                        return callback();

                      case 5:
                        payload = _context5.sent;
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: payload
                        });
                        _context5.next = 12;
                        break;

                      case 9:
                        _context5.prev = 9;
                        _context5.t0 = _context5["catch"](2);
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: _context5.t0.message
                        });

                      case 12:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5, null, [[2, 9]]);
              }));

              return function loginChallengeListener(_x6) {
                return _ref6.apply(this, arguments);
              };
            }();

            window.addEventListener('message', loginChallengeListener, false);
            _context6.next = 6;
            return call(_objectSpread(_objectSpread({
              method: 'requestLogin'
            }, params), {}, {
              asyncChallenge: true,
              callback: null
            }));

          case 6:
            response = _context6.sent;
            window.removeEventListener('message', loginChallengeListener);
            return _context6.abrupt("return", response);

          case 9:
            return _context6.abrupt("return", call(_objectSpread({
              method: 'requestLogin'
            }, params)));

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function requestLogin(_x5) {
    return _ref5.apply(this, arguments);
  };
}();

exports.requestLogin = requestLogin;

var disableWebUSB = function disableWebUSB() {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: _constants.TRANSPORT.DISABLE_WEBUSB
  });
};

exports.disableWebUSB = disableWebUSB;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","create-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hash/browser.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/ethjs-util/lib/index.js","keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/js.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/eth-sig-util/node_modules/ethereumjs-util/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js", {"json-stable-stringify":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-stable-stringify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForPayload = exports.blockTagParamIndex = exports.paramsWithoutBlockTag = exports.blockTagForPayload = exports.canCache = exports.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(payload)
        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(payload)) {
        return `${payload.method}:${(0, json_stable_stringify_1.default)(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    if (!payload.params) {
        return undefined;
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return undefined;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    if (!payload.params) {
        return [];
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return 'block';
        // never cache
        default:
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;
//# sourceMappingURL=cache.js.map
      };
    };
  }
}, {package:"eth-json-rpc-middleware",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/dist/utils/cache.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/pify/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/pify/index.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
}, {package:"pify",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/pify/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/eth-sig-util/index.js", {"ethereumjs-abi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-util/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/eth-sig-util/index.js
      return function (require, module, exports) {
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')

module.exports = {

  concatSig: function (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize: function (input) {
    if (!input) return

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ' received ' + (typeof input) + ': ' + input
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign: function (privateKey, msgParams) {
    var message = ethUtil.toBuffer(msgParams.data)
    var msgHash = ethUtil.hashPersonalMessage(message)
    var sig = ethUtil.ecsign(msgHash, privateKey)
    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return '0x' + publicKey.toString('hex')
  },

  typedSignatureHash: function (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedData: function (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature: function (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  }

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data)
    ]
  )
}

function recoverPublicKey(hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  var myString = '' + number
  while (myString.length < length) {
    myString = '0' + myString
  }
  return myString
}

      };
    };
  }
}, {package:"eth-sig-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/eth-sig-util/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/client.js", {"./bitcoin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/bitcoin.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js","./ethereum":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereum.js","./ethereumAbi":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereumAbi.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/util.js","bitwise":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/index.js","buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer/index.js","superagent":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/client.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/client.js
      return function (require, module, exports) {
const bitwise = require('bitwise');
const superagent = require('superagent');
const bitcoin = require('./bitcoin');
const ethereum = require('./ethereum');
const { buildAddAbiPayload, abiParsers, MAX_ABI_DEFS } = require('./ethereumAbi');
const {
  isValidAssetPath,
  isValidCoinType,
  signReqResolver,
  aes256_decrypt,
  aes256_encrypt,
  parseDER,
  checksum,
  ensureHexBuffer,
  getP256KeyPair,
  getP256KeyPairFromPub,
  parseLattice1Response,
  toPaddedDER,
} = require('./util');
const {
  ASCII_REGEX,
  getFwVersionConst,
  ADDR_STR_LEN,
  ENC_MSG_LEN,
  decResLengths,
  deviceCodes,
  encReqCodes,
  responseCodes,
  REQUEST_TYPE_BYTE,
  VERSION_BYTE,
  messageConstants,
  BASE_URL,
  signingSchema,
} = require('./constants');
const Buffer = require('buffer/').Buffer;
const EMPTY_WALLET_UID = Buffer.alloc(32);

class Client {
  constructor({ baseUrl, crypto, name, privKey, timeout, retryCount } = {}) {
    // Definitions
    // if (!baseUrl) throw new Error('baseUrl is required');
    if (name && name.length > 24) throw new Error('name must be less than 24 characters');
    if (!crypto) throw new Error('crypto provider is required');
    this.baseUrl = baseUrl || BASE_URL;
    this.crypto = crypto;
    this.name = name || 'Unknown';
    
    // Derive an ECDSA keypair using the p256 curve. The public key will
    // be used as an identifier
    this.privKey = privKey || this.crypto.randomBytes(32);
    this.key = getP256KeyPair(this.privKey);//.encode('hex');

    // Stateful params
    this.ephemeralPub = null;
    this.sharedSecret = null;
    this.timeout = timeout || 60000;
    this.deviceId = null;
    this.isPaired = false;
    this.retryCount = retryCount || 3;

    // Information about the current wallet. Should be null unless we know a wallet is present
    this.activeWallets = {
      internal: {
        uid: EMPTY_WALLET_UID,           // 32 byte id
        name: null,                      // 20 char (max) string
        capabilities: null,              // 4 byte flag
        external: false,
      },
      external: {
        uid: EMPTY_WALLET_UID,           // 32 byte id
        name: null,                      // 20 char (max) string
        capabilities: null,              // 4 byte flag
        external: true,
      }
    }
  }
  
  //=======================================================================
  // LATTICE FUNCTIONS
  //=======================================================================

  // `Connect` will attempt to contact a device based on its deviceId.
  // The response should include an ephemeral public key, which is used to
  // pair with the device in a later request
  connect(deviceId, cb) {
    // User may "re-connect" if a device ID has previously been stored
    if (typeof deviceId === 'function') {
      if (!this.deviceId) 
        return cb('No device ID has been stored. Please connect with your device ID first.')
      cb = deviceId;
    } else {
      // If the user passes in a device ID, connect to that device and save
      // the new ID for future use.
      this.deviceId = deviceId;
    }
    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());
    this._request(param, (err, res) => {
      if (err) return cb(err);
      this.isPaired = this._handleConnect(res) || false;
      // Check for an active wallet. This will get bypassed if we are not paired.
      if (this.isPaired) {
        this._getActiveWallet((err) => {
          return cb(err, this.isPaired);
        }, true);
      } else {
        return cb(null);
      }
      
    });
  }

  pair(pairingSecret, cb) {
    // Build the secret hash from the salt
    const pubKey = this.pubKeyBytes();
    const nameBuf = Buffer.alloc(25);
    if (this.name.length > 24) {
      return cb('Name is too many characters. Please change it to <25 characters.');
    }
    nameBuf.write(this.name);
    // Make sure we add a null termination byte to the pairing secret
    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);
    const hash = this.crypto.createHash('sha256').update(preImage).digest();
    const sig = this.key.sign(hash); // returns an array, not a buffer
    const derSig = toPaddedDER(sig);
    const payload = Buffer.concat([nameBuf, derSig]);

    // Build the request
    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);
    this._request(param, (err, res) => {
      if (err) return cb(err);
      // Recover the ephemeral key
      const errStr = this._handlePair(res);
      if (errStr) return cb(errStr);
      // Try to get the active wallet once pairing is successful
      this._getActiveWallet((err) => {
        if (err) return cb(err);
        return cb(null, this.hasActiveWallet());
      }, true);
    })  
  }

  test(data, cb) {
    if (!data.payload)
      return cb('First argument must contain `testID` and `payload` fields.');
    const TEST_DATA_SZ = 500;
    const payload = Buffer.alloc(TEST_DATA_SZ + 6);
    payload.writeUInt32BE(data.testID, 0);
    payload.writeUInt16BE(data.payload.length, 4);
    data.payload.copy(payload, 6);
    const param = this._buildEncRequest(encReqCodes.TEST, payload);
    this._request(param, (err, res) => {
      if (err) return cb(err);
      const decrypted = this._handleEncResponse(res, decResLengths.test);
      if (decrypted.err !== null ) 
        return cb(decrypted.err);
      return cb(null, decrypted.data.slice(65)); // remove ephem pub
    })
  }

  getAddresses(opts, cb) {
    const SKIP_CACHE_FLAG = 1;
    const MAX_ADDR = 10;
    const { startPath, n, skipCache=true } = opts;
    if (startPath === undefined || n === undefined)
      return cb('Please provide `startPath` and `n` options');
    if (startPath.length < 2 || startPath.length > 5)
      return cb('Path must include between 2 and 5 indices');
    if (n > MAX_ADDR)
      return cb(`You may only request ${MAX_ADDR} addresses at once.`);

    if ((skipCache === false && false === isValidAssetPath(startPath)) ||
        (skipCache === true && false === isValidCoinType(startPath)) )
      return cb('Parent path is not supported');

    const fwConstants = getFwVersionConst(this.fwVersion);
    let sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag
    if (fwConstants.varAddrPathSzAllowed) {
      sz += 1;  // pathDepth
    } else if (startPath.length !== 5) {
      return cb('Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.')
    }
    const payload = Buffer.alloc(sz);
    let off = 0;

    // WalletUID
    const wallet = this.getActiveWallet();
    if (wallet === null) return cb('No active wallet.');
    wallet.uid.copy(payload, off); off += 32;
    // Build the start path (5x u32 indices)
    if (fwConstants.varAddrPathSzAllowed) {
      payload.writeUInt8(startPath.length, off);
      off += 1;
    }
    for (let i = 0; i < 5; i++) {
      if (i <= startPath.length)
        payload.writeUInt32BE(startPath[i], off);
      off += 4;
    }
    // Specify the number of subsequent addresses to request.
    // We also allow the user to skip the cache and request any address related to the asset
    // in the wallet.
    let val;
    if (true === fwConstants.addrFlagsAllowed) {
      const flag = skipCache === true ? bitwise.nibble.read(SKIP_CACHE_FLAG) : bitwise.nibble.read(0);
      const count = bitwise.nibble.read(n);
      val = bitwise.byte.write(flag.concat(count));
    } else {
      val = n;
    }
    payload.writeUInt8(val, off); off++;
    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);
    return this._request(param, (err, res) => {
      if (err) return cb(err);
      const parsedRes = this._handleGetAddresses(res);
      if (parsedRes.err) return cb(parsedRes.err);
      return cb(null, parsedRes.data);
    })
  }

  sign(opts, cb, cachedData=null, nextCode=null) {
    const { currency } = opts;
    let { data } = opts;
    if (currency === undefined || data === undefined) {
      return cb('Please provide `currency` and `data` options');
    } else if (signReqResolver[currency] === undefined) {
      return cb('Unsupported currency');
    }
    // All transaction requests must be put into the same sized buffer.
    // This comes from sizeof(GpTransactionRequest_t), but note we remove
    // the 2-byte schemaId since it is not returned from our resolver.
    // Note that different firmware versions may have different data sizes.
    const fwConstants = getFwVersionConst(this.fwVersion);
    // Build the signing request payload to send to the device. If we catch
    // bad params, return an error instead
    data = { fwConstants, ...data};
    let req, reqPayload;
    let schema;
    if (cachedData !== null && nextCode !== null) {
      req = cachedData;
      reqPayload = Buffer.concat([nextCode, req.extraDataPayloads.shift()])
      schema = signingSchema.EXTRA_DATA;
    } else {
      req = signReqResolver[currency](data);
      if (req.err !== undefined) return cb(req.err);
      if (req.payload.length > fwConstants.reqMaxDataSz)
        return cb('Transaction is too large');
      reqPayload = req.payload;
      schema = req.schema;
    }
    // Build the payload
    const payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);
    let off = 0;
    // Whether there will be follow up requests
    const hasExtraPayloads = req.extraDataPayloads && Number(req.extraDataPayloads.length > 0);
    payload.writeUInt8(hasExtraPayloads, off); off += 1;  
    // Copy request schema (e.g. ETH or BTC transfer)
    payload.writeUInt8(schema, off); off += 1;
    // Copy the wallet UID
    const wallet = this.getActiveWallet();
    if (wallet === null) return cb('No active wallet.');
    wallet.uid.copy(payload, off); off += wallet.uid.length;
    // Build data based on the type of request
    // Copy the payload of the request
    reqPayload.copy(payload, off);
    // Construct the encrypted request and send it
    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);
    return this._request(param, (err, res, responseCode) => {
      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {
        // If we catch a case where the wallet has changed, try getting the new active wallet
        // and recursively make the original request.
        this._getActiveWallet((err) => {
          if (err) return cb(err)
          else     return this.sign(opts, cb, cachedData, nextCode);
        })
      } else if (err) {
        // If there was another error caught, return it
        if (err) return cb(err);
      } else if (hasExtraPayloads) {
        const decrypted = this._handleEncResponse(res, decResLengths.sign);
        nextCode = decrypted.data.slice(65, 73);
        if (!cachedData)
          cachedData = req;
        return this.sign(opts, cb, cachedData, nextCode);
      } else {
        // Correct wallet and no errors -- handle the response
        const parsedRes = this._handleSign(res, currency, req);
        return cb(parsedRes.err, parsedRes.data);
      }
    })
  }

  addAbiDefs(defs, cb, nextCode=null) {
    const defsToAdd = defs.slice(0, MAX_ABI_DEFS);
    defs = defs.slice(MAX_ABI_DEFS);
    let abiPayload;
    try {
      abiPayload = buildAddAbiPayload(defsToAdd);
    } catch (err) {
      return cb(err);
    }
    const payload = Buffer.alloc(abiPayload.length + 10);
    // Let the firmware know how many defs are remaining *after this one*.
    // If this is a positive number, firmware will send us a temporary code
    // to bypass user authorization if the user has configured easy ABI loading.
    payload.writeUInt16LE(defs.length);
    // If this is a follow-up request, we don't need to ask for user authorization
    // if we use the correct temporary u64
    if (nextCode !== null)
      nextCode.copy(payload, 2);
    abiPayload.copy(payload, 10);
    const param = this._buildEncRequest(encReqCodes.ADD_ABI_DEFS, payload);
    return this._request(param, (err, res, responseCode) => {
      if (responseCode && responseCode !== responseCodes.RESP_SUCCESS)
        return cb('Error making request.');
      else if (err)
        return cb(err);
      const decrypted = this._handleEncResponse(res, decResLengths.addAbiDefs);
      // Grab the 8 byte code to fast track our next request, if needed
      nextCode = decrypted.data.slice(65, 73); 
      // No defs left? Return success
      if (defs.length === 0)
        return cb(null);
      // Add the next set
      this.addAbiDefs(defs, cb, nextCode, defs);
    })
  }
  
  addPermissionV0(opts, cb) {
    const { currency, timeWindow, limit, decimals, asset } = opts;
    if (!currency || timeWindow === undefined || limit === undefined || decimals === undefined ||
        timeWindow === null || limit === null || decimals === null)
      return cb('currency, timeWindow, decimals, and limit are all required options.');
    else if (timeWindow === 0 || limit === 0)
      return cb('Time window and spending limit must be positive.');
    // Build the name of the permission
    let name = currency;
    if (asset)
      name += `_${asset}`;
    // Start building the payload
    const payload = Buffer.alloc(293);
    // Copy the name
    if (Buffer.from(name).length > 255)
      return cb('Asset name too long.');
    Buffer.from(name).copy(payload, 0);
    // Convert the limit to a 32 byte hex buffer and copy it in
    const limitBuf = ensureHexBuffer(limit)
    if (limitBuf.length > 32)
      return cb('Limit too large.');
    limitBuf.copy(payload, 256 + (32 - limitBuf.length));
    // Copy the time window (seconds)
    payload.writeUInt32BE(timeWindow, 288);
    payload.writeUInt8(decimals, 292);
    // Encrypt the request and send it to the Lattice.
    const param = this._buildEncRequest(encReqCodes.ADD_PERMISSION_V0, payload);
    return this._request(param, (err, res, responseCode) => {
      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {
        // If we catch a case where the wallet has changed, try getting the new active wallet
        // and recursively make the original request.
        this._getActiveWallet((err) => {
          if (err) return cb(err)
          else     return this.addPermissionV0(opts, cb);
        })
      } else if (err) {
        // If there was another error caught, return it
        if (err) return cb(err);
      } else {
        // Correct wallet and no errors -- handle the response
        const d = this._handleEncResponse(res, decResLengths.empty);
        if (d.err)
          return cb(d.err);
        return cb(null);
      }
    })
  }

  getKvRecords(opts, cb) {
    const { type = 0, n = 1, start = 0 } = opts;
    const fwConstants = getFwVersionConst(this.fwVersion);
    if (!fwConstants.kvActionsAllowed) {
      return cb('Unsupported. Please update firmware.');
    } else if (n < 1) {
      return cb('You must request at least one record.');
    } else if (n > fwConstants.kvActionMaxNum) {
      return cb(`You may only request up to ${fwConstants.kvActionMaxNum} records at once.`);
    }
    const payload = Buffer.alloc(9);
    payload.writeUInt32LE(type);
    payload.writeUInt8(n, 4);
    payload.writeUInt32LE(start, 5);
    // Encrypt the request and send it to the Lattice.
    const param = this._buildEncRequest(encReqCodes.GET_KV_RECORDS, payload);
    return this._request(param, (err, res, responseCode) => {
      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {
        // If we catch a case where the wallet has changed, try getting the new active wallet
        // and recursively make the original request.
        this._getActiveWallet((err) => {
          if (err) return cb(err)
          else     return this.getKvRecords(opts, cb);
        })
      } else if (err) {
        // If there was another error caught, return it
        if (err) return cb(err);
      } else {
        // Correct wallet and no errors -- handle the response
        const d = this._handleEncResponse(res, decResLengths.getKvRecords);
        if (d.err)
          return cb(d.err);
        // Decode the response
        let off = 65; // Skip 65 byte pubkey prefix
        const nTotal = parseInt(d.data.slice(off, off+4).toString('hex'), 16); off += 4;
        const nFetched = parseInt(d.data.slice(off, off+1).toString('hex'), 16); off += 1;
        if (nFetched > fwConstants.kvActionMaxNum)
          return cb('Too many records fetched. Firmware error.');
        const records = [];
        for (let i = 0; i < nFetched; i++) {
          const r = {};
          r.id = parseInt(d.data.slice(off, off + 4).toString('hex'), 16); off += 4;
          r.type = parseInt(d.data.slice(off, off + 4).toString('hex'), 16); off += 4;
          r.caseSensitive = parseInt(d.data.slice(off, off + 1).toString('hex'), 16) === 1 ? true : false; off += 1;
          const keySz = parseInt(d.data.slice(off, off + 1).toString('hex'), 16); off += 1;
          r.key = d.data.slice(off, off + keySz-1).toString(); off += (fwConstants.kvKeyMaxStrSz + 1);
          const valSz = parseInt(d.data.slice(off, off + 1).toString('hex'), 16); off += 1;
          r.val = d.data.slice(off, off + valSz-1).toString(); off += (fwConstants.kvValMaxStrSz + 1);
          records.push(r);
        }
        return cb(null, { records, total: nTotal, fetched: nFetched });
      }
    })
  }

  addKvRecords(opts, cb) {
    const { type = 0, records = {}, caseSensitive=false } = opts;
    const fwConstants = getFwVersionConst(this.fwVersion);
    if (!fwConstants.kvActionsAllowed) {
      return cb('Unsupported. Please update firmware.');
    } else if (typeof records !== 'object' || Object.keys(records).length === 0) {
      return cb('One or more key-value mapping must be provided in `records` param.');
    } else if (Object.keys(records).length > fwConstants.kvActionMaxNum) {
      return cb(`Too many keys provided. Please only provide up to ${fwConstants.kvActionMaxNum}.`);
    } else if (Object.keys(records).length < 1) {
      return cb('You must provide at least one key to add.')
    }
    const payload = Buffer.alloc(1 + (139 * fwConstants.kvActionMaxNum));
    payload.writeUInt8(Object.keys(records).length);
    let off = 1;
    try {
      Object.keys(records).forEach((key) => {
        if (typeof key !== 'string' || String(key).length > fwConstants.kvKeyMaxStrSz) {
          throw new Error(`Key ${key} too large. Must be <=${fwConstants.kvKeyMaxStrSz} characters.`);
        } else if (typeof records[key] !== 'string' || String(records[key]).length > fwConstants.kvValMaxStrSz) {
          throw new Error(`Value ${records[key]} too large. Must be <$={fwConstants.kvValMaxStrSz} characters.`);
        } else if (String(key).length === 0 || String(records[key]).length === 0) {
          throw new Error('Keys and values must be >0 characters.');
        } else if (!ASCII_REGEX.test(key) || !ASCII_REGEX.test(records[key])) {
          throw new Error('Unicode characters are not supported.');
        }
        // Skip the ID portion. This will get added by firmware.
        payload.writeUInt32LE(0, off); off += 4;
        payload.writeUInt32LE(type, off); off += 4;
        payload.writeUInt8(caseSensitive === true, off); off += 1;
        payload.writeUInt8(String(key).length + 1, off); off += 1;
        Buffer.from(String(key)).copy(payload, off); off += (fwConstants.kvKeyMaxStrSz + 1);
        payload.writeUInt8(String(records[key]).length + 1, off); off += 1;
        Buffer.from(String(records[key])).copy(payload, off); off += (fwConstants.kvValMaxStrSz + 1);
      })
    } catch (err) {
      return cb(`Error building request: ${err.message}`);
    }
    // Encrypt the request and send it to the Lattice.
    const param = this._buildEncRequest(encReqCodes.ADD_KV_RECORDS, payload);
    return this._request(param, (err, res, responseCode) => {
      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {
        // If we catch a case where the wallet has changed, try getting the new active wallet
        // and recursively make the original request.
        this._getActiveWallet((err) => {
          if (err) return cb(err)
          else     return this.addKvRecords(opts, cb);
        })
      } else if (err) {
        // If there was another error caught, return it
        if (err) return cb(err);
      } else {
        // Correct wallet and no errors -- handle the response
        const d = this._handleEncResponse(res, decResLengths.empty);
        if (d.err)
          return cb(d.err);
        return cb(null);
      }
    })
  }

  removeKvRecords(opts, cb) {
    const { type = 0, ids = [] } = opts;
    const fwConstants = getFwVersionConst(this.fwVersion);
    if (!fwConstants.kvActionsAllowed) {
      return cb('Unsupported. Please update firmware.');
    } else if (!Array.isArray(ids) || ids.length < 1) {
      return cb('You must include one or more `ids` to removed.')
    } else if (ids.length > fwConstants.kvRemoveMaxNum) {
      return cb(`Only up to ${fwConstants.kvRemoveMaxNum} records may be removed at once.`)
    }
    const payload = Buffer.alloc(5 + (4 * fwConstants.kvRemoveMaxNum));
    payload.writeUInt32LE(type);
    payload.writeUInt8(ids.length, 4);
    for (let i = 0; i < ids.length; i++) {
      payload.writeUInt32LE(ids[i], 5 + (4 * i))
    }
    // Encrypt the request and send it to the Lattice.
    const param = this._buildEncRequest(encReqCodes.REMOVE_KV_RECORDS, payload);
    return this._request(param, (err, res, responseCode) => {
      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {
        // If we catch a case where the wallet has changed, try getting the new active wallet
        // and recursively make the original request.
        this._getActiveWallet((err) => {
          if (err) return cb(err)
          else     return this.removeKvRecords(opts, cb);
        })
      } else if (err) {
        // If there was another error caught, return it
        if (err) return cb(err);
      } else {
        // Correct wallet and no errors -- handle the response
        const d = this._handleEncResponse(res, decResLengths.empty);
        if (d.err)
          return cb(d.err);
        return cb(null);
      }
    })
  }

  //=======================================================================
  // INTERNAL FUNCTIONS
  // These handle the logic around building requests and consuming
  // responses. They take into account the Lattice's serialization scheme
  // among other protocols.
  //=======================================================================

  // Get the active wallet in the device. If we already have one recorded,
  // we don't need to do anything
  // returns cb(err) -- err is a string
  _getActiveWallet(cb, forceRefresh=false) {
    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {
      // If the active wallet already exists, or if we are not paired, skip the request
      return cb(null);
    } else {
      // No active wallet? Get it from the device
      const payload = Buffer.alloc(0);
      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);
      return this._request(param, (err, res) => {
        if (err) {
          this._resetActiveWallets();
          return cb(err);
        }
        return cb(this._handleGetWallets(res));
      })
    }
  }

  // Get the shared secret, derived via ECDH from the local private key
  // and the ephemeral public key
  // @returns Buffer
  _getSharedSecret() {
    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which
    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.
    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));
  }

  // Get the ephemeral id, which is the first 4 bytes of the shared secret
  // generated from the local private key and the ephemeral public key from
  // the device.
  // @returns Buffer
  _getEphemId() {
    if (this.ephemeralPub === null) return null;
    // EphemId is the first 4 bytes of the hash of the shared secret
    const secret = this._getSharedSecret();
    const hash = this.crypto.createHash('sha256').update(secret).digest();
    return hash.slice(0, 4);
  }

  _buildEncRequest(enc_request_code, payload) {
    // Get the ephemeral id - all encrypted requests require there to be an
    // epehemeral public key in order to send
    const ephemId = parseInt(this._getEphemId().toString('hex'), 16)
    // Build the payload and checksum
    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);
    const cs = checksum(payloadPreCs);
    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4);

    // Lattice validates checksums in little endian
    payloadPreCs.copy(payloadBuf, 0);
    payloadBuf.writeUInt32LE(cs, payloadPreCs.length);
    // Encrypt this payload
    const secret = this._getSharedSecret();
    const newEncPayload = aes256_encrypt(payloadBuf, secret);

    // Write to the overall payload. We must use the same length
    // for every encrypted request and must include a 32-bit ephemId
    // along with the encrypted data
    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4);
    // First 4 bytes are the ephemeral id (in little endian)
    newPayload.writeUInt32LE(ephemId, 0);
    // Next N bytes
    newEncPayload.copy(newPayload, 4);
    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);
  
  }

  // Build a request to send to the device.
  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code
  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)
  // @param [payload] {buffer} - serialized payload
  // @returns {buffer}
  _buildRequest(request_code, payload) {
    // Length of payload;
    // we add 1 to the payload length to account for the request_code byte
    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;
    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {
      L = 1 + payload.length;
    }
    let i = 0;
    const preReq = Buffer.alloc(L + 8);
    // Build the header
    i = preReq.writeUInt8(VERSION_BYTE, i);
    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);
    const id = this.crypto.randomBytes(4);
    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);
    i = preReq.writeUInt16BE(L, i);
    // Build the payload
    i = preReq.writeUInt8(request_code, i);
    if (L > 1) i = payload.copy(preReq, i);
    // Add the checksum
    const cs = checksum(preReq);
    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum
    i = preReq.copy(req);
    req.writeUInt32BE(cs, i);
    return req;
  }

  _request(data, cb, retryCount=this.retryCount) {
    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');
    const url = `${this.baseUrl}/${this.deviceId}`;
    superagent.post(url).timeout(this.timeout)
    .send({data})
    .then(res => {
      if (!res || !res.body) return cb(`Invalid response: ${res}`)
      else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`)
      const parsed = parseLattice1Response(res.body.message);
      // If the device is busy, retry if we can
      if (( parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY ||
            parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT ) 
            && (retryCount > 0)) {
        return setTimeout(() => { this._request(data, cb, retryCount-1) }, 3000);
      }
      // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID
      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) 
        this._resetActiveWallets();
      // If there was an error in the response, return it
      if (parsed.err) 
        return cb(parsed.err);
      return cb(null, parsed.data, parsed.responseCode); 
    })
    .catch((err) => {
      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';
      if (isTimeout)
        return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.')
      else
        return cb('Failed to make request to device.');
    });
  }

  // ----- Device response handlers -----

  // Connect will call `StartPairingMode` on the device, which gives the
  // user 60 seconds to finalize the pairing
  // This will return an ephemeral public key, which is needed for the next
  // request. If the device is already paired, this ephemPub is simply used
  // to encrypt the next request. If the device is not paired, it is needed
  // to pair the device within 60 seconds.
  // @returns true if we are paired to the device already
  _handleConnect(res) {
    let off = 0;
    const pairingStatus = res.readUInt8(off); off++;
    // If we are already paired, we get the next ephemeral key
    const pub = res.slice(off, off + 65).toString('hex'); off += 65;
    // Grab the firmware version (will be 0-length for older fw versions)
    // It is of format |fix|minor|major|reserved|
    this.fwVersion = res.slice(off, off + 4);
    // Set the public key
    this.ephemeralPub = getP256KeyPairFromPub(pub);
    // return the state of our pairing
    return (pairingStatus === messageConstants.PAIRED);
  }

  // All encrypted responses must be decrypted with the previous shared secret. Per specification,
  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the 
  // new ephemeralPub.
  _handleEncResponse(encRes, len) {
    // Decrypt response
    const secret = this._getSharedSecret();
    const encData = encRes.slice(0, ENC_MSG_LEN);
    const res = aes256_decrypt(encData, secret);
    // len does not include a 65-byte pubkey that prefies each encResponse
    len += 65;
    // Validate checksum. It will be the last 4 bytes of the decrypted payload.
    // The length of the decrypted payload will be fixed for each given message type.
    const toCheck = res.slice(0, len);
    const cs = parseInt(`0x${res.slice(len, len+4).toString('hex')}`);
    const csCheck = checksum(toCheck);
    if (cs !== csCheck) return { err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})` };

    // First 65 bytes is the next ephemeral pubkey
    const pub = res.slice(0, 65).toString('hex');
    try {
      this.ephemeralPub = getP256KeyPairFromPub(pub);
      return { err: null, data: res };
    } catch (e) {
      return { err: `Error handling getAddresses response: ${e.toString()}` };
    }
  }

  // Pair will create a new pairing if the user successfully enters the secret
  // into the device in time. If successful (status=0), the device will return
  // a new ephemeral public key, which is used to derive a shared secret
  // for the next request
  // @returns error (or null)
  _handlePair(encRes) {
    const d = this._handleEncResponse(encRes, decResLengths.empty);
    if (d.err) return d.err;
    // Remove the pairing salt - we're paired!
    this.pairingSalt = null;
    this.isPaired = true;
    return null;
  }

  // GetAddresses will return an array of address strings
  _handleGetAddresses(encRes) {
    // Handle the encrypted response
    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);
    if (decrypted.err !== null ) return decrypted;

    const addrData = decrypted.data;
    let off = 65; // Skip 65 byte pubkey prefix
    // Look for addresses until we reach the end (a 4 byte checksum)
    const addrs = [];
    while (off + 4 < decResLengths.getAddresses) {
      const addrBytes = addrData.slice(off, off+ADDR_STR_LEN); off += ADDR_STR_LEN;
      // Return the UTF-8 representation
      const len = addrBytes.indexOf(0); // First 0 is the null terminator
      if (len > 0)
        addrs.push(addrBytes.slice(0, len).toString());
    }
    return { data: addrs, err: null };
  }

  _handleGetWallets(encRes) {
    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);
    if (decrypted.err !== null) return decrypted;
    const res = decrypted.data;
    let walletUID;
    // Read the external wallet data first. If it is non-null, the external wallet will
    // be the active wallet of the device and we should save it.
    // If the external wallet is blank, it means there is no card present and we should 
    // save and use the interal wallet.
    // If both wallets are empty, it means the device still needs to be set up.
    const walletDescriptorLen = 71;
    // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name
    let off = 65;
    // Internal first
    let hasActiveWallet = false;
    walletUID = res.slice(off, off+32);
    this.activeWallets.internal.uid = walletUID;
    this.activeWallets.internal.capabilities = res.readUInt32BE(off+32);
    this.activeWallets.internal.name = res.slice(off+36, off+walletDescriptorLen);
    if (!walletUID.equals(EMPTY_WALLET_UID))
      hasActiveWallet = true;

    // Offset the first item
    off += walletDescriptorLen;
    
    // External
    walletUID = res.slice(off, off+32);
    this.activeWallets.external.uid = walletUID;
    this.activeWallets.external.capabilities = res.readUInt32BE(off+32);
    this.activeWallets.external.name = res.slice(off+36, off+walletDescriptorLen);
    if (!walletUID.equals(EMPTY_WALLET_UID))
      hasActiveWallet = true;
    if (hasActiveWallet === true)
      return null;
    else
      return 'No active wallet.';
  }

  _handleSign(encRes, currencyType, req=null) {
    // Handle the encrypted response
    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);
    if (decrypted.err !== null ) return { err: decrypted.err };
    const PUBKEY_PREFIX_LEN = 65;
    const PKH_PREFIX_LEN = 20;
    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix
    const res = decrypted.data;

    // Get the change data if we are making a BTC transaction
    let changeRecipient;
    if (currencyType === 'BTC') {
      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];
      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN); off += PKH_PREFIX_LEN;
      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);
    }
    // Start building return data
    const returnData = { err: null, data: null };
    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long
    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots
    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;
    
    if (currencyType === 'BTC') {
      const compressedPubLength = 33;  // Size of compressed public key
      const pubkeys = [];
      const sigs = [];
      let n = 0;
      // Parse the signature for each output -- they are returned
      // in the serialized payload in form [pubkey, sig]
      // There is one signature per output
      while (off < res.length) {
        // Exit out if we have seen all the returned sigs and pubkeys
        if (res[off] !== 0x30) break;
        // Otherwise grab another set
        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also
        // contain a length at off+1, which we use to parse the non-zero data.
        // First get the signature from its slot
        const sigStart = off;
        const sigEnd = off + 2 + res[off + 1];
        sigs.push(res.slice(sigStart, sigEnd));
        // Next, shift by the full set of signatures to hit the respective pubkey
        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]
        const pubStart = (n * compressedPubLength) + PUBKEYS_OFFSET;
        const pubEnd = ((n+1) * compressedPubLength) + PUBKEYS_OFFSET;
        pubkeys.push(res.slice(pubStart, pubEnd));
        // Update offset to hit the next signature slot
        off += DERLength;
        n += 1;
      }
      // Build the transaction data to be serialized
      const preSerializedData = {
        inputs: [],
        outputs: [],
        spenderScriptType: req.spenderScriptType,
        network: req.origData.network,
        crypto: this.crypto,
      };

      // First output comes from request dta
      preSerializedData.outputs.push({
        value: req.origData.value,
        recipient: req.origData.recipient,
      });
      if (req.changeData.value > 0) {
        // Second output comes from change data
        preSerializedData.outputs.push({
          value: req.changeData.value,
          recipient: changeRecipient,
        });
      }
      
      // Add the inputs
      for (let i = 0; i < sigs.length; i++) {
        preSerializedData.inputs.push({
          hash: req.origData.prevOuts[i].txHash,
          index: req.origData.prevOuts[i].index,
          sig: sigs[i],
          pubkey: pubkeys[i],
        });
      }

      // Finally, serialize the transaction
      const serializedTx = bitcoin.serializeTx(preSerializedData);
      // Generate the transaction hash so the user can look this transaction up later
      let preImageTxHash = serializedTx;
      if (preSerializedData.isSegwitSpend === true) {
        // Segwit transactions need to be re-serialized using legacy serialization
        // before the transaction hash is calculated. This allows legacy clients
        // to validate the transactions.
        preSerializedData.isSegwitSpend = false;
        preImageTxHash = bitcoin.serializeTx(preSerializedData);
      }  
      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();
      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex');
      
      // Add extra data for debugging/lookup purposes
      returnData.data = {
        tx: serializedTx,
        txHash,
        changeRecipient,
        sigs,
      }
    } else if (currencyType === 'ETH') {
      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;
      const ethAddr = res.slice(off, off + 20);
      // Determine the `v` param and add it to the sig before returning
      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr);
      returnData.data = {
        tx: `0x${rawTx}`,
        txHash: `0x${ethereum.hashTransaction(rawTx)}`,
        sig: {
          v: sig.v,
          r: sig.r.toString('hex'),
          s: sig.s.toString('hex'),
        },
        signer: ethAddr,
      };
    } else if (currencyType === 'ETH_MSG') {
      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;
      const signer = res.slice(off, off + 20);
      const validatedSig = ethereum.validateEthereumMsgResponse({ signer, sig }, req);
      returnData.data = {
        sig: {
          v: validatedSig.v,
          r: validatedSig.r.toString('hex'),
          s: validatedSig.s.toString('hex'),
        },
        signer,
      }
    }

    return returnData;
  }

  _resetActiveWallets() {
    this.activeWallets.internal.uid = EMPTY_WALLET_UID;
    this.activeWallets.internal.name = null;
    this.activeWallets.internal.capabilities = null;
    this.activeWallets.external.uid = EMPTY_WALLET_UID;
    this.activeWallets.external.name = null;
    this.activeWallets.external.capabilities = null;
    return;
  }

  getActiveWallet() {
    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {
      return this.activeWallets.external;
    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {
      return this.activeWallets.internal;
    } else {
      return null;
    }
  }

  hasActiveWallet() {
    return this.getActiveWallet() !== null;
  }
  
  // Get 64 bytes representing the public key
  // This is the uncompressed key without the leading 04 byte
  pubKeyBytes(LE=false) {
    const k = this.key.getPublic();
    const p = k.encode('hex');
    const pb = Buffer.from(p, 'hex');
    if (LE === true) {
      // Need to flip X and Y components to little endian
      const x = pb.slice(1, 33).reverse();
      const y = pb.slice(33, 65).reverse();
      return Buffer.concat([pb[0], x, y]);
    } else {
      return pb;
    }
  }

  // TODO: Find a better way to export this.
  parseAbi(source, data, skipErrors=false) {
    switch (source) {
      case 'etherscan':
        return abiParsers[source](data, skipErrors);
      default:
        return { err: `No ${source} parser available.` };

    }
  }
}

module.exports = Client;

      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/client.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js", {"@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectMetadataController = void 0;
const controllers_1 = require("@metamask/controllers");
const controllerName = 'SubjectMetadataController';
const stateMetadata = {
    subjectMetadata: { persist: true, anonymous: false },
};
const defaultState = {
    subjectMetadata: {},
};
/**
 * A controller for storing metadata associated with permission subjects. More
 * or less, a cache.
 */
class SubjectMetadataController extends controllers_1.BaseControllerV2 {
    constructor({ messenger, subjectCacheLimit, state = {}, }) {
        if (!Number.isInteger(subjectCacheLimit) || subjectCacheLimit < 1) {
            throw new Error(`subjectCacheLimit must be a positive integer. Received: "${subjectCacheLimit}"`);
        }
        const hasPermissions = (origin) => {
            return messenger.call('PermissionController:hasPermissions', origin);
        };
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign({}, SubjectMetadataController.getTrimmedState(state, hasPermissions)),
        });
        this.subjectHasPermissions = hasPermissions;
        this.subjectCacheLimit = subjectCacheLimit;
        this.subjectsWithoutPermissionsEcounteredSinceStartup = new Set();
    }
    /**
     * Clears the state of this controller. Also resets the cache of subjects
     * encountered since startup, so as to not prematurely reach the cache limit.
     */
    clearState() {
        this.subjectsWithoutPermissionsEcounteredSinceStartup.clear();
        this.update((_draftState) => {
            return Object.assign({}, defaultState);
        });
    }
    /**
     * Stores domain metadata for the given origin (subject). Deletes metadata for
     * subjects without permissions in a FIFO manner once more than
     * {@link SubjectMetadataController.subjectCacheLimit} distinct origins have
     * been added since boot.
     *
     * In order to prevent a degraded user experience,
     * metadata is never deleted for subjects with permissions, since metadata
     * cannot yet be requested on demand.
     *
     * @param metadata - The subject metadata to store.
     */
    addSubjectMetadata(metadata) {
        const { origin } = metadata;
        const newMetadata = Object.assign(Object.assign({}, metadata), { extensionId: metadata.extensionId || null, iconUrl: metadata.iconUrl || null });
        let originToForget = null;
        // We only delete the oldest encountered subject from the cache, again to
        // ensure that the user's experience isn't degraded by missing icons etc.
        if (this.subjectsWithoutPermissionsEcounteredSinceStartup.size >=
            this.subjectCacheLimit) {
            const cachedOrigin = this.subjectsWithoutPermissionsEcounteredSinceStartup
                .values()
                .next().value;
            this.subjectsWithoutPermissionsEcounteredSinceStartup.delete(cachedOrigin);
            if (!this.subjectHasPermissions(cachedOrigin)) {
                originToForget = cachedOrigin;
            }
        }
        this.subjectsWithoutPermissionsEcounteredSinceStartup.add(origin);
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.subjectMetadata[origin] = newMetadata;
            if (typeof originToForget === 'string') {
                delete draftState.subjectMetadata[originToForget];
            }
        });
    }
    /**
     * Deletes all subjects without permissions from the controller's state.
     */
    trimMetadataState() {
        this.update((draftState) => {
            return SubjectMetadataController.getTrimmedState(
            // Typecast: ts(2589)
            draftState, this.subjectHasPermissions);
        });
    }
    /**
     * Returns a new state object that only includes subjects with permissions.
     * This method is static because we want to call it in the constructor, before
     * the controller's state is initialized.
     *
     * @param state - The state object to trim.
     * @param hasPermissions - A function that returns a boolean indicating
     * whether a particular subject (identified by its origin) has any
     * permissions.
     * @returns The new state object. If the specified `state` object has no
     * subject metadata, the returned object will be equivalent to the default
     * state of this controller.
     */
    static getTrimmedState(state, hasPermissions) {
        const { subjectMetadata = {} } = state;
        return {
            subjectMetadata: Object.keys(subjectMetadata).reduce((newSubjectMetadata, origin) => {
                if (hasPermissions(origin)) {
                    newSubjectMetadata[origin] = subjectMetadata[origin];
                }
                return newSubjectMetadata;
            }, {}),
        };
    }
}
exports.SubjectMetadataController = SubjectMetadataController;
//# sourceMappingURL=SubjectMetadataController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/subject-metadata/SubjectMetadataController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/utils.js","./inlineSnaps":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js","@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapController = exports.SnapStatusEvent = exports.SnapStatus = exports.SNAP_PREFIX_REGEX = exports.SNAP_PREFIX = exports.controllerName = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const controllers_1 = require("@metamask/controllers");
const nanoid_1 = require("nanoid");
const utils_1 = require("../utils");
const inlineSnaps_1 = require("./inlineSnaps");
exports.controllerName = 'SnapController';
exports.SNAP_PREFIX = 'wallet_snap_';
exports.SNAP_PREFIX_REGEX = new RegExp(`^${exports.SNAP_PREFIX}`, 'u');
const SERIALIZABLE_SNAP_PROPERTIES = new Set([
    'initialPermissions',
    'name',
    'permissionName',
]);
const defaultState = {
    snapErrors: {},
    inlineSnapIsRunning: false,
    snaps: {},
    snapStates: {},
};
var SnapStatus;
(function (SnapStatus) {
    SnapStatus["installing"] = "installing";
    SnapStatus["running"] = "running";
    SnapStatus["stopped"] = "stopped";
    SnapStatus["crashed"] = "crashed";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
var SnapStatusEvent;
(function (SnapStatusEvent) {
    SnapStatusEvent["start"] = "start";
    SnapStatusEvent["stop"] = "stop";
    SnapStatusEvent["crash"] = "crash";
})(SnapStatusEvent = exports.SnapStatusEvent || (exports.SnapStatusEvent = {}));
/**
 * Guard transitioning when the snap is disabled.
 */
const disabledGuard = (serializedSnap) => {
    return serializedSnap.enabled;
};
/**
 * The state machine configuration for a snaps `status` state.
 * Using a state machine for a snaps `status` ensures that the snap transitions to a valid next lifecycle state.
 * Supports a very minimal subset of XState conventions outlined in `_transitionSnapState`.
 */
const snapStatusStateMachineConfig = {
    initial: SnapStatus.installing,
    states: {
        [SnapStatus.installing]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.running]: {
            on: {
                [SnapStatusEvent.stop]: SnapStatus.stopped,
                [SnapStatusEvent.crash]: SnapStatus.crashed,
            },
        },
        [SnapStatus.stopped]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
        [SnapStatus.crashed]: {
            on: {
                [SnapStatusEvent.start]: {
                    target: SnapStatus.running,
                    cond: disabledGuard,
                },
            },
        },
    },
};
const name = 'SnapController';
/*
 * A snap is initialized in three phases:
 * - Add: Loads the snap from a remote source and parses it.
 * - Authorize: Requests the snap's required permissions from the user.
 * - Start: Initializes the snap in its SES realm with the authorized permissions.
 */
class SnapController extends controllers_1.BaseControllerV2 {
    constructor({ removeAllPermissionsFor, closeAllConnections, requestPermissions, getPermissions, terminateSnap, terminateAllSnaps, hasPermission, executeSnap, getRpcMessageHandler, messenger, state, maxIdleTime = 30000, idleTimeCheckInterval = 5000, maxRequestTime = 60000, }) {
        super({
            messenger,
            metadata: {
                snapErrors: {
                    persist: false,
                    anonymous: false,
                },
                inlineSnapIsRunning: {
                    persist: false,
                    anonymous: false,
                },
                snapStates: {
                    persist: true,
                    anonymous: false,
                },
                snaps: {
                    persist: (snaps) => {
                        return Object.values(snaps)
                            .map((snap) => {
                            return Object.assign(Object.assign({}, snap), { 
                                // At the time state is rehydrated, no snap will be running.
                                status: SnapStatus.stopped });
                        })
                            .reduce((memo, snap) => {
                            memo[snap.name] = snap;
                            return memo;
                        }, {});
                    },
                    anonymous: false,
                },
            },
            name,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this._removeAllPermissionsFor = removeAllPermissionsFor;
        this._closeAllConnections = closeAllConnections;
        this._requestPermissions = requestPermissions;
        this._getPermissions = getPermissions;
        this._hasPermission = hasPermission;
        this._terminateSnap = terminateSnap;
        this._terminateAllSnaps = terminateAllSnaps;
        this._executeSnap = executeSnap;
        this._getRpcMessageHandler = getRpcMessageHandler;
        this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);
        this._onUnresponsiveSnap = this._onUnresponsiveSnap.bind(this);
        this.messagingSystem.subscribe('ServiceMessenger:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.subscribe('ServiceMessenger:unresponsive', this._onUnresponsiveSnap);
        this._snapsBeingAdded = new Map();
        this._maxIdleTime = maxIdleTime;
        this._maxRequestTime = maxRequestTime;
        this._idleTimeCheckInterval = idleTimeCheckInterval;
        this._pollForLastRequestStatus();
        this._lastRequestMap = new Map();
        this._rpcHandlerMap = new Map();
    }
    _pollForLastRequestStatus() {
        this._timeoutForLastRequestStatus = setTimeout(async () => {
            this._stopSnapsLastRequestPastMax();
            this._pollForLastRequestStatus();
        }, this._idleTimeCheckInterval);
    }
    _stopSnapsLastRequestPastMax() {
        this._lastRequestMap.forEach(async (timestamp, snapName) => {
            if (this._maxIdleTime && utils_1.timeSince(timestamp) > this._maxIdleTime) {
                this.stopSnap(snapName);
            }
        });
    }
    _onUnresponsiveSnap(snapName) {
        this._transitionSnapState(snapName, SnapStatusEvent.crash);
        this._stopSnap(snapName, false);
        this.addSnapError({
            code: -32001,
            message: 'Snap Unresponsive',
            data: {
                snapName,
            },
        });
    }
    _onUnhandledSnapError(snapName, error) {
        this._transitionSnapState(snapName, SnapStatusEvent.crash);
        this._stopSnap(snapName, false);
        this.addSnapError(error);
    }
    /**
     * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out the next state.
     * This transition function uses a very minimal subset of XState conventions:
     * - supports initial state
     * - .on supports raw event target string
     * - .on supports {target, cond} object
     * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event, context) => boolean`
     * @param snapName the name of the snap to transition
     * @param event the event enum to use to transition
     */
    _transitionSnapState(snapName, event) {
        var _a;
        const snapStatus = this.state.snaps[snapName].status;
        let nextStatus = (_a = snapStatusStateMachineConfig.states[snapStatus].on[event]) !== null && _a !== void 0 ? _a : snapStatus;
        if (nextStatus.cond) {
            const cond = nextStatus.cond(this.state.snaps[snapName]);
            if (cond === false) {
                throw new Error(`Condition failed for state transition "${snapName}" with event "${event}".`);
            }
        }
        if (nextStatus.target) {
            nextStatus = nextStatus.target;
        }
        if (nextStatus === snapStatus) {
            return;
        }
        this.update((state) => {
            state.snaps[snapName].status = nextStatus;
        });
    }
    /**
     * Runs existing (installed) snaps.
     * Deletes any snaps that cannot be started.
     */
    async runExistingSnaps() {
        const { snaps } = this.state;
        if (Object.keys(snaps).length > 0) {
            console.log('Starting existing snaps...', snaps);
        }
        else {
            console.log('No existing snaps to run.');
            return;
        }
        await Promise.all(Object.values(snaps).map(async ({ name: snapName, sourceCode }) => {
            console.log(`Starting: ${snapName}`);
            try {
                await this._startSnap({
                    snapName,
                    sourceCode,
                });
            }
            catch (err) {
                console.warn(`Failed to start "${snapName}", deleting it.`, err);
                // Clean up failed snaps:
                this.removeSnap(snapName);
            }
        }));
    }
    /**
     * Starts the given snap. Throws an error if no such snap exists
     * or if it is already running.
     *
     * @param snapName - The name of the snap to start.
     */
    async startSnap(snapName) {
        const snap = this.get(snapName);
        if (!snap) {
            throw new Error(`Snap "${snapName}" not found.`);
        }
        if (this.state.snaps[snapName].enabled === false) {
            throw new Error(`Snap "${snapName}" is disabled.`);
        }
        await this._startSnap({
            snapName,
            sourceCode: snap.sourceCode,
        });
    }
    /**
     * Enables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapName - The name of the snap to enable.
     */
    enableSnap(snapName) {
        this.update((state) => {
            state.snaps[snapName].enabled = true;
        });
    }
    /**
     * Disables the given snap. A snap can only be started if it is enabled.
     *
     * @param snapName - The name of the snap to disable.
     */
    disableSnap(snapName) {
        this.stopSnap(snapName);
        this.update((state) => {
            state.snaps[snapName].enabled = false;
        });
    }
    /**
     * Stops the given snap. Throws an error if no such snap exists
     * or if it is already stopped.
     *
     * @param snapName - The name of the snap to stop.
     */
    stopSnap(snapName) {
        const snap = this.get(snapName);
        if (!snap) {
            throw new Error(`Snap "${snapName}" not found.`);
        }
        if (!this.isRunning(snapName)) {
            throw new Error(`Snap "${snapName}" already stopped.`);
        }
        this._stopSnap(snapName);
        console.log(`Snap "${snapName}" stopped.`);
    }
    /**
     * Stops the given snap, removes all hooks, closes all connections, and
     * terminates its worker.
     *
     * @param snapName - The name of the snap to stop.
     * @param setNotRunning - Whether to mark the snap as not running.
     * Should only be set to false if the snap is about to be deleted.
     */
    _stopSnap(snapName, setNotRunning = true) {
        this._lastRequestMap.delete(snapName);
        this._closeAllConnections(snapName);
        this._terminateSnap(snapName);
        if (setNotRunning) {
            this._transitionSnapState(snapName, SnapStatusEvent.stop);
        }
    }
    /**
     * Returns whether the given snap is running.
     * Throws an error if the snap doesn't exist.
     *
     * @param snapName - The name of the snap to check.
     */
    isRunning(snapName) {
        const snap = this.get(snapName);
        if (!snap) {
            throw new Error(`Snap "${snapName}" not found.`);
        }
        return snap.status === SnapStatus.running;
    }
    /**
     * Returns whether the given snap has been added to state.
     *
     * @param snapName - The name of the snap to check for.
     */
    has(snapName) {
        return snapName in this.state.snaps;
    }
    /**
     * Gets the snap with the given name if it exists, including all data.
     * This should not be used if the snap is to be serializable, as e.g.
     * the snap sourceCode may be quite large.
     *
     * @param snapName - The name of the snap to get.
     */
    get(snapName) {
        return this.state.snaps[snapName];
    }
    /**
     * Gets the snap with the given name if it exists, excluding any
     * non-serializable or expensive-to-serialize data.
     *
     * @param snapName - The name of the snap to get.
     */
    getSerializable(snapName) {
        const snap = this.get(snapName);
        return snap
            ? // The cast to "any" of the accumulator object is due to a TypeScript bug
                Object.keys(snap).reduce((serialized, key) => {
                    if (SERIALIZABLE_SNAP_PROPERTIES.has(key)) {
                        serialized[key] = snap[key];
                    }
                    return serialized;
                }, {})
            : null;
    }
    /**
     * Updates the own state of the snap with the given name.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapName - The name of the snap whose state should be updated.
     * @param newSnapState - The new state of the snap.
     */
    async updateSnapState(snapName, newSnapState) {
        this.update((state) => {
            state.snapStates[snapName] = newSnapState;
        });
    }
    /**
     * Adds error from a snap to the SnapControllers state.
     *
     * @param snapError - The error to store on the SnapController
     */
    async addSnapError(snapError) {
        this.update((state) => {
            const id = nanoid_1.nanoid();
            state.snapErrors[id] = Object.assign(Object.assign({}, snapError), { internalID: id });
        });
    }
    /**
     * Removes an error by internalID from a the SnapControllers state.
     *
     * @param internalID - The internal error ID to remove on the SnapController
     */
    async removeSnapError(internalID) {
        this.update((state) => {
            delete state.snapErrors[internalID];
        });
    }
    /**
     * Clears all errors from the SnapControllers state.
     *
     */
    async clearSnapErrors() {
        this.update((state) => {
            state.snapErrors = {};
        });
    }
    /**
     * Gets the own state of the snap with the given name.
     * This is distinct from the state MetaMask uses to manage snaps.
     *
     * @param snapName - The name of the snap whose state to get.
     */
    async getSnapState(snapName) {
        return this.state.snapStates[snapName];
    }
    /**
     * Completely clear the controller's state: delete all associated data,
     * handlers, event listeners, and permissions; tear down all snap providers.
     */
    clearState() {
        const snapNames = Object.keys(this.state.snaps);
        snapNames.forEach((snapName) => {
            this._closeAllConnections(snapName);
        });
        this._terminateAllSnaps();
        this._removeAllPermissionsFor(snapNames);
        this.update((state) => {
            state.inlineSnapIsRunning = false;
            state.snaps = {};
            state.snapStates = {};
        });
    }
    /**
     * Removes the given snap from state, and clears all associated handlers
     * and listeners.
     *
     * @param snapName - The name of the snap.
     */
    removeSnap(snapName) {
        this.removeSnaps([snapName]);
    }
    /**
     * Stops the given snaps, removes them from state, and clears all associated
     * permissions, handlers, and listeners.
     *
     * @param {Array<string>} snapName - The name of the snaps.
     */
    removeSnaps(snapNames) {
        if (!Array.isArray(snapNames)) {
            throw new Error('Expected array of snap names.');
        }
        this.update((state) => {
            snapNames.forEach((snapName) => {
                this._stopSnap(snapName, false);
                this._rpcHandlerMap.delete(snapName);
                delete state.snaps[snapName];
                delete state.snapStates[snapName];
            });
        });
        this._removeAllPermissionsFor(snapNames);
    }
    /**
     * Gets the serialized permitted snaps of the given origin, if any.
     * @param origin - The origin whose permitted snaps to retrieve.
     */
    getPermittedSnaps(origin) {
        return this._getPermissions(origin).reduce((permittedSnaps, perm) => {
            if (perm.parentCapability.startsWith(exports.SNAP_PREFIX)) {
                const snapName = perm.parentCapability.replace(exports.SNAP_PREFIX_REGEX, '');
                const snap = this.getSerializable(snapName);
                permittedSnaps[snapName] = snap || {
                    error: eth_rpc_errors_1.serializeError(new Error('Snap permitted but not installed.')),
                };
            }
            return permittedSnaps;
        }, {});
    }
    /**
     * Installs the snaps requested by the given origin, returning the snap
     * object if the origin is permitted to install it, and an authorization error
     * otherwise.
     *
     * @param origin - The origin that requested to install the snaps.
     * @param requestedSnaps - The snaps to install.
     * @returns An object of snap names and snap objects, or errors if a
     * snap couldn't be installed.
     */
    async installSnaps(origin, requestedSnaps) {
        const result = {};
        // use a for-loop so that we can return an object and await the resolution
        // of each call to processRequestedSnap
        await Promise.all(Object.keys(requestedSnaps).map(async (snapName) => {
            const permissionName = exports.SNAP_PREFIX + snapName;
            if (this._hasPermission(origin, permissionName)) {
                // attempt to install and run the snap, storing any errors that
                // occur during the process
                result[snapName] = Object.assign({}, (await this.processRequestedSnap(snapName)));
            }
            else {
                // only allow the installation of permitted snaps
                result[snapName] = {
                    error: eth_rpc_errors_1.ethErrors.provider.unauthorized(`Not authorized to install snap '${snapName}'. Request the permission for the snap before attempting to install it.`),
                };
            }
        }));
        return result;
    }
    /**
     * Adds, authorizes, and runs the given snap with a snap provider.
     * Results from this method should be efficiently serializable.
     *
     * @param - snapName - The name of the snap.
     * @returns The resulting snap object, or an error if something went wrong.
     */
    async processRequestedSnap(snapName) {
        // If the snap is already installed, just return it
        const snap = this.get(snapName);
        if (snap) {
            return this.getSerializable(snapName);
        }
        try {
            const { sourceCode } = await this.add({
                name: snapName,
                manifestUrl: snapName,
            });
            await this.authorize(snapName);
            await this._startSnap({
                snapName,
                sourceCode,
            });
            return this.getSerializable(snapName);
        }
        catch (err) {
            console.error(`Error when adding snap.`, err);
            return { error: eth_rpc_errors_1.serializeError(err) };
        }
    }
    /**
     * Returns a promise representing the complete installation of the requested snap.
     * If the snap is already being installed, the previously pending promise will be returned.
     *
     * @param snapName - The name of the snap.
     * @param args - Object containing either the URL of the snap's manifest,
     * or the snap's manifest and source code.
     * @returns The resulting snap object.
     */
    add(args) {
        const { name: snapName } = args;
        if (!snapName || typeof snapName !== 'string') {
            throw new Error(`Invalid snap name: ${snapName}`);
        }
        if (!args ||
            (!('manifestUrl' in args) &&
                (!('manifest' in args) || !('sourceCode' in args)))) {
            throw new Error(`Invalid add snap args for snap "${snapName}".`);
        }
        if (!this._snapsBeingAdded.has(snapName)) {
            console.log(`Adding snap: ${snapName}`);
            this._snapsBeingAdded.set(snapName, this._add(args));
        }
        return this._snapsBeingAdded.get(snapName);
    }
    async _startSnap(snapData) {
        const { snapName } = snapData;
        if (this.isRunning(snapName)) {
            throw new Error(`Snap "${snapName}" is already started.`);
        }
        const result = await this._executeSnap(snapData);
        this._transitionSnapState(snapName, SnapStatusEvent.start);
        return result;
    }
    /**
     * Internal method. See the "add" method.
     *
     * @param snapName - The name of the snap.
     * @param args - The add snap args.
     * @returns The resulting snap object.
     */
    async _add(args) {
        var _a;
        const { name: snapName } = args;
        let manifest, sourceCode;
        if ('manifestUrl' in args) {
            const _sourceUrl = args.manifestUrl || snapName;
            [manifest, sourceCode] = await this._fetchSnap(snapName, _sourceUrl);
        }
        else {
            manifest = args.manifest;
            sourceCode = args.sourceCode;
        }
        if (typeof sourceCode !== 'string' || sourceCode.length === 0) {
            throw new Error(`Invalid source code for snap "${snapName}".`);
        }
        const initialPermissions = (_a = manifest === null || manifest === void 0 ? void 0 : manifest.web3Wallet) === null || _a === void 0 ? void 0 : _a.initialPermissions;
        if (!initialPermissions ||
            typeof initialPermissions !== 'object' ||
            Array.isArray(initialPermissions)) {
            throw new Error(`Invalid initial permissions for snap "${snapName}".`);
        }
        let snap = {
            initialPermissions,
            name: snapName,
            permissionName: exports.SNAP_PREFIX + snapName,
            sourceCode,
            version: manifest.version,
            enabled: true,
            status: snapStatusStateMachineConfig.initial,
        };
        const snapsState = this.state.snaps;
        // restore relevant snap state if it exists
        if (snapsState[snapName]) {
            snap = Object.assign(Object.assign({}, snapsState[snapName]), snap);
        }
        // store the snap back in state
        this.update((state) => {
            state.snaps[snapName] = snap;
        });
        return snap;
    }
    /**
     * Fetches the manifest and source code of a snap.
     *
     * @param name - The name of the snap.
     * @param manifestUrl - The URL of the snap's manifest file.
     * @returns An array of the snap manifest object and the snap source code.
     */
    async _fetchSnap(snapName, manifestUrl) {
        try {
            console.log(`Fetching snap manifest from: ${manifestUrl}`);
            const snapSource = await fetch(manifestUrl);
            const manifest = await snapSource.json();
            console.log(`Destructuring snap: `, manifest);
            const { web3Wallet: { bundle }, } = manifest;
            console.log(`Fetching snap source code from: ${bundle.url}`);
            const snapBundle = await fetch(bundle.url);
            const sourceCode = await snapBundle.text();
            return [manifest, sourceCode];
        }
        catch (err) {
            throw new Error(`Problem fetching snap "${snapName}": ${err.message}`);
        }
    }
    /**
     * Initiates a request for the given snap's initial permissions.
     * Must be called in order. See processRequestedSnap.
     *
     * @param snapName - The name of the snap.
     * @returns The snap's approvedPermissions.
     */
    async authorize(snapName) {
        console.log(`Authorizing snap: ${snapName}`);
        const snapsState = this.state.snaps;
        const snap = snapsState[snapName];
        const { initialPermissions } = snap;
        // Don't prompt if there are no permissions requested:
        if (Object.keys(initialPermissions).length === 0) {
            return [];
        }
        if (initialPermissions === null) {
            return [];
        }
        try {
            const approvedPermissions = await this._requestPermissions(snapName, initialPermissions);
            return approvedPermissions.map((perm) => perm.parentCapability);
        }
        finally {
            this._snapsBeingAdded.delete(snapName);
        }
    }
    /**
     * Test method.
     */
    runInlineSnap(inlineSnapName = 'IDLE') {
        this._startSnap({
            snapName: 'inlineSnap',
            sourceCode: inlineSnaps_1.INLINE_SNAPS[inlineSnapName],
        });
        this.update((state) => {
            state.inlineSnapIsRunning = true;
        });
    }
    /**
     * Test method.
     */
    removeInlineSnap() {
        this.update((state) => {
            state.inlineSnapIsRunning = false;
        });
        this.removeSnap('inlineSnap');
    }
    destroy() {
        super.destroy();
        if (this._timeoutForLastRequestStatus) {
            clearTimeout(this._timeoutForLastRequestStatus);
        }
        this.messagingSystem.unsubscribe('ServiceMessenger:unhandledError', this._onUnhandledSnapError);
        this.messagingSystem.unsubscribe('ServiceMessenger:unresponsive', this._onUnresponsiveSnap);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapName - The name of the snap whose message handler to get.
     */
    async getRpcMessageHandler(snapName) {
        const existingHandler = this._rpcHandlerMap.get(snapName);
        if (existingHandler) {
            return existingHandler;
        }
        const rpcHandler = async (origin, request) => {
            let handler = await this._getRpcMessageHandler(snapName);
            if (this.state.snaps[snapName].enabled === false) {
                throw new Error(`Snap "${snapName}" is disabled.`);
            }
            if (this.state.snaps[snapName].status === SnapStatus.installing) {
                throw new Error(`Snap "${snapName}" has not been started yet.`);
            }
            if (!handler && this.isRunning(snapName) === false) {
                // cold start
                await this.startSnap(snapName);
                handler = await this._getRpcMessageHandler(snapName);
            }
            if (!handler) {
                throw new Error(`Snap execution service returned no RPC handler for running snap "${snapName}".`);
            }
            this._recordSnapRpcRequest(snapName);
            // Handle max request time
            let timeout;
            const timeoutPromise = new Promise((_resolve, reject) => {
                timeout = setTimeout(() => {
                    this._stopSnap(snapName);
                    reject(new Error('The request timed out.'));
                }, this._maxRequestTime);
            });
            // This will either get the result or reject due to the timeout.
            const result = await Promise.race([
                handler(origin, request),
                timeoutPromise,
            ]);
            clearTimeout(timeout);
            return result;
        };
        this._rpcHandlerMap.set(snapName, rpcHandler);
        return rpcHandler;
    }
    _recordSnapRpcRequest(snapName) {
        this._lastRequestMap.set(snapName, Date.now());
    }
}
exports.SnapController = SnapController;
//# sourceMappingURL=SnapController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/SnapController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js", {"@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/index.js","@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalResourceController = void 0;
const obs_store_1 = require("@metamask/obs-store");
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const alwaysRequiredFields = ['fromDomain'];
const computeState = (storageKey, initialResources) => {
    return { [storageKey]: initialResources };
};
const getUnauthorizedMessage = (id) => `Not authorized to access resource with id "${id}".`;
/**
 * A class intended to describe a particular resource that is managed by snaps.
 * Example resources are assets.
 *
 * These are things that MetaMask treats as first-class objects with distinct properties within its own UI.
 */
class ExternalResourceController extends safe_event_emitter_1.default {
    constructor({ storageKey, requiredFields, initialResources, }) {
        super();
        this.requiredFields = requiredFields;
        this.storageKey = storageKey;
        this.store = new obs_store_1.ObservableStore(computeState(storageKey, initialResources));
    }
    getResources() {
        return Object.assign({}, this.store.getState()[this.storageKey]);
    }
    setResources(resources) {
        this.store.updateState({
            [this.storageKey]: resources,
        });
    }
    clearResources() {
        this.setResources({});
    }
    deleteResourcesFor(fromDomain) {
        const resources = this.getResources();
        const newResources = Object.entries(resources).reduce((acc, [id, resource]) => {
            if (resource.fromDomain !== fromDomain) {
                acc[id] = resource;
            }
            return acc;
        }, {});
        this.setResources(newResources);
    }
    get(fromDomain, id) {
        const resource = this.getResources()[id];
        if (resource && resource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        return resource ? Object.assign({}, resource) : null;
    }
    getAllResources(fromDomain) {
        return Object.values(this.getResources()).filter((resource) => {
            return resource.fromDomain === fromDomain;
        });
    }
    add(fromDomain, resource) {
        const newResource = this.processNewResource(fromDomain, resource);
        const { id } = newResource;
        const resources = this.getResources();
        if (resources[id]) {
            throw new Error(`Resource with id "${id}" already exists.`);
        }
        else {
            resources[id] = newResource;
            this.setResources(resources);
        }
        return newResource.id;
    }
    update(fromDomain, resource) {
        const { id } = resource;
        const resources = this.getResources();
        const existingResource = resources[id];
        if (!existingResource) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceNotFound({
                message: `Resource with id "${id}" not found.`,
            });
        }
        else if (existingResource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        resources[id] = this.processNewResource(fromDomain, Object.assign(Object.assign({}, resources[id]), resource));
        this.setResources(resources);
        return id;
    }
    processNewResource(fromDomain, resource) {
        this.requiredFields.forEach((requiredField) => {
            if (!(requiredField in resource)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Resource from "${fromDomain}" missing required field: ${requiredField}`);
            }
        });
        return Object.assign(Object.assign({}, resource), { fromDomain, id: resource.id || nanoid_1.nanoid() });
    }
    delete(fromDomain, id) {
        const resources = this.getResources();
        const existingResource = resources[id];
        if (!existingResource) {
            throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                message: `Resource with id "${id}" not found.`,
            });
        }
        else if (existingResource.fromDomain !== fromDomain) {
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized({
                message: getUnauthorizedMessage(id),
            });
        }
        delete resources[id];
        this.setResources(resources);
        return null;
    }
    handleRpcRequest(fromDomain, method, arg) {
        if (!fromDomain || typeof fromDomain !== 'string') {
            throw new Error('Invalid fromDomain.');
        }
        switch (method) {
            case 'get':
                return this.get(fromDomain, arg);
            case 'getAll':
                return this.getAllResources(fromDomain);
            case 'add':
                return this.add(fromDomain, arg);
            case 'update':
                return this.update(fromDomain, arg);
            case 'delete':
                return this.delete(fromDomain, arg);
            default:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound({
                    message: `Not an asset method: ${method}`,
                });
        }
    }
}
exports.ExternalResourceController = ExternalResourceController;
//# sourceMappingURL=ExternalResourceController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/resource/ExternalResourceController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ExecutionEnvironmentService.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/ExecutionEnvironmentService.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js", {"@metamask/object-multiplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/index.js","@metamask/obs-store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/index.js","@metamask/post-message-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/index.js","@metamask/snap-workers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/index.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js","json-rpc-middleware-stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs","pump":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/pump/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebWorkerExecutionEnvironmentService = void 0;
const nanoid_1 = require("nanoid");
const pump_1 = __importDefault(require("pump"));
const obs_store_1 = require("@metamask/obs-store");
const object_multiplex_1 = __importDefault(require("@metamask/object-multiplex"));
const post_message_stream_1 = require("@metamask/post-message-stream");
const snap_workers_1 = require("@metamask/snap-workers");
const json_rpc_middleware_stream_1 = require("json-rpc-middleware-stream");
const json_rpc_engine_1 = require("json-rpc-engine");
class WebWorkerExecutionEnvironmentService {
    constructor({ setupSnapProvider, workerUrl, messenger, unresponsivePollingInterval = 5000, unresponsiveTimeout = 30000, }) {
        this.workerUrl = workerUrl;
        this.setupSnapProvider = setupSnapProvider;
        this.store = new obs_store_1.ObservableStore({ workers: {} });
        this.workers = new Map();
        this.snapToWorkerMap = new Map();
        this.workerToSnapMap = new Map();
        this._snapRpcHooks = new Map();
        this._messenger = messenger;
        this._unresponsivePollingInterval = unresponsivePollingInterval;
        this._unresponsiveTimeout = unresponsiveTimeout;
        this._timeoutForUnresponsiveMap = new Map();
    }
    _setWorker(workerId, workerWrapper) {
        this.workers.set(workerId, workerWrapper);
        const newWorkerState = Object.assign(Object.assign({}, this.store.getState().workers), { [workerId]: workerWrapper });
        this.store.updateState({ workers: newWorkerState });
    }
    _deleteWorker(workerId) {
        this.workers.delete(workerId);
        const newWorkerState = Object.assign({}, this.store.getState().workers);
        delete newWorkerState[workerId];
        this.store.updateState({ workers: newWorkerState });
    }
    async _command(workerId, message) {
        if (typeof message !== 'object') {
            throw new Error('Must send object.');
        }
        const workerWrapper = this.workers.get(workerId);
        if (!workerWrapper) {
            throw new Error(`Worker with id ${workerId} not found.`);
        }
        console.log('Parent: Sending Command', message);
        const response = await workerWrapper.rpcEngine.handle(message);
        if (response.error) {
            throw new Error(response.error.message);
        }
        return response.result;
    }
    async terminateAllSnaps() {
        for (const workerId of this.workers.keys()) {
            this.terminate(workerId);
        }
        this._snapRpcHooks.clear();
    }
    async terminateSnap(snapName) {
        const workerId = this.snapToWorkerMap.get(snapName);
        workerId && this.terminate(workerId);
        this._removeSnapHooks(snapName);
    }
    terminate(workerId) {
        const workerWrapper = this.workers.get(workerId);
        if (!workerWrapper) {
            throw new Error(`Worker with id "${workerId}" not found.`);
        }
        const snapName = this._getSnapForWorker(workerId);
        if (!snapName) {
            throw new Error(`Failed to find a snap for worker with id "${workerId}".`);
        }
        Object.values(workerWrapper.streams).forEach((stream) => {
            try {
                !stream.destroyed && stream.destroy();
                stream.removeAllListeners();
            }
            catch (err) {
                console.log('Error while destroying stream', err);
            }
        });
        workerWrapper.worker.terminate();
        this._removeSnapAndWorkerMapping(workerId);
        this._deleteWorker(workerId);
        clearTimeout(this._timeoutForUnresponsiveMap.get(workerId));
        this._timeoutForUnresponsiveMap.delete(workerId);
        console.log(`worker:${workerId} terminated`);
    }
    /**
     * Gets the RPC message handler for the given snap.
     *
     * @param snapName - The name of the snap whose message handler to get.
     */
    async getRpcMessageHandler(snapName) {
        return this._snapRpcHooks.get(snapName);
    }
    _removeSnapHooks(snapName) {
        this._snapRpcHooks.delete(snapName);
    }
    _createSnapHooks(snapName, workerId) {
        const rpcHook = async (origin, request) => {
            return await this._command(workerId, {
                id: nanoid_1.nanoid(),
                jsonrpc: '2.0',
                method: 'snapRpc',
                params: {
                    origin,
                    request,
                    target: snapName,
                },
            });
        };
        this._snapRpcHooks.set(snapName, rpcHook);
    }
    async executeSnap(snapData) {
        if (this.snapToWorkerMap.has(snapData.snapName)) {
            throw new Error(`Snap "${snapData.snapName}" is already being executed.`);
        }
        const worker = await this._initWorker();
        this._mapSnapAndWorker(snapData.snapName, worker.id);
        this.setupSnapProvider(snapData.snapName, worker.streams.rpc);
        const result = await this._command(worker.id, {
            jsonrpc: '2.0',
            method: 'executeSnap',
            params: snapData,
            id: nanoid_1.nanoid(),
        });
        // set up poll/ping for status to see if its up, if its not then emit event that it cant be reached
        this._pollForWorkerStatus(snapData.snapName);
        this._createSnapHooks(snapData.snapName, worker.id);
        return result;
    }
    _pollForWorkerStatus(snapName) {
        const workerId = this._getWorkerForSnap(snapName);
        if (!workerId) {
            throw new Error('no worker id found for snap');
        }
        const timeout = setTimeout(async () => {
            this._getWorkerStatus(workerId)
                .then(() => {
                this._pollForWorkerStatus(snapName);
            })
                .catch(() => {
                this._messenger.publish('ServiceMessenger:unresponsive', snapName);
            });
        }, this._unresponsivePollingInterval);
        this._timeoutForUnresponsiveMap.set(snapName, timeout);
    }
    async _getWorkerStatus(workerId) {
        let resolve;
        let reject;
        const timeoutPromise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        const timeout = setTimeout(() => {
            reject(new Error('ping request timed out'));
        }, this._unresponsiveTimeout);
        return Promise.race([
            this._command(workerId, {
                jsonrpc: '2.0',
                method: 'ping',
                params: [],
                id: nanoid_1.nanoid(),
            }).then(() => {
                clearTimeout(timeout);
                resolve();
            }),
            timeoutPromise,
        ]);
    }
    _mapSnapAndWorker(snapName, workerId) {
        this.snapToWorkerMap.set(snapName, workerId);
        this.workerToSnapMap.set(workerId, snapName);
    }
    /**
     * @returns The ID of the snap's worker.
     */
    _getWorkerForSnap(snapName) {
        return this.snapToWorkerMap.get(snapName);
    }
    /**
     * @returns The ID worker's snap.
     */
    _getSnapForWorker(workerId) {
        return this.workerToSnapMap.get(workerId);
    }
    _removeSnapAndWorkerMapping(workerId) {
        const snapName = this.workerToSnapMap.get(workerId);
        if (!snapName) {
            throw new Error(`worker:${workerId} has no mapped snap.`);
        }
        this.workerToSnapMap.delete(workerId);
        this.snapToWorkerMap.delete(snapName);
    }
    async _initWorker() {
        const workerId = nanoid_1.nanoid();
        const worker = new Worker(this.workerUrl, {
            name: workerId,
        });
        // Handle out-of-band errors, i.e. errors thrown from the snap outside of the req/res cycle.
        const errorHandler = (ev) => {
            if (this._messenger) {
                const snapName = this.workerToSnapMap.get(workerId);
                if (snapName) {
                    this._messenger.publish('ServiceMessenger:unhandledError', snapName, {
                        code: ev.error.code,
                        message: ev.error.message,
                        data: ev.error.data,
                    });
                }
            }
        };
        worker.addEventListener('error', errorHandler, { once: true });
        const streams = this._initWorkerStreams(worker, workerId);
        const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
        const jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();
        pump_1.default(jsonRpcConnection.stream, streams.command, jsonRpcConnection.stream);
        rpcEngine.push(jsonRpcConnection.middleware);
        const workerWrapper = {
            id: workerId,
            streams,
            rpcEngine,
            worker,
        };
        this._setWorker(workerId, workerWrapper);
        await this._command(workerId, {
            jsonrpc: '2.0',
            method: 'ping',
            id: nanoid_1.nanoid(),
        });
        return workerWrapper;
    }
    _initWorkerStreams(worker, workerId) {
        const workerStream = new post_message_stream_1.WorkerParentPostMessageStream({ worker });
        // Typecast justification: stream type mismatch
        const mux = setupMultiplex(workerStream, `Worker:${workerId}`);
        const commandStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.COMMAND);
        const rpcStream = mux.createStream(snap_workers_1.SNAP_STREAM_NAMES.JSON_RPC);
        // Typecast: stream type mismatch
        return {
            command: commandStream,
            rpc: rpcStream,
            _connection: workerStream,
        };
    }
}
exports.WebWorkerExecutionEnvironmentService = WebWorkerExecutionEnvironmentService;
/**
 * Sets up stream multiplexing for the given stream.
 *
 * @param {any} connectionStream - the stream to mux
 * @param {string} streamName - the name of the stream, for identification in errors
 * @return {stream.Stream} the multiplexed stream
 */
function setupMultiplex(connectionStream, streamName) {
    const mux = new object_multiplex_1.default();
    pump_1.default(connectionStream, 
    // Typecast: stream type mismatch
    mux, connectionStream, (err) => {
        if (err) {
            streamName
                ? console.error(`${streamName} stream failure.`, err)
                : console.error(err);
        }
    });
    return mux;
}
//# sourceMappingURL=WebWorkerExecutionEnvironmentService.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/services/WebWorkerExecutionEnvironmentService.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodNames = void 0;
var MethodNames;
(function (MethodNames) {
    MethodNames["requestPermissions"] = "wallet_requestPermissions";
    MethodNames["getPermissions"] = "wallet_getPermissions";
})(MethodNames = exports.MethodNames || (exports.MethodNames = {}));
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js", {"nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findCaveat = exports.constructPermission = void 0;
const nanoid_1 = require("nanoid");
/**
 * The default permission factory function. Naively constructs a permission from
 * the inputs. Sets a default, random `id` if none is provided.
 *
 * @see {@link Permission} For more details.
 *
 * @template TargetPermission - The {@link Permission} that will be constructed.
 * @param options - The options for the permission.
 * @returns The new permission object.
 */
function constructPermission(options) {
    const { caveats = null, invoker, target } = options;
    return {
        id: nanoid_1.nanoid(),
        parentCapability: target,
        invoker,
        caveats,
        date: new Date().getTime(),
    };
}
exports.constructPermission = constructPermission;
/**
 * Gets the caveat of the specified type belonging to the specified permission.
 *
 * @param permission The permission whose caveat to retrieve.
 * @param caveatType The type of the caveat to retrieve.
 * @returns The caveat, or undefined if no such caveat exists.
 */
function findCaveat(permission, caveatType) {
    var _a;
    return (_a = permission.caveats) === null || _a === void 0 ? void 0 : _a.find((caveat) => caveat.type === caveatType);
}
exports.findCaveat = findCaveat;
//# sourceMappingURL=Permission.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateWithCaveats = void 0;
const errors_1 = require("./errors");
/**
 * Decorate a restricted method implementation with its caveats.
 *
 * Note that all caveat functions (i.e. the argument and return value of the
 * decorator) must be awaited.
 */
function decorateWithCaveats(methodImplementation, permission, // bound to the requesting origin
caveatSpecifications) {
    const { caveats } = permission;
    if (!caveats) {
        return methodImplementation;
    }
    let decorated = async (args) => methodImplementation(args);
    for (const caveat of caveats) {
        const specification = caveatSpecifications[caveat.type];
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type);
        }
        decorated = specification.decorator(decorated, caveat);
    }
    return decorated;
}
exports.decorateWithCaveats = decorateWithCaveats;
//# sourceMappingURL=Caveat.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js", {"./getPermissions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js","./requestPermissions":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = void 0;
const requestPermissions_1 = require("./requestPermissions");
const getPermissions_1 = require("./getPermissions");
exports.handlers = [requestPermissions_1.requestPermissionsHandler, getPermissions_1.getPermissionsHandler];
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/utils.js","./Caveat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Caveat.js","./Permission":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/Permission.js","./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js","./permission-middleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js","@metamask/controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/index.js","deep-freeze-strict":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/deep-freeze-strict/index.js","immer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/immer/dist/index.js","nanoid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js
      return function (require, module, exports) {
"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionController = exports.CaveatMutatorOperation = void 0;
const controllers_1 = require("@metamask/controllers");
/* eslint-enable @typescript-eslint/no-unused-vars */
const deep_freeze_strict_1 = __importDefault(require("deep-freeze-strict"));
const immer_1 = require("immer");
const nanoid_1 = require("nanoid");
const utils_1 = require("../utils");
const Caveat_1 = require("./Caveat");
const Permission_1 = require("./Permission");
const errors_1 = require("./errors");
const utils_2 = require("./utils");
const permission_middleware_1 = require("./permission-middleware");
/**
 * The name of the {@link PermissionController}.
 */
const controllerName = 'PermissionController';
/**
 * Get the state metadata of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 */
function getStateMetadata() {
    return { subjects: { anonymous: true, persist: true } };
}
/**
 * Get the default state of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 */
function getDefaultState() {
    return { subjects: {} };
}
/**
 * Describes the possible results of a {@link CaveatMutator} function.
 */
var CaveatMutatorOperation;
(function (CaveatMutatorOperation) {
    CaveatMutatorOperation[CaveatMutatorOperation["noop"] = 0] = "noop";
    CaveatMutatorOperation[CaveatMutatorOperation["updateValue"] = 1] = "updateValue";
    CaveatMutatorOperation[CaveatMutatorOperation["deleteCaveat"] = 2] = "deleteCaveat";
    CaveatMutatorOperation[CaveatMutatorOperation["revokePermission"] = 3] = "revokePermission";
})(CaveatMutatorOperation = exports.CaveatMutatorOperation || (exports.CaveatMutatorOperation = {}));
/**
 * The permission controller. See the README for details.
 *
 * Assumes the existence of an {@link ApprovalController} reachable via the
 * {@link ControllerMessenger}.
 *
 * @template ControllerPermissionSpecification - A union of the types of all
 * permission specifications available to the controller. Any referenced caveats
 * must be included in the controller's caveat specifications.
 * @template ControllerCaveatSpecification - A union of the types of all
 * caveat specifications available to the controller.
 */
class PermissionController extends controllers_1.BaseControllerV2 {
    /**
     * @param options - Permission controller options.
     * @param options.caveatSpecifications - The specifications of all caveats
     * available to the controller. See {@link CaveatSpecificationMap} and the
     * documentation for more details.
     * @param options.permissionSpecifications - The specifications of all
     * permissions available to the controller. See
     * {@link PermissionSpecificationMap} and the README for more details.
     * @param options.unrestrictedMethods - The callable names of all JSON-RPC
     * methods ignored by the new controller.
     * @param options.messenger - The controller messenger. See
     * {@link BaseController} for more information.
     * @param options.state - Existing state to hydrate the controller with at
     * initialization.
     */
    constructor(options) {
        const { caveatSpecifications, permissionSpecifications, unrestrictedMethods, messenger, state = {}, } = options;
        super({
            name: controllerName,
            metadata: getStateMetadata(),
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._unrestrictedMethods = new Set(unrestrictedMethods);
        this._caveatSpecifications = deep_freeze_strict_1.default(Object.assign({}, caveatSpecifications));
        this.validatePermissionSpecifications(permissionSpecifications, this._caveatSpecifications);
        this._permissionSpecifications = deep_freeze_strict_1.default(Object.assign({}, permissionSpecifications));
        this.registerMessageHandlers();
        this.createPermissionMiddleware = permission_middleware_1.getPermissionMiddlewareFactory({
            executeRestrictedMethod: this._executeRestrictedMethod.bind(this),
            getRestrictedMethod: this.getRestrictedMethod.bind(this),
            isUnrestrictedMethod: this.unrestrictedMethods.has.bind(this.unrestrictedMethods),
        });
    }
    /**
     * The names of all JSON-RPC methods that will be ignored by the controller.
     */
    get unrestrictedMethods() {
        return this._unrestrictedMethods;
    }
    /**
     * Gets a permission specification.
     *
     * @param targetKey - The target key of the permission specification to get.
     * @returns The permission specification with the specified target key.
     */
    getPermissionSpecification(targetKey) {
        return this._permissionSpecifications[targetKey];
    }
    /**
     * Gets a caveat specification.
     *
     * @param caveatType - The type of the caveat specification to get.
     * @returns The caveat specification with the specified type.
     */
    getCaveatSpecification(caveatType) {
        return this._caveatSpecifications[caveatType];
    }
    /**
     * Constructor helper for validating permission specifications. This is
     * intended to prevent the use of invalid target keys which, while impossible
     * to add in TypeScript, could rather easily occur in plain JavaScript.
     *
     * Throws an error if validation fails.
     *
     * @param permissionSpecifications - The permission specifications passed to
     * this controller's constructor.
     * @param caveatSpecifications - The caveat specifications passed to this
     * controller.
     */
    validatePermissionSpecifications(permissionSpecifications, caveatSpecifications) {
        Object.entries(permissionSpecifications).forEach(([targetKey, { targetKey: innerTargetKey, allowedCaveats }]) => {
            // Check if the target key is the empty string, ends with "_", or ends
            // with "*" but not "_*"
            if (!targetKey || /_$/u.test(targetKey) || /[^_]\*$/u.test(targetKey)) {
                throw new Error(`Invalid permission target key: "${targetKey}"`);
            }
            if (targetKey !== innerTargetKey) {
                throw new Error(`Invalid permission specification: key "${targetKey}" must match specification.target value "${innerTargetKey}".`);
            }
            if (allowedCaveats) {
                allowedCaveats.forEach((caveatType) => {
                    if (!utils_1.hasProperty(caveatSpecifications, caveatType)) {
                        throw new errors_1.UnrecognizedCaveatTypeError(caveatType);
                    }
                });
            }
        });
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearPermissions`, () => this.clearState());
        this.messagingSystem.registerActionHandler(`${controllerName}:getSubjectNames`, () => this.getSubjectNames());
        this.messagingSystem.registerActionHandler(`${controllerName}:hasPermissions`, (origin) => this.hasPermissions(origin));
    }
    /**
     * Clears the state of the controller.
     */
    clearState() {
        this.update((_draftState) => {
            return Object.assign({}, getDefaultState());
        });
    }
    /**
     * Gets the implementation of the specified restricted method.
     *
     * A JSON-RPC error is thrown if the method does not exist.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for internal usage.
     * @param method - The name of the restricted method.
     * @param origin - The origin associated with the request for the restricted
     * method, if any.
     * @returns The restricted method implementation.
     */
    getRestrictedMethod(method, origin) {
        const targetKey = this.getTargetKey(method);
        if (!targetKey) {
            const error = errors_1.methodNotFound({ method });
            if (origin) {
                error.data = { origin };
            }
            throw error;
        }
        return this.getPermissionSpecification(targetKey).methodImplementation;
    }
    /**
     * @returns The origins (i.e. IDs) of all subjects.
     */
    getSubjectNames() {
        return Object.keys(this.state.subjects);
    }
    /**
     * Gets the permission for the specified target of the subject corresponding
     * to the specified origin.
     *
     * @param origin - The origin of the subject.
     * @param targetName - The method name as invoked by a third party (i.e., not
     * a method key).
     * @returns The permission if it exists, or undefined otherwise.
     */
    getPermission(origin, targetName) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[targetName];
    }
    /**
     * Gets all permissions for the specified subject, if any.
     *
     * @param origin - The origin of the subject.
     * @returns The permissions of the subject, if any.
     */
    getPermissions(origin) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions;
    }
    /**
     * Checks whether the subject with the specified origin has the specified
     * permission.
     *
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @returns Whether the subject has the permission.
     */
    hasPermission(origin, target) {
        return Boolean(this.getPermission(origin, target));
    }
    /**
     * Checks whether the subject with the specified origin has any permissions.
     * Use this if you want to know if a subject "exists".
     *
     * @param origin - The origin of the subject to check.
     * @returns Whether the subject has any permissions.
     */
    hasPermissions(origin) {
        return Boolean(this.state.subjects[origin]);
    }
    /**
     * Revokes all permissions from the specified origin.
     *
     * Throws an error of the origin has no permissions.
     *
     * @param origin - The origin whose permissions to revoke.
     */
    revokeAllPermissions(origin) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            delete draftState.subjects[origin];
        });
    }
    /**
     * Revokes the specified permission from the subject with the specified
     * origin.
     *
     * Throws an error if the subject or the permission does not exist.
     *
     * @param origin - The origin of the subject whose permission to revoke.
     * @param target - The target name of the permission to revoke.
     */
    revokePermission(origin, target) {
        this.revokePermissions({ [origin]: [target] });
    }
    /**
     * Revokes the specified permissions from the specified subjects.
     *
     * Throws an error if any of the subjects or permissions do not exist.
     *
     * @param subjectsAndPermissions - An object mapping subject origins
     * to arrays of permission target names to revoke.
     */
    revokePermissions(subjectsAndPermissions) {
        this.update((draftState) => {
            Object.keys(subjectsAndPermissions).forEach((origin) => {
                if (!utils_1.hasProperty(draftState.subjects, origin)) {
                    throw new errors_1.UnrecognizedSubjectError(origin);
                }
                subjectsAndPermissions[origin].forEach((target) => {
                    const { permissions } = draftState.subjects[origin];
                    if (!utils_1.hasProperty(permissions, target)) {
                        throw new errors_1.PermissionDoesNotExistError(origin, target);
                    }
                    this.deletePermission(draftState.subjects, origin, target);
                });
            });
        });
    }
    /**
     * Revokes all permissions corresponding to the specified target for all subjects.
     * Does nothing if no subjects or no such permission exists.
     *
     * @param target - The name of the target to revoke all permissions for.
     */
    revokePermissionForAllSubjects(target) {
        if (this.getSubjectNames().length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.entries(draftState.subjects).forEach(([origin, subject]) => {
                const { permissions } = subject;
                if (utils_1.hasProperty(permissions, target)) {
                    this.deletePermission(draftState.subjects, origin, target);
                }
            });
        });
    }
    /**
     * Deletes the permission identified by the given origin and target. If the
     * permission is the single remaining permission of its subject, the subject
     * is also deleted.
     *
     * @param subjects - The draft permission controller subjects.
     * @param origin - The origin of the subject associated with the permission
     * to delete.
     * @param target - The target name of the permission to delete.
     */
    deletePermission(subjects, origin, target) {
        const { permissions } = subjects[origin];
        if (Object.keys(permissions).length > 1) {
            delete permissions[target];
        }
        else {
            delete subjects[origin];
        }
    }
    /**
     * Checks whether the permission of the subject corresponding to the given
     * origin has a caveat of the specified type.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to check for.
     * @returns Whether the permission has the specified caveat.
     */
    hasCaveat(origin, target, caveatType) {
        return Boolean(this.getCaveat(origin, target, caveatType));
    }
    /**
     * Gets the caveat of the specified type, if any, for the permission of
     * the subject corresponding to the given origin.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to get.
     * @returns The caveat, or `undefined` if no such caveat exists.
     */
    getCaveat(origin, target, caveatType) {
        const permission = this.getPermission(origin, target);
        if (!permission) {
            throw new errors_1.PermissionDoesNotExistError(origin, target);
        }
        return Permission_1.findCaveat(permission, caveatType);
    }
    /**
     * Adds a caveat of the specified type, with the specified caveat value, to
     * the permission corresponding to the given subject origin and permission
     * target.
     *
     * For modifying existing caveats, use
     * {@link PermissionController.updateCaveat}.
     *
     * Throws an error if no such permission exists, or if the caveat already
     * exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to add.
     * @param caveatValue - The value of the caveat to add.
     */
    addCaveat(origin, target, caveatType, caveatValue) {
        if (this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatAlreadyExistsError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Updates the value of the caveat of the specified type belonging to the
     * permission corresponding to the given subject origin and permission
     * target.
     *
     * For adding new caveats, use
     * {@link PermissionController.addCaveat}.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to update.
     * @param caveatValue - The new value of the caveat.
     */
    updateCaveat(origin, target, caveatType, caveatValue) {
        if (!this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Sets the specified caveat on the specified permission. Overwrites existing
     * caveats of the same type in-place (preserving array order), and adds the
     * caveat to the end of the array otherwise.
     *
     * Throws an error if the permission does not exist or fails to validate after
     * its caveats have been modified.
     *
     * @see {@link PermissionController.addCaveat}
     * @see {@link PermissionController.updateCaveat}
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to set.
     * @param caveatValue - The value of the caveat to set.
     */
    setCaveat(origin, target, caveatType, caveatValue) {
        this.update((draftState) => {
            const subject = draftState.subjects[origin];
            // Unreachable because `hasCaveat` is always called before this, and it
            // throws if permissions are missing. TypeScript needs this, however.
            /* istanbul ignore if */
            if (!subject) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            const permission = subject.permissions[target];
            /* istanbul ignore if: practically impossible, but TypeScript wants it */
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            const caveat = {
                type: caveatType,
                value: caveatValue,
            };
            this.validateCaveat(caveat, origin, target);
            if (permission.caveats) {
                const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveat.type);
                if (caveatIndex === -1) {
                    permission.caveats.push(caveat);
                }
                else {
                    permission.caveats.splice(caveatIndex, 1, caveat);
                }
            }
            else {
                // Typecast: At this point, we don't know if the specific permission
                // is allowed to have caveats, but it should be impossible to call
                // this method for a permission that may not have any caveats.
                // If all else fails, the permission validator is also called.
                permission.caveats = [caveat];
            }
            this.validateModifiedPermission(permission, origin, target);
        });
    }
    /**
     * Updates all caveats with the specified type for all subjects and
     * permissions by applying the specified mutator function to them.
     *
     * **ATTN:** Permissions can be revoked entirely by the action of this method,
     * read on for details.
     *
     * Caveat mutators are functions that receive a caveat value and return a
     * tuple consisting of a {@link CaveatMutatorOperation} and, optionally, a new
     * value to update the existing caveat with.
     *
     * For each caveat, depending on the mutator result, this method will:
     * - Do nothing ({@link CaveatMutatorOperation.noop})
     * - Update the value of the caveat ({@link CaveatMutatorOperation.updateValue})
     *   - The caveat specification validator, if any, will be called after
     *     updating the value.
     * - Delete the caveat ({@link CaveatMutatorOperation.deleteCaveat})
     *   - The permission specification validator, if any, will be called after
     *     deleting the caveat.
     * - Revoke the parent permission ({@link CaveatMutatorOperation.revokePermission})
     *
     * This method throws if the validation of any caveat or permission fails.
     *
     * @param targetCaveatType - The type of the caveats to update.
     * @param mutator - The mutator function which will be applied to all caveat
     * values.
     */
    updatePermissionsByCaveat(targetCaveatType, mutator) {
        if (Object.keys(this.state.subjects).length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.values(draftState.subjects).forEach((subject) => {
                Object.values(subject.permissions).forEach((permission) => {
                    const { caveats } = permission;
                    const targetCaveat = caveats === null || caveats === void 0 ? void 0 : caveats.find(({ type }) => type === targetCaveatType);
                    if (!targetCaveat) {
                        return;
                    }
                    // The mutator may modify the caveat value in place, and must always
                    // return a valid mutation result.
                    const mutatorResult = mutator(targetCaveat.value);
                    switch (mutatorResult.operation) {
                        case CaveatMutatorOperation.noop:
                            break;
                        case CaveatMutatorOperation.updateValue:
                            // Typecast: `Mutable` is used here to assign to a readonly
                            // property. `targetConstraint` should already be mutable because
                            // it's part of a draft, but for some reason it's not. We can't
                            // use the more-correct `Draft` type here either because it
                            // results in an error.
                            targetCaveat.value =
                                mutatorResult.value;
                            this.validateCaveat(targetCaveat, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.deleteCaveat:
                            this.deleteCaveat(permission, targetCaveatType, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.revokePermission:
                            this.deletePermission(draftState.subjects, subject.origin, permission.parentCapability);
                            break;
                        default: {
                            // This type check ensures that the switch statement is
                            // exhaustive.
                            const _exhaustiveCheck = mutatorResult;
                            throw new Error(`Unrecognized mutation result: "${_exhaustiveCheck.operation}"`);
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes the caveat of the specified type from the permission corresponding
     * to the given subject origin and target name.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to remove.
     */
    removeCaveat(origin, target, caveatType) {
        this.update((draftState) => {
            var _a;
            const permission = (_a = draftState.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[target];
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            if (!permission.caveats) {
                throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
            }
            this.deleteCaveat(permission, caveatType, origin, target);
        });
    }
    /**
     * Deletes the specified caveat from the specified permission. If no caveats
     * remain after deletion, the permission's caveat property is set to `null`.
     * The permission is validated after being modified.
     *
     * Throws an error if the permission does not have a caveat with the specified
     * type.
     *
     * @param permission - The permission whose caveat to delete.
     * @param caveatType - The type of the caveat to delete.
     * @param origin - The origin the permission subject.
     * @param target - The name of the permission target.
     */
    deleteCaveat(permission, caveatType, origin, target) {
        /* istanbul ignore if: not possible in our usage */
        if (!permission.caveats) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveatType);
        if (caveatIndex === -1) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        if (permission.caveats.length === 1) {
            permission.caveats = null;
        }
        else {
            permission.caveats.splice(caveatIndex, 1);
        }
        this.validateModifiedPermission(permission, origin, target);
    }
    /**
     * Validates the specified modified permission. Should **always** be invoked
     * on a permission after its caveats have been modified.
     *
     * Just like {@link PermissionController.validatePermission}, except that the
     * corresponding target key and specification are retrieved first, and an
     * error is thrown if the target key does not exist.
     *
     * @param permission - The modified permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name name of the permission.
     */
    validateModifiedPermission(permission, origin, targetName) {
        const targetKey = this.getTargetKey(permission.parentCapability);
        /* istanbul ignore if: this should be impossible */
        if (!targetKey) {
            throw new Error(`Fatal: Existing permission target key "${targetKey}" has no specification.`);
        }
        this.validatePermission(this.getPermissionSpecification(targetKey), permission, origin, targetName);
    }
    /**
     * Gets the key for the specified permission target.
     *
     * Used to support our namespaced permission target feature, which is used
     * to implement namespaced restricted JSON-RPC methods.
     *
     * @param target - The requested permission target.
     * @returns The internal key of the permission target.
     */
    getTargetKey(target) {
        if (utils_1.hasProperty(this._permissionSpecifications, target)) {
            return target;
        }
        const namespacedTargetsWithoutWildcard = {};
        for (const targetKey of Object.keys(this._permissionSpecifications)) {
            const wildCardMatch = targetKey.match(/(.+)\*$/u);
            if (wildCardMatch) {
                namespacedTargetsWithoutWildcard[wildCardMatch[1]] = true;
            }
        }
        // Check for potentially nested namespaces:
        // Ex: wildzone_
        // Ex: eth_plugin_
        const segments = target.split('_');
        let targetKey = '';
        while (segments.length > 0 &&
            !utils_1.hasProperty(this._permissionSpecifications, targetKey) &&
            !namespacedTargetsWithoutWildcard[targetKey]) {
            targetKey += `${segments.shift()}_`;
        }
        if (namespacedTargetsWithoutWildcard[targetKey]) {
            return `${targetKey}*`;
        }
        return undefined;
    }
    /**
     * Grants _approved_ permissions to the specified subject. Every permission and
     * caveat is stringently validated – including by calling every specification
     * validator – and an error is thrown if any validation fails.
     *
     * **ATTN:** This method does **not** prompt the user for approval.
     *
     * @see {@link PermissionController.requestPermissions} For initiating a
     * permissions request requiring user approval.
     * @param options - Options bag.
     * @param options.approvedPermissions - The requested permissions approved by
     * the user.
     * @param options.requestData - Permission request data. Passed to permission
     * factory functions.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions.
     * @param options.subject - The subject to grant permissions to.
     * @returns The granted permissions.
     */
    grantPermissions({ approvedPermissions, requestData, preserveExistingPermissions = true, subject, }) {
        const { origin } = subject;
        if (!origin || typeof origin !== 'string') {
            throw new errors_1.InvalidSubjectIdentifierError(origin);
        }
        const permissions = (preserveExistingPermissions
            ? Object.assign({}, this.getPermissions(origin)) : {});
        for (const [requestedTarget, approvedPermission] of Object.entries(approvedPermissions)) {
            const targetKey = this.getTargetKey(requestedTarget);
            if (!targetKey) {
                throw errors_1.methodNotFound({ method: requestedTarget });
            }
            if (approvedPermission.parentCapability !== undefined &&
                requestedTarget !== approvedPermission.parentCapability) {
                throw new errors_1.InvalidApprovedPermissionError(origin, requestedTarget, approvedPermission);
            }
            // The requested target must be a valid target name if we found its key.
            // We reassign it to change its type.
            const targetName = requestedTarget;
            const specification = this.getPermissionSpecification(targetKey);
            // The requested caveats are validated here.
            const caveats = this.constructCaveats(origin, targetName, approvedPermission.caveats);
            const permissionOptions = {
                caveats,
                invoker: origin,
                target: targetName,
            };
            let permission;
            if (specification.factory) {
                permission = specification.factory(permissionOptions, requestData);
                // Full caveat and permission validation is performed here since the
                // factory function can arbitrarily modify the entire permission object,
                // including its caveats.
                this.validatePermission(specification, permission, origin, targetName);
            }
            else {
                permission = Permission_1.constructPermission(permissionOptions);
                // We do not need to validate caveats in this case, because the plain
                // permission constructor function does not modify the caveats, which
                // were already validated by `constructCaveats` above.
                this.validatePermission(specification, permission, origin, targetName, {
                    invokePermissionValidator: true,
                    performCaveatValidation: false,
                });
            }
            permissions[targetName] = permission;
        }
        this.setValidatedPermissions(origin, permissions);
        return permissions;
    }
    /**
     * Validates the specified permission by:
     * - Ensuring that its `caveats` property is either `null` or a non-empty
     *   array.
     * - Ensuring that it only includes caveats allowed by its specification.
     * - Ensuring that it includes no duplicate caveats (by caveat type).
     * - Validating each caveat object, if `performCaveatValidation` is `true`.
     * - Calling the validator of its specification, if one exists and
     *   `invokePermissionValidator` is `true`.
     *
     * An error is thrown if validation fails.
     *
     * @param specification - The specification of the permission.
     * @param permission - The permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name of the permission.
     * @param validationOptions - Validation options.
     * @param validationOptions.invokePermissionValidator - Whether to invoke the
     * permission's consumer-specified validator function, if any.
     * @param validationOptions.performCaveatValidation - Whether to invoke
     * {@link PermissionController.validateCaveat} on each of the permission's
     * caveats.
     */
    validatePermission(specification, permission, origin, targetName, { invokePermissionValidator, performCaveatValidation } = {
        invokePermissionValidator: true,
        performCaveatValidation: true,
    }) {
        const { allowedCaveats, validator } = specification;
        if (utils_1.hasProperty(permission, 'caveats')) {
            const { caveats } = permission;
            if (caveats !== null && !(Array.isArray(caveats) && caveats.length > 0)) {
                throw new errors_1.InvalidCaveatsPropertyError(origin, targetName, caveats);
            }
            const seenCaveatTypes = new Set();
            caveats === null || caveats === void 0 ? void 0 : caveats.forEach((caveat) => {
                if (performCaveatValidation) {
                    this.validateCaveat(caveat, origin, targetName);
                }
                if (!(allowedCaveats === null || allowedCaveats === void 0 ? void 0 : allowedCaveats.includes(caveat.type))) {
                    throw new errors_1.ForbiddenCaveatError(caveat.type, origin, targetName);
                }
                if (seenCaveatTypes.has(caveat.type)) {
                    throw new errors_1.DuplicateCaveatError(caveat.type, origin, targetName);
                }
                seenCaveatTypes.add(caveat.type);
            });
        }
        if (invokePermissionValidator && validator) {
            validator(permission, origin, targetName);
        }
    }
    /**
     * Assigns the specified permissions to the subject with the given origin.
     * Overwrites all existing permissions, and creates a subject entry if it
     * doesn't already exist.
     *
     * **ATTN:** Assumes that the new permissions have been validated.
     *
     * @param origin - The origin of the grantee subject.
     * @param permissions - The new permissions for the grantee subject.
     */
    setValidatedPermissions(origin, permissions) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                draftState.subjects[origin] = { origin, permissions: {} };
            }
            draftState.subjects[origin].permissions = immer_1.castDraft(permissions);
        });
    }
    /**
     * Validates the requested caveats for the permission of the specified
     * subject origin and target name and returns the validated caveat array.
     *
     * Throws an error if validation fails.
     *
     * @param origin - The origin of the permission subject.
     * @param target - The permission target name.
     * @param requestedCaveats - The requested caveats to construct.
     * @returns The constructed caveats.
     */
    constructCaveats(origin, target, requestedCaveats) {
        const caveatArray = requestedCaveats === null || requestedCaveats === void 0 ? void 0 : requestedCaveats.map((requestedCaveat) => {
            this.validateCaveat(requestedCaveat, origin, target);
            // Reassign so that we have a fresh object.
            const { type, value } = requestedCaveat;
            return { type, value };
        });
        return caveatArray && utils_1.isNonEmptyArray(caveatArray)
            ? caveatArray
            : undefined;
    }
    /**
     * This methods validates that the specified caveat is an object with the
     * expected properties and types. It also ensures that a caveat specification
     * exists for the requested caveat type, and calls the specification
     * validator, if it exists, on the caveat object.
     *
     * Throws an error if validation fails.
     *
     * @param caveat - The caveat object to validate.
     * @param origin - The origin associated with the subject of the parent
     * permission.
     * @param target - The target name associated with the parent permission.
     */
    validateCaveat(caveat, origin, target) {
        var _a;
        if (!utils_1.isPlainObject(caveat)) {
            throw new errors_1.InvalidCaveatError(caveat, origin, target);
        }
        if (Object.keys(caveat).length !== 2) {
            throw new errors_1.InvalidCaveatFieldsError(caveat, origin, target);
        }
        if (typeof caveat.type !== 'string') {
            throw new errors_1.InvalidCaveatTypeError(caveat, origin, target);
        }
        const specification = this.getCaveatSpecification(caveat.type);
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type, origin, target);
        }
        if (!utils_1.hasProperty(caveat, 'value') || caveat.value === undefined) {
            throw new errors_1.CaveatMissingValueError(caveat, origin, target);
        }
        if (!utils_1.isValidJson(caveat.value)) {
            throw new errors_1.CaveatInvalidJsonError(caveat, origin, target);
        }
        // Typecast: TypeScript still believes that the caveat is a PlainObject.
        (_a = specification.validator) === null || _a === void 0 ? void 0 : _a.call(specification, caveat, origin, target);
    }
    /**
     * Initiates a permission request that requires user approval. This should
     * always be used to grant additional permissions to a subject, unless user
     * approval has been obtained through some other means.
     *
     * Permissions are validated at every step of the approval process, and this
     * method will reject if validation fails.
     *
     * @see {@link ApprovalController} For the user approval logic.
     * @see {@link PermissionController.acceptPermissionsRequest} For the method
     * that _accepts_ the request and resolves the user approval promise.
     * @see {@link PermissionController.rejectPermissionsRequest} For the method
     * that _rejects_ the request and the user approval promise.
     * @param subject - The grantee subject.
     * @param requestedPermissions - The requested permissions.
     * @param options - Additional options.
     * @param options.id - The id of the permissions request. Defaults to a unique
     * id.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions. Defaults to `true`.
     * @returns The granted permissions and request metadata.
     */
    async requestPermissions(subject, requestedPermissions, options = {}) {
        const { origin } = subject;
        const { id = nanoid_1.nanoid(), preserveExistingPermissions = true } = options;
        this.validateRequestedPermissions(origin, requestedPermissions);
        const metadata = {
            id,
            origin,
        };
        const permissionsRequest = {
            metadata,
            permissions: requestedPermissions,
        };
        const _a = await this.requestUserApproval(permissionsRequest), { permissions: approvedPermissions } = _a, requestData = __rest(_a, ["permissions"]);
        return [
            this.grantPermissions({
                subject,
                approvedPermissions,
                preserveExistingPermissions,
                requestData,
            }),
            metadata,
        ];
    }
    /**
     * Validates requested permissions. Throws if validation fails.
     *
     * This method ensures that the requested permissions are a properly
     * formatted {@link RequestedPermissions} object, and performs the same
     * validation as {@link PermissionController.grantPermissions}, except that
     * consumer-specified permission validator functions are not called, since
     * they are only called on fully constructed, approved permissions that are
     * otherwise completely valid.
     *
     * Unrecognzied properties on requested permissions are ignored.
     *
     * @param origin - The origin of the grantee subject.
     * @param requestedPermissions - The requested permissions.
     */
    validateRequestedPermissions(origin, requestedPermissions) {
        if (!utils_1.isPlainObject(requestedPermissions)) {
            throw errors_1.invalidParams({
                message: `Requested permissions for origin "${origin}" is not a plain object.`,
                data: { origin, requestedPermissions },
            });
        }
        if (Object.keys(requestedPermissions).length === 0) {
            throw errors_1.invalidParams({
                message: `Permissions request for origin "${origin}" contains no permissions.`,
                data: { requestedPermissions },
            });
        }
        for (const targetName of Object.keys(requestedPermissions)) {
            const permission = requestedPermissions[targetName];
            const targetKey = this.getTargetKey(targetName);
            if (!targetKey) {
                throw errors_1.methodNotFound({
                    method: targetName,
                    data: { origin, requestedPermissions },
                });
            }
            if (!utils_1.isPlainObject(permission) ||
                (permission.parentCapability !== undefined &&
                    targetName !== permission.parentCapability)) {
                throw errors_1.invalidParams({
                    message: `Permissions request for origin "${origin}" contains invalid requested permission(s).`,
                    data: { origin, requestedPermissions },
                });
            }
            // Here we validate the permission without invoking its validator, if any.
            // The validator will be invoked after the permission has been approved.
            this.validatePermission(this.getPermissionSpecification(targetKey), 
            // Typecast: The permission is still a "PlainObject" here.
            permission, origin, targetName, { invokePermissionValidator: false, performCaveatValidation: true });
        }
    }
    /**
     * Adds a request to the {@link ApprovalController} using the
     * {@link AddApprovalRequest} action. Also validates the resulting approved
     * permissions request, and throws an error if validation fails.
     *
     * @param permissionsRequest - The permissions request object.
     * @returns The approved permissions request object.
     */
    async requestUserApproval(permissionsRequest) {
        const { origin, id } = permissionsRequest.metadata;
        const approvedRequest = await this.messagingSystem.call('ApprovalController:addRequest', {
            id,
            origin,
            requestData: permissionsRequest,
            type: utils_2.MethodNames.requestPermissions,
        }, true);
        this.validateApprovedPermissions(approvedRequest, { id, origin });
        return approvedRequest;
    }
    /**
     * Validates an approved {@link PermissionsRequest} object. The approved
     * request must have the required `metadata` and `permissions` properties,
     * the `id` and `origin` of the `metadata` must match the original request
     * metadata, and the requested permissions must be valid per
     * {@link PermissionController.validateRequestedPermissions}. Any extra
     * metadata properties are ignored.
     *
     * An error is thrown if validation fails.
     *
     * @param approvedRequest - The approved permissions request object.
     * @param originalMetadata - The original request metadata.
     */
    validateApprovedPermissions(approvedRequest, originalMetadata) {
        const { id, origin } = originalMetadata;
        if (!utils_1.isPlainObject(approvedRequest) ||
            !utils_1.isPlainObject(approvedRequest.metadata)) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" is invalid.`, { data: { approvedRequest } });
        }
        const { metadata: { id: newId, origin: newOrigin }, permissions, } = approvedRequest;
        if (newId !== id) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" mutated its id.`, { originalId: id, mutatedId: newId });
        }
        if (newOrigin !== origin) {
            throw errors_1.internalError(`Approved permissions request for subject "${origin}" mutated its origin.`, { originalOrigin: origin, mutatedOrigin: newOrigin });
        }
        try {
            this.validateRequestedPermissions(origin, permissions);
        }
        catch (error) {
            // Re-throw as an internal error; we should never receive invalid approved
            // permissions.
            throw errors_1.internalError(`Invalid approved permissions request: ${error.message}`, error.data);
        }
    }
    /**
     * Accepts a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param request - The permissions request.
     */
    async acceptPermissionsRequest(request) {
        const { id } = request.metadata;
        if (!this.hasApprovalRequest({ id })) {
            throw new errors_1.PermissionsRequestNotFoundError(id);
        }
        if (Object.keys(request.permissions).length === 0) {
            this._rejectPermissionsRequest(id, errors_1.invalidParams({
                message: 'Must request at least one permission.',
            }));
            return;
        }
        try {
            this.messagingSystem.call('ApprovalController:acceptRequest', id, request);
        }
        catch (error) {
            // If accepting unexpectedly fails, reject the request and re-throw the
            // error
            this._rejectPermissionsRequest(id, error);
            throw error;
        }
    }
    /**
     * Rejects a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param id - The id of the request to be rejected.
     */
    async rejectPermissionsRequest(id) {
        if (!this.hasApprovalRequest({ id })) {
            throw new errors_1.PermissionsRequestNotFoundError(id);
        }
        this._rejectPermissionsRequest(id, errors_1.userRejectedRequest());
    }
    /**
     * Checks whether the {@link ApprovalController} has a particular permissions
     * request.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param options - The {@link HasApprovalRequest} options.
     * @param options.id - The id of the approval request to check for.
     * @returns Whether the specified request exists.
     */
    hasApprovalRequest(options) {
        return this.messagingSystem.call('ApprovalController:hasRequest', 
        // Typecast: For some reason, the type here expects all of the possible
        // HasApprovalRequest options to be specified, when they're actually all
        // optional. Passing just the id is definitely valid, so we just cast it.
        options);
    }
    /**
     * Rejects the permissions request with the specified id, with the specified
     * error as the reason. This method is effectively a wrapper around a
     * messenger call for the `ApprovalController:rejectRequest` action.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param id - The id of the request to reject.
     * @param error - The error associated with the rejection.
     */
    _rejectPermissionsRequest(id, error) {
        return this.messagingSystem.call('ApprovalController:rejectRequest', id, error);
    }
    /**
     * Executes a restricted method as the subject with the given origin.
     * The specified params, if any, will be passed to the method implementation.
     *
     * **ATTN:** Great caution should be exercised in the use of this method.
     * Methods that cause side effects or affect application state should
     * be avoided.
     *
     * This method will first attempt to retrieve the requested restricted method
     * implementation, throwing if it does not exist. The method will then be
     * invoked as though the subject with the specified origin had invoked it with
     * the specified parameters. This means that any existing caveats will be
     * applied to the restricted method, and this method will throw if the
     * restricted method or its caveat decorators throw.
     *
     * In addition, this method will throw if the subject does not have a
     * permission for the specified restricted method.
     *
     * @param origin - The origin of the subject to execute the method on behalf
     * of.
     * @param targetName - The name of the method to execute. This must be a valid
     * permission target name.
     * @param params - The parameters to pass to the method implementation.
     * @returns The result of the executed method.
     */
    async executeRestrictedMethod(origin, targetName, params) {
        // Throws if the method does not exist
        const methodImplementation = this.getRestrictedMethod(targetName, origin);
        const result = await this._executeRestrictedMethod(methodImplementation, { origin }, targetName, params);
        if (result === undefined) {
            throw new Error(`Internal request for method "${targetName}" as origin "${origin}" returned no result.`);
        }
        return result;
    }
    /**
     * An internal method used in the controller's `json-rpc-engine` middleware
     * and {@link PermissionController.executeRestrictedMethod}. Calls the
     * specified restricted method implementation after decorating it with the
     * caveats of its permission. Throws if the subject does not have the
     * requisite permission.
     *
     * **ATTN:** Parameter validation is the responsibility of the caller, or
     * the restricted method implementation in the case of `params`.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for usage.
     * @param methodImplementation - The implementation of the method to call.
     * @param subject - Metadata about the subject that made the request.
     * @param req - The request object associated with the request.
     * @returns
     */
    _executeRestrictedMethod(methodImplementation, subject, method, params = []) {
        const { origin } = subject;
        const permission = this.getPermission(origin, method);
        if (!permission) {
            throw errors_1.unauthorized({ data: { origin, method } });
        }
        return Caveat_1.decorateWithCaveats(methodImplementation, permission, this._caveatSpecifications)({ method, params, context: { origin } });
    }
}
exports.PermissionController = PermissionController;
//# sourceMappingURL=PermissionController.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/PermissionController.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/index.js", {"./ComposedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ComposedStore.js","./MergedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/MergedStore.js","./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ObservableStore.js","./asStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/asStream.js","./transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js", {"./bc-ur-registry-eth.cjs.development.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js","./bc-ur-registry-eth.cjs.production.min.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./bc-ur-registry-eth.cjs.production.min.js')
} else {
  module.exports = require('./bc-ur-registry-eth.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq/bc-ur-registry-eth",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/index.js", {"./base-eth-keyring.cjs.development.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.development.js","./base-eth-keyring.cjs.production.min.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./base-eth-keyring.cjs.production.min.js')
} else {
  module.exports = require('./base-eth-keyring.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq/base-eth-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/middleware/pending.js", {"../util":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/util.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/middleware/pending.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPendingNonceMiddleware = createPendingNonceMiddleware;
exports.createPendingTxMiddleware = createPendingTxMiddleware;

var _jsonRpcEngine = require("json-rpc-engine");

var _util = require("../util");

function createPendingNonceMiddleware({
  getPendingNonce
}) {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    const {
      method,
      params
    } = req;

    if (method !== 'eth_getTransactionCount') {
      next();
      return;
    }

    const [param, blockRef] = params;

    if (blockRef !== 'pending') {
      next();
      return;
    }

    res.result = await getPendingNonce(param);
  });
}

function createPendingTxMiddleware({
  getPendingTransactionByHash
}) {
  return (0, _jsonRpcEngine.createAsyncMiddleware)(async (req, res, next) => {
    const {
      method,
      params
    } = req;

    if (method !== 'eth_getTransactionByHash') {
      next();
      return;
    }

    const [hash] = params;
    const txMeta = getPendingTransactionByHash(hash);

    if (!txMeta) {
      next();
      return;
    }

    res.result = (0, _util.formatTxMetaForRpcResult)(txMeta);
  });
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/middleware/pending.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/privateStore.js", {"./keyValueStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/keyValueStore.js","./utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/get":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/get.js","@babel/runtime/helpers/getPrototypeOf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/getPrototypeOf.js","@babel/runtime/helpers/inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/inherits.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/possibleConstructorReturn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/privateStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get3 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var utils = require('./utils/index');

var ENC_BLOCK_SIZE = 24;

var PrivateStore =
/*#__PURE__*/
function (_KeyValueStore) {
  (0, _inherits2["default"])(PrivateStore, _KeyValueStore);

  function PrivateStore(orbitdb, name, ensureConnected, _3id) {
    var _this;

    (0, _classCallCheck2["default"])(this, PrivateStore);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PrivateStore).call(this, orbitdb, name, ensureConnected, _3id));
    _this.keyring = _3id.getKeyringBySpaceName(name);
    _this._salt = _this.keyring.getDBSalt();
    return _this;
  }

  (0, _createClass2["default"])(PrivateStore, [{
    key: "get",
    value: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key) {
        var opts,
            entry,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "get", this).call(this, this._genDbKey(key), opts);

              case 3:
                entry = _context.sent;

                if (entry) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", null);

              case 6:
                if (!opts.metadata) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt("return", _objectSpread({}, entry, {
                  value: this._decryptEntry(entry.value)
                }));

              case 8:
                return _context.abrupt("return", this._decryptEntry(entry));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "getMetadata", this).call(this, this._genDbKey(key)));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, value) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                value = this._encryptEntry(value);
                key = this._genDbKey(key);
                return _context3.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "set", this).call(this, key, value));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(keys, values) {
        var dbKeys, encryptedValues;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                utils.throwIfNotEqualLenArrays(keys, values);
                dbKeys = keys.map(this._genDbKey, this);
                encryptedValues = values.map(this._encryptEntry, this);
                return _context4.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "setMultiple", this).call(this, dbKeys, encryptedValues));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setMultiple(_x5, _x6) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(key) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                key = this._genDbKey(key);
                return _context5.abrupt("return", (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "remove", this).call(this, key));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function remove(_x7) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.
     * Useful for generating a complete history of all operations on store. Key is hashed, so key is
     * not available from the private store.
     *
     *  @example
     *  const log = store.log
     *  const entry = log[0]
     *  console.log(entry)
     *  // { op: 'PUT', key: ...., value: 'Botbot', timeStamp: '1538575416068' }
     *
     * @return    {Array<Object>}     Array of ordered log entry objects
     */

  }, {
    key: "_genDbKey",
    value: function _genDbKey(key) {
      utils.throwIfUndefined(key, 'key');
      return utils.sha256Multihash(this._salt + key);
    }
  }, {
    key: "_encryptEntry",
    value: function _encryptEntry(entry) {
      if (typeof entry === 'undefined') throw new Error('Entry to encrypt cannot be undefined');
      return this.keyring.symEncrypt(this._pad(JSON.stringify(entry)));
    }
  }, {
    key: "_decryptEntry",
    value: function _decryptEntry(_ref) {
      var ciphertext = _ref.ciphertext,
          nonce = _ref.nonce;
      return JSON.parse(this._unpad(this.keyring.symDecrypt(ciphertext, nonce)));
    }
  }, {
    key: "_pad",
    value: function _pad(val) {
      var blockSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENC_BLOCK_SIZE;
      var blockDiff = (blockSize - val.length % blockSize) % blockSize;
      return "".concat(val).concat('\0'.repeat(blockDiff));
    }
  }, {
    key: "_unpad",
    value: function _unpad(padded) {
      return padded.replace(/\0+$/, '');
    }
  }, {
    key: "log",
    get: function get() {
      var _this2 = this;

      return (0, _get3["default"])((0, _getPrototypeOf2["default"])(PrivateStore.prototype), "log", this).map(function (obj) {
        return Object.assign(obj, {
          value: obj.value ? _this2._decryptEntry(obj.value) : null
        });
      });
    }
  }]);
  return PrivateStore;
}(KeyValueStore);

module.exports = PrivateStore;
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/privateStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/dist/store.legacy.js", {"../plugins/json2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/json2.js","../src/store-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/store-engine.js","../storages/all":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/all.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/dist/store.legacy.js
      return function (require, module, exports) {
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/dist/store.legacy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/space.js", {"./keyValueStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/keyValueStore.js","./thread":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/thread.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","orbit-db/src/orbit-db-address":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/orbit-db-address.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/space.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var Thread = require('./thread');

var _require = require('./utils'),
    sha256Multihash = _require.sha256Multihash,
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var OrbitDBAddress = require('orbit-db/src/orbit-db-address');

var ENC_BLOCK_SIZE = 24;

var nameToSpaceName = function nameToSpaceName(name) {
  return "3box.space.".concat(name, ".keyvalue");
};

var namesTothreadName = function namesTothreadName(spaceName, threadName) {
  return "3box.thread.".concat(spaceName, ".").concat(threadName);
};

var Space =
/*#__PURE__*/
function () {
  /**
   * Please use **box.openSpace** to get the instance of this class
   */
  function Space(name, threeId, orbitdb, rootStore, ensureConnected) {
    (0, _classCallCheck2["default"])(this, Space);
    this._name = name;
    this._3id = threeId;
    this._ensureConnected = ensureConnected;
    this._store = new KeyValueStore(orbitdb, nameToSpaceName(this._name), this._ensureConnected, this._3id);
    this._orbitdb = orbitdb;
    this._activeThreads = {};
    this._rootStore = rootStore;
    /**
     * @property {KeyValueStore} public         access the profile store of the space
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the space
     */

    this["private"] = null;
  }
  /**
   * @property {String} DID        the did of the user in this space
   */


  (0, _createClass2["default"])(Space, [{
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var _this = this;

        var opts,
            consentNeeded,
            spaceAddress,
            entries,
            entry,
            hasNumEntries,
            numEntries,
            syncSpace,
            _args2 = arguments;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

                if (this._store._db) {
                  _context2.next = 29;
                  break;
                }

                _context2.next = 4;
                return this._3id.initKeyringByName(this._name);

              case 4:
                consentNeeded = _context2.sent;
                if (opts.consentCallback) opts.consentCallback(consentNeeded, this._name);
                _context2.next = 8;
                return this._store._load();

              case 8:
                spaceAddress = _context2.sent;
                _context2.next = 11;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 11:
                entries = _context2.sent;
                entry = entries.find(function (entry) {
                  return entry.payload.value.odbAddress && entry.payload.value.odbAddress.indexOf(nameToSpaceName(_this._name)) !== -1;
                });

                if (entry) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 16;
                return this._rootStore.add({
                  type: 'space',
                  DID: this.DID,
                  odbAddress: spaceAddress
                });

              case 16:
                _context2.next = 23;
                break;

              case 18:
                if (entry.payload.value.type) {
                  _context2.next = 23;
                  break;
                }

                _context2.next = 21;
                return this._rootStore.del(entry.hash);

              case 21:
                _context2.next = 23;
                return this._rootStore.add({
                  type: 'space',
                  DID: this.DID,
                  odbAddress: spaceAddress
                });

              case 23:
                hasNumEntries = opts.numEntriesMessages && opts.numEntriesMessages[spaceAddress];
                numEntries = hasNumEntries ? opts.numEntriesMessages[spaceAddress].numEntries : undefined;

                syncSpace =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee() {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return _this._store._sync(numEntries);

                          case 2:
                            if (opts.onSyncDone) opts.onSyncDone();

                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function syncSpace() {
                    return _ref.apply(this, arguments);
                  };
                }();

                this._syncSpacePromise = syncSpace();
                this["public"] = publicStoreReducer(this._store);
                this["private"] = privateStoreReducer(this._store, this._3id.getKeyringBySpaceName(nameToSpaceName(this._name)));

              case 29:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function open() {
        return _open.apply(this, arguments);
      }

      return open;
    }()
    /**
     * Join a thread. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    name                    The name of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator
     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThread",
    value: function () {
      var _joinThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(name) {
        var opts,
            subscribeFn,
            thread,
            address,
            _args3 = arguments;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                if (!opts.firstModerator) opts.firstModerator = this._3id.getSubDID(this._name);
                thread = new Thread(this._orbitdb, namesTothreadName(this._name, name), this._3id, opts.members, opts.firstModerator, subscribeFn, this._ensureConnected);
                _context3.next = 6;
                return thread._getThreadAddress();

              case 6:
                address = _context3.sent;

                if (!this._activeThreads[address]) {
                  _context3.next = 9;
                  break;
                }

                return _context3.abrupt("return", this._activeThreads[address]);

              case 9:
                _context3.next = 11;
                return thread._load();

              case 11:
                this._activeThreads[address] = thread;
                return _context3.abrupt("return", thread);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function joinThread(_x) {
        return _joinThread.apply(this, arguments);
      }

      return joinThread;
    }()
    /**
     * Join a thread by full thread address. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    address                 The full address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThreadByAddress",
    value: function () {
      var _joinThreadByAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(address) {
        var opts,
            threadSpace,
            threadName,
            subscribeFn,
            thread,
            _args4 = arguments;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context4.next = 3;
                  break;
                }

                throw new Error('joinThreadByAddress: valid orbitdb address required');

              case 3:
                threadSpace = address.split('.')[2];
                threadName = address.split('.')[3];

                if (!(threadSpace !== this._name)) {
                  _context4.next = 7;
                  break;
                }

                throw new Error('joinThreadByAddress: attempting to open thread from different space, must open within same space');

              case 7:
                if (!this._activeThreads[address]) {
                  _context4.next = 9;
                  break;
                }

                return _context4.abrupt("return", this._activeThreads[address]);

              case 9:
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                thread = new Thread(this._orbitdb, namesTothreadName(this._name, threadName), this._3id, opts.members, opts.firstModerator, subscribeFn, this._ensureConnected);
                _context4.next = 13;
                return thread._load(address);

              case 13:
                this._activeThreads[address] = thread;
                return _context4.abrupt("return", thread);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function joinThreadByAddress(_x2) {
        return _joinThreadByAddress.apply(this, arguments);
      }

      return joinThreadByAddress;
    }()
    /**
     * Subscribe to the given thread, if not already subscribed
     *
     * @param     {String}    address                The address of the thread
     * @param     {Object}    config                configuration and thread meta data
     * @param     {String}    opts.name             Name of thread
     * @param     {String}    opts.firstModerator   DID of the first moderator
     * @param     {String}    opts.members          Boolean string, true if a members only thread
     */

  }, {
    key: "subscribeThread",
    value: function () {
      var _subscribeThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(address) {
        var config,
            threadKey,
            _args5 = arguments;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                config = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context5.next = 3;
                  break;
                }

                throw new Error('subscribeThread: must subscribe to valid thread/orbitdb address');

              case 3:
                threadKey = "thread-".concat(address);
                _context5.next = 6;
                return this._syncSpacePromise;

              case 6:
                _context5.next = 8;
                return this["public"].get(threadKey);

              case 8:
                if (_context5.sent) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 11;
                return this["public"].set(threadKey, Object.assign({}, config, {
                  address: address
                }));

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function subscribeThread(_x3) {
        return _subscribeThread.apply(this, arguments);
      }

      return subscribeThread;
    }()
    /**
     * Unsubscribe from the given thread, if subscribed
     *
     * @param     {String}    address     The address of the thread
     */

  }, {
    key: "unsubscribeThread",
    value: function () {
      var _unsubscribeThread = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(address) {
        var threadKey;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                threadKey = "thread-".concat(address);
                _context6.next = 3;
                return this["public"].get(threadKey);

              case 3:
                if (!_context6.sent) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 6;
                return this["public"].remove(threadKey);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function unsubscribeThread(_x4) {
        return _unsubscribeThread.apply(this, arguments);
      }

      return unsubscribeThread;
    }()
    /**
     * Get a list of all the threads subscribed to in this space
     *
     * @return    {Array<Objects>}    A list of thread objects as { address, firstModerator, members, name}
     */

  }, {
    key: "subscribedThreads",
    value: function () {
      var _subscribedThreads = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7() {
        var allEntries;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this["public"].all();

              case 2:
                allEntries = _context7.sent;
                return _context7.abrupt("return", Object.keys(allEntries).reduce(function (threads, key) {
                  if (key.startsWith('thread')) {
                    // ignores experimental threads (v1)
                    var address = key.split('thread-')[1];

                    if (OrbitDBAddress.isValid(address)) {
                      threads.push(allEntries[key]);
                    }
                  }

                  return threads;
                }, []));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function subscribedThreads() {
        return _subscribedThreads.apply(this, arguments);
      }

      return subscribedThreads;
    }()
  }, {
    key: "DID",
    get: function get() {
      return this._3id.getSubDID(this._name);
    }
  }]);
  return Space;
}();

module.exports = Space;

var publicStoreReducer = function publicStoreReducer(store) {
  var PREFIX = 'pub_';
  return {
    get: function () {
      var _get = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(key) {
        var opts,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                return _context8.abrupt("return", store.get(PREFIX + key, opts));

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function get(_x5) {
        return _get.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(key) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", store.getMetadata(PREFIX + key));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      function getMetadata(_x6) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(key, value) {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context10.abrupt("return", store.set(PREFIX + key, value));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));

      function set(_x7, _x8) {
        return _set.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(keys, values) {
        var prefixedKeys;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                prefixedKeys = keys.map(function (key) {
                  return PREFIX + key;
                });
                return _context11.abrupt("return", store.setMultiple(prefixedKeys, values));

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));

      function setMultiple(_x9, _x10) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(key) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context12.abrupt("return", store.remove(PREFIX + key));

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }));

      function remove(_x11) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }(),

    get log() {
      return store.log.reduce(function (newLog, entry) {
        if (entry.key.startsWith(PREFIX)) {
          entry.key = entry.key.slice(4);
          newLog.push(entry);
        }

        return newLog;
      }, []);
    },

    all: function () {
      var _all = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(opts) {
        var entries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return store.all(opts);

              case 2:
                entries = _context13.sent;
                return _context13.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    newAll[key.slice(4)] = entries[key];
                  }

                  return newAll;
                }, {}));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }));

      function all(_x12) {
        return _all.apply(this, arguments);
      }

      return all;
    }()
  };
};

var privateStoreReducer = function privateStoreReducer(store, keyring) {
  var PREFIX = 'priv_';
  var SALT = keyring.getDBSalt();

  var dbKey = function dbKey(key) {
    throwIfUndefined(key, 'key');
    return PREFIX + sha256Multihash(SALT + key);
  };

  var pad = function pad(val) {
    var blockSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ENC_BLOCK_SIZE;
    var blockDiff = (blockSize - val.length % blockSize) % blockSize;
    return "".concat(val).concat('\0'.repeat(blockDiff));
  };

  var unpad = function unpad(padded) {
    return padded.replace(/\0+$/, '');
  };

  var encryptEntry = function encryptEntry(entry) {
    return keyring.symEncrypt(pad(JSON.stringify(entry)));
  };

  var decryptEntry = function decryptEntry(_ref2) {
    var ciphertext = _ref2.ciphertext,
        nonce = _ref2.nonce;
    return JSON.parse(unpad(keyring.symDecrypt(ciphertext, nonce)));
  };

  return {
    get: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee14(key) {
        var opts,
            entry,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                _context14.next = 3;
                return store.get(dbKey(key), opts);

              case 3:
                entry = _context14.sent;

                if (entry) {
                  _context14.next = 6;
                  break;
                }

                return _context14.abrupt("return", null);

              case 6:
                if (!opts.metadata) {
                  _context14.next = 8;
                  break;
                }

                return _context14.abrupt("return", _objectSpread({}, entry, {
                  value: decryptEntry(entry.value).value
                }));

              case 8:
                return _context14.abrupt("return", decryptEntry(entry).value);

              case 9:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14);
      }));

      function get(_x13) {
        return _get2.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee15(key) {
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", store.getMetadata(dbKey(key)));

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      }));

      function getMetadata(_x14) {
        return _getMetadata2.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee16(key, value) {
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", store.set(dbKey(key), encryptEntry({
                  key: key,
                  value: value
                })));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      }));

      function set(_x15, _x16) {
        return _set2.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee17(keys, values) {
        var dbKeys, encryptedEntries;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                dbKeys = keys.map(dbKey);
                encryptedEntries = values.map(function (value, index) {
                  return encryptEntry({
                    key: keys[index],
                    value: value
                  });
                });
                return _context17.abrupt("return", store.setMultiple(dbKeys, encryptedEntries));

              case 4:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function setMultiple(_x17, _x18) {
        return _setMultiple2.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee18(key) {
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                return _context18.abrupt("return", store.remove(dbKey(key)));

              case 1:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function remove(_x19) {
        return _remove2.apply(this, arguments);
      }

      return remove;
    }(),

    get log() {
      return store.log.reduce(function (newLog, entry) {
        if (entry.key.startsWith(PREFIX)) {
          var decEntry = decryptEntry(entry.value);
          entry.key = decEntry.key;
          entry.value = decEntry.value;
          newLog.push(entry);
        }

        return newLog;
      }, []);
    },

    all: function () {
      var _all2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee19() {
        var opts,
            entries,
            _args19 = arguments;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                opts = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : {};
                _context19.next = 3;
                return store.all(opts);

              case 3:
                entries = _context19.sent;
                return _context19.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    var entry = entries[key];

                    if (opts.metadata) {
                      var decEntry = decryptEntry(entry.value);
                      newAll[decEntry.key] = _objectSpread({}, entry, {
                        value: decEntry.value
                      });
                    } else {
                      var _decEntry = decryptEntry(entry);

                      newAll[_decEntry.key] = _decEntry.value;
                    }
                  }

                  return newAll;
                }, {}));

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));

      function all() {
        return _all2.apply(this, arguments);
      }

      return all;
    }()
  };
};
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/space.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/api.js", {"./config.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js","./utils/id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/id.js","./utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","./utils/verifier":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/verifier.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","graphql-request":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/api.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var graphQLRequest = require('graphql-request').request;

var utils = require('./utils/index');

var verifier = require('./utils/verifier');

var _require = require('./utils/id'),
    isMuportDID = _require.isMuportDID;

var config = require('./config.js');

var GRAPHQL_SERVER_URL = config.graphql_server_url;
var PROFILE_SERVER_URL = config.profile_server_url;
var ADDRESS_SERVER_URL = config.address_server_url;

function getRootStoreAddress(_x) {
  return _getRootStoreAddress.apply(this, arguments);
}

function _getRootStoreAddress() {
  _getRootStoreAddress = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(identifier) {
    var serverUrl,
        res,
        _args = arguments;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            serverUrl = _args.length > 1 && _args[1] !== undefined ? _args[1] : ADDRESS_SERVER_URL;
            _context.next = 3;
            return utils.fetchJson(serverUrl + '/odbAddress/' + identifier);

          case 3:
            res = _context.sent;
            return _context.abrupt("return", res.data.rootStoreAddress);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getRootStoreAddress.apply(this, arguments);
}

function listSpaces(_x2) {
  return _listSpaces.apply(this, arguments);
}

function _listSpaces() {
  _listSpaces = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(address) {
    var serverUrl,
        _args2 = arguments;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            serverUrl = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : PROFILE_SERVER_URL;
            _context2.prev = 1;

            if (!isMuportDID(address)) {
              _context2.next = 8;
              break;
            }

            _context2.next = 5;
            return utils.fetchJson(serverUrl + '/list-spaces?did=' + encodeURIComponent(address));

          case 5:
            return _context2.abrupt("return", _context2.sent);

          case 8:
            _context2.next = 10;
            return utils.fetchJson(serverUrl + '/list-spaces?address=' + encodeURIComponent(address));

          case 10:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            _context2.next = 16;
            break;

          case 13:
            _context2.prev = 13;
            _context2.t0 = _context2["catch"](1);
            return _context2.abrupt("return", []);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 13]]);
  }));
  return _listSpaces.apply(this, arguments);
}

function getSpace(_x3, _x4) {
  return _getSpace.apply(this, arguments);
} // TODO consumes address now, could also give root DID to get space DID


function _getSpace() {
  _getSpace = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee3(address, name) {
    var serverUrl,
        _ref,
        metadata,
        blocklist,
        url,
        _args3 = arguments;

    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            serverUrl = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : PROFILE_SERVER_URL;
            _ref = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {}, metadata = _ref.metadata, blocklist = _ref.blocklist;

            if (!(blocklist && blocklist(address))) {
              _context3.next = 4;
              break;
            }

            throw new Error("user with ".concat(address, " is blocked"));

          case 4:
            url = "".concat(serverUrl, "/space");
            _context3.prev = 5;

            // Add first parameter: address or did
            if (isMuportDID(address)) {
              url = "".concat(url, "?did=").concat(encodeURIComponent(address));
            } else {
              url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
            } // Add name:


            url = "".concat(url, "&name=").concat(encodeURIComponent(name)); // Add metadata:

            if (metadata) {
              url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
            } // Query:
            // we await explicitly to make sure the error is catch'd in the correct scope


            _context3.next = 11;
            return utils.fetchJson(url);

          case 11:
            return _context3.abrupt("return", _context3.sent);

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3["catch"](5);
            return _context3.abrupt("return", {});

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 14]]);
  }));
  return _getSpace.apply(this, arguments);
}

function getSpaceDID(_x5, _x6) {
  return _getSpaceDID.apply(this, arguments);
}

function _getSpaceDID() {
  _getSpaceDID = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee4(address, space) {
    var opts,
        conf,
        _args4 = arguments;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
            _context4.next = 3;
            return getConfig(address, opts);

          case 3:
            conf = _context4.sent;

            if (!(!conf.spaces[space] || !conf.spaces[space].DID)) {
              _context4.next = 6;
              break;
            }

            throw new Error("Could not find appropriate DID for address ".concat(address));

          case 6:
            return _context4.abrupt("return", conf.spaces[space].DID);

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getSpaceDID.apply(this, arguments);
}

function getThread(_x7, _x8, _x9, _x10) {
  return _getThread.apply(this, arguments);
}

function _getThread() {
  _getThread = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee5(space, name, firstModerator, members) {
    var opts,
        serverUrl,
        url,
        _args5 = arguments;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            opts = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;

            if (!firstModerator.startsWith('0x')) {
              _context5.next = 6;
              break;
            }

            _context5.next = 5;
            return getSpaceDID(firstModerator, space, opts);

          case 5:
            firstModerator = _context5.sent;

          case 6:
            _context5.prev = 6;
            url = "".concat(serverUrl, "/thread?space=").concat(encodeURIComponent(space), "&name=").concat(encodeURIComponent(name));
            url += "&mod=".concat(encodeURIComponent(firstModerator), "&members=").concat(encodeURIComponent(members));
            _context5.next = 11;
            return utils.fetchJson(url);

          case 11:
            return _context5.abrupt("return", _context5.sent);

          case 14:
            _context5.prev = 14;
            _context5.t0 = _context5["catch"](6);
            throw new Error(_context5.t0);

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[6, 14]]);
  }));
  return _getThread.apply(this, arguments);
}

function getThreadByAddress(_x11) {
  return _getThreadByAddress.apply(this, arguments);
}

function _getThreadByAddress() {
  _getThreadByAddress = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee6(address) {
    var opts,
        serverUrl,
        _args6 = arguments;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;
            _context6.prev = 2;
            _context6.next = 5;
            return utils.fetchJson("".concat(serverUrl, "/thread?address=").concat(encodeURIComponent(address)));

          case 5:
            return _context6.abrupt("return", _context6.sent);

          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](2);
            throw new Error(_context6.t0);

          case 11:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[2, 8]]);
  }));
  return _getThreadByAddress.apply(this, arguments);
}

function getConfig(_x12) {
  return _getConfig.apply(this, arguments);
}

function _getConfig() {
  _getConfig = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee7(address) {
    var opts,
        serverUrl,
        _args7 = arguments;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
            serverUrl = opts.profileServer || PROFILE_SERVER_URL;
            _context7.prev = 2;
            _context7.next = 5;
            return utils.fetchJson("".concat(serverUrl, "/config?address=").concat(encodeURIComponent(address)));

          case 5:
            return _context7.abrupt("return", _context7.sent);

          case 8:
            _context7.prev = 8;
            _context7.t0 = _context7["catch"](2);
            throw new Error(_context7.t0);

          case 11:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, null, [[2, 8]]);
  }));
  return _getConfig.apply(this, arguments);
}

function getProfile(_x13) {
  return _getProfile.apply(this, arguments);
}

function _getProfile() {
  _getProfile = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee8(address) {
    var serverUrl,
        _ref2,
        metadata,
        blocklist,
        url,
        _args8 = arguments;

    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            serverUrl = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : PROFILE_SERVER_URL;
            _ref2 = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {}, metadata = _ref2.metadata, blocklist = _ref2.blocklist;

            if (!(blocklist && blocklist(address))) {
              _context8.next = 4;
              break;
            }

            throw new Error("user with ".concat(address, " is blocked"));

          case 4:
            url = "".concat(serverUrl, "/profile");
            _context8.prev = 5;

            // Add first parameter: address or did
            if (isMuportDID(address)) {
              url = "".concat(url, "?did=").concat(encodeURIComponent(address));
            } else {
              url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
            } // Add metadata:


            if (metadata) {
              url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
            } // Query:
            // we await explicitly to make sure the error is catch'd in the correct scope


            _context8.next = 10;
            return utils.fetchJson(url);

          case 10:
            return _context8.abrupt("return", _context8.sent);

          case 13:
            _context8.prev = 13;
            _context8.t0 = _context8["catch"](5);
            return _context8.abrupt("return", {});

          case 16:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[5, 13]]);
  }));
  return _getProfile.apply(this, arguments);
}

function getProfiles(_x14) {
  return _getProfiles.apply(this, arguments);
}

function _getProfiles() {
  _getProfiles = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee9(addressArray) {
    var opts,
        req,
        url,
        _args9 = arguments;
    return _regenerator["default"].wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            opts = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
            opts = Object.assign({
              profileServer: PROFILE_SERVER_URL
            }, opts);
            req = {
              addressList: [],
              didList: [] // Split addresses on ethereum / dids

            };
            addressArray.forEach(function (address) {
              if (isMuportDID(address)) {
                req.didList.push(address);
              } else {
                req.addressList.push(address);
              }
            });
            url = "".concat(opts.profileServer, "/profileList");
            return _context9.abrupt("return", utils.fetchJson(url, req));

          case 6:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _getProfiles.apply(this, arguments);
}

function profileGraphQL(_x15) {
  return _profileGraphQL.apply(this, arguments);
}

function _profileGraphQL() {
  _profileGraphQL = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee10(query) {
    var opts,
        _args10 = arguments;
    return _regenerator["default"].wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
            opts = Object.assign({
              graphqlServer: GRAPHQL_SERVER_URL
            }, opts);
            return _context10.abrupt("return", graphQLRequest(opts.graphqlServer, query));

          case 3:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _profileGraphQL.apply(this, arguments);
}

function getVerifiedAccounts(_x16) {
  return _getVerifiedAccounts.apply(this, arguments);
}

function _getVerifiedAccounts() {
  _getVerifiedAccounts = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee11(profile) {
    var verifs, did;
    return _regenerator["default"].wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            verifs = {};
            _context11.prev = 1;
            _context11.next = 4;
            return verifier.verifyDID(profile.proof_did);

          case 4:
            did = _context11.sent;
            verifs.did = did;

            if (!profile.proof_github) {
              _context11.next = 15;
              break;
            }

            _context11.prev = 7;
            _context11.next = 10;
            return verifier.verifyGithub(did, profile.proof_github);

          case 10:
            verifs.github = _context11.sent;
            _context11.next = 15;
            break;

          case 13:
            _context11.prev = 13;
            _context11.t0 = _context11["catch"](7);

          case 15:
            if (!profile.proof_twitter) {
              _context11.next = 24;
              break;
            }

            _context11.prev = 16;
            _context11.next = 19;
            return verifier.verifyTwitter(did, profile.proof_twitter);

          case 19:
            verifs.twitter = _context11.sent;
            _context11.next = 24;
            break;

          case 22:
            _context11.prev = 22;
            _context11.t1 = _context11["catch"](16);

          case 24:
            if (!profile.ethereum_proof) {
              _context11.next = 33;
              break;
            }

            _context11.prev = 25;
            _context11.next = 28;
            return verifier.verifyEthereum(profile.ethereum_proof, did);

          case 28:
            verifs.ethereum = _context11.sent;
            _context11.next = 33;
            break;

          case 31:
            _context11.prev = 31;
            _context11.t2 = _context11["catch"](25);

          case 33:
            _context11.next = 37;
            break;

          case 35:
            _context11.prev = 35;
            _context11.t3 = _context11["catch"](1);

          case 37:
            return _context11.abrupt("return", verifs);

          case 38:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, null, [[1, 35], [7, 13], [16, 22], [25, 31]]);
  }));
  return _getVerifiedAccounts.apply(this, arguments);
}

module.exports = {
  profileGraphQL: profileGraphQL,
  getProfile: getProfile,
  getSpace: getSpace,
  listSpaces: listSpaces,
  getThread: getThread,
  getThreadByAddress: getThreadByAddress,
  getConfig: getConfig,
  getRootStoreAddress: getRootStoreAddress,
  getProfiles: getProfiles,
  getVerifiedAccounts: getVerifiedAccounts,
  getSpaceDID: getSpaceDID
};
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/api.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js","js-sha256":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha256/src/sha256.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","node-fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/node-fetch/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var fetch = typeof window !== 'undefined' ? window.fetch : require('node-fetch');

var Multihash = require('multihashes');

var sha256 = require('js-sha256').sha256;

var ethers = require('ethers');

var HTTPError = function HTTPError(status, message) {
  var e = new Error(message);
  e.statusCode = status;
  return e;
};

var getMessageConsent = function getMessageConsent(did, timestamp) {
  var msg = 'Create a new 3Box profile' + '\n\n' + '- \n' + 'Your unique profile ID is ' + did;
  if (timestamp) msg += ' \n' + 'Timestamp: ' + timestamp;
  return msg;
};

var safeEthSend = function safeEthSend(ethereum, data, callback) {
  var send = (Boolean(ethereum.sendAsync) ? ethereum.sendAsync : ethereum.send).bind(ethereum);
  return new Promise(function (resolve, reject) {
    send(data, function (err, result) {
      if (err) reject(err);
      if (result.error) reject(result.error);
      resolve(result.result);
    });
  });
};

module.exports = {
  getMessageConsent: getMessageConsent,
  recoverPersonalSign: function () {
    var _recoverPersonalSign = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(msg, personalSig) {
      var msgParams;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!msg || !personalSig)) {
                _context.next = 2;
                break;
              }

              throw new Error('recoverPersonalSign: missing arguments, msg and/or personalSig');

            case 2:
              msgParams = {
                data: msg,
                sig: personalSig
              };
              return _context.abrupt("return", ethers.utils.verifyMessage(msg, personalSig));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function recoverPersonalSign(_x, _x2) {
      return _recoverPersonalSign.apply(this, arguments);
    }

    return recoverPersonalSign;
  }(),
  openBoxConsent: function openBoxConsent(fromAddress, ethereum) {
    var text = 'This app wants to view and update your 3Box profile.';
    var msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
    var params = [msg, fromAddress];
    var method = 'personal_sign';
    return safeEthSend(ethereum, {
      jsonrpc: '2.0',
      id: 0,
      method: method,
      params: params,
      fromAddress: fromAddress
    });
  },
  openSpaceConsent: function openSpaceConsent(fromAddress, ethereum, name) {
    var text = "Allow this app to open your ".concat(name, " space.");
    var msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
    var params = [msg, fromAddress];
    var method = 'personal_sign';
    return safeEthSend(ethereum, {
      jsonrpc: '2.0',
      id: 0,
      method: method,
      params: params,
      fromAddress: fromAddress
    });
  },
  getLinkConsent: function () {
    var _getLinkConsent = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(fromAddress, toDID, ethereum) {
      var timestamp, text, msg, params, method, sig;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              timestamp = Math.floor(new Date().getTime() / 1000);
              text = getMessageConsent(toDID, timestamp);
              msg = '0x' + Buffer.from(text, 'utf8').toString('hex');
              params = [msg, fromAddress];
              method = 'personal_sign';
              _context2.next = 7;
              return safeEthSend(ethereum, {
                jsonrpc: '2.0',
                id: 0,
                method: method,
                params: params,
                fromAddress: fromAddress
              });

            case 7:
              sig = _context2.sent;
              return _context2.abrupt("return", {
                msg: text,
                sig: sig,
                timestamp: timestamp
              });

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function getLinkConsent(_x3, _x4, _x5) {
      return _getLinkConsent.apply(this, arguments);
    }

    return getLinkConsent;
  }(),
  fetchJson: function () {
    var _fetchJson = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(url, body) {
      var opts, r;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (body) {
                opts = {
                  body: JSON.stringify(body),
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  }
                };
              }

              _context3.next = 3;
              return fetch(url, opts);

            case 3:
              r = _context3.sent;

              if (!r.ok) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", r.json());

            case 8:
              throw HTTPError(r.status, "Invalid response (".concat(r.status, ") for query at ").concat(url));

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function fetchJson(_x6, _x7) {
      return _fetchJson.apply(this, arguments);
    }

    return fetchJson;
  }(),
  fetchText: function () {
    var _fetchText = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(url, opts) {
      var r;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return fetch(url, opts);

            case 2:
              r = _context4.sent;

              if (!r.ok) {
                _context4.next = 7;
                break;
              }

              return _context4.abrupt("return", r.text());

            case 7:
              throw HTTPError(r.status, "Invalid response (".concat(r.status, ") for query at ").concat(url));

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function fetchText(_x8, _x9) {
      return _fetchText.apply(this, arguments);
    }

    return fetchText;
  }(),
  throwIfUndefined: function throwIfUndefined(arg, name) {
    if (arg === undefined || arg === null) {
      throw new Error("".concat(name, " is a required argument"));
    }
  },
  throwIfNotEqualLenArrays: function throwIfNotEqualLenArrays(arr1, arr2) {
    if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
      throw new Error('One or more arguments are not an array');
    }

    if (arr1.length !== arr2.length) {
      throw new Error('Arrays must be of the same length');
    }
  },
  sha256Multihash: function sha256Multihash(str) {
    var digest = Buffer.from(sha256.digest(str));
    return Multihash.encode(digest, 'sha2-256').toString('hex');
  },
  sha256: sha256
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/index.js", {"./src/ipfs-pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/src/ipfs-pubsub.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/index.js
      return function (require, module, exports) {
module.exports = require('./src/ipfs-pubsub')

      };
    };
  }
}, {package:"orbit-db-pubsub",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js","ipfs-log":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-log/src/log.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js
      return function (require, module, exports) {
(function (process){(function (){
"use strict";

var Log = require('ipfs-log');

var IFRAME_STORE_VERSION = '0.0.3';
module.exports = {
  address_server_url: process.env.ADDRESS_SERVER_URL || 'https://beta.3box.io/address-server',
  pinning_node: process.env.PINNING_NODE || '/dnsaddr/ipfs.3box.io/tcp/443/wss/ipfs/QmZvxEpiVNjmNbEKyQGvFzAY1BwmGuuvdUTmcTstQPhyVC',
  pinning_room: process.env.PINNING_ROOM || '3box-pinning',
  iframe_store_version: process.env.IFRAME_STORE_VERSION || IFRAME_STORE_VERSION,
  iframe_store_url: process.env.IFRAME_STORE_URL || "https://iframe.3box.io/".concat(IFRAME_STORE_VERSION, "/iframe.html"),
  ipfs_options: {
    EXPERIMENTAL: {
      pubsub: true
    },
    preload: {
      enabled: false
    },
    config: {
      Bootstrap: []
    }
  },
  orbitdb_options: {
    syncLocal: true,
    sortFn: Log.Sorting.SortByEntryHash // this option is required now but will likely not be in the future.

  },
  graphql_server_url: process.env.GRAPHQL_SERVER_URL || 'https://api.3box.io/graph/',
  profile_server_url: process.env.PROFILE_SERVER_URL || 'https://ipfs.3box.io',
  muport_ipfs_host: process.env.MUPORT_IPFS_HOST || 'ipfs.infura.io',
  muport_ipfs_port: process.env.MUPORT_IPFS_PORT || 5001,
  muport_ipfs_protocol: process.env.MUPORT_IPFS_PROTOCOL || 'https'
};
}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/index.js", {"../config.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js","../utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","./keyring":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/keyring.js","3box-orbitdb-plugins":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/index.js","3id-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3id-resolver/lib/register.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","did-jwt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js","ipfs-did-document":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-did-document/index.js","ipfs-mini":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-mini/src/index.js","orbit-db-identity-provider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/index.js","store":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/dist/store.legacy.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var didJWT = require('did-jwt');

var DidDocument = require('ipfs-did-document');

var IpfsMini = require('ipfs-mini');

var localstorage = require('store');

var Identities = require('orbit-db-identity-provider');

var _require = require('3box-orbitdb-plugins'),
    OdbIdentityProvider = _require.OdbIdentityProvider;

Identities.addIdentityProvider(OdbIdentityProvider);

var registerResolver = require('3id-resolver');

var utils = require('../utils/index');

var Keyring = require('./keyring');

var config = require('../config.js');

var DID_METHOD_NAME = '3';
var STORAGE_KEY = 'serialized3id_';
var MUPORT_IPFS = {
  host: config.muport_ipfs_host,
  port: config.muport_ipfs_port,
  protocol: config.muport_ipfs_protocol
};

var ThreeId =
/*#__PURE__*/
function () {
  function ThreeId(serializeState, ethereum, ipfs, opts) {
    (0, _classCallCheck2["default"])(this, ThreeId);
    this._ethereum = ethereum;
    this._ipfs = ipfs;
    this._keyrings = {};

    this._initKeys(serializeState, opts);

    registerResolver(ipfs);
    localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
  }

  (0, _createClass2["default"])(ThreeId, [{
    key: "signJWT",
    value: function () {
      var _signJWT = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(payload) {
        var _ref,
            use3ID,
            space,
            expiresIn,
            keyring,
            issuer,
            settings,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, use3ID = _ref.use3ID, space = _ref.space, expiresIn = _ref.expiresIn;
                keyring = space ? this._keyrings[space] : this._mainKeyring;
                issuer = this.muportDID;

                if (use3ID) {
                  issuer = this.DID;
                } else if (space) {
                  issuer = this._subDIDs[space];
                }

                settings = {
                  signer: keyring.getJWTSigner(),
                  issuer: issuer,
                  expiresIn: expiresIn
                };
                return _context.abrupt("return", didJWT.createJWT(payload, settings));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signJWT(_x) {
        return _signJWT.apply(this, arguments);
      }

      return signJWT;
    }()
  }, {
    key: "getSubDID",
    value: function getSubDID(space) {
      return this._subDIDs[space];
    }
  }, {
    key: "getOdbId",
    value: function () {
      var _getOdbId = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(space) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", Identities.createIdentity({
                  type: '3ID',
                  threeId: this,
                  space: space
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getOdbId(_x2) {
        return _getOdbId.apply(this, arguments);
      }

      return getOdbId;
    }()
  }, {
    key: "serializeState",
    value: function serializeState() {
      var _this = this;

      var stateObj = {
        managementAddress: this.managementAddress,
        seed: this._mainKeyring.serialize(),
        spaceSeeds: {}
      };
      Object.keys(this._keyrings).map(function (name) {
        stateObj.spaceSeeds[name] = _this._keyrings[name].serialize();
      });
      return JSON.stringify(stateObj);
    }
  }, {
    key: "_initKeys",
    value: function _initKeys(serializeState) {
      var _this2 = this;

      var state = JSON.parse(serializeState); // TODO remove toLowerCase() in future, should be sanitized elsewhere
      //      this forces existing state to correct state so that address <->
      //      rootstore relation holds

      this.managementAddress = state.managementAddress.toLowerCase();
      this._mainKeyring = new Keyring(state.seed);
      Object.keys(state.spaceSeeds).map(function (name) {
        _this2._keyrings[name] = new Keyring(state.spaceSeeds[name]);
      });
    }
  }, {
    key: "_initDID",
    value: function () {
      var _initDID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(muportIpfs) {
        var _this3 = this;

        var muportPromise, spaces, subDIDs;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                muportPromise = this._initMuport(muportIpfs);
                _context3.next = 3;
                return this._init3ID();

              case 3:
                this._rootDID = _context3.sent;
                spaces = Object.keys(this._keyrings);
                _context3.next = 7;
                return Promise.all(spaces.map(function (space) {
                  return _this3._init3ID(space);
                }));

              case 7:
                subDIDs = _context3.sent;
                this._subDIDs = {};
                spaces.map(function (space, i) {
                  _this3._subDIDs[space] = subDIDs[i];
                });
                _context3.next = 12;
                return muportPromise;

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _initDID(_x3) {
        return _initDID2.apply(this, arguments);
      }

      return _initDID;
    }()
  }, {
    key: "_init3ID",
    value: function () {
      var _init3ID2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(spaceName) {
        var doc, pubkeys, _pubkeys, payload, signature;

        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                doc = new DidDocument(this._ipfs, DID_METHOD_NAME);

                if (spaceName) {
                  _context4.next = 9;
                  break;
                }

                pubkeys = this._mainKeyring.getPublicKeys(true);
                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', this.managementAddress);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');
                _context4.next = 20;
                break;

              case 9:
                _pubkeys = this._keyrings[spaceName].getPublicKeys(true);
                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', _pubkeys.signingKey);
                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', _pubkeys.asymEncryptionKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');
                doc.addCustomProperty('space', spaceName);
                doc.addCustomProperty('root', this.DID);
                payload = {
                  subSigningKey: _pubkeys.signingKey,
                  subEncryptionKey: _pubkeys.asymEncryptionKey,
                  space: spaceName,
                  iat: null
                };
                _context4.next = 18;
                return this.signJWT(payload, {
                  use3ID: true
                });

              case 18:
                signature = _context4.sent.split('.')[2];
                doc.addCustomProperty('proof', {
                  alg: 'ES256K',
                  signature: signature
                });

              case 20:
                _context4.next = 22;
                return doc.commit({
                  noTimestamp: true
                });

              case 22:
                return _context4.abrupt("return", doc.DID);

              case 23:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _init3ID(_x4) {
        return _init3ID2.apply(this, arguments);
      }

      return _init3ID;
    }()
  }, {
    key: "_initMuport",
    value: function () {
      var _initMuport2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(muportIpfs) {
        var keys, doc, docHash, publishToInfura;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                keys = this._mainKeyring.getPublicKeys();
                doc = createMuportDocument(keys.signingKey, this.managementAddress, keys.asymEncryptionKey);
                _context6.next = 4;
                return this._ipfs.add(Buffer.from(JSON.stringify(doc)));

              case 4:
                docHash = _context6.sent[0].hash;
                this._muportDID = 'did:muport:' + docHash;
                this.muportFingerprint = utils.sha256Multihash(this.muportDID);

                publishToInfura =
                /*#__PURE__*/
                function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee5() {
                    var ipfsMini;
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            ipfsMini = new IpfsMini(muportIpfs);
                            ipfsMini.addJSON(doc, function (err, res) {
                              if (err) console.error(err);
                            });

                          case 2:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function publishToInfura() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                publishToInfura();

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _initMuport(_x5) {
        return _initMuport2.apply(this, arguments);
      }

      return _initMuport;
    }()
  }, {
    key: "getKeyringBySpaceName",
    value: function getKeyringBySpaceName(name) {
      var split = name.split('.');

      if (split[0] === this.muportFingerprint) {
        return this._mainKeyring;
      } else {
        return this._keyrings[split[2]];
      }
    }
  }, {
    key: "initKeyringByName",
    value: function () {
      var _initKeyringByName = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(name) {
        var sig, entropy, seed;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._keyrings[name]) {
                  _context7.next = 14;
                  break;
                }

                _context7.next = 3;
                return utils.openSpaceConsent(this.managementAddress, this._ethereum, name);

              case 3:
                sig = _context7.sent;
                entropy = '0x' + utils.sha256(sig.slice(2));
                seed = HDNode.mnemonicToSeed(HDNode.entropyToMnemonic(entropy));
                this._keyrings[name] = new Keyring(seed);
                _context7.next = 9;
                return this._init3ID(name);

              case 9:
                this._subDIDs[name] = _context7.sent;
                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
                return _context7.abrupt("return", true);

              case 14:
                return _context7.abrupt("return", false);

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function initKeyringByName(_x6) {
        return _initKeyringByName.apply(this, arguments);
      }

      return initKeyringByName;
    }()
  }, {
    key: "logout",
    value: function logout() {
      localstorage.remove(STORAGE_KEY + this.managementAddress);
    }
  }, {
    key: "DID",
    get: function get() {
      return this._rootDID;
    }
  }, {
    key: "muportDID",
    get: function get() {
      return this._muportDID;
    }
  }], [{
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));
    }
  }, {
    key: "getIdFromEthAddress",
    value: function () {
      var _getIdFromEthAddress = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(address, ethereum, ipfs) {
        var opts,
            normalizedAddress,
            serialized3id,
            sig,
            entropy,
            mnemonic,
            seed,
            _3id,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {};
                normalizedAddress = address.toLowerCase();
                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);

                if (!serialized3id) {
                  _context8.next = 7;
                  break;
                }

                if (opts.consentCallback) opts.consentCallback(false);
                _context8.next = 19;
                break;

              case 7:
                if (!opts.contentSignature) {
                  _context8.next = 11;
                  break;
                }

                sig = opts.contentSignature;
                _context8.next = 14;
                break;

              case 11:
                _context8.next = 13;
                return utils.openBoxConsent(normalizedAddress, ethereum);

              case 13:
                sig = _context8.sent;

              case 14:
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = HDNode.entropyToMnemonic(entropy);
                seed = HDNode.mnemonicToSeed(mnemonic);
                serialized3id = JSON.stringify({
                  managementAddress: normalizedAddress,
                  seed: seed,
                  spaceSeeds: {}
                });

              case 19:
                _3id = new ThreeId(serialized3id, ethereum, ipfs, opts);
                _context8.next = 22;
                return _3id._initDID(opts.muportIpfs || MUPORT_IPFS);

              case 22:
                return _context8.abrupt("return", _3id);

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function getIdFromEthAddress(_x7, _x8, _x9) {
        return _getIdFromEthAddress.apply(this, arguments);
      }

      return getIdFromEthAddress;
    }()
  }]);
  return ThreeId;
}();

var createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {
  return {
    version: 1,
    signingKey: signingKey,
    managementKey: managementKey,
    asymEncryptionKey: asymEncryptionKey
  };
};

module.exports = ThreeId;
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/3id/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/verified.js", {"./utils/verifier":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/verifier.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/verified.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var verifier = require('./utils/verifier');

var Verified =
/*#__PURE__*/
function () {
  /**
   * Please use **box.verified** to get the instance of this class
   */
  function Verified(box) {
    (0, _classCallCheck2["default"])(this, Verified);
    this._box = box;
    this._did = box._3id.muportDID;
  }

  (0, _createClass2["default"])(Verified, [{
    key: "_addVerifiedPublicAccount",
    value: function () {
      var _addVerifiedPublicAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key, proof, verificationFunction) {
        var account;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return verificationFunction(this._did, proof);

              case 2:
                account = _context.sent;
                _context.next = 5;
                return this._box["public"].set('proof_' + key, proof);

              case 5:
                return _context.abrupt("return", account);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _addVerifiedPublicAccount(_x, _x2, _x3) {
        return _addVerifiedPublicAccount2.apply(this, arguments);
      }

      return _addVerifiedPublicAccount;
    }()
  }, {
    key: "_getVerifiedPublicAccount",
    value: function () {
      var _getVerifiedPublicAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key, verificationFunction) {
        var proof;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._box["public"].get('proof_' + key);

              case 2:
                proof = _context2.sent;
                return _context2.abrupt("return", verificationFunction(this._did, proof));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getVerifiedPublicAccount(_x4, _x5) {
        return _getVerifiedPublicAccount2.apply(this, arguments);
      }

      return _getVerifiedPublicAccount;
    }()
  }, {
    key: "_addVerifiedPrivateAccount",
    value: function () {
      var _addVerifiedPrivateAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, proof, verificationFunction) {
        var account;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return verificationFunction(this._did, proof);

              case 2:
                account = _context3.sent;
                _context3.next = 5;
                return this._box["private"].set('proof_' + key, proof);

              case 5:
                return _context3.abrupt("return", account);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _addVerifiedPrivateAccount(_x6, _x7, _x8) {
        return _addVerifiedPrivateAccount2.apply(this, arguments);
      }

      return _addVerifiedPrivateAccount;
    }()
  }, {
    key: "_getVerifiedPrivateAccount",
    value: function () {
      var _getVerifiedPrivateAccount2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4(key, verificationFunction) {
        var proof;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._box["private"].get('proof_' + key);

              case 2:
                proof = _context4.sent;
                return _context4.abrupt("return", verificationFunction(this._did, proof));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getVerifiedPrivateAccount(_x9, _x10) {
        return _getVerifiedPrivateAccount2.apply(this, arguments);
      }

      return _getVerifiedPrivateAccount;
    }()
    /**
     * Returns the verified DID of the user
     *
     * @return    {String}                            The DID of the user
     */

  }, {
    key: "DID",
    value: function () {
      var _DID = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5() {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this._did);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function DID() {
        return _DID.apply(this, arguments);
      }

      return DID;
    }()
    /**
     * Verifies that the user has a valid github account
     * Throws an error otherwise.
     *
     * @return    {Object}                            Object containing username, and proof
     */

  }, {
    key: "github",
    value: function () {
      var _github = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this._getVerifiedPublicAccount('github', verifier.verifyGithub));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function github() {
        return _github.apply(this, arguments);
      }

      return github;
    }()
    /**
     * Adds a github verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {Object}            gistUrl         URL of the proof
     * @return    {Object}                            Object containing username, and proof
     */

  }, {
    key: "addGithub",
    value: function () {
      var _addGithub = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(gistUrl) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this._addVerifiedPublicAccount('github', gistUrl, verifier.verifyGithub));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function addGithub(_x11) {
        return _addGithub.apply(this, arguments);
      }

      return addGithub;
    }()
    /**
     * Verifies that the user has a valid twitter account
     * Throws an error otherwise.
     *
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "twitter",
    value: function () {
      var _twitter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this._getVerifiedPublicAccount('twitter', verifier.verifyTwitter));

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function twitter() {
        return _twitter.apply(this, arguments);
      }

      return twitter;
    }()
    /**
     * Adds a twitter verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {String}            claim           A did-JWT claim ownership of a twitter username
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "addTwitter",
    value: function () {
      var _addTwitter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(claim) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", this._addVerifiedPublicAccount('twitter', claim, verifier.verifyTwitter));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function addTwitter(_x12) {
        return _addTwitter.apply(this, arguments);
      }

      return addTwitter;
    }()
    /**
    * Verifies that the user has a verified email account
    * Throws an error otherwise.
    *
    * @return    {Object}                            Object containing username, proof, and the verifier
    */

  }, {
    key: "email",
    value: function () {
      var _email = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10() {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this._getVerifiedPrivateAccount('email', verifier.verifyEmail));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function email() {
        return _email.apply(this, arguments);
      }

      return email;
    }()
    /**
     * Adds an email verification to the users profile
     * Throws an error if the verification fails.
     *
     * @param     {String}            claim           A did-JWT claim ownership of an email username
     * @return    {Object}                            Object containing username, proof, and the verifier
     */

  }, {
    key: "addEmail",
    value: function () {
      var _addEmail = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(claim) {
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", this._addVerifiedPrivateAccount('email', claim, verifier.verifyEmail));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function addEmail(_x13) {
        return _addEmail.apply(this, arguments);
      }

      return addEmail;
    }()
  }]);
  return Verified;
}();

module.exports = Verified;
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/verified.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/id.js", {"@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","did-jwt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/id.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/**
 * A module to verify & validate claims
 *
 * @name idUtils
 * @memberof Box
 */
var didJWT = require('did-jwt');

var DID_MUPORT_PREFIX = 'did:muport:';
module.exports = {
  /**
   * Check whether a string is a muport did or not
   *
   * @memberOf Box.idUtils
   * @param   {String}     address  A string containing a user profile address
   * @return  {*|boolean}           Whether the address is a muport did or not
   */
  isMuportDID: function isMuportDID(address) {
    return address.startsWith(DID_MUPORT_PREFIX);
  },

  /**
   * Check whether a string is a valid claim or not
   *
   * @memberOf Box.idUtils
   * @param  {String}             claim
   * @param  {Object}             opts            Optional parameters
   * @param  {string}             opts.audience   The DID of the audience of the JWT
   * @return {Promise<boolean>}                   whether the parameter is an actual claim
   */
  isClaim: function () {
    var _isClaim = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(claim) {
      var opts,
          _args = arguments;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.prev = 1;
              _context.next = 4;
              return didJWT.decodeJWT(claim, opts);

            case 4:
              return _context.abrupt("return", true);

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              return _context.abrupt("return", false);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 7]]);
    }));

    function isClaim(_x) {
      return _isClaim.apply(this, arguments);
    }

    return isClaim;
  }(),

  /**
   * Verify a claim and return its content.
   * See https://github.com/uport-project/did-jwt/ for more details.
   *
   * @memberOf Box.idUtils
   * @param  {String}             claim
   * @param  {Object}             opts            Optional parameters
   * @param  {string}             opts.audience   The DID of the JWT's audience
   * @return {Object}                             The validated claim
   */
  verifyClaim: didJWT.verifyJWT
};
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/id.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/index.js", {"./src/access-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/src/access-controllers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/index.js
      return function (require, module, exports) {
const AccessControllers = require('./src/access-controllers')
module.exports = AccessControllers

      };
    };
  }
}, {package:"orbit-db-access-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/publicStore.js", {"./keyValueStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/keyValueStore.js","./utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/get":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/get.js","@babel/runtime/helpers/getPrototypeOf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/getPrototypeOf.js","@babel/runtime/helpers/inherits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/inherits.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/possibleConstructorReturn":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/publicStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var KeyValueStore = require('./keyValueStore');

var _require = require('./utils/index'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var ProfileStore =
/*#__PURE__*/
function (_KeyValueStore) {
  (0, _inherits2["default"])(ProfileStore, _KeyValueStore);

  function ProfileStore(orbitdb, name, linkProfile, ensureConnected, _3id) {
    var _this;

    (0, _classCallCheck2["default"])(this, ProfileStore);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ProfileStore).call(this, orbitdb, name, ensureConnected, _3id));
    _this._linkProfile = linkProfile;
    return _this;
  }

  (0, _createClass2["default"])(ProfileStore, [{
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key, value) {
        var opts,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                throwIfUndefined(key, 'key'); // if this is the noLink call we shouldn't call _linkProfile.

                if (opts.noLink) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return this._linkProfile();

              case 5:
                return _context.abrupt("return", (0, _get2["default"])((0, _getPrototypeOf2["default"])(ProfileStore.prototype), "set", this).call(this, key, value));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function set(_x, _x2) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(keys, values) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                _context2.next = 3;
                return this._linkProfile();

              case 3:
                return _context2.abrupt("return", (0, _get2["default"])((0, _getPrototypeOf2["default"])(ProfileStore.prototype), "setMultiple", this).call(this, keys, values));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setMultiple(_x3, _x4) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
  }]);
  return ProfileStore;
}(KeyValueStore);

module.exports = ProfileStore;
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/publicStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/index.js", {"./legacyIpfs3boxAccessController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/legacyIpfs3boxAccessController.js","./moderatorAccessController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/moderatorAccessController.js","./odbIdentityProvider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/odbIdentityProvider.js","./threadAccessController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/threadAccessController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/index.js
      return function (require, module, exports) {
const OdbIdentityProvider = require('./odbIdentityProvider')
const ModeratorAccessController = require('./moderatorAccessController')
const ThreadAccessController = require('./threadAccessController')
const LegacyIPFS3BoxAccessController = require('./legacyIpfs3boxAccessController')

module.exports = { OdbIdentityProvider, ModeratorAccessController, ThreadAccessController, LegacyIPFS3BoxAccessController  }

      };
    };
  }
}, {package:"3box-orbitdb-plugins",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box-orbitdb-plugins/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/OrbitDB.js", {"./db-manifest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/db-manifest.js","./exchange-heads":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/exchange-heads.js","./orbit-db-address":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/orbit-db-address.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/utils/index.js","logplease":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/logplease/src/index.js","orbit-db-access-controllers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-access-controllers/index.js","orbit-db-cache":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-cache/index-browser.js","orbit-db-counterstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-counterstore/src/CounterStore.js","orbit-db-docstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-docstore/src/DocumentStore.js","orbit-db-eventstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-eventstore/src/EventStore.js","orbit-db-feedstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-feedstore/src/FeedStore.js","orbit-db-identity-provider":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-identity-provider/index.js","orbit-db-keystore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-keystore/index-browser.js","orbit-db-kvstore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-kvstore/src/KeyValueStore.js","orbit-db-pubsub":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db-pubsub/index.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/OrbitDB.js
      return function (require, module, exports) {
'use strict'

const path = require('path')
const EventStore = require('orbit-db-eventstore')
const FeedStore = require('orbit-db-feedstore')
const KeyValueStore = require('orbit-db-kvstore')
const CounterStore = require('orbit-db-counterstore')
const DocumentStore = require('orbit-db-docstore')
const Pubsub = require('orbit-db-pubsub')
const Cache = require('orbit-db-cache')
const Keystore = require('orbit-db-keystore')
const Identities = require('orbit-db-identity-provider')
let AccessControllers = require('orbit-db-access-controllers')
const OrbitDBAddress = require('./orbit-db-address')
const createDBManifest = require('./db-manifest')
const exchangeHeads = require('./exchange-heads')
const { isDefined, io } = require('./utils')

const Logger = require('logplease')
const logger = Logger.create("orbit-db")
Logger.setLogLevel('ERROR')

// Mapping for 'database type' -> Class
let databaseTypes = {
  'counter': CounterStore,
  'eventlog': EventStore,
  'feed': FeedStore,
  'docstore': DocumentStore,
  'keyvalue': KeyValueStore,
}

  class OrbitDB {
  constructor(ipfs, identity, options = {}) {
    if (!isDefined(ipfs))
      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    if (!isDefined(identity))
      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    this._ipfs = ipfs
    this.identity = identity
    this.id = options.peerId
    this._pubsub = options && options.broker
      ? new options.broker(this._ipfs)
      : new Pubsub(this._ipfs, this.id)
    this.directory = options.directory || './orbitdb'
    this.keystore = options.keystore
    this.cache = options.cache || Cache
    this.stores = {}
    this._directConnections = {}
    // AccessControllers module can be passed in to enable
    // testing with orbit-db-access-controller
    AccessControllers = options.AccessControllers || AccessControllers
  }

  static async createInstance (ipfs, options = {}) {
    if (!isDefined(ipfs))
      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance')

    const { id } = await ipfs.id()
    const directory = options.directory || './orbitdb'
    const keystore = options.keystore || Keystore.create(path.join(directory, id, '/keystore'))

    const identity = options.identity || await Identities.createIdentity({
      id: options.id || id,
      keystore: keystore,
    })
    options = Object.assign({}, options, {
      peerId: id ,
      directory: directory,
      keystore: keystore
    })
    const orbitdb = new OrbitDB(ipfs, identity, options)
    return orbitdb
  }

  /* Databases */
  async feed (address, options = {}) {
    options = Object.assign({ create: true, type: 'feed' }, options)
    return this.open(address, options)
  }

  async log (address, options = {}) {
    options = Object.assign({ create: true, type: 'eventlog' }, options)
    return this.open(address, options)
  }

  async eventlog (address, options = {}) {
    return this.log(address, options)
  }

  async keyvalue (address, options = {}) {
    options = Object.assign({ create: true, type: 'keyvalue' }, options)
    return this.open(address, options)
  }

  async kvstore (address, options = {}) {
    return this.keyvalue(address, options)
  }

  async counter (address, options = {}) {
    options = Object.assign({ create: true, type: 'counter' }, options)
    return this.open(address, options)
  }

  async docs (address, options = {}) {
    options = Object.assign({ create: true, type: 'docstore' }, options)
    return this.open(address, options)
  }

  async docstore (address, options = {}) {
    return this.docs(address, options)
  }

  async disconnect () {
    //close Keystore
    if (this.keystore.close)
      await this.keystore.close()

    // Close all open databases
    const databases = Object.values(this.stores)
    for (let db of databases) {
      await db.close()
      delete this.stores[db.address.toString()]
    }

    // Close a direct connection and remove it from internal state
    const removeDirectConnect = e => {
      this._directConnections[e].close()
      delete this._directConnections[e]
    }

    // Close all direct connections to peers
    Object.keys(this._directConnections).forEach(removeDirectConnect)

    // Disconnect from pubsub
    if (this._pubsub) {
      await this._pubsub.disconnect()
    }

    // Remove all databases from the state
    this.stores = {}
  }

  // Alias for disconnect()
  async stop () {
    await this.disconnect()
  }

  /* Private methods */
  async _createStore (type, address, options) {
    // Get the type -> class mapping
    const Store = databaseTypes[type]

    if (!Store)
      throw new Error(`Invalid database type '${type}'`)

    let accessController
    if (options.accessControllerAddress) {
      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController)
    }

    const cache = await this._loadCache(this.directory, address)

    const opts = Object.assign({ replicate: true }, options, {
      accessController: accessController,
      keystore: this.keystore,
      cache: cache,
      onClose: this._onClose.bind(this),
    })
    const identity = options.identity || this.identity

    const store = new Store(this._ipfs, identity, address, opts)
    store.events.on('write', this._onWrite.bind(this))
    // ID of the store is the address as a string
    const addr = address.toString()
    this.stores[addr] = store

    // Subscribe to pubsub to get updates from peers,
    // this is what hooks us into the message propagation layer
    // and the p2p network
    if(opts.replicate && this._pubsub)
      this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this))

    return store
  }

  // Callback for local writes to the database. We the update to pubsub.
  _onWrite (address, entry, heads) {
    if(!heads) throw new Error("'heads' not defined")
    if(this._pubsub) this._pubsub.publish(address, heads)
  }

  // Callback for receiving a message from the network
  async _onMessage (address, heads) {
    const store = this.stores[address]
    try {
      logger.debug(`Received ${heads.length} heads for '${address}':\n`, JSON.stringify(heads.map(e => e.hash), null, 2))
      if (store && heads && heads.length > 0) {
        await store.sync(heads)
      }
    } catch (e) {
      logger.error(e)
    }
  }

  // Callback for when a peer connected to a database
  async _onPeerConnected (address, peer) {
    logger.debug(`New peer '${peer}' connected to '${address}'`)

    const getStore = address => this.stores[address]
    const getDirectConnection = peer => this._directConnections[peer]
    const onChannelCreated = channel => this._directConnections[channel._receiverID] = channel
    const onMessage = (address, heads) => this._onMessage(address, heads)

    const channel = await exchangeHeads(
      this._ipfs,
      address,
      peer,
      getStore,
      getDirectConnection,
      onMessage,
      onChannelCreated
    )

    if (getStore(address))
      getStore(address).events.emit('peer', peer)
  }

  // Callback when database was closed
  async _onClose (address) {
    logger.debug(`Close ${address}`)

    // Unsubscribe from pubsub
    if (this._pubsub) {
      await this._pubsub.unsubscribe(address)
    }

    delete this.stores[address]
  }

  async _determineAddress(name, type, options = {}) {
    if (!OrbitDB.isValidType(type))
      throw new Error(`Invalid database type '${type}'`)

    if (OrbitDBAddress.isValid(name))
      throw new Error(`Given database name is an address. Please give only the name of the database!`)

    // Create an AccessController, use IPFS AC as the default
    options.accessController = Object.assign({}, { name: name , type: 'ipfs' }, options.accessController)
    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController  || {})

    // Save the manifest to IPFS
    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options)

    // Create the database address
    return OrbitDBAddress.parse(path.join('/orbitdb', manifestHash, name))
  }

  /* Create and Open databases */

  /*
    options = {
      accessController: { write: [] } // array of keys that can write to this database
      directory: './orbitdb', // directory in which to place the database files
      overwrite: false, // whether we should overwrite the existing database if it exists
    }
  */
  async create (name, type, options = {}) {
    logger.debug(`create()`)

    // The directory to look databases from can be passed in as an option
    const directory = options.directory || this.directory
    logger.debug(`Creating database '${name}' as ${type} in '${directory}'`)

    // Create the database address
    const dbAddress = await this._determineAddress(name, type, options)

    // Load the locally saved database information
    const cache = await this._loadCache(directory, dbAddress)

    // Check if we have the database locally
    const haveDB = await this._haveLocalData(cache, dbAddress)

    if (haveDB && !options.overwrite)
      throw new Error(`Database '${dbAddress}' already exists!`)

    // Save the database locally
    await this._addManifestToCache(directory, dbAddress)

    logger.debug(`Created database '${dbAddress}'`)

    // Open the database
    return this.open(dbAddress, options)
  }

  async determineAddress(name, type, options = {}) {
    const opts = Object.assign({}, { onlyHash: true }, options)
    return this._determineAddress(name, type, opts)
  }

  /*
      options = {
        localOnly: false // if set to true, throws an error if database can't be found locally
        create: false // whether to create the database
        type: TODO
        overwrite: TODO

      }
   */
  async open (address, options = {}) {
    logger.debug(`open()`)

    options = Object.assign({ localOnly: false, create: false }, options)
    logger.debug(`Open database '${address}'`)

    // The directory to look databases from can be passed in as an option
    const directory = options.directory || this.directory
    logger.debug(`Look from '${directory}'`)

    // If address is just the name of database, check the options to crate the database
    if (!OrbitDBAddress.isValid(address)) {
      if (!options.create) {
        throw new Error(`'options.create' set to 'false'. If you want to create a database, set 'options.create' to 'true'.`)
      } else if (options.create && !options.type) {
        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`)
      } else {
        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`)
        options.overwrite = options.overwrite ? options.overwrite : true
        return this.create(address, options.type, options)
      }
    }

    // Parse the database address
    const dbAddress = OrbitDBAddress.parse(address)

    // Load the locally saved db information
    const cache = await this._loadCache(directory, dbAddress)

    // Check if we have the database
    const haveDB = await this._haveLocalData(cache, dbAddress)

    logger.debug((haveDB ? 'Found' : 'Didn\'t find') + ` database '${dbAddress}'`)

    // If we want to try and open the database local-only, throw an error
    // if we don't have the database locally
    if (options.localOnly && !haveDB) {
      logger.warn(`Database '${dbAddress}' doesn't exist!`)
      throw new Error(`Database '${dbAddress}' doesn't exist!`)
    }

    logger.debug(`Loading Manifest for '${dbAddress}'`)

    // Get the database manifest from IPFS
    const manifest = await io.read(this._ipfs, dbAddress.root)
    logger.debug(`Manifest for '${dbAddress}':\n${JSON.stringify(manifest, null, 2)}`)

    // Make sure the type from the manifest matches the type that was given as an option
    if (options.type && manifest.type !== options.type)
      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`)

    // Save the database locally
    await this._addManifestToCache(directory, dbAddress)

    // Open the the database
    options = Object.assign({}, options, { accessControllerAddress: manifest.accessController })
    return this._createStore(manifest.type, dbAddress, options)
  }

  // Save the database locally
  async _addManifestToCache (directory, dbAddress) {
    const cache = await this._loadCache(directory, dbAddress)
    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root)
    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`)
  }

  async _loadCache (directory, dbAddress) {
    let cache
    try {
      cache = await this.cache.load(directory, dbAddress)
    } catch (e) {
      console.log(e)
      logger.error("Couldn't load Cache:", e)
    }

    return cache
  }

  /**
   * Check if we have the database, or part of it, saved locally
   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]
   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]
   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]
   */
  async _haveLocalData (cache, dbAddress) {
    if (!cache) {
      return false
    }
    const data = await cache.get(path.join(dbAddress.toString(), '_manifest'))
    return data !== undefined && data !== null
  }

  /**
   * Returns supported database types as an Array of strings
   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']
   * @return {[Array]} [Supported database types]
   */
  static get databaseTypes () {
    return Object.keys(databaseTypes)
  }

  static isValidType (type) {
    return Object.keys(databaseTypes).includes(type)
  }

  static addDatabaseType (type, store) {
    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`)
    databaseTypes[type] = store
  }

  static getDatabaseTypes () {
    return databaseTypes
  }

  static isValidAddress (address) {
    return OrbitDBAddress.isValid(address)
  }

  static parseAddress (address) {
    return OrbitDBAddress.parse(address)
  }
}

module.exports = OrbitDB

      };
    };
  }
}, {package:"orbit-db",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/OrbitDB.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/index.js", {"./boot":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/boot.js","./components":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/components/index.js","./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/config.js","./mfs-preload":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/mfs-preload.js","./preload":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/preload.js","./runtime/ipld-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/ipld-browser.js","./runtime/repo-nodejs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/runtime/repo-browser.js","./state":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/state.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","debug":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/debug/src/browser.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js","ipfs-block-service":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs-block-service/src/index.js","ipld":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipld/src/index.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js","libp2p-crypto":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/libp2p-crypto/src/index.js","merge-options":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/merge-options/index.js","multiaddr":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multiaddr/src/index.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multibase/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","multihashing-async":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/node_modules/multihashing-async/src/index.js","peer-book":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-book/src/index.js","peer-id":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-id/src/index.js","peer-info":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/peer-info/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const BlockService = require('ipfs-block-service')
const Ipld = require('ipld')
const PeerId = require('peer-id')
const PeerInfo = require('peer-info')
const crypto = require('libp2p-crypto')
const isIPFS = require('is-ipfs')
const multiaddr = require('multiaddr')
const multihash = require('multihashes')
const PeerBook = require('peer-book')
const multibase = require('multibase')
const multicodec = require('multicodec')
const multihashing = require('multihashing-async')
const CID = require('cids')
const debug = require('debug')
const mergeOptions = require('merge-options')
const EventEmitter = require('events')

const config = require('./config')
const boot = require('./boot')
const components = require('./components')

// replaced by repo-browser when running in the browser
const defaultRepo = require('./runtime/repo-nodejs')
const preload = require('./preload')
const mfsPreload = require('./mfs-preload')
const ipldOptions = require('./runtime/ipld-nodejs')

class IPFS extends EventEmitter {
  constructor (options) {
    super()

    const defaults = {
      init: true,
      start: true,
      EXPERIMENTAL: {},
      preload: {
        enabled: true,
        addresses: [
          '/dnsaddr/node0.preload.ipfs.io/https',
          '/dnsaddr/node1.preload.ipfs.io/https'
        ]
      }
    }

    options = config.validate(options || {})

    this._options = mergeOptions(defaults, options)

    if (options.init === false) {
      this._options.init = false
    }

    if (!(options.start === false)) {
      this._options.start = true
    }

    if (typeof options.repo === 'string' ||
        options.repo === undefined) {
      this._repo = defaultRepo(options.repo)
    } else {
      this._repo = options.repo
    }

    // IPFS utils
    this.log = debug('ipfs')
    this.log.err = debug('ipfs:err')

    // IPFS Core Internals
    // this._repo - assigned above
    this._peerInfoBook = new PeerBook()
    this._peerInfo = undefined
    this._bitswap = undefined
    this._blockService = new BlockService(this._repo)
    this._ipld = new Ipld(ipldOptions(this._blockService, this._options.ipld, this.log))
    this._preload = preload(this)
    this._mfsPreload = mfsPreload(this)
    this._ipns = undefined
    // eslint-disable-next-line no-console
    this._print = this._options.silent ? this.log : console.log

    // IPFS Core exposed components
    //   - for booting up a node
    this.init = components.init(this)
    this.preStart = components.preStart(this)
    this.start = components.start(this)
    this.stop = components.stop(this)
    this.shutdown = this.stop
    this.isOnline = components.isOnline(this)
    //   - interface-ipfs-core defined API
    Object.assign(this, components.filesRegular(this))
    this.version = components.version(this)
    this.id = components.id(this)
    this.repo = components.repo(this)
    this.bootstrap = components.bootstrap(this)
    this.config = components.config(this)
    this.block = components.block(this)
    this.object = components.object(this)
    this.dag = components.dag(this)
    this.files = components.filesMFS(this)
    this.libp2p = null // assigned on start
    this.swarm = components.swarm(this)
    this.name = components.name(this)
    this.bitswap = components.bitswap(this)
    this.pin = components.pin(this)
    this.ping = components.ping(this)
    this.pingPullStream = components.pingPullStream(this)
    this.pingReadableStream = components.pingReadableStream(this)
    this.pubsub = components.pubsub(this)
    this.dht = components.dht(this)
    this.dns = components.dns(this)
    this.key = components.key(this)
    this.stats = components.stats(this)
    this.resolve = components.resolve(this)

    if (this._options.EXPERIMENTAL.pubsub) {
      this.log('EXPERIMENTAL pubsub is enabled')
    }
    if (this._options.EXPERIMENTAL.ipnsPubsub) {
      if (!this._options.EXPERIMENTAL.pubsub) {
        this.log('EXPERIMENTAL pubsub is enabled to use IPNS pubsub')
        this._options.EXPERIMENTAL.pubsub = true
      }

      this.log('EXPERIMENTAL IPNS pubsub is enabled')
    }
    if (this._options.EXPERIMENTAL.sharding) {
      this.log('EXPERIMENTAL sharding is enabled')
    }

    this.state = require('./state')(this)

    boot(this)
  }
}

module.exports = IPFS

// Note: We need to do this to force browserify to load the Buffer module
const BufferImpl = Buffer
Object.assign(module.exports, { crypto, isIPFS, Buffer: BufferImpl, CID, multiaddr, multibase, multihash, multihashing, multicodec, PeerId, PeerInfo })

module.exports.createNode = (options) => {
  return new IPFS(options)
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ipfs",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ipfs/src/core/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/index.js", {"./add-ethereum-chain":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/add-ethereum-chain.js","./eth-accounts":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/eth-accounts.js","./get-provider-state":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/get-provider-state.js","./log-web3-shim-usage":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/log-web3-shim-usage.js","./request-accounts":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/request-accounts.js","./send-metadata":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/send-metadata.js","./switch-ethereum-chain":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/switch-ethereum-chain.js","./watch-asset":"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/watch-asset.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/index.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _addEthereumChain = _interopRequireDefault(require("./add-ethereum-chain"));

var _ethAccounts = _interopRequireDefault(require("./eth-accounts"));

var _getProviderState = _interopRequireDefault(require("./get-provider-state"));

var _logWeb3ShimUsage = _interopRequireDefault(require("./log-web3-shim-usage"));

var _requestAccounts = _interopRequireDefault(require("./request-accounts"));

var _sendMetadata = _interopRequireDefault(require("./send-metadata"));

var _switchEthereumChain = _interopRequireDefault(require("./switch-ethereum-chain"));

var _watchAsset = _interopRequireDefault(require("./watch-asset"));

const handlers = [_addEthereumChain.default, _ethAccounts.default, _getProviderState.default, _logWeb3ShimUsage.default, _requestAccounts.default, _sendMetadata.default, _switchEthereumChain.default, _watchAsset.default];
var _default = handlers;
exports.default = _default;

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/lib/rpc-method-middleware/handlers/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/index.js", {"./permitted":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/permitted/index.js","./restricted":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/restricted/index.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectHooks = exports.restrictedMethodBuilders = exports.permittedMethods = void 0;
var permitted_1 = require("./permitted");
Object.defineProperty(exports, "permittedMethods", { enumerable: true, get: function () { return permitted_1.handlers; } });
var restricted_1 = require("./restricted");
Object.defineProperty(exports, "restrictedMethodBuilders", { enumerable: true, get: function () { return restricted_1.builders; } });
var utils_1 = require("./utils");
Object.defineProperty(exports, "selectHooks", { enumerable: true, get: function () { return utils_1.selectHooks; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/rpc-methods/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/helpers.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/helpers.js
      return function (require, module, exports) {
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
}
Object.defineProperty(exports, "hasOwnProperty", { value: hasOwnProperty });
function _objectKeys(obj) {
    if (Array.isArray(obj)) {
        var keys = new Array(obj.length);
        for (var k = 0; k < keys.length; k++) {
            keys[k] = "" + k;
        }
        return keys;
    }
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var i in obj) {
        if (hasOwnProperty(obj, i)) {
            keys.push(i);
        }
    }
    return keys;
}
exports._objectKeys = _objectKeys;
;
/**
* Deeply clone the object.
* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
* @param  {any} obj value to clone
* @return {any} cloned obj
*/
function _deepClone(obj) {
    switch (typeof obj) {
        case "object":
            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
        case "undefined":
            return null; //this is how JSON.stringify behaves for array items
        default:
            return obj; //no need to clone primitives
    }
}
exports._deepClone = _deepClone;
//3x faster than cached /^\d+$/.test(str)
function isInteger(str) {
    var i = 0;
    var len = str.length;
    var charCode;
    while (i < len) {
        charCode = str.charCodeAt(i);
        if (charCode >= 48 && charCode <= 57) {
            i++;
            continue;
        }
        return false;
    }
    return true;
}
exports.isInteger = isInteger;
/**
* Escapes a json pointer path
* @param path The raw pointer
* @return the Escaped path
*/
function escapePathComponent(path) {
    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
        return path;
    return path.replace(/~/g, '~0').replace(/\//g, '~1');
}
exports.escapePathComponent = escapePathComponent;
/**
 * Unescapes a json pointer path
 * @param path The escaped pointer
 * @return The unescaped path
 */
function unescapePathComponent(path) {
    return path.replace(/~1/g, '/').replace(/~0/g, '~');
}
exports.unescapePathComponent = unescapePathComponent;
function _getPathRecursive(root, obj) {
    var found;
    for (var key in root) {
        if (hasOwnProperty(root, key)) {
            if (root[key] === obj) {
                return escapePathComponent(key) + '/';
            }
            else if (typeof root[key] === 'object') {
                found = _getPathRecursive(root[key], obj);
                if (found != '') {
                    return escapePathComponent(key) + '/' + found;
                }
            }
        }
    }
    return '';
}
exports._getPathRecursive = _getPathRecursive;
function getPath(root, obj) {
    if (root === obj) {
        return '/';
    }
    var path = _getPathRecursive(root, obj);
    if (path === '') {
        throw new Error("Object not found in root");
    }
    return '/' + path;
}
exports.getPath = getPath;
/**
* Recursively checks whether an object has any undefined values inside.
*/
function hasUndefined(obj) {
    if (obj === undefined) {
        return true;
    }
    if (obj) {
        if (Array.isArray(obj)) {
            for (var i = 0, len = obj.length; i < len; i++) {
                if (hasUndefined(obj[i])) {
                    return true;
                }
            }
        }
        else if (typeof obj === "object") {
            var objKeys = _objectKeys(obj);
            var objKeysLength = objKeys.length;
            for (var i = 0; i < objKeysLength; i++) {
                if (hasUndefined(obj[objKeys[i]])) {
                    return true;
                }
            }
        }
    }
    return false;
}
exports.hasUndefined = hasUndefined;
function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
        if (typeof value !== 'undefined') {
            messageParts.push(key + ": " + value);
        }
    }
    return messageParts.join('\n');
}
var PatchError = /** @class */ (function (_super) {
    __extends(PatchError, _super);
    function PatchError(message, name, index, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
        _this.name = name;
        _this.index = index;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
        return _this;
    }
    return PatchError;
}(Error));
exports.PatchError = PatchError;

      };
    };
  }
}, {package:"fast-json-patch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/helpers.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/core.js", {"./helpers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/helpers.js","fast-deep-equal":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/node_modules/fast-deep-equal/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/core.js
      return function (require, module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var areEquals = require('fast-deep-equal');
var helpers_1 = require("./helpers");
exports.JsonPatchError = helpers_1.PatchError;
exports.deepClone = helpers_1._deepClone;
/* We use a Javascript hash to store each
 function. Each hash entry (property) uses
 the operation identifiers specified in rfc6902.
 In this way, we can map each patch operation
 to its dedicated function in efficient way.
 */
/* The operations applicable to an object */
var objOps = {
    add: function (obj, key, document) {
        obj[key] = this.value;
        return { newDocument: document };
    },
    remove: function (obj, key, document) {
        var removed = obj[key];
        delete obj[key];
        return { newDocument: document, removed: removed };
    },
    replace: function (obj, key, document) {
        var removed = obj[key];
        obj[key] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: function (obj, key, document) {
        /* in case move target overwrites an existing value,
        return the removed value, this can be taxing performance-wise,
        and is potentially unneeded */
        var removed = getValueByPointer(document, this.path);
        if (removed) {
            removed = helpers_1._deepClone(removed);
        }
        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
        applyOperation(document, { op: "add", path: this.path, value: originalValue });
        return { newDocument: document, removed: removed };
    },
    copy: function (obj, key, document) {
        var valueToCopy = getValueByPointer(document, this.from);
        // enforce copy by value so further operations don't affect source (see issue #177)
        applyOperation(document, { op: "add", path: this.path, value: helpers_1._deepClone(valueToCopy) });
        return { newDocument: document };
    },
    test: function (obj, key, document) {
        return { newDocument: document, test: areEquals(obj[key], this.value) };
    },
    _get: function (obj, key, document) {
        this.value = obj[key];
        return { newDocument: document };
    }
};
/* The operations applicable to an array. Many are the same as for the object */
var arrOps = {
    add: function (arr, i, document) {
        if (helpers_1.isInteger(i)) {
            arr.splice(i, 0, this.value);
        }
        else { // array props
            arr[i] = this.value;
        }
        // this may be needed when using '-' in an array
        return { newDocument: document, index: i };
    },
    remove: function (arr, i, document) {
        var removedList = arr.splice(i, 1);
        return { newDocument: document, removed: removedList[0] };
    },
    replace: function (arr, i, document) {
        var removed = arr[i];
        arr[i] = this.value;
        return { newDocument: document, removed: removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
};
/**
 * Retrieves a value from a JSON document by a JSON pointer.
 * Returns the value.
 *
 * @param document The document to get the value from
 * @param pointer an escaped JSON pointer
 * @return The retrieved value
 */
function getValueByPointer(document, pointer) {
    if (pointer == '') {
        return document;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document, getOriginalDestination);
    return getOriginalDestination.value;
}
exports.getValueByPointer = getValueByPointer;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the {newDocument, result} of the operation.
 * It modifies the `document` and `operation` objects - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return `{newDocument, result}` after the operation
 */
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
    if (validateOperation === void 0) { validateOperation = false; }
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (index === void 0) { index = 0; }
    if (validateOperation) {
        if (typeof validateOperation == 'function') {
            validateOperation(operation, 0, document, operation.path);
        }
        else {
            validator(operation, 0);
        }
    }
    /* ROOT OPERATIONS */
    if (operation.path === "") {
        var returnValue = { newDocument: document };
        if (operation.op === 'add') {
            returnValue.newDocument = operation.value;
            return returnValue;
        }
        else if (operation.op === 'replace') {
            returnValue.newDocument = operation.value;
            returnValue.removed = document; //document we removed
            return returnValue;
        }
        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
            if (operation.op === 'move') { // report removed item
                returnValue.removed = document;
            }
            return returnValue;
        }
        else if (operation.op === 'test') {
            returnValue.test = areEquals(document, operation.value);
            if (returnValue.test === false) {
                throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
            }
            returnValue.newDocument = document;
            return returnValue;
        }
        else if (operation.op === 'remove') { // a remove on root
            returnValue.removed = document;
            returnValue.newDocument = null;
            return returnValue;
        }
        else if (operation.op === '_get') {
            operation.value = document;
            return returnValue;
        }
        else { /* bad operation */
            if (validateOperation) {
                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
            }
            else {
                return returnValue;
            }
        }
    } /* END ROOT OPERATIONS */
    else {
        if (!mutateDocument) {
            document = helpers_1._deepClone(document);
        }
        var path = operation.path || "";
        var keys = path.split('/');
        var obj = document;
        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
        var len = keys.length;
        var existingPathFragment = undefined;
        var key = void 0;
        var validateFunction = void 0;
        if (typeof validateOperation == 'function') {
            validateFunction = validateOperation;
        }
        else {
            validateFunction = validator;
        }
        while (true) {
            key = keys[t];
            if (banPrototypeModifications && key == '__proto__') {
                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
            }
            if (validateOperation) {
                if (existingPathFragment === undefined) {
                    if (obj[key] === undefined) {
                        existingPathFragment = keys.slice(0, t).join('/');
                    }
                    else if (t == len - 1) {
                        existingPathFragment = operation.path;
                    }
                    if (existingPathFragment !== undefined) {
                        validateFunction(operation, 0, document, existingPathFragment);
                    }
                }
            }
            t++;
            if (Array.isArray(obj)) {
                if (key === '-') {
                    key = obj.length;
                }
                else {
                    if (validateOperation && !helpers_1.isInteger(key)) {
                        throw new exports.JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
                    } // only parse key when it's an integer for `arr.prop` to work
                    else if (helpers_1.isInteger(key)) {
                        key = ~~key;
                    }
                }
                if (t >= len) {
                    if (validateOperation && operation.op === "add" && key > obj.length) {
                        throw new exports.JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
                    }
                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            else {
                if (key && key.indexOf('~') != -1) {
                    key = helpers_1.unescapePathComponent(key);
                }
                if (t >= len) {
                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
                    if (returnValue.test === false) {
                        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
                    }
                    return returnValue;
                }
            }
            obj = obj[key];
        }
    }
}
exports.applyOperation = applyOperation;
/**
 * Apply a full JSON Patch array on a JSON document.
 * Returns the {newDocument, result} of the patch.
 * It modifies the `document` object and `patch` - it gets the values by reference.
 * If you would like to avoid touching your values, clone them:
 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
 *
 * @param document The document to patch
 * @param patch The patch to apply
 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
 * @param mutateDocument Whether to mutate the original document or clone it before applying
 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
 * @return An array of `{newDocument, result}` after the patch
 */
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) { mutateDocument = true; }
    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
    if (validateOperation) {
        if (!Array.isArray(patch)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
    }
    if (!mutateDocument) {
        document = helpers_1._deepClone(document);
    }
    var results = new Array(patch.length);
    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
        document = results[i].newDocument; // in case root was replaced
    }
    results.newDocument = document;
    return results;
}
exports.applyPatch = applyPatch;
/**
 * Apply a single JSON Patch Operation on a JSON document.
 * Returns the updated document.
 * Suitable as a reducer.
 *
 * @param document The document to patch
 * @param operation The operation to apply
 * @return The updated document
 */
function applyReducer(document, operation, index) {
    var operationResult = applyOperation(document, operation);
    if (operationResult.test === false) { // failed test
        throw new exports.JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
    }
    return operationResult.newDocument;
}
exports.applyReducer = applyReducer;
/**
 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
 * @param {object} operation - operation object (patch)
 * @param {number} index - index of operation in the sequence
 * @param {object} [document] - object where the operation is supposed to be applied
 * @param {string} [existingPathFragment] - comes along with `document`
 */
function validator(operation, index, document, existingPathFragment) {
    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
    }
    else if (!objOps[operation.op]) {
        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
    }
    else if (typeof operation.path !== 'string') {
        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
        // paths that aren't empty string should start with "/"
        throw new exports.JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
    }
    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
    }
    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {
        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
    }
    else if (document) {
        if (operation.op == "add") {
            var pathLen = operation.path.split("/").length;
            var existingPathLen = existingPathFragment.split("/").length;
            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
            }
        }
        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
            if (operation.path !== existingPathFragment) {
                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
            }
        }
        else if (operation.op === 'move' || operation.op === 'copy') {
            var existingValue = { op: "_get", path: operation.from, value: undefined };
            var error = validate([existingValue], document);
            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
            }
        }
    }
}
exports.validator = validator;
/**
 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
 * If error is encountered, returns a JsonPatchError object
 * @param sequence
 * @param document
 * @returns {JsonPatchError|undefined}
 */
function validate(sequence, document, externalValidator) {
    try {
        if (!Array.isArray(sequence)) {
            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
        }
        if (document) {
            //clone document and sequence so that we can safely try applying operations
            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);
        }
        else {
            externalValidator = externalValidator || validator;
            for (var i = 0; i < sequence.length; i++) {
                externalValidator(sequence[i], i, document, undefined);
            }
        }
    }
    catch (e) {
        if (e instanceof exports.JsonPatchError) {
            return e;
        }
        else {
            throw e;
        }
    }
}
exports.validate = validate;
/**
 * Default export for backwards compat
 */
exports.default = {
    JsonPatchError: exports.JsonPatchError,
    deepClone: exports.deepClone,
    getValueByPointer: getValueByPointer,
    applyOperation: applyOperation,
    applyPatch: applyPatch,
    applyReducer: applyReducer,
    validator: validator,
    validate: validate
};

      };
    };
  }
}, {package:"fast-json-patch",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-json-patch/lib/core.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js", {"./cid-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/cid-util.js","multibase":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multibase/src/index.js","multicodec":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multicodec/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/multihashes/src/index.js","uint8arrays/concat":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/concat.js","uint8arrays/equals":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/equals.js","uint8arrays/to-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/node_modules/uint8arrays/to-string.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js
      return function (require, module, exports) {
'use strict'

const mh = require('multihashes')
const multibase = require('multibase')
const multicodec = require('multicodec')
const CIDUtil = require('./cid-util')
const uint8ArrayConcat = require('uint8arrays/concat')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayEquals = require('uint8arrays/equals')

const codecs = multicodec.nameToCode
const codecInts = /** @type {CodecName[]} */(Object.keys(codecs)).reduce((p, name) => {
  p[codecs[name]] = name
  return p
}, /** @type {Record<CodecCode, CodecName>} */({}))

const symbol = Symbol.for('@ipld/js-cid/CID')

/**
 * @typedef {Object} SerializedCID
 * @property {string} codec
 * @property {number} version
 * @property {Uint8Array} hash
 */
/**
 * @typedef {0|1} CIDVersion
 * @typedef {__import__('multibase').BaseNameOrCode} BaseNameOrCode
 * @typedef {__import__('multicodec').CodecName} CodecName
 * @typedef {__import__('multicodec').CodecCode} CodecCode
 */

/**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 *
 * @class CID
 */
class CID {
  /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Uint8Array)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {CIDVersion | string | Uint8Array | CID} version
   * @param {string|number} [codec]
   * @param {Uint8Array} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.bytes>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */
  constructor (version, codec, multihash, multibaseName) {
    // We have below three blank field accessors only because
    // otherwise TS will not pick them up if done after assignemnts

    /**
     * The version of the CID.
     *
     * @type {CIDVersion}
     */
    // eslint-disable-next-line no-unused-expressions
    this.version

    /**
     * The codec of the CID.
     *
     * @deprecated
     * @type {CodecName}
     */
    // eslint-disable-next-line no-unused-expressions
    this.codec

    /**
     * The multihash of the CID.
     *
     * @type {Uint8Array}
     */
    // eslint-disable-next-line no-unused-expressions
    this.multihash

    Object.defineProperty(this, symbol, { value: true })
    if (CID.isCID(version)) {
      // version is an exising CID instance
      const cid = /** @type {CID} */(version)
      this.version = cid.version
      this.codec = cid.codec
      this.multihash = cid.multihash
      // Default guard for when a CID < 0.7 is passed with no multibaseName
      // @ts-ignore
      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
      return
    }

    if (typeof version === 'string') {
      // e.g. 'base32' or false
      const baseName = multibase.isEncoded(version)
      if (baseName) {
        // version is a CID String encoded with multibase, so v1
        const cid = multibase.decode(version)
        this.version = /** @type {CIDVersion} */(parseInt(cid[0].toString(), 16))
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = baseName
      } else {
        // version is a base58btc string multihash, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = mh.fromB58String(version)
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      Object.defineProperty(this, 'string', { value: version })
      return
    }

    if (version instanceof Uint8Array) {
      const v = parseInt(version[0].toString(), 16)
      if (v === 1) {
        // version is a CID Uint8Array
        const cid = version
        this.version = v
        this.codec = multicodec.getCodec(cid.slice(1))
        this.multihash = multicodec.rmPrefix(cid.slice(1))
        this.multibaseName = 'base32'
      } else {
        // version is a raw multihash Uint8Array, so v0
        this.version = 0
        this.codec = 'dag-pb'
        this.multihash = version
        this.multibaseName = 'base58btc'
      }
      CID.validateCID(this)
      return
    }

    // otherwise, assemble the CID from the parameters

    this.version = version

    if (typeof codec === 'number') {
      // @ts-ignore
      codec = codecInts[codec]
    }

    this.codec = /** @type {CodecName} */ (codec)

    this.multihash = /** @type {Uint8Array} */ (multihash)

    /**
     * Multibase name as string.
     *
     * @deprecated
     * @type {string}
     */
    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

    CID.validateCID(this)
  }

  /**
   * The CID as a `Uint8Array`
   *
   * @returns {Uint8Array}
   *
   */
  get bytes () {
    // @ts-ignore
    let bytes = this._bytes

    if (!bytes) {
      if (this.version === 0) {
        bytes = this.multihash
      } else if (this.version === 1) {
        const codec = multicodec.getCodeVarint(this.codec)
        bytes = uint8ArrayConcat([
          [1], codec, this.multihash
        ], 1 + codec.byteLength + this.multihash.byteLength)
      } else {
        throw new Error('unsupported version')
      }

      // Cache this Uint8Array so it doesn't have to be recreated
      Object.defineProperty(this, '_bytes', { value: bytes })
    }

    return bytes
  }

  /**
   * The prefix of the CID.
   *
   * @returns {Uint8Array}
   */
  get prefix () {
    const codec = multicodec.getCodeVarint(this.codec)
    const multihash = mh.prefix(this.multihash)
    const prefix = uint8ArrayConcat([
      [this.version], codec, multihash
    ], 1 + codec.byteLength + multihash.byteLength)

    return prefix
  }

  /**
   * The codec of the CID in its number form.
   *
   * @returns {CodecCode}
   */
  get code () {
    return codecs[this.codec]
  }

  /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */
  toV0 () {
    if (this.codec !== 'dag-pb') {
      throw new Error('Cannot convert a non dag-pb CID to CIDv0')
    }

    const { name, length } = mh.decode(this.multihash)

    if (name !== 'sha2-256') {
      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
    }

    if (length !== 32) {
      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
    }

    return new CID(0, this.codec, this.multihash)
  }

  /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */
  toV1 () {
    return new CID(1, this.codec, this.multihash, this.multibaseName)
  }

  /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toBaseEncodedString (base = this.multibaseName) {
    // @ts-ignore non enumerable cache property
    if (this.string && this.string.length !== 0 && base === this.multibaseName) {
      // @ts-ignore non enumerable cache property
      return this.string
    }
    let str
    if (this.version === 0) {
      if (base !== 'base58btc') {
        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
      }
      str = mh.toB58String(this.multihash)
    } else if (this.version === 1) {
      str = uint8ArrayToString(multibase.encode(base, this.bytes))
    } else {
      throw new Error('unsupported version')
    }
    if (base === this.multibaseName) {
      // cache the string value
      Object.defineProperty(this, 'string', { value: str })
    }
    return str
  }

  /**
   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
   *
   * @returns {string}
   */
  [Symbol.for('nodejs.util.inspect.custom')] () {
    return 'CID(' + this.toString() + ')'
  }

  /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */
  toString (base) {
    return this.toBaseEncodedString(base)
  }

  /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */
  toJSON () {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash
    }
  }

  /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {boolean}
   */
  equals (other) {
    return this.codec === other.codec &&
      this.version === other.version &&
      uint8ArrayEquals(this.multihash, other.multihash)
  }

  /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other - The other CID.
   * @returns {void}
   */
  static validateCID (other) {
    const errorMsg = CIDUtil.checkCIDComponents(other)
    if (errorMsg) {
      throw new Error(errorMsg)
    }
  }

  /**
   * Check if object is a CID instance
   *
   * @param {any} value
   * @returns {value is CID}
   */
  static isCID (value) {
    return value instanceof CID || Boolean(value && value[symbol])
  }
}

CID.codecs = codecs

module.exports = CID

      };
    };
  }
}, {package:"cids",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/cids/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/constants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

      };
    };
  }
}, {package:"multihashes",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multihashes/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js", {"./decode.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/decode.js","./encode.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/encode.js","./length.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/varint/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js", {"util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/util/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js
      return function (require, module, exports) {
"use strict"

exports.TextEncoder =
  typeof TextEncoder !== "undefined" ? TextEncoder : require("util").TextEncoder

exports.TextDecoder =
  typeof TextDecoder !== "undefined" ? TextDecoder : require("util").TextDecoder

      };
    };
  }
}, {package:"web-encoding",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/web-encoding/src/lib.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/index.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/constants.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/util.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/index.js
      return function (require, module, exports) {
// @ts-check
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')
const { decodeText, asBuffer } = require('./util')

/** @typedef {__import__("./base")} Base */

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  const buffer = Buffer.alloc(codeBuf.length + buf.length)
  buffer.set(codeBuf, 0)
  buffer.set(buf, codeBuf.length)

  return buffer
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)

  return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (ArrayBuffer.isView(data)) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(data[0])
  return asBuffer(enc.decode(data.substring(1)))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 * @returns {false|string}
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(data[0])
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {string} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {string|number} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (constants.names[nameOrCode]) {
    return constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    return constants.codes[nameOrCode]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(data[0])
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
exports.names = Object.freeze(constants.names)
exports.codes = Object.freeze(constants.codes)

      };
    };
  }
}, {package:"multibase",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multibase/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-base64/base64.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/js-base64/base64.js
      return function (require, module, exports) {
(function (Buffer){(function (){


//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
        ? define(factory) :
        // cf. https://github.com/dankogai/js-base64/issues/119
        (function() {
            // existing version for noConflict()
            const _Base64 = global.Base64;
            const gBase64 = factory();
            gBase64.noConflict = () => {
                global.Base64 = _Base64;
                return gBase64;
            };
            if (global.Meteor) { // Meteor.js
                Base64 = gBase64;
            }
            global.Base64 = gBase64;
        })();
}((typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
        : this
), function() {
    'use strict';

/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.6.1';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = [...b64ch];
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_')
    .replace(/=+$/m, '');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};

    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(k => gBase64.Base64[k] = gBase64[k]);
    return gBase64;
}));



}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"js-base64",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-base64/base64.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/int-table.js", {"./base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/int-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const { baseTable } = require('./base-table')

/**
 * @type {Map<CodecNumber,CodecName>}
 */
const nameTable = new Map()

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  nameTable.set(code, /** @type {CodecName} */(encodingName))
}

module.exports = Object.freeze(nameTable)

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/int-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/constants.js", {"./base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/constants.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantNumberMap} ConstantNumberMap */

const { baseTable } = require('./base-table')

const constants = /** @type {ConstantNumberMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  const constant = name.toUpperCase().replace(/-/g, '_')
  constants[constant] = code
}

module.exports = Object.freeze(constants)

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/print.js", {"./base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/print.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').NumberNameMap} NumberNameMap */

const { baseTable } = require('./base-table')

const tableByCode = /** @type {NumberNameMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  if (tableByCode[code] === undefined) {
    tableByCode[code] = /** @type {CodecName} **/(name)
  }
}

module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/print.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/varint-table.js", {"./base-table":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/base-table.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/varint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

const { baseTable } = require('./base-table')
const varintEncode = require('./util').varintEncode

const varintTable = /** @type {NameUint8ArrayMap} */ ({})

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  varintTable[encodingName] = varintEncode(code)
}

module.exports = Object.freeze(varintTable)

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/varint-table.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/concat.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/concat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {Number} length
 * @returns {Uint8Array}
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
}, {package:"uint8arrays",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/concat.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js", {"./decode.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/decode.js","./encode.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/encode.js","./length.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/length.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
}, {package:"varint",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js", {"uint8arrays/from-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/from-string.js","uint8arrays/to-string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/uint8arrays/to-string.js","varint":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/node_modules/varint/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
}, {package:"multicodec",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@ensdomains/content-hash/node_modules/multicodec/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/rng-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/analytics-node/node_modules/uuid/lib/bytesToUuid.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypt/crypt.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/crypt/crypt.js
      return function (require, module, exports) {
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

      };
    };
  }
}, {package:"crypt",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crypt/crypt.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/charenc/charenc.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/charenc/charenc.js
      return function (require, module, exports) {
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

      };
    };
  }
}, {package:"charenc",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/charenc/charenc.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-type/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/component-type/index.js
      return function (require, module, exports) {
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  if (isBuffer(val)) return 'buffer';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val);

  return typeof val;
};

// code borrowed from https://github.com/feross/is-buffer/blob/master/index.js
function isBuffer(obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

      };
    };
  }
}, {package:"component-type",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-type/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/join-component/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/join-component/index.js
      return function (require, module, exports) {

/**
 * Join `arr` with the trailing `str` defaulting to "and",
 * and `sep` string defaulting to ", ".
 *
 * @param {Array} arr
 * @param {String} str
 * @param {String} sep
 * @return {String}
 * @api public
 */

module.exports = function(arr, str, sep){
  str = str || 'and';
  sep = sep || ', ';

  if (arr.length < 2) return arr[0] || '';

  var oxford = str.slice(0, 2) === sep;

  if (!oxford) {
    str = ' ' + str;
  } else if (arr.length == 2) {
    str = str.slice(1);
  }

  return arr.slice(0, -1).join(sep) + str + ' ' + arr[arr.length - 1];
};

      };
    };
  }
}, {package:"join-component",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/join-component/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/lib/index.js", {"is-retry-allowed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-retry-allowed/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/lib/index.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNetworkError = isNetworkError;
exports.isRetryableError = isRetryableError;
exports.isSafeRequestError = isSafeRequestError;
exports.isIdempotentRequestError = isIdempotentRequestError;
exports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
exports.exponentialDelay = exponentialDelay;
exports.default = axiosRetry;

var _isRetryAllowed = require('is-retry-allowed');

var _isRetryAllowed2 = _interopRequireDefault(_isRetryAllowed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var namespace = 'axios-retry';

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkError(error) {
  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests
  error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests
  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors
}

var SAFE_HTTP_METHODS = ['get', 'head', 'options'];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isRetryableError(error) {
  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isSafeRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isIdempotentRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}

/**
 * @return {number} - delay in milliseconds, always 0
 */
function noDelay() {
  return 0;
}

/**
 * @param  {number} [retryNumber=0]
 * @return {number} - delay in milliseconds
 */
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  var delay = Math.pow(2, retryNumber) * 100;
  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay
  return delay + randomSum;
}

/**
 * Initializes and returns the retry state for the given request/config
 * @param  {AxiosRequestConfig} config
 * @return {Object}
 */
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  config[namespace] = currentState;
  return currentState;
}

/**
 * Returns the axios-retry options for the current request
 * @param  {AxiosRequestConfig} config
 * @param  {AxiosRetryConfig} defaultOptions
 * @return {AxiosRetryConfig}
 */
function getRequestOptions(config, defaultOptions) {
  return Object.assign({}, defaultOptions, config[namespace]);
}

/**
 * @param  {Axios} axios
 * @param  {AxiosRequestConfig} config
 */
function fixConfig(axios, config) {
  if (axios.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}

/**
 * Adds response interceptors to an axios instance to retry requests failed due to network issues
 *
 * @example
 *
 * import axios from 'axios';
 *
 * axiosRetry(axios, { retries: 3 });
 *
 * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Exponential back-off retry delay between requests
 * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});
 *
 * // Custom retry delay
 * axiosRetry(axios, { retryDelay : (retryCount) => {
 *   return retryCount * 1000;
 * }});
 *
 * // Also works with custom axios instances
 * const client = axios.create({ baseURL: 'http://example.com' });
 * axiosRetry(client, { retries: 3 });
 *
 * client.get('/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Allows request-specific configuration
 * client
 *   .get('/test', {
 *     'axios-retry': {
 *       retries: 0
 *     }
 *   })
 *   .catch(error => { // The first request fails
 *     error !== undefined
 *   });
 *
 * @param {Axios} axios An axios instance (the axios object or one created from axios.create)
 * @param {Object} [defaultOptions]
 * @param {number} [defaultOptions.retries=3] Number of retries
 * @param {boolean} [defaultOptions.shouldResetTimeout=false]
 *        Defines if the timeout should be reset between retries
 * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]
 *        A function to determine if the error can be retried
 * @param {Function} [defaultOptions.retryDelay=noDelay]
 *        A function to determine the delay between retry requests
 */
function axiosRetry(axios, defaultOptions) {
  axios.interceptors.request.use(function (config) {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  });

  axios.interceptors.response.use(null, function (error) {
    var config = error.config;

    // If we have no information to retry the request
    if (!config) {
      return Promise.reject(error);
    }

    var _getRequestOptions = getRequestOptions(config, defaultOptions),
        _getRequestOptions$re = _getRequestOptions.retries,
        retries = _getRequestOptions$re === undefined ? 3 : _getRequestOptions$re,
        _getRequestOptions$re2 = _getRequestOptions.retryCondition,
        retryCondition = _getRequestOptions$re2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2,
        _getRequestOptions$re3 = _getRequestOptions.retryDelay,
        retryDelay = _getRequestOptions$re3 === undefined ? noDelay : _getRequestOptions$re3,
        _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout,
        shouldResetTimeout = _getRequestOptions$sh === undefined ? false : _getRequestOptions$sh;

    var currentState = getCurrentState(config);

    var shouldRetry = retryCondition(error) && currentState.retryCount < retries;

    if (shouldRetry) {
      currentState.retryCount += 1;
      var delay = retryDelay(currentState.retryCount, error);

      // Axios fails merging this configuration to the default configuration because it has an issue
      // with circular structures: https://github.com/mzabriskie/axios/issues/370
      fixConfig(axios, config);

      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
        var lastRequestDuration = Date.now() - currentState.lastRequestTime;
        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)
        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);
      }

      config.transformRequest = [function (data) {
        return data;
      }];

      return new Promise(function (resolve) {
        return setTimeout(function () {
          return resolve(axios(config));
        }, delay);
      });
    }

    return Promise.reject(error);
  });
}

// Compatibility with CommonJS
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
axiosRetry.isRetryableError = isRetryableError;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"axios-retry",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios-retry/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/axios.js", {"./cancel/Cancel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/Cancel.js","./cancel/CancelToken":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/CancelToken.js","./cancel/isCancel":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/cancel/isCancel.js","./core/Axios":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/Axios.js","./core/mergeConfig":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/core/mergeConfig.js","./defaults":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/defaults.js","./helpers/bind":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/bind.js","./helpers/isAxiosError":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/isAxiosError.js","./helpers/spread":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/helpers/spread.js","./utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/axios.js
      return function (require, module, exports) {
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

      };
    };
  }
}, {package:"axios",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/axios/lib/axios.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/constants.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/constants.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
var BN = require("bn.js");
/**
 * The max integer that this VM can handle
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
/**
 * 2^256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
/**
 * Keccak-256 hash of null
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
/**
 * Keccak-256 of an RLP of an empty array
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
/**
 * Keccak-256 hash of the RLP of null
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/account.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js","./hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js","./secp256k1v3-adapter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/account.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns a zero address.
 */
exports.zeroAddress = function () {
    var addressLength = 20;
    var addr = bytes_1.zeros(addressLength);
    return bytes_1.bufferToHex(addr);
};
/**
 * Checks if the address is a valid. Accepts checksummed addresses too.
 */
exports.isValidAddress = function (address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
};
/**
 * Checks if a given address is a zero address.
 */
exports.isZeroAddress = function (address) {
    var zeroAddr = exports.zeroAddress();
    return zeroAddr === bytes_1.addHexPrefix(address);
};
/**
 * Returns a checksummed address.
 *
 * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This
 * has the effect of checksummed addresses for one chain having invalid checksums for others.
 * For more details, consult EIP-1191.
 *
 * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly
 * used variation in Ethereum was without the chainId. This may change in the future.
 */
exports.toChecksumAddress = function (address, eip1191ChainId) {
    address = ethjsUtil.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';
    var hash = hash_1.keccak(prefix + address).toString('hex');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
/**
 * Checks if the address is a valid checksummed address.
 *
 * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.
 */
exports.isValidChecksumAddress = function (address, eip1191ChainId) {
    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
};
/**
 * Generates an address of a newly created contract.
 * @param from The address which is creating this new address
 * @param nonce The nonce of the from account
 */
exports.generateAddress = function (from, nonce) {
    from = bytes_1.toBuffer(from);
    var nonceBN = new BN(nonce);
    if (nonceBN.isZero()) {
        // in RLP we want to encode null in the case of zero nonce
        // read the RLP documentation for an answer if you dare
        return hash_1.rlphash([from, null]).slice(-20);
    }
    // Only take the lower 160bits of the hash
    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
};
/**
 * Generates an address for a contract created using CREATE2.
 * @param from The address which is creating this new address
 * @param salt A salt
 * @param initCode The init code of the contract being created
 */
exports.generateAddress2 = function (from, salt, initCode) {
    var fromBuf = bytes_1.toBuffer(from);
    var saltBuf = bytes_1.toBuffer(salt);
    var initCodeBuf = bytes_1.toBuffer(initCode);
    assert(fromBuf.length === 20);
    assert(saltBuf.length === 32);
    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
    return address.slice(-20);
};
/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium).
 */
exports.isPrecompiled = function (address) {
    var a = bytes_1.unpad(address);
    return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};
/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 */
exports.isValidPrivate = function (privateKey) {
    return secp256k1.privateKeyVerify(privateKey);
};
/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.isValidPublic = function (publicKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    if (publicKey.length === 64) {
        // Convert to SEC1 for secp256k1
        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
        return false;
    }
    return secp256k1.publicKeyVerify(publicKey);
};
/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param sanitize Accept public keys in other formats
 */
exports.pubToAddress = function (pubKey, sanitize) {
    if (sanitize === void 0) { sanitize = false; }
    pubKey = bytes_1.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
    }
    assert(pubKey.length === 64);
    // Only take the lower 160bits of the hash
    return hash_1.keccak(pubKey).slice(-20);
};
exports.publicToAddress = exports.pubToAddress;
/**
 * Returns the ethereum address of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToAddress = function (privateKey) {
    return exports.publicToAddress(exports.privateToPublic(privateKey));
};
/**
 * Returns the ethereum public key of a given private key.
 * @param privateKey A private key must be 256 bits wide
 */
exports.privateToPublic = function (privateKey) {
    privateKey = bytes_1.toBuffer(privateKey);
    // skip the type flag and use the X, Y points
    return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};
/**
 * Converts a public key to the Ethereum format.
 */
exports.importPublic = function (publicKey) {
    publicKey = bytes_1.toBuffer(publicKey);
    if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/account.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/signature.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js","./hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js","./secp256k1v3-adapter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/signature.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
var secp256k1 = require('./secp256k1v3-adapter');
var BN = require("bn.js");
var bytes_1 = require("./bytes");
var hash_1 = require("./hash");
/**
 * Returns the ECDSA signature of a message hash.
 */
exports.ecsign = function (msgHash, privateKey, chainId) {
    var sig = secp256k1.sign(msgHash, privateKey);
    var recovery = sig.recovery;
    var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27,
    };
    return ret;
};
/**
 * ECDSA public key recovery from signature.
 * @returns Recovered public key
 */
exports.ecrecover = function (msgHash, v, r, s, chainId) {
    var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
/**
 * Convert signature parameters into the format of `eth_sign` RPC method.
 * @returns Signature
 */
exports.toRpcSig = function (v, r, s, chainId) {
    var recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
        throw new Error('Invalid signature v value');
    }
    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
    return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
};
/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 */
exports.fromRpcSig = function (sig) {
    var buf = bytes_1.toBuffer(sig);
    // NOTE: with potential introduction of chainId this might need to be updated
    if (buf.length !== 65) {
        throw new Error('Invalid signature length');
    }
    var v = buf[64];
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64),
    };
};
/**
 * Validate a ECDSA signature.
 * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one
 */
exports.isValidSignature = function (v, r, s, homesteadOrLater, chainId) {
    if (homesteadOrLater === void 0) { homesteadOrLater = true; }
    var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
    var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);
    if (r.length !== 32 || s.length !== 32) {
        return false;
    }
    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
    }
    var rBN = new BN(r);
    var sBN = new BN(s);
    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
    }
    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
    }
    return true;
};
/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 */
exports.hashPersonalMessage = function (message) {
    var prefix = Buffer.from("\u0019Ethereum Signed Message:\n" + message.length.toString(), 'utf-8');
    return hash_1.keccak(Buffer.concat([prefix, message]));
};
function calculateSigRecovery(v, chainId) {
    return chainId ? v - (2 * chainId + 35) : v - 27;
}
function isValidSigRecovery(recovery) {
    return recovery === 0 || recovery === 1;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/signature.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js", {"bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
var ethjsUtil = require('ethjs-util');
var BN = require("bn.js");
/**
 * Returns a buffer filled with 0s.
 * @param bytes the number of bytes the buffer should be
 */
exports.zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @param right whether to start padding form the left or right
 * @return (Buffer|Array)
 */
exports.setLengthLeft = function (msg, length, right) {
    if (right === void 0) { right = false; }
    var buf = exports.zeros(length);
    msg = exports.toBuffer(msg);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
exports.setLength = exports.setLengthLeft;
/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param msg the value to pad (Buffer|Array)
 * @param length the number of bytes the output should be
 * @return (Buffer|Array)
 */
exports.setLengthRight = function (msg, length) {
    return exports.setLength(msg, length, true);
};
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
exports.unpad = function (a) {
    a = ethjsUtil.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = exports.unpad;
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
exports.toBuffer = function (v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjsUtil.isHexString(v)) {
                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjsUtil.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (BN.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
};
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
    return new BN(exports.toBuffer(buf)).toNumber();
};
/**
 * Converts a `Buffer` into a `0x`-prefixed hex `String`.
 * @param buf `Buffer` object to convert
 */
exports.bufferToHex = function (buf) {
    buf = exports.toBuffer(buf);
    return '0x' + buf.toString('hex');
};
/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param num Signed integer value
 */
exports.fromSigned = function (num) {
    return new BN(num).fromTwos(256);
};
/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param num
 */
exports.toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
exports.addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjsUtil.isHexPrefixed(str) ? str : '0x' + str;
};
/**
 * Converts a `Buffer` or `Array` to JSON.
 * @param ba (Buffer|Array)
 * @return (Array|String|null)
 */
exports.baToJSON = function (ba) {
    if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString('hex');
    }
    else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
            array.push(exports.baToJSON(ba[i]));
        }
        return array;
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/object.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js","assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/object.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineProperties = void 0;
var assert = require('assert');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param self the `Object` to define properties on
 * @param fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param data data to be validated against the definitions
 * @deprecated
 */
exports.defineProperties = function (self, fields, data) {
    self.raw = [];
    self._fields = [];
    // attach the `toJSON`
    self.toJSON = function (label) {
        if (label === void 0) { label = false; }
        if (label) {
            var obj_1 = {};
            self._fields.forEach(function (field) {
                obj_1[field] = "0x" + self[field].toString('hex');
            });
            return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
    };
    self.serialize = function serialize() {
        return rlp.encode(self.raw);
    };
    fields.forEach(function (field, i) {
        self._fields.push(field.name);
        function getter() {
            return self.raw[i];
        }
        function setter(v) {
            v = bytes_1.toBuffer(v);
            if (v.toString('hex') === '00' && !field.allowZero) {
                v = Buffer.allocUnsafe(0);
            }
            if (field.allowLess && field.length) {
                v = bytes_1.stripZeros(v);
                assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
            }
            else if (!(field.allowZero && v.length === 0) && field.length) {
                assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
            }
            self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
            enumerable: true,
            configurable: true,
            get: getter,
            set: setter,
        });
        if (field.default) {
            self[field.name] = field.default;
        }
        // attach alias
        if (field.alias) {
            Object.defineProperty(self, field.alias, {
                enumerable: false,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    });
    // if the constuctor is passed data
    if (data) {
        if (typeof data === 'string') {
            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');
        }
        if (Buffer.isBuffer(data)) {
            data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
            if (data.length > self._fields.length) {
                throw new Error('wrong number of fields in data');
            }
            // make sure all the items are buffers
            data.forEach(function (d, i) {
                self[self._fields[i]] = bytes_1.toBuffer(d);
            });
        }
        else if (typeof data === 'object') {
            var keys_1 = Object.keys(data);
            fields.forEach(function (field) {
                if (keys_1.indexOf(field.name) !== -1)
                    self[field.name] = data[field.name];
                if (keys_1.indexOf(field.alias) !== -1)
                    self[field.alias] = data[field.alias];
            });
        }
        else {
            throw new Error('invalid data');
        }
    }
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/object.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js", {"./bytes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/bytes.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","create-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hash/browser.js","ethereum-cryptography/keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereum-cryptography/keccak.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
var _a = require('ethereum-cryptography/keccak'), keccak224 = _a.keccak224, keccak384 = _a.keccak384, k256 = _a.keccak256, keccak512 = _a.keccak512;
var createHash = require('create-hash');
var ethjsUtil = require('ethjs-util');
var rlp = require("rlp");
var bytes_1 = require("./bytes");
/**
 * Creates Keccak hash of the input
 * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value
 * it's interpreted as hexadecimal, otherwise as utf8.
 * @param bits The Keccak width
 */
exports.keccak = function (a, bits) {
    if (bits === void 0) { bits = 256; }
    if (typeof a === 'string' && !ethjsUtil.isHexString(a)) {
        a = Buffer.from(a, 'utf8');
    }
    else {
        a = bytes_1.toBuffer(a);
    }
    if (!bits)
        bits = 256;
    switch (bits) {
        case 224: {
            return keccak224(a);
        }
        case 256: {
            return k256(a);
        }
        case 384: {
            return keccak384(a);
        }
        case 512: {
            return keccak512(a);
        }
        default: {
            throw new Error("Invald algorithm: keccak" + bits);
        }
    }
};
/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256).
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.keccak256 = function (a) {
    return exports.keccak(a);
};
/**
 * Creates SHA256 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 */
exports.sha256 = function (a) {
    a = bytes_1.toBuffer(a);
    return createHash('sha256')
        .update(a)
        .digest();
};
/**
 * Creates RIPEMD160 hash of the input.
 * @param a The input data (Buffer|Array|String|Number)
 * @param padded Whether it should be padded to 256 bits or not
 */
exports.ripemd160 = function (a, padded) {
    a = bytes_1.toBuffer(a);
    var hash = createHash('rmd160')
        .update(a)
        .digest();
    if (padded === true) {
        return bytes_1.setLength(hash, 32);
    }
    else {
        return hash;
    }
};
/**
 * Creates SHA-3 hash of the RLP encoded version of the input.
 * @param a The input data
 */
exports.rlphash = function (a) {
    return exports.keccak(rlp.encode(a));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/hash.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-hex-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-hex-prefixed/src/index.js","strip-hex-prefix":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/strip-hex-prefix/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethjs-util/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js", {"./secp256k1v3-lib/der":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js","./secp256k1v3-lib/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereum-cryptography/secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereum-cryptography/secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
var secp256k1 = require('ethereum-cryptography/secp256k1');
var secp256k1v3 = require('./secp256k1v3-lib/index');
var der = require('./secp256k1v3-lib/der');
/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
exports.privateKeyVerify = function (privateKey) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        return false;
    }
    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};
/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
exports.privateKeyExport = function (privateKey, compressed) {
    // secp256k1 v4 version throws when privateKey length is not 32
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
    return der.privateKeyExport(privateKey, publicKey, compressed);
};
/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyImport = function (privateKey) {
    // privateKeyImport method is not part of secp256k1 v4 package
    // this implementation is based on v3
    privateKey = der.privateKeyImport(privateKey);
    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
    }
    throw new Error("couldn't import from DER format");
};
/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyNegate = function (privateKey) {
    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};
/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.privateKeyModInverse = function (privateKey) {
    if (privateKey.length !== 32) {
        throw new Error('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakAdd = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
exports.privateKeyTweakMul = function (privateKey, tweak) {
    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCreate = function (privateKey, compressed) {
    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyConvert = function (publicKey, compressed) {
    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.publicKeyVerify = function (publicKey) {
    // secp256k1 v4 version throws when publicKey length is not 33 or 65
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
    }
    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};
/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.publicKeyCombine = function (publicKeys, compressed) {
    var keys = [];
    publicKeys.forEach(function (publicKey) {
        keys.push(Uint8Array.from(publicKey));
    });
    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};
/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureNormalize = function (signature) {
    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};
/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureExport = function (signature) {
    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImport = function (signature) {
    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};
/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
exports.signatureImportLax = function (signature) {
    // signatureImportLax method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure that signature is greater than 0
    if (signature.length === 0) {
        throw new RangeError('signature length is invalid');
    }
    var sigObj = der.signatureImportLax(signature);
    if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
    }
    return secp256k1v3.signatureImport(sigObj);
};
/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
exports.sign = function (message, privateKey, options) {
    if (options === null) {
        throw new TypeError('options should be an Object');
    }
    var signOptions = undefined;
    if (options) {
        signOptions = {};
        if (options.data === null) {
            // validate option.data length
            throw new TypeError('options.data should be a Buffer');
        }
        if (options.data) {
            if (options.data.length != 32) {
                throw new RangeError('options.data length is invalid');
            }
            signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
            throw new TypeError('options.noncefn should be a Function');
        }
        if (options.noncefn) {
            // convert option.noncefn function signature
            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
                var bufferAlgo = algo != null ? Buffer.from(algo) : null;
                var bufferData = data != null ? Buffer.from(data) : null;
                var buffer = Buffer.from('');
                if (options.noncefn) {
                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
                }
                return new Uint8Array(buffer);
            };
        }
    }
    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid,
    };
};
/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
exports.verify = function (message, signature, publicKey) {
    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};
/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
exports.recover = function (message, signature, recid, compressed) {
    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};
/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
exports.ecdh = function (publicKey, privateKey) {
    // note: secp256k1 v3 doesn't allow optional parameter
    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
    // ecdhUnsafe method is not part of secp256k1 v4 package
    // this implementation is based on v3
    // ensure valid publicKey length
    if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError('public key length is invalid');
    }
    // ensure valid privateKey length
    if (privateKey.length !== 32) {
        throw new RangeError('private key length is invalid');
    }
    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js
      return function (require, module, exports) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/rng-browser.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js
      return function (require, module, exports) {
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

      };
    };
  }
}, {package:"uuid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-wallet/node_modules/uuid/lib/bytesToUuid.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createEventEmitterProxy.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createEventEmitterProxy.js
      return function (require, module, exports) {
const filterNoop = () => true
const internalEvents = ['newListener', 'removeListener']
const externalEventFilter = (name) => !internalEvents.includes(name)

module.exports = function createEventEmitterProxy (initialTarget, opts) {
  // parse options
  opts = opts || {}
  let eventFilter = opts.eventFilter || filterNoop
  if (eventFilter === 'skipInternal') eventFilter = externalEventFilter
  if (typeof eventFilter !== 'function') throw new Error('createEventEmitterProxy - Invalid eventFilter')

  let target = initialTarget

  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === 'setTarget') return setTarget
      return target[name]
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === 'setTarget') {
        setTarget = value
        return true
      }
      target[name] = value
      return true
    },
  })

  return proxy

  function setTarget(newTarget) {
    const oldTarget = target
    target = newTarget
    // migrate listeners
    oldTarget.eventNames().filter(eventFilter).forEach((name) => {
      getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler))
    })
    // remove old
    oldTarget.removeAllListeners()
  }
}

function getRawListeners(eventEmitter, name) {
  // prefer native
  if (eventEmitter.rawListeners) return eventEmitter.rawListeners(name)
  // fallback to lookup against internal object
  let events = eventEmitter._events[name] || []
  // ensure array
  if (!Array.isArray(events)) events = [events]
  // return copy
  return events.slice()
}

      };
    };
  }
}, {package:"swappable-obj-proxy",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createEventEmitterProxy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createSwappableProxy.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createSwappableProxy.js
      return function (require, module, exports) {

module.exports = function createSwappableProxy (initialTarget) {
  let target = initialTarget

  const proxy = new Proxy({}, {
    get: (_, name) => {
      // override `setTarget` access
      if (name === 'setTarget') return setTarget
      return target[name]
    },
    set: (_, name, value) => {
      // allow `setTarget` overrides
      if (name === 'setTarget') {
        setTarget = value
        return true
      }
      target[name] = value
      return true
    },
  })

  return proxy

  function setTarget(newTarget) {
    target = newTarget
  }
}

      };
    };
  }
}, {package:"swappable-obj-proxy",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/swappable-obj-proxy/src/createSwappableProxy.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/index.js", {"./BaseBlockTracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/BaseBlockTracker.js","./PollingBlockTracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/PollingBlockTracker.js","./SubscribeBlockTracker":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./BaseBlockTracker"), exports);
__exportStar(require("./PollingBlockTracker"), exports);
__exportStar(require("./SubscribeBlockTracker"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"eth-block-tracker",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-block-tracker/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/node_modules/bs58/lib/bs58.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/node_modules/bs58/lib/bs58.js
      return function (require, module, exports) {
// Base58 encoding/decoding
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var ALPHABET_MAP = {}
for(var i = 0; i < ALPHABET.length; i++) {
  ALPHABET_MAP[ALPHABET.charAt(i)] = i
}
var BASE = 58

function encode(buffer) {
  if (buffer.length === 0) return ''

  var i, j, digits = [0]
  for (i = 0; i < buffer.length; i++) {
    for (j = 0; j < digits.length; j++) digits[j] <<= 8

    digits[0] += buffer[i]

    var carry = 0
    for (j = 0; j < digits.length; ++j) {
      digits[j] += carry

      carry = (digits[j] / BASE) | 0
      digits[j] %= BASE
    }

    while (carry) {
      digits.push(carry % BASE)

      carry = (carry / BASE) | 0
    }
  }

  // deal with leading zeros
  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0)

  // convert digits to a string
  var stringOutput = ""
  for (var i = digits.length - 1; i >= 0; i--) {
    stringOutput = stringOutput + ALPHABET[digits[i]]
  }
  return stringOutput
}

function decode(string) {
  if (string.length === 0) return []

  var i, j, bytes = [0]
  for (i = 0; i < string.length; i++) {
    var c = string[i]
    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character')

    for (j = 0; j < bytes.length; j++) bytes[j] *= BASE
    bytes[0] += ALPHABET_MAP[c]

    var carry = 0
    for (j = 0; j < bytes.length; ++j) {
      bytes[j] += carry

      carry = bytes[j] >> 8
      bytes[j] &= 0xff
    }

    while (carry) {
      bytes.push(carry & 0xff)

      carry >>= 8
    }
  }

  // deal with leading zeros
  for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0)

  return bytes.reverse()
}

module.exports = {
  encode: encode,
  decode: decode
}

      };
    };
  }
}, {package:"bs58",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/coinstring/node_modules/bs58/lib/bs58.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/misc.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/misc.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/misc.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/params.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/params.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/params.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/account.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/account.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/account.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/management.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/management.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/management.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/bitcoin.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/bitcoin.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/bitcoin.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/binance.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/binance.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/binance.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/coinInfo.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/coinInfo.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/coinInfo.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/eos.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/eos.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/eos.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ethereum.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ethereum.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ethereum.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ripple.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ripple.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ripple.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/stellar.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/stellar.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/stellar.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/nem.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/nem.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/nem.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/tezos.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/tezos.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/tezos.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/transactions.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/transactions.js
      return function (require, module, exports) {
"use strict";
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/transactions.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/cardano.js", {"../trezor/protobuf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/protobuf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/cardano.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CardanoTxWitnessType = exports.CardanoTxSigningMode = exports.CardanoPoolRelayType = exports.CardanoNativeScriptHashDisplayFormat = exports.CardanoNativeScriptType = exports.CardanoCertificateType = exports.CardanoAddressType = void 0;

var _protobuf = require("../trezor/protobuf");

exports.CardanoAddressType = _protobuf.Enum_CardanoAddressType;
exports.CardanoCertificateType = _protobuf.Enum_CardanoCertificateType;
exports.CardanoNativeScriptType = _protobuf.Enum_CardanoNativeScriptType;
exports.CardanoNativeScriptHashDisplayFormat = _protobuf.Enum_CardanoNativeScriptHashDisplayFormat;
exports.CardanoPoolRelayType = _protobuf.Enum_CardanoPoolRelayType;
exports.CardanoTxSigningMode = _protobuf.Enum_CardanoTxSigningMode;
exports.CardanoTxWitnessType = _protobuf.Enum_CardanoTxWitnessType;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/cardano.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/api.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js","./account":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/account.js","./backend/blockchain":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/blockchain.js","./events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/events.js","./misc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/misc.js","./networks/binance":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/binance.js","./networks/bitcoin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/bitcoin.js","./networks/cardano":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/cardano.js","./networks/coinInfo":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/coinInfo.js","./networks/eos":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/eos.js","./networks/ethereum":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ethereum.js","./networks/nem":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/nem.js","./networks/ripple":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/ripple.js","./networks/stellar":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/stellar.js","./networks/tezos":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/networks/tezos.js","./params":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/params.js","./trezor/device":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/device.js","./trezor/management":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/management.js","./trezor/protobuf":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/protobuf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/api.js
      return function (require, module, exports) {
"use strict";

var CONSTANTS = _interopRequireWildcard(require("../constants"));

var P = _interopRequireWildcard(require("./params"));

var Device = _interopRequireWildcard(require("./trezor/device"));

var Mgmnt = _interopRequireWildcard(require("./trezor/management"));

var Protobuf = _interopRequireWildcard(require("./trezor/protobuf"));

var Account = _interopRequireWildcard(require("./account"));

var Bitcoin = _interopRequireWildcard(require("./networks/bitcoin"));

var Binance = _interopRequireWildcard(require("./networks/binance"));

var Cardano = _interopRequireWildcard(require("./networks/cardano"));

var CoinInfo = _interopRequireWildcard(require("./networks/coinInfo"));

var EOS = _interopRequireWildcard(require("./networks/eos"));

var Ethereum = _interopRequireWildcard(require("./networks/ethereum"));

var NEM = _interopRequireWildcard(require("./networks/nem"));

var Ripple = _interopRequireWildcard(require("./networks/ripple"));

var Stellar = _interopRequireWildcard(require("./networks/stellar"));

var Tezos = _interopRequireWildcard(require("./networks/tezos"));

var Misc = _interopRequireWildcard(require("./misc"));

var Events = _interopRequireWildcard(require("./events"));

var Blockchain = _interopRequireWildcard(require("./backend/blockchain"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/api.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/events.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/events.js
      return function (require, module, exports) {
"use strict";

var _constants = require("../constants");
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/events.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/device.js", {"../../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/device.js
      return function (require, module, exports) {
"use strict";

var _constants = require("../../constants");
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/trezor/device.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/blockchain.js", {"../../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/blockchain.js
      return function (require, module, exports) {
"use strict";

var _constants = require("../../constants");
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/types/backend/blockchain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/blockchain.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/blockchain.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.FIAT_RATES_UPDATE = exports.NOTIFICATION = exports.BLOCK = exports.CONNECT = exports.ERROR = void 0;
// blockchain events
var ERROR = 'blockchain-error';
exports.ERROR = ERROR;
var CONNECT = 'blockchain-connect';
exports.CONNECT = CONNECT;
var BLOCK = 'blockchain-block';
exports.BLOCK = BLOCK;
var NOTIFICATION = 'blockchain-notification';
exports.NOTIFICATION = NOTIFICATION;
var FIAT_RATES_UPDATE = 'fiat-rates-update';
exports.FIAT_RATES_UPDATE = FIAT_RATES_UPDATE;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/blockchain.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/device.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/device.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.WAIT_FOR_SELECTION = exports.WORD = exports.PASSPHRASE_ON_DEVICE = exports.PASSPHRASE = exports.PIN = exports.BUTTON = exports.LOADING = exports.USED_ELSEWHERE = exports.RELEASED = exports.ACQUIRED = exports.RELEASE = exports.ACQUIRE = exports.CHANGED = exports.DISCONNECT = exports.CONNECT_UNACQUIRED = exports.CONNECT = void 0;
// device list events
var CONNECT = 'device-connect';
exports.CONNECT = CONNECT;
var CONNECT_UNACQUIRED = 'device-connect_unacquired';
exports.CONNECT_UNACQUIRED = CONNECT_UNACQUIRED;
var DISCONNECT = 'device-disconnect';
exports.DISCONNECT = DISCONNECT;
var CHANGED = 'device-changed';
exports.CHANGED = CHANGED;
var ACQUIRE = 'device-acquire';
exports.ACQUIRE = ACQUIRE;
var RELEASE = 'device-release';
exports.RELEASE = RELEASE;
var ACQUIRED = 'device-acquired';
exports.ACQUIRED = ACQUIRED;
var RELEASED = 'device-released';
exports.RELEASED = RELEASED;
var USED_ELSEWHERE = 'device-used_elsewhere';
exports.USED_ELSEWHERE = USED_ELSEWHERE;
var LOADING = 'device-loading'; // trezor-link events in protobuf format

exports.LOADING = LOADING;
var BUTTON = 'button';
exports.BUTTON = BUTTON;
var PIN = 'pin';
exports.PIN = PIN;
var PASSPHRASE = 'passphrase';
exports.PASSPHRASE = PASSPHRASE;
var PASSPHRASE_ON_DEVICE = 'passphrase_on_device';
exports.PASSPHRASE_ON_DEVICE = PASSPHRASE_ON_DEVICE;
var WORD = 'word'; // custom

exports.WORD = WORD;
var WAIT_FOR_SELECTION = 'device-wait_for_selection';
exports.WAIT_FOR_SELECTION = WAIT_FOR_SELECTION;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/device.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/iframe.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/iframe.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CALL = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
// Message called from iframe.html inline script before "window.onload" event. This is first message from iframe to window.opener.
var BOOTSTRAP = 'iframe-bootstrap'; // Message from iframe.js to window.opener, called after "window.onload" event. This is second message from iframe to window.opener.

exports.BOOTSTRAP = BOOTSTRAP;
var LOADED = 'iframe-loaded'; // Message from window.opener to iframe.js

exports.LOADED = LOADED;
var INIT = 'iframe-init'; // Error message from iframe.js to window.opener. Could be thrown during iframe initialization process

exports.INIT = INIT;
var ERROR = 'iframe-error'; // Message from window.opener to iframe. Call method

exports.ERROR = ERROR;
var CALL = 'iframe-call';
exports.CALL = CALL;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/iframe.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/network.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/network.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.TYPES = void 0;
var TYPES = Object.freeze({
  bitcoin: 'Bitcoin',
  ethereum: 'Ethereum',
  eos: 'Eos',
  nem: 'NEM',
  stellar: 'Stellar',
  cardano: 'Cardano',
  ripple: 'Ripple',
  tezos: 'Tezors',
  binance: 'Binance'
});
exports.TYPES = TYPES;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/network.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/popup.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/popup.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.CLOSE_WINDOW = exports.CANCEL_POPUP_REQUEST = exports.CLOSED = exports.HANDSHAKE = exports.EXTENSION_USB_PERMISSIONS = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
// Message called from popup.html inline script before "window.onload" event. This is first message from popup to window.opener.
var BOOTSTRAP = 'popup-bootstrap'; // Message from popup.js to window.opener, called after "window.onload" event. This is second message from popup to window.opener.

exports.BOOTSTRAP = BOOTSTRAP;
var LOADED = 'popup-loaded'; // Message from window.opener to popup.js. Send settings to popup. This is first message from window.opener to popup.

exports.LOADED = LOADED;
var INIT = 'popup-init'; // Error message from popup to window.opener. Could be thrown during popup initialization process (POPUP.INIT)

exports.INIT = INIT;
var ERROR = 'popup-error'; // Message to webextensions, opens "trezor-usb-permission.html" within webextension

exports.ERROR = ERROR;
var EXTENSION_USB_PERMISSIONS = 'open-usb-permissions'; // Message called from both [popup > iframe] then [iframe > popup] in this exact order.
// Firstly popup call iframe to resolve popup promise in Core
// Then iframe reacts to POPUP.HANDSHAKE message and sends ConnectSettings, transport information and requested method details back to popup

exports.EXTENSION_USB_PERMISSIONS = EXTENSION_USB_PERMISSIONS;
var HANDSHAKE = 'popup-handshake'; // Event emitted from PopupManager at the end of popup closing process.
// Sent from popup thru window.opener to an iframe because message channel between popup and iframe is no longer available

exports.HANDSHAKE = HANDSHAKE;
var CLOSED = 'popup-closed'; // Message called from iframe to popup, it means that popup will not be needed (example: Blockchain methods are not using popup at all)
// This will close active popup window and/or clear opening process in PopupManager (maybe popup wasn't opened yet)

exports.CLOSED = CLOSED;
var CANCEL_POPUP_REQUEST = 'ui-cancel-popup-request'; // Message called from inline element in popup.html (window.closeWindow), this is used only with webextensions to properly handle popup close event

exports.CANCEL_POPUP_REQUEST = CANCEL_POPUP_REQUEST;
var CLOSE_WINDOW = 'window.close';
exports.CLOSE_WINDOW = CLOSE_WINDOW;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/popup.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/transport.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/transport.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.START_PENDING = exports.DISABLE_WEBUSB = exports.REQUEST = exports.STREAM = exports.UPDATE = exports.ERROR = exports.START = void 0;
var START = 'transport-start';
exports.START = START;
var ERROR = 'transport-error';
exports.ERROR = ERROR;
var UPDATE = 'transport-update';
exports.UPDATE = UPDATE;
var STREAM = 'transport-stream';
exports.STREAM = STREAM;
var REQUEST = 'transport-request_device';
exports.REQUEST = REQUEST;
var DISABLE_WEBUSB = 'transport-disable_webusb';
exports.DISABLE_WEBUSB = DISABLE_WEBUSB;
var START_PENDING = 'transport-start_pending';
exports.START_PENDING = START_PENDING;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/transport.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/ui.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/ui.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.IFRAME_FAILURE = exports.ADDRESS_VALIDATION = exports.BUNDLE_PROGRESS = exports.LOGIN_CHALLENGE_RESPONSE = exports.LOGIN_CHALLENGE_REQUEST = exports.CUSTOM_MESSAGE_RESPONSE = exports.CUSTOM_MESSAGE_REQUEST = exports.CHANGE_SETTINGS = exports.RECEIVE_WORD = exports.RECEIVE_FEE = exports.RECEIVE_ACCOUNT = exports.CHANGE_ACCOUNT = exports.RECEIVE_DEVICE = exports.RECEIVE_PASSPHRASE = exports.RECEIVE_PIN = exports.RECEIVE_CONFIRMATION = exports.RECEIVE_PERMISSION = exports.REQUEST_WORD = exports.REQUEST_BUTTON = exports.INSUFFICIENT_FUNDS = exports.UPDATE_CUSTOM_FEE = exports.SELECT_FEE = exports.SELECT_ACCOUNT = exports.SELECT_DEVICE = exports.SET_OPERATION = exports.LOADING = exports.CONNECT = exports.INVALID_PASSPHRASE_ACTION = exports.INVALID_PASSPHRASE = exports.REQUEST_PASSPHRASE_ON_DEVICE = exports.REQUEST_PASSPHRASE = exports.INVALID_PIN = exports.REQUEST_PIN = exports.REQUEST_CONFIRMATION = exports.REQUEST_PERMISSION = exports.CLOSE_UI_WINDOW = exports.REQUEST_UI_WINDOW = exports.DEVICE_NEEDS_BACKUP = exports.FIRMWARE_PROGRESS = exports.FIRMWARE_NOT_INSTALLED = exports.FIRMWARE_NOT_COMPATIBLE = exports.FIRMWARE_NOT_SUPPORTED = exports.FIRMWARE_OUTDATED = exports.FIRMWARE_OLD = exports.SEEDLESS = exports.INITIALIZE = exports.REQUIRE_MODE = exports.NOT_IN_BOOTLOADER = exports.BOOTLOADER = exports.TRANSPORT = void 0;
var TRANSPORT = 'ui-no_transport';
exports.TRANSPORT = TRANSPORT;
var BOOTLOADER = 'ui-device_bootloader_mode';
exports.BOOTLOADER = BOOTLOADER;
var NOT_IN_BOOTLOADER = 'ui-device_not_in_bootloader_mode';
exports.NOT_IN_BOOTLOADER = NOT_IN_BOOTLOADER;
var REQUIRE_MODE = 'ui-device_require_mode';
exports.REQUIRE_MODE = REQUIRE_MODE;
var INITIALIZE = 'ui-device_not_initialized';
exports.INITIALIZE = INITIALIZE;
var SEEDLESS = 'ui-device_seedless';
exports.SEEDLESS = SEEDLESS;
var FIRMWARE_OLD = 'ui-device_firmware_old';
exports.FIRMWARE_OLD = FIRMWARE_OLD;
var FIRMWARE_OUTDATED = 'ui-device_firmware_outdated';
exports.FIRMWARE_OUTDATED = FIRMWARE_OUTDATED;
var FIRMWARE_NOT_SUPPORTED = 'ui-device_firmware_unsupported';
exports.FIRMWARE_NOT_SUPPORTED = FIRMWARE_NOT_SUPPORTED;
var FIRMWARE_NOT_COMPATIBLE = 'ui-device_firmware_not_compatible';
exports.FIRMWARE_NOT_COMPATIBLE = FIRMWARE_NOT_COMPATIBLE;
var FIRMWARE_NOT_INSTALLED = 'ui-device_firmware_not_installed';
exports.FIRMWARE_NOT_INSTALLED = FIRMWARE_NOT_INSTALLED;
var FIRMWARE_PROGRESS = 'ui-firmware-progress';
exports.FIRMWARE_PROGRESS = FIRMWARE_PROGRESS;
var DEVICE_NEEDS_BACKUP = 'ui-device_needs_backup';
exports.DEVICE_NEEDS_BACKUP = DEVICE_NEEDS_BACKUP;
var REQUEST_UI_WINDOW = 'ui-request_window';
exports.REQUEST_UI_WINDOW = REQUEST_UI_WINDOW;
var CLOSE_UI_WINDOW = 'ui-close_window';
exports.CLOSE_UI_WINDOW = CLOSE_UI_WINDOW;
var REQUEST_PERMISSION = 'ui-request_permission';
exports.REQUEST_PERMISSION = REQUEST_PERMISSION;
var REQUEST_CONFIRMATION = 'ui-request_confirmation';
exports.REQUEST_CONFIRMATION = REQUEST_CONFIRMATION;
var REQUEST_PIN = 'ui-request_pin';
exports.REQUEST_PIN = REQUEST_PIN;
var INVALID_PIN = 'ui-invalid_pin';
exports.INVALID_PIN = INVALID_PIN;
var REQUEST_PASSPHRASE = 'ui-request_passphrase';
exports.REQUEST_PASSPHRASE = REQUEST_PASSPHRASE;
var REQUEST_PASSPHRASE_ON_DEVICE = 'ui-request_passphrase_on_device';
exports.REQUEST_PASSPHRASE_ON_DEVICE = REQUEST_PASSPHRASE_ON_DEVICE;
var INVALID_PASSPHRASE = 'ui-invalid_passphrase';
exports.INVALID_PASSPHRASE = INVALID_PASSPHRASE;
var INVALID_PASSPHRASE_ACTION = 'ui-invalid_passphrase_action';
exports.INVALID_PASSPHRASE_ACTION = INVALID_PASSPHRASE_ACTION;
var CONNECT = 'ui-connect';
exports.CONNECT = CONNECT;
var LOADING = 'ui-loading';
exports.LOADING = LOADING;
var SET_OPERATION = 'ui-set_operation';
exports.SET_OPERATION = SET_OPERATION;
var SELECT_DEVICE = 'ui-select_device';
exports.SELECT_DEVICE = SELECT_DEVICE;
var SELECT_ACCOUNT = 'ui-select_account';
exports.SELECT_ACCOUNT = SELECT_ACCOUNT;
var SELECT_FEE = 'ui-select_fee';
exports.SELECT_FEE = SELECT_FEE;
var UPDATE_CUSTOM_FEE = 'ui-update_custom_fee';
exports.UPDATE_CUSTOM_FEE = UPDATE_CUSTOM_FEE;
var INSUFFICIENT_FUNDS = 'ui-insufficient_funds';
exports.INSUFFICIENT_FUNDS = INSUFFICIENT_FUNDS;
var REQUEST_BUTTON = 'ui-button';
exports.REQUEST_BUTTON = REQUEST_BUTTON;
var REQUEST_WORD = 'ui-request_word';
exports.REQUEST_WORD = REQUEST_WORD;
var RECEIVE_PERMISSION = 'ui-receive_permission';
exports.RECEIVE_PERMISSION = RECEIVE_PERMISSION;
var RECEIVE_CONFIRMATION = 'ui-receive_confirmation';
exports.RECEIVE_CONFIRMATION = RECEIVE_CONFIRMATION;
var RECEIVE_PIN = 'ui-receive_pin';
exports.RECEIVE_PIN = RECEIVE_PIN;
var RECEIVE_PASSPHRASE = 'ui-receive_passphrase';
exports.RECEIVE_PASSPHRASE = RECEIVE_PASSPHRASE;
var RECEIVE_DEVICE = 'ui-receive_device';
exports.RECEIVE_DEVICE = RECEIVE_DEVICE;
var CHANGE_ACCOUNT = 'ui-change_account';
exports.CHANGE_ACCOUNT = CHANGE_ACCOUNT;
var RECEIVE_ACCOUNT = 'ui-receive_account';
exports.RECEIVE_ACCOUNT = RECEIVE_ACCOUNT;
var RECEIVE_FEE = 'ui-receive_fee';
exports.RECEIVE_FEE = RECEIVE_FEE;
var RECEIVE_WORD = 'ui-receive_word';
exports.RECEIVE_WORD = RECEIVE_WORD;
var CHANGE_SETTINGS = 'ui-change_settings';
exports.CHANGE_SETTINGS = CHANGE_SETTINGS;
var CUSTOM_MESSAGE_REQUEST = 'ui-custom_request';
exports.CUSTOM_MESSAGE_REQUEST = CUSTOM_MESSAGE_REQUEST;
var CUSTOM_MESSAGE_RESPONSE = 'ui-custom_response';
exports.CUSTOM_MESSAGE_RESPONSE = CUSTOM_MESSAGE_RESPONSE;
var LOGIN_CHALLENGE_REQUEST = 'ui-login_challenge_request';
exports.LOGIN_CHALLENGE_REQUEST = LOGIN_CHALLENGE_REQUEST;
var LOGIN_CHALLENGE_RESPONSE = 'ui-login_challenge_response';
exports.LOGIN_CHALLENGE_RESPONSE = LOGIN_CHALLENGE_RESPONSE;
var BUNDLE_PROGRESS = 'ui-bundle_progress';
exports.BUNDLE_PROGRESS = BUNDLE_PROGRESS;
var ADDRESS_VALIDATION = 'ui-address_validation';
exports.ADDRESS_VALIDATION = ADDRESS_VALIDATION;
var IFRAME_FAILURE = 'ui-iframe_failure';
exports.IFRAME_FAILURE = IFRAME_FAILURE;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/ui.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/cardano.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/cardano.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.POOL_RELAY_TYPE = exports.CERTIFICATE_TYPE = exports.ADDRESS_TYPE = exports.NETWORK_IDS = exports.PROTOCOL_MAGICS = void 0;
var PROTOCOL_MAGICS = Object.freeze({
  mainnet: 764824073,
  testnet: 42
});
exports.PROTOCOL_MAGICS = PROTOCOL_MAGICS;
var NETWORK_IDS = Object.freeze({
  mainnet: 1,
  testnet: 0
}); // constants below are deprecated
// use `CardanoAddressType`, `CardanoCertificateType` and `CardanoPoolRelayType` from protobuf instead

exports.NETWORK_IDS = NETWORK_IDS;
var ADDRESS_TYPE = Object.freeze({
  Base: 0,
  Pointer: 4,
  Enterprise: 6,
  Byron: 8,
  Reward: 14
});
exports.ADDRESS_TYPE = ADDRESS_TYPE;
var CERTIFICATE_TYPE = Object.freeze({
  StakeRegistration: 0,
  StakeDeregistration: 1,
  StakeDelegation: 2,
  StakePoolRegistration: 3
});
exports.CERTIFICATE_TYPE = CERTIFICATE_TYPE;
var POOL_RELAY_TYPE = Object.freeze({
  SingleHostIp: 0,
  SingleHostName: 1,
  MultipleHostName: 2
});
exports.POOL_RELAY_TYPE = POOL_RELAY_TYPE;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/cardano.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/errors.js", {"@babel/runtime/helpers/inheritsLoose":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/inheritsLoose.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/wrapNativeSuper":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/wrapNativeSuper.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/errors.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.LIBUSB_ERROR_MESSAGE = exports.WEBUSB_ERROR_MESSAGE = exports.INVALID_PIN_ERROR_MESSAGE = exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = exports.TypedError = exports.TrezorError = exports.ERROR_CODES = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var ERROR_CODES = {
  Init_NotInitialized: 'TrezorConnect not yet initialized',
  // race condition: call on not initialized Core (usually hot-reloading)
  Init_AlreadyInitialized: 'TrezorConnect has been already initialized',
  // thrown by .init called multiple times
  Init_IframeBlocked: 'Iframe blocked',
  // iframe injection blocked (ad-blocker)
  Init_IframeTimeout: 'Iframe timeout',
  // iframe didn't load in specified time
  Init_ManifestMissing: 'Manifest not set. Read more at https://github.com/trezor/connect/blob/develop/docs/index.md',
  // manifest is not set
  Popup_ConnectionMissing: 'Unable to establish connection with iframe',
  // thrown by popup
  Transport_Missing: 'Transport is missing',
  // no transport available
  Transport_InvalidProtobuf: '',
  // generic error from transport layer (trezor-link)
  Method_InvalidPackage: 'This version of trezor-connect is not suitable to work without browser. Use trezor-connect@extended package instead',
  // thrown by node and react-native env while using regular 'web' package
  Method_InvalidParameter: '',
  // replaced by generic text
  Method_NotAllowed: 'Method not allowed for this configuration',
  // example: device management in popup mode
  Method_PermissionsNotGranted: 'Permissions not granted',
  // permission/confirmation not granted in popup
  Method_Cancel: 'Cancelled',
  // permission/confirmation not granted in popup OR .cancel() custom error
  Method_Interrupted: 'Popup closed',
  // interruption: popup closed
  Method_UnknownCoin: 'Coin not found',
  // coin definition not found
  Method_AddressNotMatch: 'Addresses do not match',
  // thrown by all getAddress methods with custom UI validation
  Method_FirmwareUpdate_DownloadFailed: 'Failed to download firmware binary',
  // thrown by FirmwareUpdate method
  Method_CustomMessage_Callback: 'Parameter "callback" is not a function',
  // thrown by CustomMessage method
  Method_Discovery_BundleException: '',
  // thrown by getAccountInfo method
  Method_Override: 'override',
  // inner "error", it's more like a interruption
  Method_NoResponse: 'Call resolved without response',
  // thrown by npm index(es), call to Core resolved without response, should not happen
  Backend_NotSupported: 'BlockchainLink settings not found in coins.json',
  // thrown by methods which using backends, blockchainLink not defined for this coin
  Backend_WorkerMissing: '',
  // thrown by BlockchainLink class, worker not specified
  Backend_Disconnected: 'Backend disconnected',
  // thrown by BlockchainLink class
  Backend_Invalid: 'Invalid backend',
  // thrown by BlockchainLink class, invalid backend (ie: backend for wrong coin set)
  Backend_Error: '',
  // thrown by BlockchainLink class, generic message from 'blockchain-link'
  Runtime: '',
  // thrown from several places, this shouldn't ever happen tho
  Device_NotFound: 'Device not found',
  Device_InitializeFailed: '',
  // generic error from firmware while calling "Initialize" message
  Device_FwException: '',
  // generic FirmwareException type
  Device_ModeException: '',
  // generic Device.UnexpectedMode type
  Device_Disconnected: 'Device disconnected',
  // device disconnected during call
  Device_UsedElsewhere: 'Device is used in another window',
  // interruption: current session toked by other application
  Device_InvalidState: 'Passphrase is incorrect',
  // authorization error (device state comparison)
  Device_CallInProgress: 'Device call in progress' // thrown when trying to make another call while current is still running

};
exports.ERROR_CODES = ERROR_CODES;

var TrezorError = /*#__PURE__*/function (_Error) {
  (0, _inheritsLoose2["default"])(TrezorError, _Error);

  function TrezorError(code, message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.code = code;
    _this.message = message;
    return _this;
  }

  return TrezorError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

exports.TrezorError = TrezorError;

var TypedError = function TypedError(id, message) {
  return new TrezorError(id, message || ERROR_CODES[id]);
}; // a slight hack
// this error string is hard-coded
// in both bridge and extension


exports.TypedError = TypedError;
var WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = 'wrong previous session';
exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = WRONG_PREVIOUS_SESSION_ERROR_MESSAGE;
var INVALID_PIN_ERROR_MESSAGE = 'PIN invalid';
exports.INVALID_PIN_ERROR_MESSAGE = INVALID_PIN_ERROR_MESSAGE;
var WEBUSB_ERROR_MESSAGE = 'NetworkError: Unable to claim interface.'; // trezord error prefix.
// user has insufficient permissions. may occur in Linux (missing udev rules), Windows and MacOS.

exports.WEBUSB_ERROR_MESSAGE = WEBUSB_ERROR_MESSAGE;
var LIBUSB_ERROR_MESSAGE = 'LIBUSB_ERROR';
exports.LIBUSB_ERROR_MESSAGE = LIBUSB_ERROR_MESSAGE;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/webusb/button.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/webusb/button.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var render = function render(className, url, origin) {
  var query = className || '.trezor-webusb-button';
  var buttons = document.querySelectorAll(query);
  var src = url + "?" + Date.now();
  buttons.forEach(function (b) {
    if (b.getElementsByTagName('iframe').length < 1) {
      var bounds = b.getBoundingClientRect();
      var btnIframe = document.createElement('iframe');
      btnIframe.frameBorder = '0';
      btnIframe.width = Math.round(bounds.width) + "px";
      btnIframe.height = Math.round(bounds.height) + "px";
      btnIframe.style.position = 'absolute';
      btnIframe.style.top = '0px';
      btnIframe.style.left = '0px';
      btnIframe.style.zIndex = '1'; // btnIframe.style.opacity = '0'; // this makes click impossible on cross-origin

      btnIframe.setAttribute('allow', 'usb');
      btnIframe.setAttribute('scrolling', 'no');

      btnIframe.onload = function () {
        btnIframe.contentWindow.postMessage({// style: JSON.stringify( window.getComputedStyle(b) ),
          // outer: b.outerHTML,
          // inner: b.innerHTML
        }, origin);
      };

      btnIframe.src = src; // inject iframe into button

      b.append(btnIframe);
    }
  });
};

var _default = render;
exports["default"] = _default;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/webusb/button.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/debug.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/debug.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.getLog = exports.enableLogByPrefix = exports.enableLog = exports.initLog = void 0;

/* eslint-disable no-console */
var colors = {
  // green
  DescriptorStream: 'color: #77ab59',
  DeviceList: 'color: #36802d',
  Device: 'color: #bada55',
  Core: 'color: #c9df8a',
  IFrame: 'color: #FFFFFF; background: #f4a742;',
  Popup: 'color: #f48a00'
};
var MAX_ENTRIES = 100;

var Log = /*#__PURE__*/function () {
  function Log(prefix, enabled) {
    this.prefix = prefix;
    this.enabled = enabled;
    this.messages = [];
    this.css = colors[prefix] || 'color: #3ca7f2; background: #000000;';
  }

  var _proto = Log.prototype;

  _proto.addMessage = function addMessage(level, prefix) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.messages.push({
      level: level,
      prefix: prefix,
      message: args,
      timestamp: new Date().getTime()
    });

    if (this.messages.length > MAX_ENTRIES) {
      this.messages.shift();
    }
  };

  _proto.log = function log() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    this.addMessage.apply(this, ['log', this.prefix].concat(args));

    if (this.enabled) {
      var _console;

      (_console = console).log.apply(_console, [this.prefix].concat(args));
    }
  };

  _proto.error = function error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    this.addMessage.apply(this, ['error', this.prefix].concat(args));

    if (this.enabled) {
      var _console2;

      (_console2 = console).error.apply(_console2, [this.prefix].concat(args));
    }
  };

  _proto.warn = function warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    this.addMessage.apply(this, ['warn', this.prefix].concat(args));

    if (this.enabled) {
      var _console3;

      (_console3 = console).warn.apply(_console3, [this.prefix].concat(args));
    }
  };

  _proto.debug = function debug() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    this.addMessage.apply(this, ['debug', this.prefix].concat(args));

    if (this.enabled) {
      var _console4;

      (_console4 = console).log.apply(_console4, ["%c" + this.prefix, this.css].concat(args));
    }
  };

  return Log;
}();

var _logs = {};

var initLog = function initLog(prefix, enabled) {
  var instance = new Log(prefix, !!enabled);
  _logs[prefix] = instance;
  return instance;
};

exports.initLog = initLog;

var enableLog = function enableLog(enabled) {
  Object.keys(_logs).forEach(function (key) {
    _logs[key].enabled = enabled;
  });
};

exports.enableLog = enableLog;

var enableLogByPrefix = function enableLogByPrefix(prefix, enabled) {
  if (_logs[prefix]) {
    _logs[prefix].enabled = enabled;
  }
};

exports.enableLogByPrefix = enableLogByPrefix;

var getLog = function getLog() {
  var logs = [];
  Object.keys(_logs).forEach(function (key) {
    logs = logs.concat(_logs[key].messages);
  });
  logs.sort(function (a, b) {
    return a.timestamp - b.timestamp;
  });
  return logs;
};

exports.getLog = getLog;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/debug.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/index.js
      return function (require, module, exports) {
"use strict";

exports.__esModule = true;
exports.errorMessage = exports.parseMessage = void 0;

// parse MessageEvent .data into CoreMessage
var parseMessage = function parseMessage(messageData) {
  var message = {
    event: messageData.event,
    type: messageData.type,
    payload: messageData.payload
  };

  if (typeof messageData.id === 'number') {
    message.id = messageData.id;
  }

  if (typeof messageData.success === 'boolean') {
    message.success = messageData.success;
  }

  return message;
}; // common response used straight from npm index (not from Core)


exports.parseMessage = parseMessage;

var errorMessage = function errorMessage(error) {
  return {
    success: false,
    payload: {
      error: error.message,
      code: error.code
    }
  };
};

exports.errorMessage = errorMessage;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/builder.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js","../env/browser/networkUtils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/networkUtils.js","../utils/deferred":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/deferred.js","./inline-styles":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/inline-styles.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/builder.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.clearTimeout = exports.dispose = exports.postMessage = exports.init = exports.messagePromises = exports.error = exports.timeout = exports.initPromise = exports.origin = exports.instance = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _deferred = require("../utils/deferred");

var _constants = require("../constants");

var _networkUtils = require("../env/browser/networkUtils");

var _inlineStyles = _interopRequireDefault(require("./inline-styles"));

/* eslint-disable import/no-mutable-exports */
var instance;
exports.instance = instance;
var origin;
exports.origin = origin;
var initPromise = (0, _deferred.create)();
exports.initPromise = initPromise;
var timeout = 0;
exports.timeout = timeout;
var error;
/* eslint-enable import/no-mutable-exports */

exports.error = error;
var _messageID = 0; // every postMessage to iframe has its own promise to resolve

var messagePromises = {};
exports.messagePromises = messagePromises;

var init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
    var existedFrame, src, manifestString, manifest, onLoad;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            exports.initPromise = initPromise = (0, _deferred.create)();
            existedFrame = document.getElementById('trezorconnect');

            if (existedFrame) {
              exports.instance = instance = existedFrame;
            } else {
              exports.instance = instance = document.createElement('iframe');
              instance.frameBorder = '0';
              instance.width = '0px';
              instance.height = '0px';
              instance.style.position = 'absolute';
              instance.style.display = 'none';
              instance.style.border = '0px';
              instance.style.width = '0px';
              instance.style.height = '0px';
              instance.id = 'trezorconnect';
            }

            if (settings.env === 'web') {
              manifestString = settings.manifest ? JSON.stringify(settings.manifest) : 'undefined'; // note: btoa(undefined) === btoa('undefined') === "dW5kZWZpbmVk"

              manifest = "version=" + settings.version + "&manifest=" + encodeURIComponent(btoa(JSON.stringify(manifestString)));
              src = settings.iframeSrc + "?" + manifest;
            } else {
              src = settings.iframeSrc;
            }

            instance.setAttribute('src', src);

            if (settings.webusb) {
              instance.setAttribute('allow', 'usb');
            }

            exports.origin = origin = (0, _networkUtils.getOrigin)(instance.src);
            exports.timeout = timeout = window.setTimeout(function () {
              initPromise.reject(_constants.ERRORS.TypedError('Init_IframeTimeout'));
            }, 10000);

            onLoad = function onLoad() {
              if (!instance) {
                initPromise.reject(_constants.ERRORS.TypedError('Init_IframeBlocked'));
                return;
              }

              try {
                // if hosting page is able to access cross-origin location it means that the iframe is not loaded
                var iframeOrigin = instance.contentWindow.location.origin;

                if (!iframeOrigin || iframeOrigin === 'null') {
                  // eslint-disable-next-line no-use-before-define
                  handleIframeBlocked();
                  return;
                }
              } catch (e) {// empty
              }

              var extension; // $FlowIssue chrome is not declared outside

              if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
                chrome.runtime.onConnect.addListener(function () {});
                extension = chrome.runtime.id;
              }

              instance.contentWindow.postMessage({
                type: _constants.IFRAME.INIT,
                payload: {
                  settings: settings,
                  extension: extension
                }
              }, origin);
              instance.onload = undefined;
            }; // IE hack


            if (instance.attachEvent) {
              instance.attachEvent('onload', onLoad);
            } else {
              instance.onload = onLoad;
            } // inject iframe into host document body


            if (document.body) {
              document.body.appendChild(instance); // eslint-disable-next-line no-use-before-define

              injectStyleSheet();
            }

            _context.prev = 11;
            _context.next = 14;
            return initPromise.promise;

          case 14:
            _context.next = 20;
            break;

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](11);

            // reset state to allow initialization again
            if (instance) {
              if (instance.parentNode) {
                instance.parentNode.removeChild(instance);
              }

              exports.instance = instance = null;
            }

            throw _context.t0;

          case 20:
            _context.prev = 20;
            window.clearTimeout(timeout);
            exports.timeout = timeout = 0;
            return _context.finish(20);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[11, 16, 20, 24]]);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var injectStyleSheet = function injectStyleSheet() {
  if (!instance) {
    throw _constants.ERRORS.TypedError('Init_IframeBlocked');
  }

  var doc = instance.ownerDocument;
  var head = doc.head || doc.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.setAttribute('id', 'TrezorConnectStylesheet'); // $FlowIssue

  if (style.styleSheet) {
    // IE
    // $FlowIssue
    style.styleSheet.cssText = _inlineStyles["default"];
    head.appendChild(style);
  } else {
    style.appendChild(document.createTextNode(_inlineStyles["default"]));
    head.append(style);
  }
};

var handleIframeBlocked = function handleIframeBlocked() {
  window.clearTimeout(timeout);
  exports.error = error = _constants.ERRORS.TypedError('Init_IframeBlocked'); // eslint-disable-next-line no-use-before-define

  dispose();
  initPromise.reject(error);
}; // post messages to iframe


var postMessage = function postMessage(message, usePromise) {
  if (usePromise === void 0) {
    usePromise = true;
  }

  if (!instance) {
    throw _constants.ERRORS.TypedError('Init_IframeBlocked');
  }

  if (usePromise) {
    _messageID++;
    message.id = _messageID;
    messagePromises[_messageID] = (0, _deferred.create)();
    var promise = messagePromises[_messageID].promise;
    instance.contentWindow.postMessage(message, origin);
    return promise;
  }

  instance.contentWindow.postMessage(message, origin);
  return null;
};

exports.postMessage = postMessage;

var dispose = function dispose() {
  if (instance && instance.parentNode) {
    try {
      instance.parentNode.removeChild(instance);
    } catch (e) {// do nothing
    }
  }

  exports.instance = instance = null;
  exports.timeout = timeout = 0;
};

exports.dispose = dispose;

var clearTimeout = function clearTimeout() {
  window.clearTimeout(timeout);
};

exports.clearTimeout = clearTimeout;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/iframe/builder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/builder.js", {"../constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/index.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/builder.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.BlockchainMessage = exports.ResponseMessage = exports.TransportMessage = exports.DeviceMessage = exports.UiMessage = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("../constants");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var UiMessage = function UiMessage(type, payload) {
  return {
    event: _constants.UI_EVENT,
    type: type,
    payload: payload
  };
};

exports.UiMessage = UiMessage;

var DeviceMessage = function DeviceMessage(type, payload) {
  return {
    event: _constants.DEVICE_EVENT,
    type: type,
    payload: payload
  };
};

exports.DeviceMessage = DeviceMessage;

var TransportMessage = function TransportMessage(type, payload) {
  return {
    event: _constants.TRANSPORT_EVENT,
    type: type,
    // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
    payload: payload.error ? _objectSpread(_objectSpread({}, payload), {}, {
      error: payload.error.message,
      code: payload.error.code
    }) : payload
  };
};

exports.TransportMessage = TransportMessage;

var ResponseMessage = function ResponseMessage(id, success, payload) {
  if (payload === void 0) {
    payload = null;
  }

  return {
    event: _constants.RESPONSE_EVENT,
    type: _constants.RESPONSE_EVENT,
    id: id,
    success: success,
    // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
    payload: success ? payload : {
      error: payload.error.message,
      code: payload.error.code
    }
  };
};

exports.ResponseMessage = ResponseMessage;

var BlockchainMessage = function BlockchainMessage(type, payload) {
  return {
    event: _constants.BLOCKCHAIN_EVENT,
    type: type,
    payload: payload
  };
};

exports.BlockchainMessage = BlockchainMessage;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/message/builder.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/data/ConnectSettings.js", {"@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/data/ConnectSettings.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.parse = exports.corsValidator = exports.getEnv = exports.DEFAULT_PRIORITY = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/*
 * Initial settings for connect.
 * It could be changed by passing values into TrezorConnect.init(...) method
 */
var VERSION = '8.2.3';
var versionN = VERSION.split('.').map(function (s) {
  return parseInt(s, 10);
}); // const DIRECTORY = `${ versionN[0] }${ (versionN[1] > 0 ? `.${versionN[1]}` : '') }/`;

var DIRECTORY = versionN[0] + "/";
var DEFAULT_DOMAIN = "https://connect.trezor.io/" + DIRECTORY;
var DEFAULT_PRIORITY = 2;
exports.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
var initialSettings = {
  configSrc: './data/config.json',
  // constant
  version: VERSION,
  // constant
  debug: false,
  priority: DEFAULT_PRIORITY,
  trustedHost: false,
  connectSrc: DEFAULT_DOMAIN,
  iframeSrc: DEFAULT_DOMAIN + "iframe.html",
  popup: true,
  popupSrc: DEFAULT_DOMAIN + "popup.html",
  webusbSrc: DEFAULT_DOMAIN + "webusb.html",
  transportReconnect: false,
  webusb: true,
  pendingTransportEvent: true,
  supportedBrowser: typeof navigator !== 'undefined' ? !/Trident|MSIE|Edge/.test(navigator.userAgent) : true,
  manifest: null,
  env: 'web',
  lazyLoad: false,
  timestamp: new Date().getTime(),
  interactionTimeout: 600 // 5 minutes

};
var currentSettings = initialSettings;

var parseManifest = function parseManifest(manifest) {
  if (!manifest) return;
  if (typeof manifest.email !== 'string') return;
  if (typeof manifest.appUrl !== 'string') return;
  return {
    email: manifest.email,
    appUrl: manifest.appUrl
  };
};

var getEnv = function getEnv() {
  // $FlowIssue: chrome is not declared outside the project
  if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
    return 'webextension';
  }

  if (typeof navigator !== 'undefined') {
    if (typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
      return 'react-native';
    }

    var userAgent = navigator.userAgent.toLowerCase();

    if (userAgent.indexOf(' electron/') > -1) {
      return 'electron';
    }
  } // if (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
  //     return 'react-native';
  // }
  // if (typeof process !== 'undefined' && process.versions.hasOwnProperty('electron')) {
  //     return 'electron';
  // }


  return 'web';
}; // Cors validation copied from Trezor Bridge
// see: https://github.com/trezor/trezord-go/blob/05991cea5900d18bcc6ece5ae5e319d138fc5551/server/api/api.go#L229
// Its pointless to allow `trezor-connect` endpoints { connectSrc } for domains other than listed below
// `trezord` will block communication anyway


exports.getEnv = getEnv;

var corsValidator = function corsValidator(url) {
  if (typeof url !== 'string') return;
  if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//)) return url;
  if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//)) return url;
  if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//)) return url;
  if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//)) return url;
};

exports.corsValidator = corsValidator;

var parse = function parse(input) {
  if (input === void 0) {
    input = {};
  }

  var settings = _objectSpread({}, currentSettings);

  if (Object.prototype.hasOwnProperty.call(input, 'debug')) {
    if (Array.isArray(input)) {// enable log with prefix
    }

    if (typeof input.debug === 'boolean') {
      settings.debug = input.debug;
    } else if (typeof input.debug === 'string') {
      settings.debug = input.debug === 'true';
    }
  }

  if (typeof input.connectSrc === 'string') {
    settings.connectSrc = input.connectSrc;
  } // For debugging purposes `connectSrc` could be defined in `global.__TREZOR_CONNECT_SRC` variable


  if (typeof global !== 'undefined' && typeof global.__TREZOR_CONNECT_SRC === 'string') {
    settings.connectSrc = corsValidator(global.__TREZOR_CONNECT_SRC);
    settings.debug = true;
  } // For debugging purposes `connectSrc` could be defined in url query of hosting page. Usage:
  // https://3rdparty-page.com/?trezor-connect-src=https://localhost:8088/


  if (typeof window !== 'undefined' && window.location && typeof window.location.search === 'string') {
    var vars = window.location.search.split('&');
    var customUrl = vars.find(function (v) {
      return v.indexOf('trezor-connect-src') >= 0;
    });

    if (customUrl) {
      var _customUrl$split = customUrl.split('='),
          connectSrc = _customUrl$split[1];

      settings.connectSrc = corsValidator(decodeURIComponent(connectSrc));
      settings.debug = true;
    }
  }

  var src = settings.connectSrc || DEFAULT_DOMAIN;
  settings.iframeSrc = src + "iframe.html";
  settings.popupSrc = src + "popup.html";
  settings.webusbSrc = src + "webusb.html";

  if (typeof input.transportReconnect === 'boolean') {
    settings.transportReconnect = input.transportReconnect;
  }

  if (typeof input.webusb === 'boolean') {
    settings.webusb = input.webusb;
  }

  if (typeof input.popup === 'boolean') {
    settings.popup = input.popup;
  }

  if (typeof input.lazyLoad === 'boolean') {
    settings.lazyLoad = input.lazyLoad;
  }

  if (typeof input.pendingTransportEvent === 'boolean') {
    settings.pendingTransportEvent = input.pendingTransportEvent;
  } // local files


  if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
    settings.origin = "file://" + window.location.pathname;
    settings.webusb = false;
  }

  if (typeof input.extension === 'string') {
    settings.extension = input.extension;
  }

  if (typeof input.env === 'string') {
    settings.env = input.env;
  } else {
    settings.env = getEnv();
  }

  if (typeof input.timestamp === 'number') {
    settings.timestamp = input.timestamp;
  }

  if (typeof input.interactionTimeout === 'number') {
    settings.interactionTimeout = input.interactionTimeout;
  }

  if (typeof input.manifest === 'object') {
    settings.manifest = parseManifest(input.manifest);
  }

  currentSettings = settings;
  return currentSettings;
};

exports.parse = parse;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/data/ConnectSettings.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/PopupManager.js", {"../constants/iframe":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/iframe.js","../constants/popup":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/popup.js","../constants/ui":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/constants/ui.js","../env/browser/networkUtils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/env/browser/networkUtils.js","../utils/deferred":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/utils/deferred.js","./showPopupRequest":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/showPopupRequest.js","@babel/runtime/helpers/assertThisInitialized":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/assertThisInitialized.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/inheritsLoose":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/inheritsLoose.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","events":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/events/events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/PopupManager.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _events = _interopRequireDefault(require("events"));

var POPUP = _interopRequireWildcard(require("../constants/popup"));

var IFRAME = _interopRequireWildcard(require("../constants/iframe"));

var UI = _interopRequireWildcard(require("../constants/ui"));

var _showPopupRequest = require("./showPopupRequest");

var _networkUtils = require("../env/browser/networkUtils");

var _deferred = require("../utils/deferred");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// const POPUP_REQUEST_TIMEOUT = 602;
var POPUP_REQUEST_TIMEOUT = 850;
var POPUP_CLOSE_INTERVAL = 500;
var POPUP_OPEN_TIMEOUT = 3000;

var PopupManager = /*#__PURE__*/function (_EventEmitter) {
  (0, _inheritsLoose2["default"])(PopupManager, _EventEmitter);

  // Window
  function PopupManager(settings) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "requestTimeout", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "closeInterval", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "extensionTabId", 0);
    _this.settings = settings;
    _this.origin = (0, _networkUtils.getOrigin)(settings.popupSrc);
    _this.handleMessage = _this.handleMessage.bind((0, _assertThisInitialized2["default"])(_this));
    _this.iframeHandshake = (0, _deferred.create)(IFRAME.LOADED);

    if (_this.settings.env === 'webextension') {
      _this.handleExtensionConnect = _this.handleExtensionConnect.bind((0, _assertThisInitialized2["default"])(_this));
      _this.handleExtensionMessage = _this.handleExtensionMessage.bind((0, _assertThisInitialized2["default"])(_this)); // $FlowIssue chrome not declared outside

      chrome.runtime.onConnect.addListener(_this.handleExtensionConnect);
    }

    window.addEventListener('message', _this.handleMessage, false);
    return _this;
  }

  var _proto = PopupManager.prototype;

  _proto.request = function request(lazyLoad) {
    var _this2 = this;

    if (lazyLoad === void 0) {
      lazyLoad = false;
    }

    // popup request
    // TODO: ie - open immediately and hide it but post handshake after timeout
    // bring popup window to front
    if (this.locked) {
      if (this._window) {
        if (this.settings.env === 'webextension') {
          // $FlowIssue chrome not declared outside
          chrome.tabs.update(this._window.id, {
            active: true
          });
        } else {
          this._window.focus();
        }
      }

      return;
    }

    var openFn = this.open.bind(this);
    this.locked = true;

    if (!this.settings.supportedBrowser) {
      openFn();
    } else {
      var timeout = lazyLoad || this.settings.env === 'webextension' ? 1 : POPUP_REQUEST_TIMEOUT;
      this.requestTimeout = window.setTimeout(function () {
        _this2.requestTimeout = 0;
        openFn(lazyLoad);
      }, timeout);
    }
  };

  _proto.cancel = function cancel() {
    this.close();
  };

  _proto.unlock = function unlock() {
    this.locked = false;
  };

  _proto.open = function open(lazyLoad) {
    var _this3 = this;

    var src = this.settings.popupSrc;

    if (!this.settings.supportedBrowser) {
      this.openWrapper(src + "#unsupported");
      return;
    }

    this.popupPromise = (0, _deferred.create)(POPUP.LOADED);
    this.openWrapper(lazyLoad ? src + "#loading" : src);
    this.closeInterval = window.setInterval(function () {
      if (!_this3._window) return;

      if (_this3.settings.env === 'webextension') {
        // $FlowIssue chrome not declared outside
        chrome.tabs.get(_this3._window.id, function (tab) {
          if (!tab) {
            _this3.close();

            _this3.emit(POPUP.CLOSED);
          }
        });
      } else if (_this3._window.closed) {
        _this3.close();

        _this3.emit(POPUP.CLOSED);
      }
    }, POPUP_CLOSE_INTERVAL); // open timeout will be cancelled by POPUP.BOOTSTRAP message

    this.openTimeout = window.setTimeout(function () {
      _this3.close();

      (0, _showPopupRequest.showPopupRequest)(_this3.open.bind(_this3), function () {
        _this3.emit(POPUP.CLOSED);
      });
    }, POPUP_OPEN_TIMEOUT);
  };

  _proto.openWrapper = function openWrapper(url) {
    var _this4 = this;

    if (this.settings.env === 'webextension') {
      // $FlowIssue chrome not declared outside
      chrome.windows.getCurrent(null, function (currentWindow) {
        // Request coming from extension popup,
        // create new window above instead of opening new tab
        if (currentWindow.type !== 'normal') {
          // $FlowIssue chrome not declared outside
          chrome.windows.create({
            url: url
          }, function (newWindow) {
            // $FlowIssue chrome not declared outside
            chrome.tabs.query({
              windowId: newWindow.id,
              active: true
            }, function (tabs) {
              // eslint-disable-next-line prefer-destructuring
              _this4._window = tabs[0];
            });
          });
        } else {
          // $FlowIssue chrome not declared outside
          chrome.tabs.query({
            currentWindow: true,
            active: true
          }, function (tabs) {
            _this4.extensionTabId = tabs[0].id; // $FlowIssue chrome not declared outside

            chrome.tabs.create({
              url: url,
              index: tabs[0].index + 1
            }, function (tab) {
              _this4._window = tab;
            });
          });
        }
      });
    } else if (this.settings.env === 'electron') {
      this._window = window.open(url, 'modal');
    } else {
      this._window = window.open('', '_blank');

      if (this._window) {
        this._window.location.href = url; // otherwise android/chrome loose window.opener reference
      }
    }
  };

  _proto.handleExtensionConnect = function handleExtensionConnect(port) {
    if (port.name !== 'trezor-connect') return;

    if (!this._window || this._window && this._window.id !== port.sender.tab.id) {
      port.disconnect();
      return;
    } // since POPUP.BOOTSTRAP will not be handled by "handleMessage" we need to threat "content-script" connection as the same event
    // popup is opened properly, now wait for POPUP.LOADED message (in this case handled by "handleExtensionMessage")


    window.clearTimeout(this.openTimeout);
    this.extensionPort = port; // $FlowIssue need to update ChromePort definition

    this.extensionPort.onMessage.addListener(this.handleExtensionMessage);
  };

  _proto.handleExtensionMessage = function handleExtensionMessage(message) {
    var _this5 = this;

    if (!this.extensionPort) return;
    var port = this.extensionPort;
    var data = message.data;
    if (!data || typeof data !== 'object') return;

    if (data.type === POPUP.ERROR) {
      // handle popup error
      var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
      this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
      this.close();
    } else if (data.type === POPUP.LOADED) {
      if (this.popupPromise) {
        this.popupPromise.resolve();
      }

      this.iframeHandshake.promise.then(function (useBroadcastChannel) {
        port.postMessage({
          type: POPUP.INIT,
          payload: {
            settings: _this5.settings,
            useBroadcastChannel: useBroadcastChannel
          }
        });
      });
    } else if (data.type === POPUP.EXTENSION_USB_PERMISSIONS) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.query({
        currentWindow: true,
        active: true
      }, function (tabs) {
        // $FlowIssue chrome not declared outside
        chrome.tabs.create({
          url: 'trezor-usb-permissions.html',
          index: tabs[0].index + 1
        }, function (_tab) {// do nothing
        });
      });
    } else if (data.type === POPUP.CLOSE_WINDOW) {
      this.emit(POPUP.CLOSED);
      this.close();
    }
  };

  _proto.handleMessage = function handleMessage(message) {
    var _this6 = this;

    // ignore messages from domain other then popup origin and without data
    // const data: CoreMessage = message.data;
    var data = message.data;
    if ((0, _networkUtils.getOrigin)(message.origin) !== this.origin || !data || typeof data !== 'object') return;

    if (data.type === IFRAME.LOADED) {
      var useBroadcastChannel = data.payload && typeof data.payload.useBroadcastChannel === 'boolean' ? data.payload.useBroadcastChannel : false;
      this.iframeHandshake.resolve(useBroadcastChannel);
    } else if (data.type === POPUP.BOOTSTRAP) {
      // popup is opened properly, now wait for POPUP.LOADED message
      window.clearTimeout(this.openTimeout);
    } else if (data.type === POPUP.ERROR && this._window) {
      var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
      this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
      this.close();
    } else if (data.type === POPUP.LOADED) {
      if (this.popupPromise) {
        this.popupPromise.resolve();
      } // popup is successfully loaded


      this.iframeHandshake.promise.then(function (useBroadcastChannel) {
        _this6._window.postMessage({
          type: POPUP.INIT,
          payload: {
            settings: _this6.settings,
            useBroadcastChannel: useBroadcastChannel
          }
        }, _this6.origin);
      }); // send ConnectSettings to popup
      // note this settings and iframe.ConnectSettings could be different (especially: origin, popup, webusb, debug)
      // now popup is able to load assets
    } else if (data.type === POPUP.CANCEL_POPUP_REQUEST || data.type === UI.CLOSE_UI_WINDOW) {
      this.close();
    }
  };

  _proto.close = function close() {
    this.locked = false;
    this.popupPromise = undefined;

    if (this.requestTimeout) {
      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = 0;
    }

    if (this.openTimeout) {
      window.clearTimeout(this.openTimeout);
      this.openTimeout = 0;
    }

    if (this.closeInterval) {
      window.clearInterval(this.closeInterval);
      this.closeInterval = 0;
    }

    if (this.extensionPort) {
      this.extensionPort.disconnect();
      this.extensionPort = null;
    } // switch to previously focused tab


    if (this.extensionTabId) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.update(this.extensionTabId, {
        active: true
      });
      this.extensionTabId = 0;
    }

    if (this._window) {
      if (this.settings.env === 'webextension') {
        // eslint-disable-next-line no-unused-vars
        var _e = chrome.runtime.lastError; // $FlowIssue chrome not declared outside

        chrome.tabs.remove(this._window.id, function () {
          // eslint-disable-next-line no-unused-vars
          _e = chrome.runtime.lastError;
        });
      } else {
        this._window.close();
      }

      this._window = null;
    }
  };

  _proto.postMessage = /*#__PURE__*/function () {
    var _postMessage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(message) {
      var _this7 = this;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!this._window && message.type !== UI.REQUEST_UI_WINDOW && this.openTimeout)) {
                _context.next = 4;
                break;
              }

              this.close();
              (0, _showPopupRequest.showPopupRequest)(this.open.bind(this), function () {
                _this7.emit(POPUP.CLOSED);
              });
              return _context.abrupt("return");

            case 4:
              if (!this.popupPromise) {
                _context.next = 7;
                break;
              }

              _context.next = 7;
              return this.popupPromise.promise;

            case 7:
              // post message to popup window
              if (this._window) {
                this._window.postMessage(message, this.origin);
              }

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function postMessage(_x) {
      return _postMessage.apply(this, arguments);
    }

    return postMessage;
  }();

  return PopupManager;
}(_events["default"]);

exports["default"] = PopupManager;
      };
    };
  }
}, {package:"trezor-connect",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/trezor-connect/lib/popup/PopupManager.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/ethjs-util/lib/index.js", {"buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","is-hex-prefixed":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-hex-prefixed/src/index.js","strip-hex-prefix":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/strip-hex-prefix/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/ethjs-util/lib/index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"ethjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/ethjs-util/lib/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/js.js", {"./lib/api":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/api/index.js","./lib/keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/lib/keccak.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/js.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib/api')(require('./lib/keccak'))

      };
    };
  }
}, {package:"keccak",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/eth-ledger-bridge-keyring/node_modules/keccak/js.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-util/dist/index.js", {"assert":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/assert/assert.js","bn.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bn.js/lib/bn.js","create-hash":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/create-hash/browser.js","ethjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethjs-util/lib/index.js","keccak":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/keccak/js.js","rlp":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp/dist.browser/index.js","safe-buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/safe-buffer/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-util/dist/index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"ethereumjs-util",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-util/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/index.js", {"./lib/index.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/lib/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/index.js
      return function (require, module, exports) {
module.exports = require('./lib/index.js')

      };
    };
  }
}, {package:"ethereumjs-abi",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-json-rpc-middleware/node_modules/ethereumjs-abi/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js
      return function (require, module, exports) {
// Consistent with Lattice's IV
const AES_IV = [0x6d, 0x79, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64]

const ADDR_STR_LEN = 129; // 128-char strings (null terminated)

// Decrypted response lengths will be fixed for any given message type.
// These are defined in the Lattice spec.
// Every decrypted response should have a 65-byte pubkey prefixing it (and a 4-byte request ID)
// These are NOT counted in `decResLengths`, meaning these values are 69-bytes smaller than the
// corresponding structs in firmware.
const decResLengths = {
    empty: 0,                           // Only contains the pubkey
    getAddresses: 10 * ADDR_STR_LEN,    // 10x 129 byte strings (128 bytes + null terminator)
    sign: 1090,                         // 1 DER signature for ETH, 10 for BTC + change pubkeyhash
    getWallets: 142,                    // 71 bytes per wallet record (response contains internal and external)
    addAbiDefs: 8,
    getKvRecords: 1395,
    test: 1646                          // Max size of test response payload
}

// Every corresponding decrypted response struct in firmware has a pubkey
// and checksum added. These are not included in `decResLengths`
const DES_RES_EXTRADATA_LEN = 69; 

// Encrypted responses also have metadata
// Prefix:
// * protocol version (1 byte)
// * response type, reserved (1 byte) -- not used
// * response id (4 bytes) -- not used
// * payload length (2 bytes)
// * response code (1 byte)
// Suffix:
// * checksum (4 bytes) -- NOT the same checksum as inside the decrypted msg
const ENC_MSG_METADATA_LEN = 13;

const ENC_MSG_EXTRA_LEN = DES_RES_EXTRADATA_LEN + ENC_MSG_METADATA_LEN;
// Per Lattice spec, all encrypted messages must fit in a buffer of this size.
// The length comes from the largest request/response data type size
// We also add the prefix length
let ENC_MSG_LEN = 0;
Object.keys(decResLengths).forEach((k) => {
    if (decResLengths[k] + ENC_MSG_EXTRA_LEN > ENC_MSG_LEN)
        ENC_MSG_LEN = decResLengths[k] + ENC_MSG_EXTRA_LEN;
})
  
const deviceCodes = {
    'CONNECT': 1,
    'ENCRYPTED_REQUEST': 2,
}

const encReqCodes = {
    'FINALIZE_PAIRING': 0,
    'GET_ADDRESSES': 1,
    'ADD_PERMISSION': 2,
    'SIGN_TRANSACTION': 3,
    'GET_WALLETS': 4,
    'ADD_PERMISSION_V0': 5,
    'ADD_ABI_DEFS': 6,
    'GET_KV_RECORDS': 7,
    'ADD_KV_RECORDS': 8,
    'REMOVE_KV_RECORDS': 9,
    'TEST': 10,
}

const messageConstants = {
    'NOT_PAIRED': 0x00,
    'PAIRED': 0x01,
}

const addressSizes = {
    'BTC': 20,  // 20 byte pubkeyhash
    'ETH': 20,  // 20 byte address not including 0x prefix
}
  
const responseCodes = {
    RESP_SUCCESS: 0x00,
    RESP_ERR_INVALID_MSG: 0x80,
    RESP_ERR_UNSUPPORTED_VER: 0x81,
    RESP_ERR_DEV_BUSY: 0x82,
    RESP_ERR_USER_TIMEOUT: 0x83,
    RESP_ERR_USER_DECLINED: 0x84,
    RESP_ERR_PAIR_FAIL: 0x85,
    RESP_ERR_PAIR_DISABLED: 0x86,
    RESP_ERR_PERMISSION_DISABLED: 0x87,
    RESP_ERR_INTERNAL: 0x88,
    RESP_ERR_GCE_TIMEOUT: 0x89,
    RESP_ERR_WALLET_NOT_PRESENT: 0x8a,
    RESP_ERR_DEV_LOCKED: 0x8b,
    RESP_ERR_DISABLED: 0x8c,
    RESP_ERR_ALREADY: 0x8d,
}

const responseMsgs = {
    [responseCodes.RESP_SUCCESS]: 0x00,
    [responseCodes.RESP_ERR_INVALID_MSG]: 'Invalid Request',
    [responseCodes.RESP_ERR_UNSUPPORTED_VER]: 'Unsupported Version',
    [responseCodes.RESP_ERR_DEV_BUSY]: 'Device Busy',
    [responseCodes.RESP_ERR_USER_TIMEOUT]: 'Timeout Waiting for User',
    [responseCodes.RESP_ERR_USER_DECLINED]: 'Request Declined by User',
    [responseCodes.RESP_ERR_PAIR_FAIL]: 'Pairing Failed',
    [responseCodes.RESP_ERR_PAIR_DISABLED]: 'Pairing is Currently Disabled',
    [responseCodes.RESP_ERR_PERMISSION_DISABLED]: 'Automated Signing is Currently Disabled',
    [responseCodes.RESP_ERR_INTERNAL]: 'Device Error',
    [responseCodes.RESP_ERR_GCE_TIMEOUT]: 'Timeout',
    [responseCodes.RESP_ERR_WALLET_NOT_PRESENT]: 'Incorrect Wallet UID Provided',
    [responseCodes.RESP_ERR_DEV_LOCKED]: 'Device Locked',
    [responseCodes.RESP_ERR_DISABLED]: 'Disabled',
    [responseCodes.RESP_ERR_ALREADY]: 'Record already exists. You must first remove it on your device.'
}
 

const signingSchema = {
    BTC_TRANSFER: 0,
    ETH_TRANSFER: 1,
    ERC20_TRANSFER: 2,
    ETH_MSG: 3,
    EXTRA_DATA: 4,
}

const REQUEST_TYPE_BYTE = 0x02; // For all HSM-bound requests
const VERSION_BYTE = 1;
const HARDENED_OFFSET = 0x80000000; // Hardened offset
const HANDLE_LARGER_CHAIN_ID = 255; // ChainId value to signify larger chainID is in data buffer
const MAX_CHAIN_ID_BYTES = 8; // Max number of bytes to contain larger chainID in data buffer

const BASE_URL = 'https://signing.gridpl.us';

const EIP712_ABI_LATTICE_FW_TYPE_MAP = {
    'address': 1,
    'bool': 2,
    'uint8': 3,
    'uint16': 4,
    'uint24': 5,
    'uint32': 6,
    'uint40': 7,
    'uint48': 8,
    'uint56': 9,
    'uint64': 10,
    'uint72': 11,
    'uint80': 12,
    'uint88': 13,
    'uint96': 14,
    'uint104': 15,
    'uint112': 16,
    'uint120': 17,
    'uint128': 18,
    'uint136': 19,
    'uint144': 20,
    'uint152': 21,
    'uint160': 22,
    'uint168': 23,
    'uint176': 24,
    'uint184': 25,
    'uint192': 26,
    'uint200': 27,
    'uint208': 28,
    'uint216': 29,
    'uint224': 30,
    'uint232': 31,
    'uint240': 32,
    'uint248': 33,
    'uint256': 34,
    'int8': 35,
    'int16': 36,
    'int24': 37,
    'int32': 38,
    'int40': 39,
    'int48': 40,
    'int56': 41,
    'int64': 42,
    'int72': 43,
    'int80': 44,
    'int88': 45,
    'int96': 46,
    'int104': 47,
    'int112': 48,
    'int120': 49,
    'int128': 50,
    'int136': 51,
    'int144': 52,
    'int152': 53,
    'int160': 54,
    'int168': 55,
    'int176': 56,
    'int184': 57,
    'int192': 58,
    'int200': 59,
    'int208': 60,
    'int216': 61,
    'int224': 62,
    'int232': 63,
    'int240': 64,
    'int248': 65,
    'int256': 66,
    'uint': 67,
    'bytes1': 69,
    'bytes2': 70,
    'bytes3': 71,
    'bytes4': 72,
    'bytes5': 73,
    'bytes6': 74,
    'bytes7': 75,
    'bytes8': 76,
    'bytes9': 77,
    'bytes10': 78,
    'bytes11': 79,
    'bytes12': 80,
    'bytes13': 81,
    'bytes14': 82,
    'bytes15': 83,
    'bytes16': 84,
    'bytes17': 85,
    'bytes18': 86,
    'bytes19': 87,
    'bytes20': 88,
    'bytes21': 89,
    'bytes22': 90,
    'bytes23': 91,
    'bytes24': 92,
    'bytes25': 93,
    'bytes26': 94,
    'bytes27': 95,
    'bytes28': 96,
    'bytes29': 97,
    'bytes30': 98,
    'bytes31': 99,
    'bytes32': 100,
    'bytes': 101,
    'string': 102,
}

const ETH_ABI_LATTICE_FW_TYPE_MAP = {
    ...EIP712_ABI_LATTICE_FW_TYPE_MAP,
    'tuple1': 103,
    'tuple2': 104,
    'tuple3': 105,
    'tuple4': 106,
    'tuple5': 107,
    'tuple6': 108,
    'tuple7': 109,
    'tuple8': 110,
    'tuple9': 111,
    'tuple10': 112,
    'tuple11': 113,
    'tuple12': 114,
    'tuple13': 115,
    'tuple14': 116,
    'tuple15': 117,
    'tuple16': 118,
    'tuple17': 119,  // Firmware currently cannot support tuples larger than this
};

const ethMsgProtocol = {
    SIGN_PERSONAL: {
        str: 'signPersonal',
        enumIdx: 0,             // Enum index of this protocol in Lattice firmware
    },
    TYPED_DATA: {
        str: 'typedData',
        enumIdx: 1,
        rawDataMaxLen: 1629,    // Max size of raw data payload in bytes
        typeCodes: EIP712_ABI_LATTICE_FW_TYPE_MAP // Enum indices of data types in Lattice firmware
    },
}

function getFwVersionConst(v) {
    const c = {
        extraDataFrameSz: 0,
        extraDataMaxFrames: 0,
    };
    function gte(v, exp) {
        // Note that `v` fields come in as [fix|minor|major]
        return  (v[2] > exp[0]) || 
                (v[2] === exp[0] && v[1] > exp[1]) || 
                (v[2] === exp[0] && v[1] === exp[1] && v[0] > exp[2]) ||
                (v[2] === exp[0] && v[1] === exp[1] && v[0] === exp[2]);
    }
    // Very old legacy versions do not give a version number
    const legacy = (v.length === 0);

    // BASE FIELDS
    //--------------------------------------

    // Various size constants have changed on the firmware side over time and
    // are captured here
    if (!legacy && gte(v, [0, 10, 4])) {
        // >=0.10.3
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    } else if (!legacy && gte(v, [0, 10, 0])) {
        // >=0.10.0
        c.reqMaxDataSz = 1678;
        c.ethMaxGasPrice = 20000000000000; // 20000 gwei
        c.addrFlagsAllowed = true;
    } else {
        // Legacy or <0.10.0
        c.reqMaxDataSz = 1152;
        c.ethMaxGasPrice = 500000000000; // 500 gwei
        c.addrFlagsAllowed = false;
    }
    // These transformations apply to all versions
    c.ethMaxDataSz = c.reqMaxDataSz - 128;
    c.ethMaxMsgSz = c.ethMaxDataSz;

    // EXTRA FIELDS ADDED IN LATER VERSIONS
    //-------------------------------------

    // V0.11.5 added an API for creating, removing, and fetching key-val file
    // records. For the purposes of this SDK, we only hook into one type of kv
    // file: address names.
    if (!legacy && gte(v, [0, 12, 0])) {
        c.kvActionsAllowed = true;
        c.kvKeyMaxStrSz = 63;
        c.kvValMaxStrSz = 63;
        c.kvActionMaxNum = 10;
        c.kvRemoveMaxNum = 100;
    }

    // V0.11.2 changed how messages are displayed. For personal_sign messages
    // we now write the header (`Signer: <path>`) into the main body of the screen.
    // This means personal sign message max size is slightly smaller than for
    // EIP712 messages because in the latter case there is no header
    // Note that `<path>` has max size of 62 bytes (`m/X/X/...`)
    if (!legacy && gte(v, [0, 11, 2])) {
        c.personalSignHeaderSz = 72;
    }

    // V0.11.0 allows new ETH transaction types
    if (!legacy && gte(v, [0, 11, 0])) {
        c.allowedEthTxTypesVersion = 1;
        c.allowedEthTxTypes = [
            1, // eip2930
            2, // eip1559
        ]
        c.totalExtraEthTxDataSz = 10;
    }

    // V0.10.10 allows a user to sign a prehashed ETH message if payload too big
    if (!legacy && gte(v, [0, 10, 10])) {
        c.ethMsgPreHashAllowed = true;
    }

    // V0.10.8 allows a user to sign a prehashed transaction if the payload
    // is too big
    if (!legacy && gte(v, [0, 10, 8])) {
        c.prehashAllowed = true;
    }
    // V0.10.5 added the ability to use flexible address path sizes, which
    // changes the `getAddress` API. It also added support for EIP712
    if (!legacy && gte(v, [0, 10, 5])) {
        c.varAddrPathSzAllowed = true;
        c.eip712Supported = true;
    }
    // V0.10.4 introduced the ability to send signing requests over multiple
    // data frames (i.e. in multiple requests)
    if (!legacy && gte(v, [0, 10, 4])) {
        c.extraDataFrameSz = 1500; // 1500 bytes per frame of extraData allowed
        c.extraDataMaxFrames = 1;  // 1 frame of extraData allowed
    }

    return c;
}

module.exports = {
    ASCII_REGEX: (/^[\x00-\x7F]+$/),
    getFwVersionConst,
    ADDR_STR_LEN,
    AES_IV,
    BASE_URL,
    ENC_MSG_LEN,
    addressSizes,
    decResLengths,
    deviceCodes,
    encReqCodes,
    ethMsgProtocol,
    messageConstants,
    responseCodes,
    responseMsgs,
    signingSchema,
    REQUEST_TYPE_BYTE,
    VERSION_BYTE,
    HARDENED_OFFSET,
    HANDLE_LARGER_CHAIN_ID,
    MAX_CHAIN_ID_BYTES,
    ETH_ABI_LATTICE_FW_TYPE_MAP,
}
      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/bitcoin.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js","bech32":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bech32/dist/index.js","bs58check":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bs58check/index.js","buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/bitcoin.js
      return function (require, module, exports) {
// Util for Bitcoin-specific functionality
const bech32 = require('bech32').bech32;
const bs58check = require('bs58check');
const Buffer = require('buffer/').Buffer;
const constants = require('./constants')
const DEFAULT_SEQUENCE = 0xffffffff;
const DEFAULT_SIGHASH_BUFFER = Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01
const { HARDENED_OFFSET } = require('./constants');
const DEFAULT_CHANGE = [44 + HARDENED_OFFSET, HARDENED_OFFSET, HARDENED_OFFSET, 1, 0];

const OP = {
  ZERO: 0x00,
  HASH160: 0xa9,
  DUP: 0x76,
  EQUAL: 0x87,
  EQUALVERIFY: 0x88,
  CHECKSIG: 0xac,
}

const addressVersion = {
  'LEGACY': 0x00,
  'SEGWIT': 0x05,
  'TESTNET': 0x6F,
  'SEGWIT_TESTNET': 0xC4,
  'SEGWIT_NATIVE_V0': 0xD0,
  'SEGWIT_NATIVE_V0_TESTNET': 0xF0,
}
exports.addressVersion = addressVersion;

// Bitcoin script types -- defined by the Lattice protocol spec
// NOTE: Only certain script types are supported for the spender, but all are supported for recipient
const scriptTypes = {
  P2PKH: 0x01, // Supported spender type
  P2SH: 0x02,
  P2SH_P2WPKH: 0x03, // Supported spender type
  P2WPKH_V0: 0x04,
}
exports.scriptTypes = scriptTypes

// We need to build two different objects here:
// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction
//    with the returned signatures to build and serialize the transaction before
//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones
//    we get from the Lattice
// 2. The serialized Lattice request, which includes data (outlined in the specification)
//    that is needed to sign all of the inputs and build a change output. 
// @inputs (contained in `data`)
// `prevOuts`: an array of objects with the following properties:
//           a. txHash
//           b. value
//           c. index          -- the index of the output in the transaction
//           d. signerPath -- the path of the address in our wallet that is signing this input
// `recipient`: Receiving address, which must be converted to a pubkeyhash
// `value`:     Number of satoshis to send the recipient
// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)
//              already based on the number of inputs plus two outputs
// `version`:   Transaction version of the inputs. All inputs must be of the same version! 
// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb
exports.buildBitcoinTxRequest = function(data) {
  try {
    const { 
      prevOuts, recipient, value, changePath=DEFAULT_CHANGE, 
      fee, isSegwit=null, changeVersion='SEGWIT', spenderScriptType=null 
    } = data;
    if (changePath.length !== 5) throw new Error('Please provide a full change path.')
    // Serialize the request
    const payload = Buffer.alloc(59 + (69 * prevOuts.length));
    let off = 0;
    // Change version byte (a.k.a. address format byte)
    if (addressVersion[changeVersion] === undefined)
      throw new Error('Invalid change version specified.');
    payload.writeUInt8(addressVersion[changeVersion]); off++;

    // Build the change data
    payload.writeUInt32LE(changePath.length, off); off += 4;
    for (let i = 0; i < changePath.length; i++) {
      payload.writeUInt32LE(changePath[i], off); off += 4;
    }    

    // Fee is a param
    payload.writeUInt32LE(fee, off); off += 4;
    const dec = decodeAddress(recipient);
    // Parameterize the recipient output
    payload.writeUInt8(dec.versionByte, off); off++;
    dec.pkh.copy(payload, off); off += dec.pkh.length;
    writeUInt64LE(value, payload, off); off += 8;

    // Build the inputs from the previous outputs
    payload.writeUInt8(prevOuts.length, off); off++;
    let inputSum = 0;

    let spenderScriptTypeToUse;
    if (spenderScriptType !== null && scriptTypes[spenderScriptType]) {
      // For newer versions we use the input scriptType
      spenderScriptTypeToUse = scriptTypes[spenderScriptType];
    } else if (isSegwit !== null) {
      // For legacy callers we use the boolean `isSegwit` to denote if we are spending
      // *wrapped* segwit inputs
      spenderScriptTypeToUse = isSegwit === true ? scriptTypes.P2SH_P2WPKH : scriptTypes.P2PKH;
    } else {
      throw new Error('Unsupported spender script type or none provided.')
    }
    prevOuts.forEach((input) => {
      if (!input.signerPath || input.signerPath.length !== 5) {
        throw new Error('Full recipient path not specified ')
      }
      payload.writeUInt32LE(input.signerPath.length, off); off += 4;
      for (let i = 0; i < input.signerPath.length; i++) {
        payload.writeUInt32LE(input.signerPath[i], off); off += 4;
      }
      payload.writeUInt32LE(input.index, off); off += 4;
      writeUInt64LE(input.value, payload, off); off += 8;
      inputSum += input.value;
      payload.writeUInt8(spenderScriptTypeToUse, off); off++;
      if (!Buffer.isBuffer(input.txHash)) input.txHash = Buffer.from(input.txHash, 'hex');
      input.txHash.copy(payload, off); off += input.txHash.length;
    })
    // Send them back!
    return {
      payload,
      spenderScriptType: spenderScriptTypeToUse,
      schema: constants.signingSchema.BTC_TRANSFER,
      origData: data,   // We will need the original data for serializing the tx
      changeData: {     // This data helps fill in the change output
        changeVersion,
        value: inputSum - (value + fee),
      }
    };
  } catch (err) {
    return { err };
  }
}

// Serialize a transaction consisting of inputs, outputs, and some
// metadata
// -- inputs  = { hash, index, sig, pubkey }
// -- outputs = { value, recipient }  // expects an address string for `recipient`
// -- isSegwitSpend = true if the inputs are being spent using segwit
//                    (NOTE: either ALL are being spent, or none are)
// -- network = Name of network, used to determine transaction version
// -- lockTime = Will probably always be 0
exports.serializeTx = function(data) {
  const { inputs, outputs, spenderScriptType, lockTime=0, crypto } = data;
  let payload = Buffer.alloc(4);
  let off = 0;
  // Always use version 2
  const version = 2;
  payload.writeUInt32LE(version, off); off += 4;
  if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {
    payload = concat(payload, Buffer.from('00', 'hex')); // marker = 0x00
    payload = concat(payload, Buffer.from('01', 'hex')); // flag = 0x01
  }
  // Serialize signed inputs
  const numInputs = getVarInt(inputs.length);
  payload = concat(payload, numInputs); off += numInputs.length;
  inputs.forEach((input) => {
    payload = concat(payload, input.hash.reverse()); off += input.hash.length;
    const index = getU32LE(input.index);
    payload = concat(payload, index); off += index.length;
    if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {
      // Build a vector (varSlice of varSlice) containing the redeemScript
      const redeemScript = buildRedeemScript(input.pubkey, crypto);
      const redeemScriptLen = getVarInt(redeemScript.length);
      const slice = Buffer.concat([redeemScriptLen, redeemScript]);
      const sliceLen = getVarInt(slice.length);
      payload = concat(payload, sliceLen); off += sliceLen.length;
      payload = concat(payload, slice); off += slice.length;
    } else {
      // Build the signature + pubkey script to spend this input
      const slice = buildSig(input.sig, input.pubkey);
      payload = concat(payload, slice); off += slice.length;
    }
    // Use the default sequence for all transactions
    const sequence = getU32LE(DEFAULT_SEQUENCE);
    payload = concat(payload, sequence); off += sequence.length;
  })
  // Serialize outputs
  const numOutputs = getVarInt(outputs.length);
  payload = concat(payload, numOutputs); off += numOutputs.length;
  outputs.forEach((output) => {
    const value = getU64LE(output.value);
    payload = concat(payload, value); off += value.length;
    // Build the output locking script and write it as a var slice
    const script = buildLockingScript(output.recipient);
    const scriptLen = getVarInt(script.length);
    payload = concat(payload, scriptLen); off += scriptLen.length;
    payload = concat(payload, script); off += script.length;
  })
  // Add witness data if needed
  if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {
    const sigs = [];
    const pubkeys = [];
    for (let i = 0; i < inputs.length; i++) {
      sigs.push(inputs[i].sig);
      pubkeys.push(inputs[i].pubkey);
    }
    const witnessSlice = buildWitness(sigs, pubkeys);
    payload = concat(payload, witnessSlice); off += witnessSlice.length;
  }
  // Finish with locktime
  return Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');
}

// Convert a pubkeyhash to a bitcoin base58check address with a version byte
exports.getBitcoinAddress = function(pubkeyhash, version) {
  return bs58check.encode(Buffer.concat([Buffer.from([version]), pubkeyhash]));
}


// Builder utils
//-----------------------
function buildRedeemScript(pubkey, crypto) {
  const redeemScript = Buffer.alloc(22);
  const shaHash = crypto.createHash('sha256').update(pubkey).digest();
  const pubkeyhash = crypto.createHash('rmd160').update(shaHash).digest();
  redeemScript.writeUInt8(OP.ZERO);
  redeemScript.writeUInt8(pubkeyhash.length, 1);
  pubkeyhash.copy(redeemScript, 2);
  return redeemScript;
}

// Var slice of signature + var slice of pubkey
function buildSig(sig, pubkey) {
  sig = Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER])
  const sigLen = getVarInt(sig.length);
  const pubkeyLen = getVarInt(pubkey.length);
  const slice = Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);
  const len = getVarInt(slice.length);
  return Buffer.concat([len, slice]);
}

// Witness is written as a "vector", which is a list of varSlices
// prefixed by the number of items
function buildWitness(sigs, pubkeys) {
  let witness = Buffer.alloc(0);
  // Two items in each vector (sig, pubkey)
  const len = Buffer.alloc(1); len.writeUInt8(2);
  for (let i = 0; i < sigs.length; i++) {
    const sig = Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);
    const sigLen = getVarInt(sig.length);
    const pubkey = pubkeys[i];
    const pubkeyLen = getVarInt(pubkey.length);
    witness = Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);
  }
  return witness;
}

// Locking script buiders
//-----------------------
function buildLockingScript(address) {
  const dec = decodeAddress(address);
  switch (dec.versionByte) {
    case addressVersion.SEGWIT_NATIVE_V0:
    case addressVersion.SEGWIT_NATIVE_V0_TESTNET:
      return buildP2wpkhLockingScript(dec.pkh);
    case addressVersion.SEGWIT:
    case addressVersion.SEGWIT_TESTNET:
      return buildP2shLockingScript(dec.pkh);
    case addressVersion.LEGACY:
    case addressVersion.TESTNET:
      return buildP2pkhLockingScript(dec.pkh);
    default:
      throw new Error(`Unknown version byte: ${dec.versionByte}. Cannot build BTC transaction.`);
  }
}

function buildP2pkhLockingScript(pubkeyhash) {
  const out = Buffer.alloc(5 + pubkeyhash.length);
  let off = 0;
  out.writeUInt8(OP.DUP, off); off++;
  out.writeUInt8(OP.HASH160, off); off++;
  out.writeUInt8(pubkeyhash.length, off); off++;
  pubkeyhash.copy(out, off); off += pubkeyhash.length;
  out.writeUInt8(OP.EQUALVERIFY, off); off++;
  out.writeUInt8(OP.CHECKSIG, off); off++;
  return out;
}

function buildP2shLockingScript(pubkeyhash) {
  const out = Buffer.alloc(3 + pubkeyhash.length);
  let off = 0;
  out.writeUInt8(OP.HASH160, off); off++;
  out.writeUInt8(pubkeyhash.length, off); off++;
  pubkeyhash.copy(out, off); off += pubkeyhash.length;
  out.writeUInt8(OP.EQUAL, off); off++;
  return out;
}

function buildP2wpkhLockingScript(pubkeyhash) {
  const out = Buffer.alloc(2 + pubkeyhash.length);
  out.writeUInt8(OP.ZERO, 0);
  out.writeUInt8(pubkeyhash.length, 1);
  pubkeyhash.copy(out, 2);
  return out;  
}

// Static Utils
//----------------------
function concat(base, addition) {
  return Buffer.concat([base, addition]);
}

function getU64LE(x) {
  const buffer = Buffer.alloc(8);
  writeUInt64LE(x, buffer, 0);
  return buffer;
}

function getU32LE(x) {
  const buffer = Buffer.alloc(4);
  buffer.writeUInt32LE(x);
  return buffer;
}

function getVarInt (x) {
  let buffer;
  if (x < 0xfd) {
    buffer = Buffer.alloc(1);
    buffer.writeUInt8(x);
  } else if (x <= 0xffff) {
    buffer = Buffer.alloc(3);
    buffer.writeUInt8(0xfd, 0);
    buffer.writeUInt16LE(x, 1);
  } else if (x < 0xffffffff) {
    buffer = Buffer.alloc(5);
    buffer.writeUInt8(0xfe, 0);
    buffer.writeUInt32LE(x, 1);
  } else {
    buffer = Buffer.alloc(9);
    buffer.writeUInt8(0xff, 0);
    buffer.writeUInt32LE(x >>> 0, 1);
    buffer.writeUInt32LE((x / 0x100000000) | 0, 5);
  }
  return buffer;
}

function writeUInt64LE(n, buf, off) {
  if (typeof n === 'number') n = n.toString(16);
  const preBuf = Buffer.alloc(8);
  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;
  const nBuf = Buffer.from(nStr, 'hex');
  nBuf.reverse().copy(preBuf, 0);
  preBuf.copy(buf, off);
  return preBuf;
}

function decodeAddress(address) {
let versionByte, pkh;
  try {
    versionByte = bs58check.decode(address)[0];
    pkh = bs58check.decode(address).slice(1);
  } catch (err) {
    try {
      const bech32Dec = bech32.decode(address);
      if (bech32Dec.prefix === 'bc')
        versionByte = 0xD0;
      else if (bech32Dec.prefix === 'tb')
        versionByte = 0xF0;
      else
        throw new Error('Unsupported prefix: must be bc or tb.');
      if (bech32Dec.words[0] !== 0)
        throw new Error(`Unsupported segwit version: must be 0, got ${bech32Dec.words[0]}`);
      pkh = Buffer.from(bech32.fromWords(bech32Dec.words.slice(1)));
    } catch (err) {
      throw new Error(`Unable to decode address: ${address}: ${err.message}`)
    }
  }
  return {versionByte, pkh};
}
      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/bitcoin.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereumAbi.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js","buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereumAbi.js
      return function (require, module, exports) {
const Buffer = require('buffer/').Buffer
const keccak256 = require('js-sha3').keccak256;
const { ETH_ABI_LATTICE_FW_TYPE_MAP } = require('./constants');
const NAME_MAX_SZ = 100;
const HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count
const CATEGORY_SZ = 32;
const PARAM_SZ = 26; // 20 byte name + 6 byte def
const MAX_PARAMS = 18;
const MAX_ABI_DEFS = 2;
exports.MAX_ABI_DEFS = MAX_ABI_DEFS;

// Build a request to add ABI data
exports.buildAddAbiPayload = function(defs) {
  if (!defs || !Array.isArray(defs))
    throw new Error('Missing definitions.');
  if (defs.length > exports.MAX_ABI_DEFS)
    throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);
  const b = Buffer.alloc(1 + (MAX_ABI_DEFS * (HEADER_SZ + CATEGORY_SZ + (PARAM_SZ * MAX_PARAMS))));
  let off = 0;
  b.writeUInt8(defs.length, off); off++;
  defs.forEach((def) => {
    if (!def.sig || !def.name || !def.params)
      throw new Error('name, sig, and params must be present for every ABI definition.')
    // -- Header data --
    const sig = Buffer.from(def.sig, 'hex');
    if (sig.length !== 4)
      throw new Error('Function signatures must always be four bytes.');
    sig.copy(b, off); off += sig.length;
    const name = Buffer.from(def.name);
    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator
      throw new Error(`Only function names shorter than ${NAME_MAX_SZ-1} characters are supported.`);
    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off); off += NAME_MAX_SZ;
    // Number of parameters
    const numParams = Array.isArray(def.params) ? def.params.length : 0;
    b.writeUInt8(numParams, off); off++;
    // -- (optional) Category name --
    if (def.category && typeof def.category === 'string') {
      const category = Buffer.from(def.category);
      if (category.length > CATEGORY_SZ - 1) // -1 accounts for null terminator
        throw new Error(`Category name must be shorter than ${CATEGORY_SZ - 1}. Got ${category.length}`);
      category.copy(b, off);
    }
    off += CATEGORY_SZ;
    // -- Param data --
    if (numParams > MAX_PARAMS)
      throw new Error('Currently only ABI defintions with <=10 parameters are supported.');
    if (numParams > 0) {
      // First copy param names (first 20 bytes)
      def.params.forEach((param) => {
        if (param.name === undefined || param.latticeTypeIdx === undefined || param.isArray === undefined || param.arraySz === undefined)
          throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');
        Buffer.from(param.name).slice(0, 20).copy(b, off); off += 20;
      })
      // Bump offset to account for blank param slots
      off += 20 * (MAX_PARAMS - numParams);
      // Next copy the definitions
      def.params.forEach((param) => {
        b.writeUInt8(param.latticeTypeIdx, off); off++;
        b.writeUInt8(param.isArray === true, off); off++;
        b.writeUInt32LE(param.arraySz, off); off += 4;
      })
      // Bump offset again
      off += 6 * (MAX_PARAMS - numParams);
    } else {
      // If there are no params, just bump the offset
      off += PARAM_SZ * MAX_PARAMS;
    }
  })
  return b;
}

// Get the 4-byte function identifier based on the canonical name
exports.getFuncSig = function(f) {
  // Canonical name is:
  // funcName(paramType0, ..., paramTypeN)
  let canonicalName = `${f.name}(`;
  f.inputs.forEach((input) => {
    if (input.type.indexOf('tuple') > -1) {
      const arrSuffix = input.type.slice(input.type.indexOf('tuple') + 5);
      canonicalName += '('
      input.components.forEach((c, i) => {
        canonicalName += `${c.type}${i === input.components.length - 1 ? '' : ','}`;
      })
      canonicalName += `)${arrSuffix},`
    } else {
      canonicalName += `${input.type},`
    }
  })
  if (f.inputs.length > 0)
    canonicalName = canonicalName.slice(0, canonicalName.length - 1)
  canonicalName += ')'
  return keccak256(canonicalName).slice(0, 8);
}

//--------------------------------------
// PARSERS
//--------------------------------------
function parseEtherscanAbiDefs(_defs, skipErrors=false) { // `_defs` are `result` of the parsed response
  const defs = [];
  _defs.forEach((d) => {
    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view' && d.constant !== true) {
      try {
        const sig = exports.getFuncSig(d);
        const params = parseEtherscanAbiInputs(d.inputs);
        defs.push({
          name: d.name,
          sig,
          params,
        })
      } catch (err) {
        if (skipErrors === true)
          console.error('Failed to load def:', d.name, err.toString())
        else
          throw new Error(err)
      }
    }
  })
  return defs;
}

exports.abiParsers = {
  etherscan: parseEtherscanAbiDefs,
}

//--------------------------------------
// HELPERS
//--------------------------------------
// Parse the ABI param data into structs Lattice firmware will recognize.
function parseEtherscanAbiInputs(inputs, data=[], isNestedTuple=false) {
  let tupleParams = [];
  inputs.forEach((input) => {
    const typeName = input.type;
    const d = { isArray: false, arraySz: 0, name: input.name, };
    const openBracketIdx = typeName.indexOf('[');
    const closeBracketIdx = typeName.indexOf(']');
    const isMultiDim = typeName.split('[').length > 2;
    if (isMultiDim) {
      throw new Error('Skipping function with unsupported multidimensional array type')
    } else {
      if (openBracketIdx > -1 && closeBracketIdx > -1) {
        if (openBracketIdx >= closeBracketIdx) {
          ; // not a valid param -- skip it
        } else if ((openBracketIdx + 1) === closeBracketIdx) {
          d.isArray = true;
        } else {
          // Parse the array size if applicable
          const number = parseInt(typeName.slice(openBracketIdx + 1, closeBracketIdx))
          if (isNaN(number)) {
            return d;
          }
          d.isArray = true;
          d.arraySz = number;
        }
      }
      let singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;
      if (singularTypeName === 'tuple') {
        if (isNestedTuple === true)
          throw new Error('Nested tuples are not supported')
        singularTypeName = `tuple${input.components.length}`;
        tupleParams = parseEtherscanAbiInputs(input.components, tupleParams, true);
      }
      d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName)
      if (!d.latticeTypeIdx)
        throw new Error(`Unsupported type: ${typeName}`)
      data.push(d)
    }
  })
  const params = data.concat(tupleParams)
  if (params.length > 18)
    throw new Error('Function has too many parameters for Lattice firmware (18 max)')
  return data.concat(tupleParams);
}

// Enum values from inside Lattice firmware
function getTypeIdxLatticeFw(type) {
  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];
}

      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereumAbi.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/util.js", {"./bitcoin":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/bitcoin.js","./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js","./ethereum":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereum.js","aes-js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/aes-js/index.js","buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer/index.js","crc-32":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/crc-32/crc32.js","elliptic":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/elliptic/lib/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/util.js
      return function (require, module, exports) {
// Static utility functions
const { buildBitcoinTxRequest } = require('./bitcoin');
const { buildEthereumTxRequest, buildEthereumMsgRequest, ensureHexBuffer } = require('./ethereum');
const Buffer = require('buffer/').Buffer
const aes = require('aes-js');
const crc32 = require('crc-32');
const elliptic = require('elliptic');
const { AES_IV, responseCodes, responseMsgs, VERSION_BYTE } = require('./constants');
const EC = elliptic.ec;
const ec = new EC('p256');

//--------------------------------------------------
// LATTICE UTILS
//--------------------------------------------------

// Parse a response from the Lattice1
function parseLattice1Response(r) {
  const parsed = {
    err: null,
    data: null,
  }
  const b = Buffer.from(r, 'hex');
  let off = 0;
  
  // Get protocol version
  const protoVer = b.readUInt8(off); off++;
  if (protoVer !== VERSION_BYTE) {
    parsed.err = 'Incorrect protocol version. Please update your SDK';
    return parsed;
  }

  // Get the type of response
  // Should always be 0x00
  const msgType = b.readUInt8(off); off++;
  if (msgType !== 0x00) {
    parsed.err = 'Incorrect response from Lattice1';
    return parsed;
  }

  // Get the payload
  b.readUInt32BE(off); off+=4; // First 4 bytes is the id, but we don't need that anymore
  const len = b.readUInt16BE(off); off+=2;
  const payload = b.slice(off, off+len); off+=len;

  // Get response code
  const responseCode = payload.readUInt8(0);
  if (responseCode !== responseCodes.RESP_SUCCESS) {
    parsed.err = `Error from device: ${responseMsgs[responseCode] ? responseMsgs[responseCode] : 'Unknown Error'}`;
    parsed.responseCode = responseCode;
    return parsed;
  } else {
    parsed.data = payload.slice(1, payload.length);
  }

  // Verify checksum
  const cs = b.readUInt32BE(off);
  const expectedCs = checksum(b.slice(0, b.length - 4));
  if (cs !== expectedCs) {
    parsed.err = 'Invalid checksum from device response'
    parsed.data = null;
    return parsed;
  }
  
  return parsed;
}

function checksum(x) {
  // crc32 returns a signed integer - need to cast it to unsigned
  // Note that this uses the default 0xedb88320 polynomial
  return crc32.buf(x) >>> 0; // Need this to be a uint, hence the bit shift
}

// Get a 74-byte padded DER-encoded signature buffer
// `sig` must be the signature output from elliptic.js
function toPaddedDER(sig) {
  // We use 74 as the maximum length of a DER signature. All sigs must
  // be right-padded with zeros so that this can be a fixed size field
  const b = Buffer.alloc(74);
  const ds = Buffer.from(sig.toDER());
  ds.copy(b);
  return b;
}

//--------------------------------------------------
// TRANSACTION UTILS
//--------------------------------------------------
const signReqResolver = {
  'BTC': buildBitcoinTxRequest,
  'ETH': buildEthereumTxRequest,
  'ETH_MSG': buildEthereumMsgRequest,
}

// Temporary helper to determine if this is a supported BIP44 parent path
function isValidAssetPath(path) {
  const HARDENED_OFFSET = 0x80000000;
  const allowedPurposes = [HARDENED_OFFSET+49, HARDENED_OFFSET+44];
  const allowedCoins = [HARDENED_OFFSET, HARDENED_OFFSET+1, HARDENED_OFFSET+60];
  const allowedAccounts = [HARDENED_OFFSET];
  const allowedChange = [0, 1]
  return (
    (allowedPurposes.indexOf(path[0]) >= 0) &&
    (allowedCoins.indexOf(path[1]) >= 0) &&
    (allowedAccounts.indexOf(path[2]) >= 0) &&
    (allowedChange.indexOf(path[3]) >= 0)
  );
}

function isValidCoinType(path) {
  return [0x80000000, 0x80000000+1, 0x80000000+60].indexOf(path[1]) >= 0
}

//--------------------------------------------------
// CRYPTO UTILS
//--------------------------------------------------
function aes256_encrypt(data, key) {
  const iv = Buffer.from(AES_IV);
  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);
  const paddedData = (data.length) % 16 === 0 ? data : aes.padding.pkcs7.pad(data);
  return Buffer.from(aesCbc.encrypt(paddedData));
}

function aes256_decrypt(data, key) {
  const iv = Buffer.from(AES_IV);
  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);
  return Buffer.from(aesCbc.decrypt(data));
}

// Decode a DER signature. Returns signature object {r, s } or null if there is an error
function parseDER(sigBuf) {
  if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02) return null;
  let off = 3;
  const sig = { r: null, s: null }
  const rLen = sigBuf[off]; off++;
  sig.r = sigBuf.slice(off, off + rLen); off += rLen
  if (sigBuf[off] !== 0x02) return null;
  off++;
  const sLen = sigBuf[off]; off++;
  sig.s = sigBuf.slice(off, off + sLen);
  return sig;
}

function getP256KeyPair (priv) {
  return ec.keyFromPrivate(priv, 'hex');
}

function getP256KeyPairFromPub(pub) {
  return ec.keyFromPublic(pub, 'hex');
}

module.exports = {
  isValidAssetPath,
  isValidCoinType,
  ensureHexBuffer,
  signReqResolver,
  aes256_decrypt,
  aes256_encrypt,
  parseDER,
  checksum,
  parseLattice1Response,
  getP256KeyPair,
  getP256KeyPairFromPub,
  toPaddedDER,
}
      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/client.js", {"./agent-base":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/agent-base.js","./is-object":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/is-object.js","./request-base":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/request-base.js","./response-base":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/response-base.js","component-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/component-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/client.js
      return function (require, module, exports) {
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('component-emitter');
var RequestBase = require('./request-base');
var isObject = require('./is-object');
var ResponseBase = require('./response-base');
var Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

      };
    };
  }
}, {package:"superagent",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/superagent/lib/client.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/index.js", {"./bits":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/bits/index.js","./buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/buffer/index.js","./byte":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/byte/index.js","./integer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/integer/index.js","./nibble":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/nibble/index.js","./string":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/string/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.string = exports.nibble = exports.integer = exports.byte = exports.buffer = exports.bits = void 0;
var bits_1 = require("./bits");
exports.bits = bits_1.default;
var buffer_1 = require("./buffer");
exports.buffer = buffer_1.default;
var byte_1 = require("./byte");
exports.byte = byte_1.default;
var integer_1 = require("./integer");
exports.integer = integer_1.default;
var nibble_1 = require("./nibble");
exports.nibble = nibble_1.default;
var string_1 = require("./string");
exports.string = string_1.default;
var bitwise = { bits: bits_1.default, buffer: buffer_1.default, byte: byte_1.default, integer: integer_1.default, nibble: nibble_1.default, string: string_1.default };
exports.default = bitwise;

      };
    };
  }
}, {package:"bitwise",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/bitwise/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereum.js", {"./constants":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/constants.js","bignumber.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/bignumber.js/bignumber.js","borc":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/borc/src/index.js","buffer/":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/buffer/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers/lib/index.js","ethers-eip712":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethers-eip712/dist/index.js","js-sha3":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha3/src/sha3.js","rlp-browser":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/rlp-browser/index.js","secp256k1":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/node_modules/secp256k1/elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereum.js
      return function (require, module, exports) {
// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which
// does not have browser (or, by proxy, React-Native) support.
const BN = require('bignumber.js');
const Buffer = require('buffer/').Buffer;
const cbor = require('borc');
const constants = require('./constants');
const ethers = require('ethers');
const eip712 = require('ethers-eip712');
const keccak256 = require('js-sha3').keccak256;
const rlp = require('rlp-browser');
const secp256k1 = require('secp256k1');

exports.buildEthereumMsgRequest = function(input) {
  if (!input.payload || !input.protocol || !input.signerPath)
    throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');
  if (input.signerPath.length > 5 || input.signerPath.length < 2) 
    throw new Error('Please provide a signer path with 2-5 indices');
  const req = {
    schema: constants.signingSchema.ETH_MSG,
    payload: null,
    input, // Save the input for later
    msg: null, // Save the buffered message for later
  }
  try {
    switch (input.protocol) {
      case 'signPersonal':
        return buildPersonalSignRequest(req, input)
      case 'eip712':
        if (!input.fwConstants.eip712Supported)
          throw new Error('EIP712 is not supported by your Lattice firmware version. Please upgrade.')
        return buildEIP712Request(req, input)
      default:
        throw new Error('Unsupported protocol');
    }
  } catch (err) {
    return { err: err.toString() }
  }
}

exports.validateEthereumMsgResponse = function(res, req) {
  const { signer, sig } = res;
  const { input, msg, prehash=null } = req;
  if (input.protocol === 'signPersonal') {
    // NOTE: We are currently hardcoding networkID=1 and useEIP155=false but these
    //       may be configurable in future versions
    const hash =  prehash ? 
                  prehash : 
                  Buffer.from(keccak256(Buffer.concat([get_personal_sign_prefix(msg.length), msg])), 'hex');
    // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
    return addRecoveryParam(hash, sig, signer, { chainId: 1, useEIP155: false })
  } else if (input.protocol === 'eip712') {
    const digest = prehash ? prehash : eip712.TypedDataUtils.encodeDigest(req.input.payload);
    // Get recovery param with a `v` value of [27,28] by setting `useEIP155=false`
    return addRecoveryParam(digest, sig, signer, { useEIP155: false })
  } else {
    throw new Error('Unsupported protocol');
  }
}

exports.buildEthereumTxRequest = function(data) {
  try {
    let { chainId=1 } = data;
    const { signerPath, eip155=null, fwConstants, type=null } = data;
    const { extraDataFrameSz, extraDataMaxFrames, prehashAllowed } = fwConstants;
    const EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
    let MAX_BASE_DATA_SZ = fwConstants.ethMaxDataSz;
    const VAR_PATH_SZ = fwConstants.varAddrPathSzAllowed;
    // Sanity checks:
    // There are a handful of named chains we allow the user to reference (`chainIds`)
    // Custom chainIDs should be either numerical or hex strings
    if (typeof chainId !== 'number' && isValidChainIdHexNumStr(chainId) === false) 
      chainId = chainIds[chainId];
    // If this was not a custom chainID and we cannot find the name of it, exit
    if (!chainId) 
      throw new Error('Unsupported chain ID or name');
    // Sanity check on signePath
    if (!signerPath) 
      throw new Error('`signerPath` not provided');
    
    // We support eip1559 and eip2930 types (as well as legacy)
    const eip1559IsAllowed = (fwConstants.allowedEthTxTypes && 
                              fwConstants.allowedEthTxTypes.indexOf(2) > -1);
    const eip2930IsAllowed = (fwConstants.allowedEthTxTypes && 
                              fwConstants.allowedEthTxTypes.indexOf(1) > -1);
    const isEip1559 = (eip1559IsAllowed && (type === 2 || type === 'eip1559'));
    const isEip2930 = (eip2930IsAllowed && (type === 1 || type === 'eip2930'));
    if (type !== null && !isEip1559 && !isEip2930)
      throw new Error('Unsupported Ethereum transaction type');
    // Determine if we should use EIP155 given the chainID.
    // If we are explicitly told to use eip155, we will use it. Otherwise,
    // we will look up if the specified chainId is associated with a chain
    // that does not use EIP155 by default. Note that most do use EIP155.
    let useEIP155 = chainUsesEIP155(chainId);
    if (eip155 !== null && typeof eip155 === 'boolean') {
      useEIP155 = eip155;
    } else if (isEip1559 || isEip2930) {
      // Newer transaction types do not use EIP155 since the chainId is serialized
      useEIP155 = false;
    }

    // Hack for metamask, which sends value=null for 0 ETH transactions
    if (!data.value)
      data.value = 0;
      
    //--------------
    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING
    //--------------
    // Ensure all fields are 0x-prefixed hex strings
    const rawTx = [];
    // Build the transaction buffer array
    const chainIdBytes = ensureHexBuffer(chainId);
    const nonceBytes = ensureHexBuffer(data.nonce);
    let gasPriceBytes;
    const gasLimitBytes = ensureHexBuffer(data.gasLimit);
    const toBytes = ensureHexBuffer(data.to);
    const valueBytes = ensureHexBuffer(data.value);
    const dataBytes = ensureHexBuffer(data.data);

    if (isEip1559 || isEip2930) {
      // EIP1559 and EIP2930 transactions have a chainID field
      rawTx.push(chainIdBytes);
    }
    rawTx.push(nonceBytes);
    let maxPriorityFeePerGasBytes, maxFeePerGasBytes;
    if (isEip1559) {
      if (!data.maxPriorityFeePerGas)
        throw new Error('EIP1559 transactions must include `maxPriorityFeePerGas`');
      if (!data.maxPriorityFeePerGas)
        throw new Error('EIP1559 transactions must include `maxFeePerGas`');
      maxPriorityFeePerGasBytes = ensureHexBuffer(data.maxPriorityFeePerGas);
      rawTx.push(maxPriorityFeePerGasBytes);
      maxFeePerGasBytes = ensureHexBuffer(data.maxFeePerGas);
      rawTx.push(maxFeePerGasBytes);
      // EIP1559 renamed "gasPrice" to "maxFeePerGas", but firmware still
      // uses `gasPrice` in the struct, so update that value here.
      gasPriceBytes = maxFeePerGasBytes;
    } else {
      // EIP1559 transactions do not have the gasPrice field
      gasPriceBytes = ensureHexBuffer(data.gasPrice);
      rawTx.push(gasPriceBytes);
    }
    rawTx.push(gasLimitBytes);
    rawTx.push(toBytes);
    rawTx.push(valueBytes);
    rawTx.push(dataBytes);
    // We do not currently support accessList in firmware so we need to prehash if
    // the list is non-null
    let PREHASH_FROM_ACCESS_LIST = false;
    if (isEip1559 || isEip2930) {
      const accessList = [];
      if (Array.isArray(data.accessList)) {
        data.accessList.forEach((listItem) => {
          const keys = [];
          listItem.storageKeys.forEach((key) => {
            keys.push(ensureHexBuffer(key))
          })
          accessList.push([ ensureHexBuffer(listItem.address), keys ])
          PREHASH_FROM_ACCESS_LIST = true;
        })
      }
      rawTx.push(accessList);
    } else if (useEIP155 === true) {
      // Add empty v,r,s values for EIP155 legacy transactions
      rawTx.push(chainIdBytes); // v (which is the same as chainId in EIP155 txs)
      rawTx.push(ensureHexBuffer(null));    // r
      rawTx.push(ensureHexBuffer(null));    // s
    }
    //--------------
    // 2. BUILD THE LATTICE REQUEST PAYLOAD
    //--------------
    const ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params
    let ETH_TX_EXTRA_FIELDS_SZ = 0; // Accounts for newer ETH tx types (e.g. eip1559)
    if (fwConstants.allowedEthTxTypesVersion === 1) {
      // eip1559 and eip2930
      // Add extra params and shrink the data region (extraData blocks are unaffected)
      ETH_TX_EXTRA_FIELDS_SZ = fwConstants.totalExtraEthTxDataSz;
      MAX_BASE_DATA_SZ -= ETH_TX_EXTRA_FIELDS_SZ;
    }
    const txReqPayload = Buffer.alloc(MAX_BASE_DATA_SZ + ETH_TX_NON_DATA_SZ);
    let off = 0;
    // 1. EIP155 switch and chainID
    //------------------
    txReqPayload.writeUInt8(Number(useEIP155), off); off++;
    // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger
    // chainID values. To account for these, we will put the chainID into the `data` buffer if it
    // is >=255. Values up to UINT64_MAX will be allowed.
    let chainIdBuf; 
    let chainIdBufSz = 0;
    if (useChainIdBuffer(chainId) === true) {
      chainIdBuf = getChainIdBuf(chainId);
      chainIdBufSz = chainIdBuf.length;
      if (chainIdBufSz > constants.MAX_CHAIN_ID_BYTES)
        throw new Error('ChainID provided is too large.');
      // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer
      txReqPayload.writeUInt8(constants.HANDLE_LARGER_CHAIN_ID, off); off++;
    } else {
      // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer
      chainIdBuf = ensureHexBuffer(chainId);
      if (chainIdBuf.length !== 1)
        throw new Error('Error parsing chainID');
      chainIdBuf.copy(txReqPayload, off); off += chainIdBuf.length;
    }
    // 2. Signer Path
    //------------------
    const signerPathBuf = buildSignerPathBuf(signerPath, VAR_PATH_SZ);
    signerPathBuf.copy(txReqPayload, off);
    off += signerPathBuf.length;

    // 3. ETH TX request data
    //------------------
    if (nonceBytes.length > 4)
      throw new Error('Nonce too large');
    nonceBytes.copy(txReqPayload, off + (4 - nonceBytes.length)); off += 4;
    if (gasPriceBytes.length > 8)
      throw new Error('Gas price too large');
    gasPriceBytes.copy(txReqPayload, off + (8 - gasPriceBytes.length)); off += 8;
    if (gasLimitBytes.length > 4)
      throw new Error('Gas limit too large');
    gasLimitBytes.copy(txReqPayload, off + (4 - gasLimitBytes.length)); off += 4;
    if (toBytes.length !== 20)
      throw new Error('Invalid `to` address');
    toBytes.copy(txReqPayload, off); off += 20;
    if (valueBytes.length > 32)
      throw new Error('Value too large');
    valueBytes.copy(txReqPayload, off + (32 - valueBytes.length)); off += 32;

    // Extra Tx data comes before `data` in the struct
    let PREHASH_UNSUPPORTED = false;
    if (fwConstants.allowedEthTxTypesVersion === 1) {
      const extraEthTxDataSz = fwConstants.totalExtraEthTxDataSz || 0;
      // Some types may not be supported by firmware, so we will need to prehash
      if (PREHASH_FROM_ACCESS_LIST) {
        PREHASH_UNSUPPORTED = true;
      }
      txReqPayload.writeUint8(PREHASH_UNSUPPORTED === true, off); off += 1;  
      // EIP1559 & EIP2930 struct version
      if (isEip1559) {
        txReqPayload.writeUint8(2, off); off += 1; // Eip1559 type enum value
        if (maxPriorityFeePerGasBytes.length > 8)
          throw new Error('maxPriorityFeePerGasBytes too large');
        maxPriorityFeePerGasBytes.copy(txReqPayload, off + (8 - maxPriorityFeePerGasBytes.length)); off += 8;
      } else if (isEip2930) {
        txReqPayload.writeUint8(1, off); off += 1; // Eip2930 type enum value
        off += extraEthTxDataSz - 2; // Skip EIP1559 params
      } else {
        off += extraEthTxDataSz - 1; // Skip EIP1559 and EIP2930 params
      }
    }

    // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable    
    const extraDataPayloads = [];
    let prehash = null;

    // Create the buffer, prefix with chainId (if needed) and add data slice
    const dataSz = dataBytes.length || 0;
    const chainIdExtraSz = chainIdBufSz > 0 ? chainIdBufSz + 1 : 0;
    const dataToCopy = Buffer.alloc(dataSz + chainIdExtraSz);
    if (chainIdExtraSz > 0) {
        dataToCopy.writeUInt8(chainIdBufSz, 0);
        chainIdBuf.copy(dataToCopy, 1);
    }
    dataBytes.copy(dataToCopy, chainIdExtraSz);

    if (dataSz > MAX_BASE_DATA_SZ) {
      // Determine sizes and run through sanity checks
      const totalSz = dataSz + chainIdExtraSz;
      const maxSzAllowed = MAX_BASE_DATA_SZ + (extraDataMaxFrames * extraDataFrameSz);

      if (prehashAllowed && totalSz > maxSzAllowed) {
        // If this payload is too large to send, but the Lattice allows a prehashed message, do that
        prehash = Buffer.from(keccak256(get_rlp_encoded_preimage(rawTx, type)), 'hex')
      } else {
        if ((!EXTRA_DATA_ALLOWED) || (EXTRA_DATA_ALLOWED && totalSz > maxSzAllowed))
          throw new Error(`Data field too large (got ${dataBytes.length}; must be <=${maxSzAllowed-chainIdExtraSz} bytes)`);
        // Split overflow data into extraData frames
        const frames = splitFrames(dataToCopy.slice(MAX_BASE_DATA_SZ), extraDataFrameSz);
        frames.forEach((frame) => {
          const szLE = Buffer.alloc(4);
          szLE.writeUInt32LE(frame.length);
          extraDataPayloads.push(Buffer.concat([szLE, frame]));
        })
      }
    } else if (PREHASH_UNSUPPORTED) {
      // If something is unsupported in firmware but we want to allow such transactions,
      // we prehash the message here.
      prehash = Buffer.from(keccak256(get_rlp_encoded_preimage(rawTx, type)), 'hex')
    }

    // Write the data size (does *NOT* include the chainId buffer, if that exists)
    txReqPayload.writeUInt16BE(dataBytes.length, off); off += 2;
    // Copy in the chainId buffer if needed
    if (chainIdBufSz > 0) {
      txReqPayload.writeUInt8(chainIdBufSz, off); off++;
      chainIdBuf.copy(txReqPayload, off); off += chainIdBufSz;
    }
    // Copy the first slice of the data itself. If this payload has been pre-hashed, include it
    // in the `data` field. This will result in a different Lattice screen being drawn.
    if (prehash) {
      prehash.copy(txReqPayload, off); off += MAX_BASE_DATA_SZ;
    } else {
      dataBytes.slice(0, MAX_BASE_DATA_SZ).copy(txReqPayload, off); off += MAX_BASE_DATA_SZ;
    }
    return {
      rawTx,
      type,
      payload: txReqPayload.slice(0, off),
      extraDataPayloads,
      schema: constants.signingSchema.ETH_TRANSFER,  // We will use eth transfer for all ETH txs for v1 
      chainId,
      useEIP155,
      signerPath,
    };
  } catch (err) {
    return { err: err.message };
  }
}

// From ethereumjs-util
function stripZeros(a) {
  let first = a[0]
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1)
    first = a[0]
  }
  return a
}

// Given a 64-byte signature [r,s] we need to figure out the v value
// and attah the full signature to the end of the transaction payload
exports.buildEthRawTx = function(tx, sig, address) {
  // RLP-encode the data we sent to the lattice
  const hash = Buffer.from(keccak256(get_rlp_encoded_preimage(tx.rawTx, tx.type)), 'hex');
  const newSig = addRecoveryParam(hash, sig, address, tx);
  // Use the signature to generate a new raw transaction payload
  // Strip the last 3 items and replace them with signature components
  const newRawTx = tx.useEIP155 ? tx.rawTx.slice(0, -3) : tx.rawTx;
  newRawTx.push(newSig.v);
  // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros
  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187
  newRawTx.push(stripZeros(newSig.r));
  newRawTx.push(stripZeros(newSig.s));
  let rlpEncodedWithSig = rlp.encode(newRawTx);
  if (tx.type) {
    rlpEncodedWithSig = Buffer.concat([Buffer.from([tx.type]), rlpEncodedWithSig])
  }
  return rlpEncodedWithSig.toString('hex');
}

// Attach a recovery parameter to a signature by brute-forcing ECRecover
function addRecoveryParam(hashBuf, sig, address, txData={}) {
  try {
    // Rebuild the keccak256 hash here so we can `ecrecover`
    const hash = new Uint8Array(hashBuf);
    let v = 0;
    // Fix signature componenet lengths to 32 bytes each
    const r = fixLen(sig.r, 32); sig.r = r;
    const s = fixLen(sig.s, 32); sig.s = s;
    // Calculate the recovery param
    const rs = new Uint8Array(Buffer.concat([r, s]));
    let pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1)
    // If the first `v` value is a match, return the sig!
    if (pubToAddrStr(pubkey) === address.toString('hex')) {
      sig.v  = getRecoveryParam(v, txData);
      return sig;
    }
    // Otherwise, try the other `v` value
    v = 1;
    pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1)
    if (pubToAddrStr(pubkey) === address.toString('hex')) {
      sig.v  = getRecoveryParam(v, txData);
      return sig;
    } else {
      // If neither is a match, we should return an error
      throw new Error('Invalid Ethereum signature returned.');
    }
  } catch (err) {
    throw new Error(err);
  }
}

// Convert an RLP-serialized transaction (plus signature) into a transaction hash
exports.hashTransaction = function(serializedTx) {
  return keccak256(Buffer.from(serializedTx, 'hex')); 
}

// Returns address string given public key buffer
function pubToAddrStr(pub) {
  return keccak256(pub).slice(-40);
}

function fixLen(msg, length) {
  const buf = Buffer.alloc(length)
  if (msg.length < length) {
    msg.copy(buf, length - msg.length)
    return buf
  }
  return msg.slice(-length)
}

// Convert a 0/1 `v` into a recovery param:
// * For non-EIP155 transactions, return `27 + v`
// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`
function getRecoveryParam(v, txData={}) {
  const { chainId, useEIP155, type } = txData;
  // For EIP1559 and EIP2930 transactions, we want the recoveryParam (0 or 1)
  // rather than the `v` value because the `chainId` is already included in the
  // transaction payload.
  if (type === 1 || type === 2) {
    return ensureHexBuffer(v, true); // 0 or 1, with 0 expected as an empty buffer
  } else if (false === useEIP155 || chainId === null) {
    // For ETH messages and non-EIP155 chains the set should be [27, 28] for `v`
    return Buffer.from(new BN(v).plus(27).toString(16), 'hex');
  }

  // We will use EIP155 in most cases. Convert v to a bignum and operate on it.
  // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36
  // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1
  // so we add 35 to that.
  const chainIdBuf = getChainIdBuf(chainId);
  const chainIdBN = new BN(chainIdBuf.toString('hex'), 16);
  return ensureHexBuffer(`0x${chainIdBN.times(2).plus(35).plus(v).toString(16)}`);
}

// Determine if the Lattice can display a string we give it. Currently, the Lattice can only
// display ASCII strings, so we will reject other UTF8 codes.
// In the future we may add a mechanism to display certain UTF8 codes such as popular emojis.
function latticeCanDisplayStr(str) {
  for (let i = 0; i < str.length; i++)
    if (str.charCodeAt(i) < 0x0020 || str.charCodeAt(i) > 0x007f)
      return false;
  return true;
}

const chainIds = {
  mainnet: 1,
  roptsten: 3,
  rinkeby: 4,
  kovan: 42,
  goerli: 5
}

// Get a buffer containing the chainId value.
// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian
function getChainIdBuf(chainId) {
  let b;
  // If our chainID is a hex string, we can convert it to a hex
  // buffer directly
  if (true === isValidChainIdHexNumStr(chainId))
    b = ensureHexBuffer(chainId);
  // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer
  else
    b = ensureHexBuffer(`0x${new BN(chainId).toString(16)}`);
  // Make sure the buffer is an allowed size
  if (b.length > 8)
    throw new Error('ChainID provided is too large.');
  // If this matches a u16, u32, or u64 size, return it now
  if (b.length <= 2 || b.length === 4 || b.length === 8)
    return b;
  // For other size buffers, we need to pack into u32 or u64 before returning;
  let buf;
  if (b.length === 3) {
    buf = Buffer.alloc(4);
    buf.writeUInt32BE(chainId);
  } else if (b.length <= 8) {
    buf = Buffer.alloc(8);
    b.copy(buf, 8 - b.length)
  }
  return buf;
}

// Determine if the chain uses EIP155 by default, based on the chainID
function chainUsesEIP155(chainID) {
  switch (chainID) {
    case 3: // ropsten
    case 4: // rinkeby
      return false;
    case 1: // mainnet
    case 42: // kovan
    case 5: // goerli
    default: // all others should use eip155
      return true;
  }
}

// Determine if a valid number was passed in as a hex string
function isValidChainIdHexNumStr(s) {
  if (typeof s !== 'string')
    return false;
  if (s.slice(0, 2) !== '0x')
    return false;
  try {
    const b = new BN(s, 16)
    return b.isNaN() === false;
  } catch (err) {
    return false;
  }
}

// If this is a nubmer that fits in one byte, we don't need to add it
// to the `data` buffer of the main transaction. 
// Note the one edge case: we still need to use the `data` field for chainID=255.
function useChainIdBuffer(id) {
  const buf = getChainIdBuf(id);
  if (buf.length === 1)
    return buf.readUInt8(0) === 255;
  return true;
}

exports.chainIds = chainIds;

function isBase10NumStr(x) {
  const bn = new BN(x).toString().split('.').join('');
  const s = new String(x)
  // Note that the JS native `String()` loses precision for large numbers, but we only
  // want to validate the base of the number so we don't care about far out precision.
  return bn.slice(0, 8) === s.slice(0, 8)
}

// Ensure a param is represented by a buffer
// TODO: Remove circular dependency in util.js so that we can put this function there
function ensureHexBuffer(x, zeroIsNull=true) {
  try {
    // For null values, return a 0-sized buffer. For most situations we assume
    // 0 should be represented with a zero-length buffer (e.g. for RLP-building
    // txs), but it can also be treated as a 1-byte buffer (`00`) if needed
    if (x === null || (x === 0 && zeroIsNull === true)) 
      return Buffer.alloc(0);
    const isNumber = typeof x === 'number' || isBase10NumStr(x);
    // Otherwise try to get this converted to a hex string
    if (isNumber) {
      // If this is a number or a base-10 number string, convert it to hex
      x = `${new BN(x).toString(16)}`;
    } else if (typeof x === 'string' && x.slice(0, 2) === '0x') {
      x = x.slice(2);
    } else {
      x = x.toString('hex')
    }
    if (x.length % 2 > 0) x = `0${x}`;
    if (x === '00' && !isNumber)
      return Buffer.alloc(0);
    return Buffer.from(x, 'hex');
  } catch (err) {
    throw new Error(`Cannot convert ${x.toString()} to hex buffer (${err.toString()})`);
  }
}
exports.ensureHexBuffer = ensureHexBuffer;


function buildPersonalSignRequest(req, input) {
  const MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;
  const VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;
  const L = (24) + MAX_BASE_MSG_SZ + 4;
  let off = 0;
  req.payload = Buffer.alloc(L);
  req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0); off += 1;
  // Write the signer path into the buffer
  const signerPathBuf = buildSignerPathBuf(input.signerPath, VAR_PATH_SZ);
  signerPathBuf.copy(req.payload, off);
  off += signerPathBuf.length;
  // Write the payload buffer. The payload can come in either as a buffer or as a string
  let payload = input.payload;
  // Determine if this is a hex string
  let displayHex = false;
  if (typeof input.payload === 'string') {
    if (input.payload.slice(0, 2) === '0x') {
      payload = ensureHexBuffer(input.payload)
      displayHex = false === constants.ASCII_REGEX.test(Buffer.from(input.payload.slice(2), 'hex').toString())
    } else {
      if (false === latticeCanDisplayStr(input.payload))
        throw new Error('Currently, the Lattice can only display ASCII strings.');
      payload = Buffer.from(input.payload)
    }
  } else if (typeof input.displayHex === 'boolean') {
    // If this is a buffer and the user has specified whether or not this
    // is a hex buffer with the optional argument, write that
    displayHex = input.displayHex
  } else {
    // Otherwise, determine if this buffer is an ASCII string. If it is, set `displayHex` accordingly.
    // NOTE: THIS MEANS THAT NON-ASCII STRINGS WILL DISPLAY AS HEX SINCE WE CANNOT KNOW IF THE REQUESTER
    //        EXPECTED NON-ASCII CHARACTERS TO DISPLAY IN A STRING
    // TODO: Develop a more elegant solution for this
    if (!input.payload.toString)
      throw new Error('Unsupported input data type');
    displayHex = false === constants.ASCII_REGEX.test(input.payload.toString())
  }
  const fwConst = input.fwConstants;
  let maxSzAllowed = MAX_BASE_MSG_SZ + (fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz);
  if (fwConst.personalSignHeaderSz) {
    // Account for the personal_sign header string
    maxSzAllowed -= fwConst.personalSignHeaderSz;
  }
  if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {
    // If this message will not fit and pre-hashing is allowed, do that
    req.payload.writeUInt8(displayHex, off); off += 1;
    req.payload.writeUInt16LE(payload.length, off); off += 2;
    const prehash = Buffer.from(keccak256(Buffer.concat([get_personal_sign_prefix(payload.length), payload])), 'hex');
    prehash.copy(req.payload, off);
    req.prehash = prehash;
  } else {
    // Otherwise we can fit the payload.
    // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable    
    const extraDataPayloads = getExtraData(payload, input);
    // Write the payload and metadata into our buffer
    req.extraDataPayloads = extraDataPayloads
    req.msg = payload;
    req.payload.writeUInt8(displayHex, off); off += 1;
    req.payload.writeUInt16LE(payload.length, off); off += 2;
    payload.copy(req.payload, off);
  }
  return req;
}

function buildEIP712Request(req, input) {
  try {
    const MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;
    const VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;
    const TYPED_DATA = constants.ethMsgProtocol.TYPED_DATA;
    const L = (24) + MAX_BASE_MSG_SZ + 4;
    let off = 0;
    req.payload = Buffer.alloc(L);
    req.payload.writeUInt8(TYPED_DATA.enumIdx, 0); off += 1;
    // Write the signer path
    const signerPathBuf = buildSignerPathBuf(input.signerPath, VAR_PATH_SZ);
    signerPathBuf.copy(req.payload, off);
    off += signerPathBuf.length;
    // Parse/clean the EIP712 payload, serialize with CBOR, and write to the payload
    const data = JSON.parse(JSON.stringify(input.payload));
    if (!data.primaryType || !data.types[data.primaryType])
      throw new Error('primaryType must be specified and the type must be included.')
    if (!data.message || !data.domain)
      throw new Error('message and domain must be specified.')
    if (0 > Object.keys(data.types).indexOf('EIP712Domain'))
      throw new Error('EIP712Domain type must be defined.')
    // Parse the payload to ensure we have valid EIP712 data types and that
    // they are encoded such that Lattice firmware can parse them.
    // We need two different encodings:
    // 1. Use `ethers` BigNumber when building the request to be validated by ethers-eip712.
    //    Make sure we use a copy of the data to avoid mutation problems
    input.payload.message = parseEIP712Msg( JSON.parse(JSON.stringify(data.message)), 
                                            JSON.parse(JSON.stringify(data.primaryType)), 
                                            JSON.parse(JSON.stringify(data.types)), 
                                            true);
    input.payload.domain = parseEIP712Msg( JSON.parse(JSON.stringify(data.domain)), 
                                            'EIP712Domain', 
                                            JSON.parse(JSON.stringify(data.types)), 
                                            true);
    // 2. Use `bignumber.js` for the request going to the Lattice, since it's the required
    //    BigNumber lib for `cbor`, which we use to encode the request data to the Lattice.
    data.domain = parseEIP712Msg(data.domain, 'EIP712Domain', data.types, false);
    data.message = parseEIP712Msg(data.message, data.primaryType, data.types, false);
    // Now build the message to be sent to the Lattice
    const payload = Buffer.from(cbor.encode(data));
    const fwConst = input.fwConstants;
    const maxSzAllowed = MAX_BASE_MSG_SZ + (fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz);
    if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {
      // If this payload is too large to send, but the Lattice allows a prehashed message, do that
      req.payload.writeUInt16LE(payload.length, off); off += 2;
      const prehash = Buffer.from(keccak256(eip712.TypedDataUtils.encodeDigest(req.input.payload), 'hex'), 'hex');
      prehash.copy(req.payload, off);
      req.prehash = prehash;
    } else {
      const extraDataPayloads = getExtraData(payload, input);
      req.extraDataPayloads = extraDataPayloads;
      req.payload.writeUInt16LE(payload.length, off); off += 2;
      payload.copy(req.payload, off); off += payload.length;
      // Slice out the part of the buffer that we didn't use.
      req.payload = req.payload.slice(0, off);
    }
    return req;
  } catch (err) {
    return { err: `Failed to build EIP712 request: ${err.message}` };
  }
}

function buildSignerPathBuf(signerPath, varAddrPathSzAllowed) {
  const buf = Buffer.alloc(24);
  let off = 0;
  if (varAddrPathSzAllowed && signerPath.length > 5)
    throw new Error('Signer path must be <=5 indices.');
  if (!varAddrPathSzAllowed && signerPath.length !== 5)
    throw new Error('Your Lattice firmware only supports 5-index derivation paths. Please upgrade.');
  buf.writeUInt32LE(signerPath.length, off); off += 4;
  for (let i = 0; i < 5; i++) {
    if (i < signerPath.length)
      buf.writeUInt32LE(signerPath[i], off); 
    else
      buf.writeUInt32LE(0, off);
    off += 4;
  }
  return buf;
}

function getExtraData(payload, input) {
  const { ethMaxMsgSz, extraDataFrameSz, extraDataMaxFrames } = input.fwConstants;
  const MAX_BASE_MSG_SZ = ethMaxMsgSz;
  const EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;
  const extraDataPayloads = [];
  if (payload.length > MAX_BASE_MSG_SZ) {
    // Determine sizes and run through sanity checks
    const maxSzAllowed = MAX_BASE_MSG_SZ + (extraDataMaxFrames * extraDataFrameSz);
    if (!EXTRA_DATA_ALLOWED)
      throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${MAX_BASE_MSG_SZ}`);
    else if (EXTRA_DATA_ALLOWED && payload.length > maxSzAllowed)
      throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${maxSzAllowed}`);
    // Split overflow data into extraData frames
    const frames = splitFrames(payload.slice(MAX_BASE_MSG_SZ), extraDataFrameSz);
    frames.forEach((frame) => {
      const szLE = Buffer.alloc(4);
      szLE.writeUInt32LE(frame.length);
      extraDataPayloads.push(Buffer.concat([szLE, frame]));
    })
  }
  return extraDataPayloads;
}

function splitFrames(data, frameSz) {
  const frames = []
  const n = Math.ceil(data.length / frameSz);
  let off = 0;
  for (let i = 0; i < n; i++) {
    frames.push(data.slice(off, off + frameSz));
    off += frameSz;
  }
  return frames;
}

function parseEIP712Msg(msg, typeName, types, isEthers=false) {
  try {
    const type = types[typeName];
    type.forEach((item) => {
      const isArrayType = item.type.indexOf('[') > -1;
      const singularType = isArrayType ? item.type.slice(0, item.type.indexOf('[')) : item.type;
      const isCustomType = Object.keys(types).indexOf(singularType) > -1;
      if (isCustomType && Array.isArray(msg)) {
        // For custom types we need to jump into the `msg` using the key (name of type) and 
        // parse that entire sub-struct as if it were a message.
        // We will recurse into sub-structs until we reach a level where every item is an
        // elementary (i.e. non-custom) type.
        // For arrays, we need to loop through each message item.
        for (let i = 0; i < msg.length; i++) {
            msg[i][item.name] = parseEIP712Msg(msg[i][item.name], singularType, types, isEthers)
        }
      } else if (isCustomType) {
        // Not an array means we can jump directly into the sub-struct to convert
        msg[item.name] = parseEIP712Msg(msg[item.name], singularType, types, isEthers)
      } else if (Array.isArray(msg)) {
        // If we have an array for this particular type and the type we are parsing
        // is *not* a custom type, loop through the array elements and convert the types.
        for (let i = 0; i < msg.length; i++) {
          if (isArrayType) {
            // If this type is itself an array, loop through those elements and parse individually.
            // This code is not reachable for custom types so we assume these are arrays of
            // elementary types.
            for (let j = 0; j < msg[i][item.name].length; j++) {
              msg[i][item.name][j] = parseEIP712Item(msg[i][item.name][j], singularType, isEthers)
            }
          } else {
            // Non-arrays parse + replace one value for the elementary type
            msg[i][item.name] = parseEIP712Item(msg[i][item.name], singularType, isEthers)
          }
        }
      } else if (isArrayType) {
        // If we have an elementary array type and a non-array message level, 
        //loop through the array and parse + replace  each item individually.
        for (let i = 0; i < msg[item.name].length; i++) {
          msg[item.name][i] = parseEIP712Item(msg[item.name][i], singularType, isEthers)
        }
      } else {
        // If this is a singular elementary type, simply parse + replace.
        msg[item.name] = parseEIP712Item(msg[item.name], singularType, isEthers)
      }
      
    })
  } catch (err) {
    throw new Error(err.message);
  }
  return msg;
}

function parseEIP712Item(data, type, isEthers=false) {
  if (type === 'bytes') {
    // Variable sized bytes need to be buffer type
    data = ensureHexBuffer(data);
  } else if (type.slice(0, 5) === 'bytes') {
    // Fixed sizes bytes need to be buffer type. We also add some sanity checks.
    const nBytes = parseInt(type.slice(5));
    data = ensureHexBuffer(data);
    if (data.length !== nBytes)
      throw new Error(`Expected ${type} type, but got ${data.length} bytes`);
  } else if (type === 'address') {
    // Address must be a 20 byte buffer
    data = ensureHexBuffer(data);
    // Edge case to handle the 0-address
    if (data.length === 0) {
      data = Buffer.alloc(20);
    }
    if (data.length !== 20)
      throw new Error(`Address type must be 20 bytes, but got ${data.length} bytes`);
    // Ethers wants addresses as hex strings
    if (isEthers === true) {
      data = `0x${data.toString('hex')}`
    }
  } else if ( (constants.ethMsgProtocol.TYPED_DATA.typeCodes[type]) && 
              (type.indexOf('uint') > -1 || type.indexOf('int') > -1)) {
    let b = ensureHexBuffer(data);
    // Edge case to handle 0-value bignums
    if (b.length === 0) {
      b = Buffer.from('00', 'hex');
    }
    // Uint256s should be encoded as bignums.
    if (isEthers === true) {
      // `ethers` uses their own BigNumber lib
      data = ethers.BigNumber.from(`0x${b.toString('hex')}`)
    } else {
      // `bignumber.js` is needed for `cbor` encoding, which gets sent to the Lattice and plays
      // nicely with its firmware cbor lib.
      // NOTE: If we instantiate a `bignumber.js` object, it will not match what `borc` creates
      // when run inside of the browser (i.e. MetaMask). Thus we introduce this hack to make sure
      // we are creating a compatible type.
      // TODO: Find another cbor lib that is compataible with the firmware's lib in a browser
      // context. This is surprisingly difficult - I tried several libs and only cbor/borc have
      // worked (borc is a supposedly "browser compatible" version of cbor)
      data = new cbor.Encoder().semanticTypes[1][0](b.toString('hex'), 16)
    }
  } else if (type === 'bool') {
    // Booleans need to be cast to a u8
    data = data === true ? 1 : 0;
  }
  // Other types don't need to be modified
  return data;
}

function get_personal_sign_prefix(L) {
  return Buffer.from(
    `\u0019Ethereum Signed Message:\n${L.toString()}`,
    'utf-8',
  );
}

function get_rlp_encoded_preimage(rawTx, txType) {
  if (txType) {
    return Buffer.concat([Buffer.from([txType]), rlp.encode(rawTx)]);
  } else {
    return rlp.encode(rawTx);
  }
}
      };
    };
  }
}, {package:"gridplus-sdk",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/gridplus-sdk/src/ethereum.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/index.js", {"./BaseController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseController.js","./BaseControllerV2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/BaseControllerV2.js","./ComposableController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ComposableController.js","./ControllerMessenger":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/ControllerMessenger.js","./approval/ApprovalController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/approval/ApprovalController.js","./assets/AccountTrackerController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AccountTrackerController.js","./assets/AssetsContractController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsContractController.js","./assets/AssetsDetectionController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/AssetsDetectionController.js","./assets/CollectiblesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CollectiblesController.js","./assets/CurrencyRateController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/CurrencyRateController.js","./assets/TokenBalancesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenBalancesController.js","./assets/TokenListController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenListController.js","./assets/TokenRatesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokenRatesController.js","./assets/TokensController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/assets/TokensController.js","./gas/GasFeeController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/gas/GasFeeController.js","./keyring/KeyringController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/keyring/KeyringController.js","./message-manager/MessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/MessageManager.js","./message-manager/PersonalMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/PersonalMessageManager.js","./message-manager/TypedMessageManager":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/message-manager/TypedMessageManager.js","./network/NetworkController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/network/NetworkController.js","./notification/NotificationController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/notification/NotificationController.js","./third-party/PhishingController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/third-party/PhishingController.js","./transaction/TransactionController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/transaction/TransactionController.js","./user/AddressBookController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/AddressBookController.js","./user/PreferencesController":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/user/PreferencesController.js","./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/util.js","isomorphic-fetch":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/isomorphic-fetch/fetch-npm-browserify.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.util = exports.getAnonymizedState = exports.getPersistentState = exports.BaseControllerV2 = void 0;
require("isomorphic-fetch");
const util = __importStar(require("./util"));
exports.util = util;
__exportStar(require("./assets/AccountTrackerController"), exports);
__exportStar(require("./user/AddressBookController"), exports);
__exportStar(require("./approval/ApprovalController"), exports);
__exportStar(require("./assets/AssetsContractController"), exports);
__exportStar(require("./assets/AssetsDetectionController"), exports);
__exportStar(require("./BaseController"), exports);
var BaseControllerV2_1 = require("./BaseControllerV2");
Object.defineProperty(exports, "BaseControllerV2", { enumerable: true, get: function () { return BaseControllerV2_1.BaseController; } });
Object.defineProperty(exports, "getPersistentState", { enumerable: true, get: function () { return BaseControllerV2_1.getPersistentState; } });
Object.defineProperty(exports, "getAnonymizedState", { enumerable: true, get: function () { return BaseControllerV2_1.getAnonymizedState; } });
__exportStar(require("./ComposableController"), exports);
__exportStar(require("./ControllerMessenger"), exports);
__exportStar(require("./assets/CurrencyRateController"), exports);
__exportStar(require("./keyring/KeyringController"), exports);
__exportStar(require("./message-manager/MessageManager"), exports);
__exportStar(require("./network/NetworkController"), exports);
__exportStar(require("./third-party/PhishingController"), exports);
__exportStar(require("./user/PreferencesController"), exports);
__exportStar(require("./assets/TokenBalancesController"), exports);
__exportStar(require("./assets/TokenRatesController"), exports);
__exportStar(require("./transaction/TransactionController"), exports);
__exportStar(require("./message-manager/PersonalMessageManager"), exports);
__exportStar(require("./message-manager/TypedMessageManager"), exports);
__exportStar(require("./notification/NotificationController"), exports);
__exportStar(require("./assets/TokenListController"), exports);
__exportStar(require("./gas/GasFeeController"), exports);
__exportStar(require("./assets/TokensController"), exports);
__exportStar(require("./assets/CollectiblesController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/controllers/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/utils.js", {"fast-deep-equal":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/fast-deep-equal/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/utils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidJson = exports.isNonEmptyArray = exports.hasProperty = exports.isPlainObject = exports.timeSince = void 0;
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
/**
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
function isPlainObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isPlainObject = isPlainObject;
const hasProperty = (object, key) => Reflect.hasOwnProperty.call(object, key);
exports.hasProperty = hasProperty;
/**
 * {@link NonEmptyArray} type guard.
 *
 * @template T - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * {@link Json} type guard.
 *
 * @param value - The value to check.
 * @returns Whether the value is valid JSON.
 */
function isValidJson(value) {
    try {
        return fast_deep_equal_1.default(value, JSON.parse(JSON.stringify(value)));
    }
    catch (_) {
        return false;
    }
}
exports.isValidJson = isValidJson;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/utils.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INLINE_SNAPS = void 0;
exports.INLINE_SNAPS = {
    IDLE: `
    console.log('Welcome to Flavortown.');
  `,
    INFINITE_LOOP: `
    console.log('Infinite loop snap start.');
    let num = 0;
    let time;
    while (true) {
      if (num === 0) {
        time = Date.now();
      }
      if (num === (2e8 - 1)) {
        console.log('Ding, gratz.');
        console.log(console.log((Date.now() - time) / 1000))
      }
      num = (num + 1) % 2e8;
  `,
    MEMORY_LEAK: `
    console.log('Memory leak snap start.')
    const getStr = () => Math.random().toString(2)
    const getLongStr = (str) => new Array(1000000).join(str)
    wallet.leakyBoi = {}
    let str
    while (true) {
      str = getStr()
      wallet.leakyBoi[str] = Object.assign({}, wallet.leakyBoi, { [str]: getLongStr(str) })
    }
  `,
};
//# sourceMappingURL=inlineSnaps.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/snaps/inlineSnaps.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs", {"./url-alphabet/index.cjs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/url-alphabet/index.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs
      return function (require, module, exports) {
let { urlAlphabet } = require('./url-alphabet/index.cjs')
if ("development" !== 'production') {
  if (
    typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative' &&
    typeof crypto === 'undefined'
  ) {
    throw new Error(
      'React Native does not have a built-in secure random generator. ' +
        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +
        'For secure IDs, import `react-native-get-random-values` ' +
        'before Nano ID.'
    )
  }
  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
    throw new Error(
      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +
        ' before importing Nano ID to fix IE 11 support'
    )
  }
  if (typeof crypto === 'undefined') {
    throw new Error(
      'Your browser does not have secure random generator. ' +
        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
    )
  }
}
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, size, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * size) / alphabet.length)
  return () => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)
let nanoid = (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array(size))
  while (size--) {
    let byte = bytes[size] & 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

      };
    };
  }
}, {package:"nanoid",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/nanoid/index.browser.cjs",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/index.js", {"./ComposedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ComposedStore.js","./MergedStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/MergedStore.js","./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/ObservableStore.js","./asStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/asStream.js","./transform":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/@metamask/obs-store/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/index.js", {"./enums":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/enums.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SNAP_STREAM_NAMES = void 0;
var enums_1 = require("./enums");
Object.defineProperty(exports, "SNAP_STREAM_NAMES", { enumerable: true, get: function () { return enums_1.STREAM_NAMES; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/snap-workers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-workers/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/index.js", {"./createEngineStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createEngineStream.js","./createStreamMiddleware":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/createStreamMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStreamMiddleware = exports.createEngineStream = void 0;
const createEngineStream_1 = __importDefault(require("./createEngineStream"));
exports.createEngineStream = createEngineStream_1.default;
const createStreamMiddleware_1 = __importDefault(require("./createStreamMiddleware"));
exports.createStreamMiddleware = createStreamMiddleware_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"json-rpc-middleware-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/node_modules/json-rpc-middleware-stream/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/index.js", {"./ObjectMultiplex":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/ObjectMultiplex.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/index.js
      return function (require, module, exports) {
"use strict";
const ObjectMultiplex_1 = require("./ObjectMultiplex");
module.exports = ObjectMultiplex_1.ObjectMultiplex;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/object-multiplex",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/object-multiplex/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/index.js", {"./WindowPostMessageStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WindowPostMessageStream.js","./WorkerParentPostMessageStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerParentPostMessageStream.js","./WorkerPostMessageStream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/WorkerPostMessageStream.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerParentPostMessageStream = exports.WorkerPostMessageStream = exports.WindowPostMessageStream = void 0;
var WindowPostMessageStream_1 = require("./WindowPostMessageStream");
Object.defineProperty(exports, "WindowPostMessageStream", { enumerable: true, get: function () { return WindowPostMessageStream_1.WindowPostMessageStream; } });
var WorkerPostMessageStream_1 = require("./WorkerPostMessageStream");
Object.defineProperty(exports, "WorkerPostMessageStream", { enumerable: true, get: function () { return WorkerPostMessageStream_1.WorkerPostMessageStream; } });
var WorkerParentPostMessageStream_1 = require("./WorkerParentPostMessageStream");
Object.defineProperty(exports, "WorkerParentPostMessageStream", { enumerable: true, get: function () { return WorkerParentPostMessageStream_1.WorkerParentPostMessageStream; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/post-message-stream",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/post-message-stream/dist/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js", {"eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionsRequestNotFoundError = exports.DuplicateCaveatError = exports.ForbiddenCaveatError = exports.InvalidCaveatFieldsError = exports.CaveatInvalidJsonError = exports.CaveatMissingValueError = exports.InvalidCaveatTypeError = exports.InvalidCaveatError = exports.CaveatAlreadyExistsError = exports.CaveatDoesNotExistError = exports.InvalidCaveatsPropertyError = exports.UnrecognizedCaveatTypeError = exports.PermissionDoesNotExistError = exports.InvalidApprovedPermissionError = exports.UnrecognizedSubjectError = exports.InvalidSubjectIdentifierError = exports.internalError = exports.userRejectedRequest = exports.invalidParams = exports.methodNotFound = exports.unauthorized = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
function unauthorized(opts) {
    return eth_rpc_errors_1.ethErrors.provider.unauthorized({
        message: 'Unauthorized to perform action. Try requesting the required permission(s) first. For more information, see: https://docs.metamask.io/guide/rpc-api.html#permissions',
        data: opts.data,
    });
}
exports.unauthorized = unauthorized;
function methodNotFound(opts) {
    const message = `The method "${opts.method}" does not exist / is not available.`;
    return eth_rpc_errors_1.ethErrors.rpc.methodNotFound({ data: opts.data, message });
}
exports.methodNotFound = methodNotFound;
function invalidParams(opts) {
    return eth_rpc_errors_1.ethErrors.rpc.invalidParams({
        data: opts.data,
        message: opts.message,
    });
}
exports.invalidParams = invalidParams;
function userRejectedRequest(data) {
    return eth_rpc_errors_1.ethErrors.provider.userRejectedRequest({ data });
}
exports.userRejectedRequest = userRejectedRequest;
function internalError(message, data) {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message, data });
}
exports.internalError = internalError;
class InvalidSubjectIdentifierError extends Error {
    constructor(origin) {
        super(`Invalid subject identifier: "${typeof origin === 'string' ? origin : typeof origin}"`);
    }
}
exports.InvalidSubjectIdentifierError = InvalidSubjectIdentifierError;
class UnrecognizedSubjectError extends Error {
    constructor(origin) {
        super(`Unrecognized subject: "${origin}" has no permissions.`);
    }
}
exports.UnrecognizedSubjectError = UnrecognizedSubjectError;
class InvalidApprovedPermissionError extends Error {
    constructor(origin, target, approvedPermission) {
        super(`Invalid approved permission for origin "${origin}" and target "${target}".`);
        this.data = { origin, target, approvedPermission };
    }
}
exports.InvalidApprovedPermissionError = InvalidApprovedPermissionError;
class PermissionDoesNotExistError extends Error {
    constructor(origin, target) {
        super(`Subject "${origin}" has no permission for "${target}".`);
    }
}
exports.PermissionDoesNotExistError = PermissionDoesNotExistError;
class UnrecognizedCaveatTypeError extends Error {
    constructor(caveatType, origin, target) {
        super(`Unrecognized caveat type: "${caveatType}"`);
        this.data = { caveatType };
        if (origin !== undefined) {
            this.data.origin = origin;
        }
        if (target !== undefined) {
            this.data.target = target;
        }
    }
}
exports.UnrecognizedCaveatTypeError = UnrecognizedCaveatTypeError;
class InvalidCaveatsPropertyError extends Error {
    constructor(origin, target, caveatsProperty) {
        super(`The "caveats" property of permission for "${target}" of subject "${origin}" is invalid. It must be a non-empty array if specified.`);
        this.data = { origin, target, caveatsProperty };
    }
}
exports.InvalidCaveatsPropertyError = InvalidCaveatsPropertyError;
class CaveatDoesNotExistError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" has no caveat of type "${caveatType}".`);
    }
}
exports.CaveatDoesNotExistError = CaveatDoesNotExistError;
class CaveatAlreadyExistsError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" already has a caveat of type "${caveatType}".`);
    }
}
exports.CaveatAlreadyExistsError = CaveatAlreadyExistsError;
class InvalidCaveatError extends eth_rpc_errors_1.EthereumRpcError {
    constructor(receivedCaveat, origin, target) {
        super(eth_rpc_errors_1.errorCodes.rpc.invalidParams, `Invalid caveat. Caveats must be plain objects.`, { receivedCaveat });
        this.data = { origin, target };
    }
}
exports.InvalidCaveatError = InvalidCaveatError;
class InvalidCaveatTypeError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat types must be strings. Received: "${typeof caveat.type}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatTypeError = InvalidCaveatTypeError;
class CaveatMissingValueError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat is missing "value" field.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatMissingValueError = CaveatMissingValueError;
class CaveatInvalidJsonError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat "value" is invalid JSON.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatInvalidJsonError = CaveatInvalidJsonError;
class InvalidCaveatFieldsError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat has unexpected number of fields: "${Object.keys(caveat).length}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatFieldsError = InvalidCaveatFieldsError;
class ForbiddenCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" may not have caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.ForbiddenCaveatError = ForbiddenCaveatError;
class DuplicateCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" contains multiple caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.DuplicateCaveatError = DuplicateCaveatError;
class PermissionsRequestNotFoundError extends Error {
    constructor(id) {
        super(`Permissions request with id "${id}" not found.`);
    }
}
exports.PermissionsRequestNotFoundError = PermissionsRequestNotFoundError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js", {"../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionsHandler = void 0;
const utils_1 = require("../utils");
exports.getPermissionsHandler = {
    methodNames: [utils_1.MethodNames.getPermissions],
    implementation: getPermissionsImplementation,
    hookNames: {
        getPermissionsForOrigin: true,
    },
};
async function getPermissionsImplementation(_req, res, _next, end, { getPermissionsForOrigin }) {
    res.result = Object.values(getPermissionsForOrigin() || {});
    return end();
}
//# sourceMappingURL=getPermissions.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/getPermissions.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js", {"../../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/utils.js","../errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js","../utils":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/utils.js","eth-rpc-errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/eth-rpc-errors/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestPermissionsHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const utils_2 = require("../../utils");
exports.requestPermissionsHandler = {
    methodNames: [utils_1.MethodNames.requestPermissions],
    implementation: requestPermissionsImplementation,
    hookNames: {
        requestPermissionsForOrigin: true,
    },
};
async function requestPermissionsImplementation(req, res, _next, end, { requestPermissionsForOrigin }) {
    const { id, params } = req;
    if ((typeof id !== 'number' && typeof id !== 'string') ||
        (typeof id === 'string' && !id)) {
        return end(eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
            message: 'Invalid request: Must specify a valid id.',
            data: { request: req },
        }));
    }
    if (!Array.isArray(params) || !utils_2.isPlainObject(params[0])) {
        return end(errors_1.invalidParams({ data: { request: req } }));
    }
    const [requestedPermissions] = params;
    const [grantedPermissions] = await requestPermissionsForOrigin(requestedPermissions, String(id));
    // `wallet_requestPermission` is specified to return an array.
    res.result = Object.values(grantedPermissions);
    return end();
}
//# sourceMappingURL=requestPermissions.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/rpc-methods/requestPermissions.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/deep-freeze-strict/index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/deep-freeze-strict/index.js
      return function (require, module, exports) {
module.exports = function deepFreeze (o) {
  Object.freeze(o);

  var oIsFunction = typeof o === "function";
  var hasOwnProp = Object.prototype.hasOwnProperty;

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (hasOwnProp.call(o, prop)
    && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true )
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

      };
    };
  }
}, {package:"deep-freeze-strict",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/deep-freeze-strict/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js", {"./errors":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/errors.js","json-rpc-engine":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/json-rpc-engine/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionMiddlewareFactory = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const errors_1 = require("./errors");
/**
 * Creates a permission middleware function factory. Intended for internal use
 * in the {@link PermissionController}. Like any {@link JsonRpcEngine}
 * middleware, each middleware will only receive requests from a particular
 * subject / origin. However, each middleware also requires access to some
 * `PermissionController` internals, which is why this "factory factory" exists.
 *
 * The middlewares returned by the factory will pass through requests for
 * unrestricted methods, and attempt to execute restricted methods. If a method
 * is neither restricted nor unrestricted, a "method not found" error will be
 * returned.
 * If a method is restricted, the middleware will first attempt to retrieve the
 * subject's permission for that method. If the permission is found, the method
 * will be executed. Otherwise, an "unauthorized" error will be returned.
 *
 * @param options - Options bag.
 * @param options.executeRestrictedMethod - {@link PermissionController._executeRestrictedMethod}.
 * @param options.getRestrictedMethod - {@link PermissionController.getRestrictedMethod}.
 * @param options.isUnrestrictedMethod - A function that checks whether a
 * particular method is unrestricted.
 * @returns A permission middleware factory function.
 */
function getPermissionMiddlewareFactory({ executeRestrictedMethod, getRestrictedMethod, isUnrestrictedMethod, }) {
    return function createPermissionMiddleware(subject) {
        const { origin } = subject;
        if (typeof origin !== 'string' || !origin) {
            throw new Error('The subject "origin" must be a non-empty string.');
        }
        const permissionsMiddleware = async (req, res, next) => {
            const { method, params } = req;
            // Skip registered unrestricted methods.
            if (isUnrestrictedMethod(method)) {
                return next();
            }
            // This will throw if no restricted method implementation is found.
            const methodImplementation = getRestrictedMethod(method, origin);
            // This will throw if the permission does not exist.
            const result = await executeRestrictedMethod(methodImplementation, subject, method, params);
            if (result === undefined) {
                res.error = errors_1.internalError(`Request for method "${req.method}" returned undefined result.`, { request: req });
                return undefined;
            }
            res.result = result;
            return undefined;
        };
        return json_rpc_engine_1.createAsyncMiddleware(permissionsMiddleware);
    };
}
exports.getPermissionMiddlewareFactory = getPermissionMiddlewareFactory;
//# sourceMappingURL=permission-middleware.js.map
      };
    };
  }
}, {package:"@metamask/snap-controllers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/snap-controllers/dist/permissions/permission-middleware.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/asStream.js", {"stream":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/stream-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/asStream.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ComposedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ComposedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/MergedStore.js", {"./ObservableStore":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/MergedStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ObservableStore.js", {"@metamask/safe-event-emitter":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@metamask/safe-event-emitter/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/ObservableStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/transform.js", {"through2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/through2/through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@metamask/obs-store/dist/transform.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js", {"@keystonehq/bc-ur-registry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/bc-ur-registry/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hdkey/lib/hdkey.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var bcUrRegistry = require('@keystonehq/bc-ur-registry');
var uuid = require('uuid');
var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');

const {
  RegistryType
} = bcUrRegistry.extend;
const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new RegistryType('eth-sign-request', 401),
  ETH_SIGNATAURE: /*#__PURE__*/new RegistryType('eth-signature', 402)
};

const {
  decodeToDataItem,
  RegistryTypes
} = bcUrRegistry.extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(exports.DataType || (exports.DataType = {}));

class EthSignRequest extends bcUrRegistry.RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.setupData = args => {
      this.requestId = args.requestId;
      this.signData = args.signData;
      this.dataType = args.dataType;
      this.chainId = args.chainId;
      this.derivationPath = args.derivationPath;
      this.address = args.address;
      this.origin = args.origin;
    };

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new bcUrRegistry.DataItem(map);
    };

    this.setupData(args);
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, '').split('/');
    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ''));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new bcUrRegistry.PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, 'hex'));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = bcUrRegistry.extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends bcUrRegistry.RegistryItem {
  constructor(signature, requestId) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      map[Keys$1.signature] = this.signature;
      return new bcUrRegistry.DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressfromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = '0x' + ethereumjsUtil.publicToAddress(publicKey.publicKey, true).toString('hex');
  return ethereumjsUtil.toChecksumAddress(address);
};
const findHDpatfromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;
    const caculateAddress = generateAddressfromXpub(xpub, path);

    if (address.toLowerCase() == caculateAddress.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

const {
  cbor
} = bcUrRegistry.extend;
cbor.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

Object.keys(bcUrRegistry).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return bcUrRegistry[k];
        }
    });
});
exports.ETHSignature = ETHSignature;
exports.EthSignRequest = EthSignRequest;
exports.findHDpatfromAddress = findHDpatfromAddress;
exports.generateAddressfromXpub = generateAddressfromXpub;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/bc-ur-registry-eth",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.development.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js", {"@keystonehq/bc-ur-registry":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/bc-ur-registry/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hdkey/lib/hdkey.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),s=require("uuid"),a=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,i=require("ethereumjs-util");const{RegistryType:r}=e.extend,n={ETH_SIGN_REQUEST:new r("eth-sign-request",401),ETH_SIGNATAURE:new r("eth-signature",402)},{decodeToDataItem:d,RegistryTypes:o}=e.extend;var h,u;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address",t[t.origin=7]="origin"}(h||(h={})),(u=exports.DataType||(exports.DataType={}))[u.transaction=1]="transaction",u[u.typedData=2]="typedData",u[u.personalMessage=3]="personalMessage",u[u.typedTransaction=4]="typedTransaction";class g extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>n.ETH_SIGN_REQUEST,this.setupData=t=>{this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address,this.origin=t.origin},this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSignRequestAddress=()=>this.address,this.getOrigin=()=>this.origin,this.toDataItem=()=>{const t={};this.requestId&&(t[h.requestId]=new e.DataItem(this.requestId,o.UUID.getTag())),this.address&&(t[h.address]=this.address),this.chainId&&(t[h.chainId]=this.chainId),this.origin&&(t[h.origin]=this.origin),t[h.signData]=this.signData,t[h.dataType]=this.dataType;const s=this.derivationPath.toDataItem();return s.setTag(this.derivationPath.getRegistryType().getTag()),t[h.derivationPath]=s,new e.DataItem(t)},this.setupData(t)}static constructETHRequest(t,a,i,r,n,d,o,h){const u=i.replace(/[m|M]\//,"").split("/"),c=new e.CryptoKeypath(u.map(t=>{const s=parseInt(t.replace("'",""));let a=!1;return t.endsWith("'")&&(a=!0),new e.PathComponent({index:s,hardened:a})}),Buffer.from(r,"hex"));return new g({requestId:n?Buffer.from(s.parse(n)):void 0,signData:t,dataType:a,derivationPath:c,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0,origin:h||void 0})}}g.fromDataItem=t=>{const s=t.getData(),a=s[h.signData],i=s[h.dataType],r=e.CryptoKeypath.fromDataItem(s[h.derivationPath]),n=s[h.chainId]?s[h.chainId]:void 0,d=s[h.address]?s[h.address]:void 0,o=s[h.requestId]?s[h.requestId].getData():void 0;return new g({requestId:o,signData:a,dataType:i,chainId:n,derivationPath:r,address:d,origin:s[h.origin]?s[h.origin]:void 0})},g.fromCBOR=t=>{const e=d(t);return g.fromDataItem(e)};const{RegistryTypes:c,decodeToDataItem:I}=e.extend;var p;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature"}(p||(p={}));class y extends e.RegistryItem{constructor(t,s){super(),this.getRegistryType=()=>n.ETH_SIGNATAURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.toDataItem=()=>{const t={};return this.requestId&&(t[p.requestId]=new e.DataItem(this.requestId,c.UUID.getTag())),t[p.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=s}}y.fromDataItem=t=>{const e=t.getData(),s=e[p.signature],a=e[p.requestId]?e[p.requestId].getData():void 0;return new y(s,a)},y.fromCBOR=t=>{const e=I(t);return y.fromDataItem(e)};const T=(t,e)=>{const s=a.fromExtendedKey(t).derive(e),r="0x"+i.publicToAddress(s.publicKey,!0).toString("hex");return i.toChecksumAddress(r)},{cbor:D}=e.extend;D.patchTags(Object.values(n).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHSignature=y,exports.EthSignRequest=g,exports.findHDpatfromAddress=(t,e,s,a)=>{for(let i=0;i<s;i++){const s=T(e,"M/0/"+i);if(t.toLowerCase()==s.toLowerCase())return`${a}/0/${i}`}return null},exports.generateAddressfromXpub=T;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/bc-ur-registry-eth",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/metamask-airgapped-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/bc-ur-registry-eth.cjs.production.min.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.development.js", {"@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/index.js","@keystonehq/bc-ur-registry-eth":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hdkey/lib/hdkey.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = 'QR Hardware Wallet Device';
const pathBase = 'm';
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = '0/*';
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error('KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.');
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error('KeystoneError#invalid_data: read signature error: mismatched requestId');
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString('hex');
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error('KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint');
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== '') {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString('hex');

      if (!xfp) {
        throw new Error('KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint');
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error('KeystoneError#invalid_data: invalid crypto-account, no crypto output found');
      }

      if (outputs.length % 5 !== 0) {
        throw new Error('KeystoneError#invalid_data: only support 5x pubkey accounts for now');
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = '0x' + ethereumjsUtil.publicToAddress(key, true).toString('hex');
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[ethereumjsUtil.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[ethereumjsUtil.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      return new Promise(async (resolve, reject) => {
        try {
          const from = (this.page - 1) * this.perPage;
          const to = from + this.perPage;
          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = await this.__addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i
            });
            this.indexes[ethereumjsUtil.toChecksumAddress(address)] = i;
          }

          resolve(accounts);
        } catch (e) {
          reject(e);
        }
      });
    };

    this.__getLedgerLivePage = increment => {
      const nextPage = this.page + increment;
      return new Promise(async (resolve, reject) => {
        try {
          const from = (nextPage - 1) * this.perPage;
          const to = from + this.perPage;
          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = await this.__addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i
            });
          }

          this.page += increment;
          resolve(accounts);
        } catch (e) {
          reject(e);
        }
      });
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace('*', String(i)).replaceAll('*', '0');
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = '0x' + ethereumjsUtil.publicToAddress(dkey.publicKey, true).toString('hex');
        return ethereumjsUtil.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return ethereumjsUtil.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = 'QR Hardware';
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = '';
    this.xpub = '';
    this.hdPath = '';
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();

    if (result.getRegistryType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(result);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(result);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error('KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly');
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  addAccounts(n = 1) {
    return new Promise(async (resolve, reject) => {
      try {
        const from = this.unlockedAccount;
        const to = from + n;
        const newAccounts = [];

        for (let i = from; i < to; i++) {
          const address = await this.__addressFromIndex(pathBase, i);
          newAccounts.push(address);
          this.page = 0;
          this.unlockedAccount++;
        }

        this.accounts = this.accounts.concat(newAccounts);
        resolve(this.accounts);
      } catch (e) {
        reject(e);
      }
    });
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  } // tx is an instance of the ethereumjs-transaction class.


  static serializeTx(tx) {
    // need use EIP-155
    // @ts-ignore
    tx.v = new ethereumjsUtil.BN(tx.common.chainId()); // @ts-ignore

    tx.r = new ethereumjsUtil.BN(0); // @ts-ignore

    tx.s = new ethereumjsUtil.BN(0);
    return tx.serialize();
  }

  async signTransaction(address, tx$1) {
    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(BaseKeyring.serializeTx(tx$1), bcUrRegistryEth.DataType.transaction, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    return tx.Transaction.fromTxData({
      to: txJson['to'],
      gasLimit: txJson['gasLimit'],
      gasPrice: txJson['gasPrice'],
      data: txJson['data'],
      nonce: txJson['nonce'],
      value: txJson['value'],
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = ethereumjsUtil.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, 'hex'), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return '0x' + Buffer.concat([r, s, v]).toString('hex');
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), 'utf-8'), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return '0x' + Buffer.concat([r, s, v]).toString('hex');
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === 'undefined') {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === 'undefined') {
        throw new Error('Unknown address');
      }

      return `${this.hdPath}/${this.childrenPath.replace('*', index.toString()).replaceAll('*', '0')}`;
    } else {
      const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === 'undefined') {
        throw new Error('Unknown address');
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/base-eth-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.development.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.production.min.js", {"@ethereumjs/tx":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@ethereumjs/tx/dist.browser/index.js","@keystonehq/bc-ur-registry-eth":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/node_modules/@keystonehq/bc-ur-registry-eth/dist/index.js","buffer":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/browserify/node_modules/buffer/index.js","ethereumjs-util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/ethereumjs-util/dist.browser/index.js","hdkey":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/hdkey/lib/hdkey.js","uuid":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/uuid/dist/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t,r,i=(e=require("hdkey"))&&"object"==typeof e&&"default"in e?e.default:e,s=require("ethereumjs-util"),n=require("@ethereumjs/tx"),a=require("@keystonehq/bc-ur-registry-eth"),o=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(r||(r={}));class h{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,i)=>{const s=await this.getInteraction().requestSignature(t,r,i),n=s.getRequestId(),a=s.getSignature();if(n&&o.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,i;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(i=e.getChildren())?void 0:i.getPath())||"0/*",o=e.getName();if(e.getNote()===r.standard?this.keyringAccount=r.standard:e.getNote()===r.ledger_legacy&&(this.keyringAccount=r.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,i;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(i=e.getOutputDescriptors())||i.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),i="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===r.ledger_live&&(this.keyringAccount=r.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=i}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=e=>(this.page+=e,this.page<=0&&(this.page=1),new Promise(async(e,t)=>{try{const t=(this.page-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}e(i)}catch(e){t(e)}})),this.__getLedgerLivePage=e=>{const t=this.page+e;return new Promise(async(r,i)=>{try{const i=(t-1)*this.perPage,s=i+this.perPage,n=[];for(let e=i;e<s;e++){const t=await this.__addressFromIndex("m",e);n.push({address:t,balance:null,index:e})}this.page+=e,r(n)}catch(e){i(e)}})},this.__addressFromIndex=async(e,r)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=i.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(r)).replaceAll("*","0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[r];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=r.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();e.getRegistryType()===a.extend.RegistryTypes.CRYPTO_HDKEY?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||r.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}addAccounts(e=1){return new Promise(async(t,r)=>{try{const r=this.unlockedAccount,i=r+e,s=[];for(let e=r;e<i;e++){const t=await this.__addressFromIndex("m",e);s.push(t),this.page=0,this.unlockedAccount++}this.accounts=this.accounts.concat(s),t(this.accounts)}catch(e){r(e)}})}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}static serializeTx(e){return e.v=new s.BN(e.common.chainId()),e.r=new s.BN(0),e.s=new s.BN(0),e.serialize()}async signTransaction(e,t){const r=await this._pathFromAddress(e),i=t.common.chainId(),s=o.v4(),c=a.EthSignRequest.constructETHRequest(h.serializeTx(t),a.DataType.transaction,r,this.xfp,s,i),{r:d,s:u,v:g}=await this.requestSignature(s,c,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),l=t.toJSON();return n.Transaction.fromTxData({to:l.to,gasLimit:l.gasLimit,gasPrice:l.gasPrice,data:l.data,nonce:l.nonce,value:l.value,r:d,s:u,v:g},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const r=s.stripHexPrefix(t),i=await this._pathFromAddress(e),n=o.v4(),h=a.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),a.DataType.personalMessage,i,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,h,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const r=await this._pathFromAddress(e),i=o.v4(),s=a.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),a.DataType.typedData,r,this.xfp,i,void 0,e),{r:n,s:h,v:c}=await this.requestSignature(i,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,h,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let r=this.indexes[t];if(void 0===r)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){r=e;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",r.toString()).replaceAll("*","0")}`}{const t=s.toChecksumAddress(e),r=this.paths[t];if(void 0===r)throw new Error("Unknown address");return r}}}h.type="QR Hardware Wallet Device",exports.BaseKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/base-eth-keyring",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@keystonehq/base-eth-keyring/dist/base-eth-keyring.cjs.production.min.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/util.js", {"../../../../shared/constants/network":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/network.js","../../../../shared/constants/transaction":"/home/clarisco/Desktop/metamask-extension-develop/shared/constants/transaction.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTxMetaForRpcResult = formatTxMetaForRpcResult;
exports.getNetworkDisplayName = void 0;

var _network = require("../../../../shared/constants/network");

var _transaction = require("../../../../shared/constants/transaction");

const getNetworkDisplayName = key => _network.NETWORK_TO_NAME_MAP[key];

exports.getNetworkDisplayName = getNetworkDisplayName;

function formatTxMetaForRpcResult(txMeta) {
  const {
    r,
    s,
    v,
    hash,
    txReceipt,
    txParams
  } = txMeta;
  const {
    to,
    data,
    nonce,
    gas,
    from,
    value,
    gasPrice,
    accessList,
    maxFeePerGas,
    maxPriorityFeePerGas
  } = txParams;
  const formattedTxMeta = {
    v,
    r,
    s,
    to,
    gas,
    from,
    hash,
    nonce,
    input: data || '0x',
    value: value || '0x0',
    accessList: accessList || null,
    blockHash: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockHash) || null,
    blockNumber: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.blockNumber) || null,
    transactionIndex: (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.transactionIndex) || null
  };

  if (maxFeePerGas && maxPriorityFeePerGas) {
    formattedTxMeta.gasPrice = maxFeePerGas;
    formattedTxMeta.maxFeePerGas = maxFeePerGas;
    formattedTxMeta.maxPriorityFeePerGas = maxPriorityFeePerGas;
    formattedTxMeta.type = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
  } else {
    formattedTxMeta.gasPrice = gasPrice;
    formattedTxMeta.type = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }

  return formattedTxMeta;
}

      };
    };
  }
}, {package:"<root>",file:"/home/clarisco/Desktop/metamask-extension-develop/app/scripts/controllers/network/util.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/keyValueStore.js", {"./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js","./utils/index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/keyValueStore.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _require = require('./utils/index'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var config = require('./config');

var ORBITDB_OPTS = config.orbitdb_options;

var KeyValueStore =
/*#__PURE__*/
function () {
  /**
   * Please use **box.public** or **box.private** to get the instance of this class
   */
  function KeyValueStore(orbitdb, name, ensureConnected, threeId) {
    (0, _classCallCheck2["default"])(this, KeyValueStore);
    this._orbitdb = orbitdb;
    this._name = name;

    if (this._name.startsWith('3box.space.')) {
      this._space = this._name.split('.')[2];
    }

    this._ensureConnected = ensureConnected;
    this._3id = threeId;
  }
  /**
   * Get the value and optionally metadata of the given key
   *
   * @param     {String}    key                             the key
   * @param     {Object}    opts                            optional parameters
   * @param     {Boolean}   opts.metadata                   return both value and metadata
   * @return    {String|{value: String, timestamp: Number}} the value associated with the key, undefined if there's no such key
   */


  (0, _createClass2["default"])(KeyValueStore, [{
    key: "get",
    value: function () {
      var _get2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(key) {
        var opts,
            x,
            metadata,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this._get(key);

              case 3:
                x = _context.sent;

                if (x) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", x);

              case 6:
                if (!opts.metadata) {
                  _context.next = 9;
                  break;
                }

                metadata = this._extractMetadata(x);
                return _context.abrupt("return", _objectSpread({}, metadata, {
                  value: x.value
                }));

              case 9:
                return _context.abrupt("return", x.value);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get2.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Get metadata for for a given key
     *
     * @param     {String}    key                     the key
     * @return    {Metadata}                          Metadata for the key, undefined if there's no such key
     */

  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(key) {
        var x;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._get(key);

              case 2:
                x = _context2.sent;

                if (x) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", x);

              case 5:
                return _context2.abrupt("return", this._extractMetadata(x));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
    /**
     * Set a value for the given key
     *
     * @param     {String}    key                     the key
     * @param     {String}    value                   the value
     * @return    {Boolean}                           true if successful
     */

  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key, value) {
        var timeStamp;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                throwIfUndefined(key, 'key');

                this._requireLoad();

                this._ensureConnected();

                timeStamp = new Date().getTime();
                _context3.next = 6;
                return this._db.put(key, {
                  value: value,
                  timeStamp: timeStamp
                });

              case 6:
                return _context3.abrupt("return", true);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
    /**
    * Set multiple values for multiple keys
    *
    * @param     {Array<String>}    keys                     the keys
    * @param     {Array<String>}    values                   the values
    * @return    {Boolean}                                  true if successful, throw error if not
    */

  }, {
    key: "setMultiple",
    value: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(keys, values) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);

                this._requireLoad();

                this._ensureConnected();

                _context5.prev = 3;
                _context5.next = 6;
                return keys.reduce(
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4(previousPromise, nextKey, index) {
                    var timeStamp;
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return previousPromise;

                          case 2:
                            throwIfUndefined(nextKey, 'key');
                            timeStamp = new Date().getTime();
                            return _context4.abrupt("return", _this._db.put(nextKey, {
                              value: values[index],
                              timeStamp: timeStamp
                            }));

                          case 5:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x7, _x8, _x9) {
                    return _ref.apply(this, arguments);
                  };
                }(), Promise.resolve());

              case 6:
                return _context5.abrupt("return", true);

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](3);
                throw new Error(_context5.t0);

              case 12:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 9]]);
      }));

      function setMultiple(_x5, _x6) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }()
    /**
     * Remove the value for the given key
     *
     * @param     {String}    key                     the key
     * @return    {Boolean}                           true if successful
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(key) {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                throwIfUndefined(key, 'key');

                this._requireLoad();

                this._ensureConnected();

                _context6.next = 5;
                return this._db.del(key);

              case 5:
                return _context6.abrupt("return", true);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function remove(_x10) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Extract metadata from store object
     * @private
     * @param x {Object} data from store
     * @return {Metadata} store metadata
     */

  }, {
    key: "_extractMetadata",
    value: function _extractMetadata(x) {
      // ms -> seconds, see issue #396 for details
      var timestamp = Math.floor(x.timeStamp / 1000);
      return {
        timestamp: timestamp
      };
    }
    /**
     * Get the raw value of the given key
     * @private
     *
     * @param     {String}    key                     the key
     * @return    {String}                            the value associated with the key
     */

  }, {
    key: "_get",
    value: function () {
      var _get3 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(key) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._requireLoad();

                return _context7.abrupt("return", this._db.get(key));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _get(_x11) {
        return _get3.apply(this, arguments);
      }

      return _get;
    }()
  }, {
    key: "_sync",
    value: function () {
      var _sync2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(numRemoteEntries) {
        var _this2 = this;

        var numEntriesDefined;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._requireLoad(); // let toid = null


                numEntriesDefined = !(numRemoteEntries === null || numRemoteEntries === undefined);

                if (!(numEntriesDefined && numRemoteEntries <= this._db._oplog.values.length)) {
                  _context8.next = 4;
                  break;
                }

                return _context8.abrupt("return", Promise.resolve());

              case 4:
                _context8.next = 6;
                return new Promise(function (resolve, reject) {
                  if (!numRemoteEntries) {
                    setTimeout(function () {
                      _this2._db.events.removeAllListeners('replicated');

                      _this2._db.events.removeAllListeners('replicate.progress');

                      resolve();
                    }, 3000);
                  }

                  _this2._db.events.on('replicated', function () {
                    if (numRemoteEntries <= _this2._db._oplog.values.length) resolve();
                  });
                  /*
                  this._db.events.on('replicate.progress', (_x, _y, _z, num, max) => {
                    if (toid) {
                      clearTimeout(toid)
                      toid = null
                    }
                    const total = numRemoteEntries || max
                    if (num >= total) {
                      this._db.events.on('replicated', resolve)
                      listenerAdded = true
                    }
                  })
                  */

                });

              case 6:
                return _context8.abrupt("return", this._db.address.toString());

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _sync(_x12) {
        return _sync2.apply(this, arguments);
      }

      return _sync;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(odbAddress) {
        var key, opts;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                key = this._3id.getKeyringBySpaceName(this._name).getPublicKeys(true).signingKey;
                opts = _objectSpread({}, ORBITDB_OPTS, {
                  format: 'dag-pb',
                  accessController: {
                    write: [key],
                    type: 'legacy-ipfs-3box',
                    skipManifest: true
                  }
                });

                if (!this._space) {
                  _context9.next = 6;
                  break;
                }

                _context9.next = 5;
                return this._3id.getOdbId(this._space);

              case 5:
                opts.identity = _context9.sent;

              case 6:
                _context9.next = 8;
                return this._orbitdb.keyvalue(odbAddress || this._name, opts);

              case 8:
                this._db = _context9.sent;
                _context9.next = 11;
                return this._db.load();

              case 11:
                return _context9.abrupt("return", this._db.address.toString());

              case 12:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _load(_x13) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_requireLoad",
    value: function _requireLoad() {
      if (!this._db) throw new Error('_load must be called before interacting with the store');
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10() {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._requireLoad();

                _context10.next = 3;
                return this._db.close();

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Get all values and optionally metadata
     *
     * @param     {Object}    opts                                    optional parameters
     * @param     {Boolean}   opts.metadata                           return both values and metadata
     * @return    {Array<String|{value: String, timestamp: Number}>}  the values
     */

  }, {
    key: "all",
    value: function () {
      var _all = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11() {
        var _this3 = this;

        var opts,
            entries,
            allSimple,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                opts = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};

                this._requireLoad();

                entries = this._db.all;
                allSimple = {};
                Object.keys(entries).map(function (key) {
                  var entry = entries[key];

                  if (opts.metadata) {
                    allSimple[key] = _objectSpread({}, _this3._extractMetadata(entry), {
                      value: entry.value
                    });
                  } else {
                    allSimple[key] = entry.value;
                  }
                });
                return _context11.abrupt("return", allSimple);

              case 6:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function all() {
        return _all.apply(this, arguments);
      }

      return all;
    }()
    /**
     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.
     * Useful for generating a complete history of all operations on store.
     *
     *  @example
     *  const log = store.log
     *  const entry = log[0]
     *  console.log(entry)
     *  // { op: 'PUT', key: 'Name', value: 'Botbot', timeStamp: '1538575416068' }
     *
     * @return    {Array<Object>}     Array of ordered log entry objects
     */

  }, {
    key: "log",
    get: function get() {
      return this._db._oplog.values.map(function (obj) {
        return {
          op: obj.payload.op,
          key: obj.payload.key,
          value: obj.payload.value ? obj.payload.value.value : null,
          timeStamp: obj.payload.value ? obj.payload.value.timeStamp : null
        };
      });
    }
  }]);
  return KeyValueStore;
}();

module.exports = KeyValueStore;
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/keyValueStore.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/get.js", {"./superPropBase.js":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/superPropBase.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/get.js
      return function (require, module, exports) {
var superPropBase = require("./superPropBase.js");

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _get.apply(this, arguments);
}

module.exports = _get;
module.exports["default"] = module.exports, module.exports.__esModule = true;
      };
    };
  }
}, {package:"@babel/runtime",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/get.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/store-engine.js", {"./util":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/store-engine.js
      return function (require, module, exports) {
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/src/store-engine.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/json2.js", {"./lib/json2":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/lib/json2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/json2.js
      return function (require, module, exports) {
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/plugins/json2.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/all.js", {"./cookieStorage":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/cookieStorage.js","./localStorage":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/localStorage.js","./memoryStorage":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/memoryStorage.js","./oldFF-globalStorage":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldFF-globalStorage.js","./oldIE-userDataStorage":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/oldIE-userDataStorage.js","./sessionStorage":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/sessionStorage.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/all.js
      return function (require, module, exports) {
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

      };
    };
  }
}, {package:"store",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/store/storages/all.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/orbit-db-address.js", {"cids":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/cids/src/index.js","multihashes":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/multihashes/src/index.js","path":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/path-browserify/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/orbit-db-address.js
      return function (require, module, exports) {
'use strict'
const path = require('path')
const multihash = require('multihashes')
const CID = require('cids')

const notEmpty = e => e !== '' && e !== ' '

class OrbitDBAddress {
  constructor (root, path) {
    this.root = root
    this.path = path
  }

  toString () {
    return path.join('/orbitdb', this.root, this.path)
  }

  static isValid (address) {
    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')

    const parts = address.toString()
      .split('/')
      .filter(containsProtocolPrefix)
      .filter(notEmpty)

    let accessControllerHash

    try {
      accessControllerHash = (parts[0].indexOf('zd') > -1 || parts[0].indexOf('Qm') > -1)
        ? new CID(parts[0]).toBaseEncodedString()
        : null
    } catch (e) {
      return false
    }

    return accessControllerHash !== null
  }

  static parse (address) {
    if (!address)
      throw new Error(`Not a valid OrbitDB address: ${address}`)

    if (!OrbitDBAddress.isValid(address))
      throw new Error(`Not a valid OrbitDB address: ${address}`)

    const parts = address.toString()
      .split('/')
      .filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb'))
      .filter(e => e !== '' && e !== ' ')

    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'))
  }
}

module.exports = OrbitDBAddress

      };
    };
  }
}, {package:"orbit-db",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/orbit-db/src/orbit-db-address.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/thread.js", {"./api":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/api.js","./config":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/config.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/defineProperty":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","is-ipfs":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/is-ipfs/src/index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/thread.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var isIPFS = require('is-ipfs');

var API = require('./api');

var config = require('./config');

var ORBITDB_OPTS = config.orbitdb_options;
var MODERATOR = 'MODERATOR';
var MEMBER = 'MEMBER';

var isValid3ID = function isValid3ID(did) {
  var parts = did.split(':');
  if (!parts[0] === 'did' || !parts[1] === '3') return false;
  return isIPFS.cid(parts[2]);
};

var Thread =
/*#__PURE__*/
function () {
  /**
   * Please use **space.joinThread** to get the instance of this class
   */
  function Thread(orbitdb, name, threeId, members, firstModerator, subscribe, ensureConnected) {
    (0, _classCallCheck2["default"])(this, Thread);
    this._orbitdb = orbitdb;
    this._name = name;
    this._spaceName = name.split('.')[2];
    this._3id = threeId;
    this._subscribe = subscribe;
    this._ensureConnected = ensureConnected;
    this._queuedNewPosts = [];
    this._members = Boolean(members);
    this._firstModerator = firstModerator || this._3id.getSubDID(this._spaceName);
  }
  /**
   * Post a message to the thread
   *
   * @param     {Object}    message                 The message
   * @return    {String}                            The postId of the new post
   */


  (0, _createClass2["default"])(Thread, [{
    key: "post",
    value: function () {
      var _post = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(message) {
        var timestamp;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._requireLoad();

                this._subscribe(this._address, {
                  firstModerator: this._firstModerator,
                  members: this._members,
                  name: this._name
                });

                this._ensureConnected(this._address, true);

                timestamp = Math.floor(new Date().getTime() / 1000); // seconds

                return _context.abrupt("return", this._db.add({
                  message: message,
                  timestamp: timestamp
                }));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function post(_x) {
        return _post.apply(this, arguments);
      }

      return post;
    }()
  }, {
    key: "_getThreadAddress",
    value: function () {
      var _getThreadAddress2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        var address;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._initConfigs();

              case 2:
                _context2.next = 4;
                return this._orbitdb._determineAddress(this._name, 'feed', {
                  accessController: this._accessController
                }, false);

              case 4:
                address = _context2.sent.toString();
                this._address = address;
                return _context2.abrupt("return", this._address);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getThreadAddress() {
        return _getThreadAddress2.apply(this, arguments);
      }

      return _getThreadAddress;
    }()
    /**
     * Add a moderator to this thread, throws error is user can not add a moderator
     *
     * @param     {String}    id                      Moderator Id
     */

  }, {
    key: "addModerator",
    value: function () {
      var _addModerator = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(id) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._requireLoad();

                if (!id.startsWith('0x')) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 4;
                return API.getSpaceDID(id, this._spaceName);

              case 4:
                id = _context3.sent;

              case 5:
                if (isValid3ID(id)) {
                  _context3.next = 7;
                  break;
                }

                throw new Error('addModerator: must provide valid 3ID');

              case 7:
                return _context3.abrupt("return", this._db.access.grant(MODERATOR, id));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function addModerator(_x2) {
        return _addModerator.apply(this, arguments);
      }

      return addModerator;
    }()
    /**
     * List moderators
     *
     * @return    {Array<String>}      Array of moderator DIDs
     */

  }, {
    key: "listModerators",
    value: function () {
      var _listModerators = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._requireLoad();

                return _context4.abrupt("return", this._db.access.capabilities['moderators']);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function listModerators() {
        return _listModerators.apply(this, arguments);
      }

      return listModerators;
    }()
    /**
     * Add a member to this thread, throws if user can not add member, throw is not member thread
     *
     * @param     {String}    id                      Member Id
     */

  }, {
    key: "addMember",
    value: function () {
      var _addMember = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(id) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._requireLoad();

                this._throwIfNotMembers();

                if (!id.startsWith('0x')) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return API.getSpaceDID(id, this._spaceName);

              case 5:
                id = _context5.sent;

              case 6:
                if (isValid3ID(id)) {
                  _context5.next = 8;
                  break;
                }

                throw new Error('addModerator: must provide valid 3ID');

              case 8:
                this._throwIfNotMembers();

                return _context5.abrupt("return", this._db.access.grant(MEMBER, id));

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function addMember(_x3) {
        return _addMember.apply(this, arguments);
      }

      return addMember;
    }()
    /**
     * List members, throws if not member thread
     *
     * @return    {Array<String>}      Array of member DIDs
     */

  }, {
    key: "listMembers",
    value: function () {
      var _listMembers = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._throwIfNotMembers();

                this._requireLoad();

                return _context6.abrupt("return", this._db.access.capabilities['members']);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function listMembers() {
        return _listMembers.apply(this, arguments);
      }

      return listMembers;
    }()
  }, {
    key: "_throwIfNotMembers",
    value: function _throwIfNotMembers() {
      if (!this._members) throw new Error('Thread: Not a members only thread, function not available');
    }
    /**
     * Delete post
     *
     * @param     {String}    id                      Moderator Id
     */

  }, {
    key: "deletePost",
    value: function () {
      var _deletePost = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(hash) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._requireLoad();

                return _context7.abrupt("return", this._db.remove(hash));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function deletePost(_x4) {
        return _deletePost.apply(this, arguments);
      }

      return deletePost;
    }()
    /**
     * Returns an array of posts, based on the options.
     * If hash not found when passing gt, gte, lt, or lte,
     * the iterator will return all items (respecting limit and reverse).
     *
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.gt                 Greater than, takes an postId
     * @param     {String}    opts.gte                Greater than or equal to, takes an postId
     * @param     {String}    opts.lt                 Less than, takes an postId
     * @param     {String}    opts.lte                Less than or equal to, takes an postId
     * @param     {Integer}   opts.limit              Limiting the number of entries in result, defaults to -1 (no limit)
     * @param     {Boolean}   opts.reverse            If set to true will result in reversing the result
     *
     * @return    {Array<Object>}                           true if successful
     */

  }, {
    key: "getPosts",
    value: function () {
      var _getPosts = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8() {
        var opts,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};

                this._requireLoad();

                if (!opts.limit) opts.limit = -1;
                return _context8.abrupt("return", this._db.iterator(opts).collect().map(function (entry) {
                  var post = entry.payload.value;
                  var metaData = {
                    postId: entry.hash,
                    author: entry.identity.id
                  };
                  return Object.assign(metaData, post);
                }));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getPosts() {
        return _getPosts.apply(this, arguments);
      }

      return getPosts;
    }()
    /**
     * Register a function to be called after new updates
     * have been received from the network or locally.
     *
     * @param     {Function}  updateFn               The function that will get called
     */

  }, {
    key: "onUpdate",
    value: function () {
      var _onUpdate = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(updateFn) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this._requireLoad();

                this._db.events.on('replicated', function (address, hash, entry, prog, tot) {
                  updateFn();
                });

                this._db.events.on('write', function (dbname, entry) {
                  updateFn();
                });

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function onUpdate(_x5) {
        return _onUpdate.apply(this, arguments);
      }

      return onUpdate;
    }()
    /**
     * Register a function to be called for every new
     * capability that is added to the thread access controller.
     * This inlcudes when a moderator or member is added.
     * The function takes one parameter, which is the capabilities obj, or
     * you can call listModerator / listMembers again instead.
     *
     * @param     {Function}  updateFn     The function that will get called
     */

  }, {
    key: "onNewCapabilities",
    value: function () {
      var _onNewCapabilities = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee10(updateFn) {
        var _this = this;

        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._db.access.on('updated', function (event) {
                  updateFn(_this._db.access.capabilities);
                });

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function onNewCapabilities(_x6) {
        return _onNewCapabilities.apply(this, arguments);
      }

      return onNewCapabilities;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(odbAddress) {
        var identity;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._initConfigs();

              case 2:
                identity = this._identity;
                _context11.next = 5;
                return this._orbitdb.feed(odbAddress || this._name, _objectSpread({}, ORBITDB_OPTS, {
                  identity: identity,
                  accessController: this._accessController
                }));

              case 5:
                this._db = _context11.sent;
                _context11.next = 8;
                return this._db.load();

              case 8:
                this._address = this._db.address.toString();

                this._ensureConnected(this._address, true);

                return _context11.abrupt("return", this._address);

              case 11:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _load(_x7) {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: "_requireLoad",
    value: function _requireLoad() {
      if (!this._db) throw new Error('_load must be called before interacting with the store');
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12() {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._requireLoad();

                _context12.next = 3;
                return this._db.close();

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_initConfigs",
    value: function () {
      var _initConfigs2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13() {
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!this._identity) {
                  _context13.next = 2;
                  break;
                }

                return _context13.abrupt("return");

              case 2:
                _context13.next = 4;
                return this._3id.getOdbId(this._spaceName);

              case 4:
                this._identity = _context13.sent;

                if (!this._firstModerator.startsWith('0x')) {
                  _context13.next = 9;
                  break;
                }

                _context13.next = 8;
                return API.getSpaceDID(this._firstModerator, this._spaceName);

              case 8:
                this._firstModerator = _context13.sent;

              case 9:
                this._accessController = {
                  type: 'thread-access',
                  threadName: this._name,
                  members: this._members,
                  firstModerator: this._firstModerator,
                  identity: this._identity
                };

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _initConfigs() {
        return _initConfigs2.apply(this, arguments);
      }

      return _initConfigs;
    }()
  }, {
    key: "address",
    get: function get() {
      return this._db ? this._address : null;
    }
  }]);
  return Thread;
}();

module.exports = Thread;
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/thread.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/verifier.js", {"./index":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/index.js","@babel/runtime/helpers/asyncToGenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/@babel/runtime/regenerator/index.js","did-jwt":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/did-jwt/lib/index.js","ethers":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js","https-did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/https-did-resolver/lib/register.js","muport-did-resolver":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/muport-did-resolver/lib/register.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/verifier.js
      return function (require, module, exports) {
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _require = require('./index'),
    fetchText = _require.fetchText,
    getMessageConsent = _require.getMessageConsent;

var didJWT = require('did-jwt');

var ethers = require('ethers');

require('https-did-resolver')["default"]();

require('muport-did-resolver')();

module.exports = {
  /**
   * Verifies that the gist contains the given muportDID and returns the users github username.
   * Throws an error otherwise.
   *
   * @param     {String}            did                     The muport DID of the user
   * @param     {Object}            gistUrl                 URL of the proof
   * @return    {Object}                                    Object containing username, and proof
   */
  verifyGithub: function () {
    var _verifyGithub = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(did, gistUrl) {
      var gistFileContent, username;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!gistUrl || gistUrl.trim() === '')) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", null);

            case 2:
              _context.next = 4;
              return fetchText(gistUrl);

            case 4:
              gistFileContent = _context.sent;

              if (!(gistFileContent.indexOf(did) === -1)) {
                _context.next = 7;
                break;
              }

              throw new Error('Gist File provided does not contain the correct DID of the user');

            case 7:
              username = gistUrl.split('/')[3];
              return _context.abrupt("return", {
                username: username,
                proof: gistUrl
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function verifyGithub(_x, _x2) {
      return _verifyGithub.apply(this, arguments);
    }

    return verifyGithub;
  }(),

  /**
   * Verifies that the tweet contains the given muportDID and returns the users twitter username.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyTwitter: function () {
    var _verifyTwitter = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (claim) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", null);

            case 2:
              _context2.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context2.sent;

              if (!(verified.payload.sub !== did)) {
                _context2.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (!(!claimData.twitter_handle || !claimData.twitter_proof)) {
                _context2.next = 10;
                break;
              }

              throw new Error('The claim for your twitter is not correct');

            case 10:
              return _context2.abrupt("return", {
                username: claimData.twitter_handle,
                proof: claimData.twitter_proof,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function verifyTwitter(_x3, _x4) {
      return _verifyTwitter.apply(this, arguments);
    }

    return verifyTwitter;
  }(),

  /**
   * Verifies that the code entered by the user is the same one that was sent via email.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyEmail: function () {
    var _verifyEmail = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee3(did, claim) {
      var verified, claimData;
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (claim) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", null);

            case 2:
              _context3.next = 4;
              return didJWT.verifyJWT(claim);

            case 4:
              verified = _context3.sent;

              if (!(verified.payload.sub !== did)) {
                _context3.next = 7;
                break;
              }

              throw new Error('Verification not valid for given user');

            case 7:
              claimData = verified.payload.claim;

              if (claimData.email_address) {
                _context3.next = 10;
                break;
              }

              throw new Error('The claim for your email address is not correct');

            case 10:
              return _context3.abrupt("return", {
                email_address: claimData.email_address,
                verifiedBy: verified.payload.iss
              });

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    function verifyEmail(_x5, _x6) {
      return _verifyEmail.apply(this, arguments);
    }

    return verifyEmail;
  }(),

  /**
   * Verifies that the proof for a did is correct
   *
   * @param     {String}            claim           A did-JWT with claim
   * @return    {String}                            The DID of the user
   */
  verifyDID: function () {
    var _verifyDID = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee4(claim) {
      var verified;
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return didJWT.verifyJWT(claim);

            case 2:
              verified = _context4.sent;
              return _context4.abrupt("return", verified.payload.iss);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function verifyDID(_x7) {
      return _verifyDID.apply(this, arguments);
    }

    return verifyDID;
  }(),

  /**
   * Verifies that the proof for an ethereum address is correct
   *
   * @param     {Object}    ethProof                      The claim generated by getLinkConsent
   * @param     {string}    ethProof.consent_msg
   * @param     {string}    ethProof.consent_signature
   * @param     {string}    ethProof.linked_did
   * @param     {String}    did                           The box' did
   * @return    {String}                                  The ethereum address used to sign the message
   */
  verifyEthereum: function () {
    var _verifyEthereum = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee5(ethProof, did) {
      var consentMsg, consentSig, expected;
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              consentMsg = ethProof.version ? ethProof.message : ethProof['consent_msg'];
              consentSig = ethProof.version ? ethProof.signature : ethProof['consent_signature']; // Make sure the message matches our expectation

              expected = getMessageConsent(did);

              if (!(consentMsg !== expected)) {
                _context5.next = 5;
                break;
              }

              throw new Error("Invalid consent message, got: \"".concat(consentMsg, "\", expected: \"").concat(expected, "\""));

            case 5:
              return _context5.abrupt("return", ethers.utils.verifyMessage(consentMsg, consentSig));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    function verifyEthereum(_x8, _x9) {
      return _verifyEthereum.apply(this, arguments);
    }

    return verifyEthereum;
  }()
};
      };
    };
  }
}, {package:"3box",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/lib/utils/verifier.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/index.js", {"./types":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/types.js","cross-fetch/polyfill":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/node_modules/cross-fetch/dist/browser-polyfill.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/index.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("./types");
var types_2 = require("./types");
exports.ClientError = types_2.ClientError;
require("cross-fetch/polyfill");
var GraphQLClient = /** @class */ (function () {
    function GraphQLClient(url, options) {
        this.url = url;
        this.options = options || {};
    }
    GraphQLClient.prototype.rawRequest = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, others, body, response, result, headers_1, status_1, errorResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                        body = JSON.stringify({
                            query: query,
                            variables: variables ? variables : undefined,
                        });
                        return [4 /*yield*/, fetch(this.url, __assign({ method: 'POST', headers: Object.assign({ 'Content-Type': 'application/json' }, headers), body: body }, others))];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, getResult(response)];
                    case 2:
                        result = _b.sent();
                        if (response.ok && !result.errors && result.data) {
                            headers_1 = response.headers, status_1 = response.status;
                            return [2 /*return*/, __assign({}, result, { headers: headers_1, status: status_1 })];
                        }
                        else {
                            errorResult = typeof result === 'string' ? { error: result } : result;
                            throw new types_1.ClientError(__assign({}, errorResult, { status: response.status, headers: response.headers }), { query: query, variables: variables });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphQLClient.prototype.request = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, others, body, response, result, errorResult;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, others = __rest(_a, ["headers"]);
                        body = JSON.stringify({
                            query: query,
                            variables: variables ? variables : undefined,
                        });
                        return [4 /*yield*/, fetch(this.url, __assign({ method: 'POST', headers: Object.assign({ 'Content-Type': 'application/json' }, headers), body: body }, others))];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, getResult(response)];
                    case 2:
                        result = _b.sent();
                        if (response.ok && !result.errors && result.data) {
                            return [2 /*return*/, result.data];
                        }
                        else {
                            errorResult = typeof result === 'string' ? { error: result } : result;
                            throw new types_1.ClientError(__assign({}, errorResult, { status: response.status }), { query: query, variables: variables });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    GraphQLClient.prototype.setHeaders = function (headers) {
        this.options.headers = headers;
        return this;
    };
    GraphQLClient.prototype.setHeader = function (key, value) {
        var headers = this.options.headers;
        if (headers) {
            headers[key] = value;
        }
        else {
            this.options.headers = (_a = {}, _a[key] = value, _a);
        }
        return this;
        var _a;
    };
    return GraphQLClient;
}());
exports.GraphQLClient = GraphQLClient;
function rawRequest(url, query, variables) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.rawRequest(query, variables)];
        });
    });
}
exports.rawRequest = rawRequest;
function request(url, query, variables) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.request(query, variables)];
        });
    });
}
exports.request = request;
exports.default = request;
function getResult(response) {
    return __awaiter(this, void 0, void 0, function () {
        var contentType;
        return __generator(this, function (_a) {
            contentType = response.headers.get('Content-Type');
            if (contentType && contentType.startsWith('application/json')) {
                return [2 /*return*/, response.json()];
            }
            else {
                return [2 /*return*/, response.text()];
            }
            return [2 /*return*/];
        });
    });
}
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"graphql-request",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/graphql-request/dist/src/index.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js
      return function (require, module, exports) {
!function(e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).ethers=e()}(function(){return function o(s,a,u){function l(t,e){if(!a[t]){if(!s[t]){var r="function"==typeof require&&require;if(!e&&r)return r(t,!0);if(h)return h(t,!0);var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}var i=a[t]={exports:{}};s[t][0].call(i.exports,function(e){return l(s[t][1][e]||e)},i,i.exports,o,s,a,u)}return a[t].exports}for(var h="function"==typeof require&&require,e=0;e<u.length;e++)l(u[e]);return l}({1:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.version="4.0.48"},{}],2:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./utils/properties"),i=(o.isSigner=function(e){return n.isType(e,"Signer")},o);function o(){n.setType(this,"Signer")}r.Signer=i},{"./utils/properties":74}],3:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./utils/bignumber");r.AddressZero="0x0000000000000000000000000000000000000000";r.HashZero="0x0000000000000000000000000000000000000000000000000000000000000000";r.EtherSymbol="\u039e";var i=n.bigNumberify(-1);r.NegativeOne=i;var o=n.bigNumberify(0);r.Zero=o;var s=n.bigNumberify(1);r.One=s;var a=n.bigNumberify(2);r.Two=a;var u=n.bigNumberify("1000000000000000000");r.WeiPerEther=u;var l=n.bigNumberify("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");r.MaxUint256=l},{"./utils/bignumber":63}],4:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,u=e("./constants"),l=o(e("./errors")),h=e("./utils/abi-coder"),a=e("./utils/address"),f=e("./utils/bignumber"),c=e("./utils/bytes"),d=e("./utils/interface"),p=e("./utils/properties"),v=e("./providers/abstract-provider"),y=e("./abstract-signer"),m=(s=y.Signer,i(g,s),g.prototype.getAddress=function(){return Promise.resolve(this.address)},g.prototype._fail=function(e,t){return Promise.resolve().then(function(){l.throwError(e,l.UNSUPPORTED_OPERATION,{operation:t})})},g.prototype.signMessage=function(e){return this._fail("VoidSigner cannot sign messages","signMessage")},g.prototype.sendTransaction=function(e){return this._fail("VoidSigner cannot sign transactions","sendTransaction")},g.prototype.connect=function(e){return new g(this.address,e)},g);function g(e,t){var r=s.call(this)||this;return p.defineReadOnly(r,"address",e),p.defineReadOnly(r,"provider",t),r}r.VoidSigner=m;var b={chainId:!0,data:!0,from:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0};function w(o,e,s){var a=o.interface.functions[e];return function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var i={},r=null;if(e.length===a.inputs.length+1&&"object"==typeof e[e.length-1])for(var n in null!=(i=p.shallowCopy(e.pop())).blockTag&&(r=i.blockTag),delete i.blockTag,i)if(!b[n])throw new Error("unknown transaction override "+n);if(e.length!=a.inputs.length)throw new Error("incorrect number of arguments");return["data","to"].forEach(function(e){null!=i[e]&&l.throwError("cannot override "+e,l.UNSUPPORTED_OPERATION,{operation:e})}),i.to=o._deployed(r).then(function(){return o.addressPromise}),function n(i,o,e){if(Array.isArray(e)){var s=[];return e.forEach(function(e,t){var r=null,r=Array.isArray(o)?o[t]:o[e.name];s.push(n(i,r,e))}),Promise.all(s)}if("address"===e.type)return i.resolveName(o);if("tuple"===e.type)return n(i,o,e.components);var t=e.type.match(/(.*)(\[[0-9]*\]$)/);if(t){if(!Array.isArray(o))throw new Error("invalid value for array");var r=[],a={components:e.components,type:t[1]};return o.forEach(function(e){r.push(n(i,e,a))}),Promise.all(r)}return Promise.resolve(o)}(o.provider,e,a.inputs).then(function(n){if(i.data=a.encode(n),"call"===a.type)return s?Promise.resolve(u.Zero):(o.provider||l.throwError("call (constant functions) require a provider or a signer with a provider",l.UNSUPPORTED_OPERATION,{operation:"call"}),["gasLimit","gasPrice","value"].forEach(function(e){if(null!=i[e])throw new Error("call cannot override "+e)}),null==i.from&&o.signer&&(i.from=o.signer.getAddress()),o.provider.call(i,r).then(function(t){var e;c.hexDataLength(t)%32==4&&"0x08c379a0"===c.hexDataSlice(t,0,4)&&(e=h.defaultAbiCoder.decode(["string"],c.hexDataSlice(t,4)),l.throwError("call revert exception",l.CALL_EXCEPTION,{address:o.address,args:n,method:a.signature,errorSignature:"Error(string)",errorArgs:[e],reason:e,transaction:i}));try{var r=a.decode(t);return 1===a.outputs.length&&(r=r[0]),r}catch(e){throw"0x"===t&&0<a.outputs.length&&l.throwError("call exception",l.CALL_EXCEPTION,{address:o.address,method:a.signature,args:n}),e}}));if("transaction"===a.type)return s?(o.provider||l.throwError("estimate gas require a provider or a signer with a provider",l.UNSUPPORTED_OPERATION,{operation:"estimateGas"}),null==i.from&&o.signer&&(i.from=o.signer.getAddress()),o.provider.estimateGas(i)):(null==i.gasLimit&&null!=a.gas&&(i.gasLimit=f.bigNumberify(a.gas).add(21e3)),o.signer||l.throwError("sending a transaction requires a signer",l.UNSUPPORTED_OPERATION,{operation:"sendTransaction"}),null!=i.from&&l.throwError("cannot override from in a transaction",l.UNSUPPORTED_OPERATION,{operation:"sendTransaction"}),o.signer.sendTransaction(i).then(function(e){var t=e.wait.bind(e);return e.wait=function(e){return t(e).then(function(n){return n.events=n.logs.map(function(e){var t=p.deepCopy(e),r=o.interface.parseLog(e);return r&&(t.args=r.values,t.decode=r.decode,t.event=r.name,t.eventSignature=r.signature),t.removeListener=function(){return o.provider},t.getBlock=function(){return o.provider.getBlock(n.blockHash)},t.getTransaction=function(){return o.provider.getTransaction(n.transactionHash)},t.getTransactionReceipt=function(){return Promise.resolve(n)},t}),n})},e}));throw new Error("invalid type - "+a.type)})}}function _(e){return!e.address||null!=e.topics&&0!==e.topics.length?(e.address||"*")+"@"+(e.topics?e.topics.join(":"):""):"*"}var M=(A.prototype.deployed=function(){return this._deployed()},A.prototype._deployed=function(e){var t=this;return this._deployedPromise||(this.deployTransaction?this._deployedPromise=this.deployTransaction.wait().then(function(){return t}):this._deployedPromise=this.provider.getCode(this.address,e).then(function(e){return"0x"===e&&l.throwError("contract not deployed",l.UNSUPPORTED_OPERATION,{contractAddress:t.address,operation:"getDeployed"}),t})),this._deployedPromise},A.prototype.fallback=function(e){var t=this;this.signer||l.throwError("sending a transaction requires a signer",l.UNSUPPORTED_OPERATION,{operation:"sendTransaction(fallback)"});var r=p.shallowCopy(e||{});return["from","to"].forEach(function(e){null!=r[e]&&l.throwError("cannot override "+e,l.UNSUPPORTED_OPERATION,{operation:e})}),r.to=this.addressPromise,this.deployed().then(function(){return t.signer.sendTransaction(r)})},A.prototype.connect=function(e){"string"==typeof e&&(e=new m(e,this.provider));var t=new A(this.address,this.interface,e);return this.deployTransaction&&p.defineReadOnly(t,"deployTransaction",this.deployTransaction),t},A.prototype.attach=function(e){return new A(e,this.interface,this.signer||this.provider)},A.isIndexed=function(e){return d.Interface.isIndexed(e)},A.prototype._getEventFilter=function(e){var r=this;if("string"==typeof e){if("*"===e)return{prepareEvent:function(e){var t=r.interface.parseLog(e);return t&&(e.args=t.values,e.decode=t.decode,e.event=t.name,e.eventSignature=t.signature),[e]},eventTag:"*",filter:{address:this.address}};-1!==e.indexOf("(")&&(e=h.formatSignature(h.parseSignature("event "+e)));var n=this.interface.events[e];n||l.throwError("unknown event - "+e,l.INVALID_ARGUMENT,{argumnet:"eventName",value:e});var t={address:this.address,topics:[n.topic]};return{prepareEvent:function(e){var t=n.decode(e.data,e.topics);e.args=t;var r=Array.prototype.slice.call(t);return r.push(e),r},event:n,eventTag:_(t),filter:t}}var i={address:this.address},o=null;if(e.topics&&e.topics[0])for(var s in i.topics=e.topics,this.interface.events)if(-1!==s.indexOf("(")){var a=this.interface.events[s];if(a.topic===e.topics[0].toLowerCase()){o=a;break}}return{prepareEvent:function(e){if(!o)return[e];var t=o.decode(e.data,e.topics);e.args=t;var r=Array.prototype.slice.call(t);return r.push(e),r},event:o,eventTag:_(i),filter:i}},A.prototype._addEventListener=function(n,i,e){var o=this;this.provider||l.throwError("events require a provider or a signer with a provider",l.UNSUPPORTED_OPERATION,{operation:"once"});function t(e){var t=p.deepCopy(e),r=n.prepareEvent(t);n.event&&(t.decode=n.event.decode,t.event=n.event.name,t.eventSignature=n.event.signature),t.removeListener=function(){o.removeListener(n.filter,i)},t.getBlock=function(){return o.provider.getBlock(e.blockHash)},t.getTransaction=function(){return o.provider.getTransaction(e.transactionHash)},t.getTransactionReceipt=function(){return o.provider.getTransactionReceipt(e.transactionHash)},o.emit.apply(o,[n.filter].concat(r))}this.provider.on(n.filter,t),this._events.push({eventFilter:n,listener:i,wrappedListener:t,once:e})},A.prototype.on=function(e,t){return this._addEventListener(this._getEventFilter(e),t,!1),this},A.prototype.once=function(e,t){return this._addEventListener(this._getEventFilter(e),t,!0),this},A.prototype.addListener=function(e,t){return this.on(e,t)},A.prototype.emit=function(e){for(var t=this,r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];if(!this.provider)return!1;var i=!1,o=this._getEventFilter(e);return this._events=this._events.filter(function(e){return e.eventFilter.eventTag!==o.eventTag||(setTimeout(function(){e.listener.apply(t,r)},0),i=!0,!e.once)}),i},A.prototype.listenerCount=function(e){if(!this.provider)return 0;var t=this._getEventFilter(e);return this._events.filter(function(e){return e.eventFilter.eventTag===t.eventTag}).length},A.prototype.listeners=function(e){if(!this.provider)return[];var t=this._getEventFilter(e);return this._events.filter(function(e){return e.eventFilter.eventTag===t.eventTag}).map(function(e){return e.listener})},A.prototype.removeAllListeners=function(e){var t=this;if(!this.provider)return this;var r=this._getEventFilter(e);return this._events=this._events.filter(function(e){return e.eventFilter.eventTag!==r.eventTag||(t.provider.removeListener(e.eventFilter.filter,e.wrappedListener),!1)}),this},A.prototype.removeListener=function(e,t){var r=this;if(!this.provider)return this;var n=!1,i=this._getEventFilter(e);return this._events=this._events.filter(function(e){return e.eventFilter.eventTag!==i.eventTag||(e.listener!==t||(r.provider.removeListener(e.eventFilter.filter,e.wrappedListener),!!n||!(n=!0)))}),this},A);function A(t,e,r){var n=this;if(l.checkNew(this,A),d.Interface.isInterface(e)?p.defineReadOnly(this,"interface",e):p.defineReadOnly(this,"interface",new d.Interface(e)),y.Signer.isSigner(r)?(p.defineReadOnly(this,"provider",r.provider),p.defineReadOnly(this,"signer",r)):v.Provider.isProvider(r)?(p.defineReadOnly(this,"provider",r),p.defineReadOnly(this,"signer",null)):l.throwError("invalid signer or provider",l.INVALID_ARGUMENT,{arg:"signerOrProvider",value:r}),p.defineReadOnly(this,"estimate",{}),p.defineReadOnly(this,"functions",{}),p.defineReadOnly(this,"filters",{}),Object.keys(this.interface.events).forEach(function(e){var r=n.interface.events[e];p.defineReadOnly(n.filters,e,function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return{address:n.address,topics:r.encodeTopics(e)}})}),this._events=[],p.defineReadOnly(this,"address",t),this.provider)p.defineReadOnly(this,"addressPromise",this.provider.resolveName(t).then(function(e){if(null==e)throw new Error("name not found");return e}).catch(function(e){throw e}));else try{p.defineReadOnly(this,"addressPromise",Promise.resolve(a.getAddress(t)))}catch(e){l.throwError("provider is required to use non-address contract address",l.INVALID_ARGUMENT,{argument:"addressOrName",value:t})}Object.keys(this.interface.functions).forEach(function(e){var t=w(n,e,!1);null==n[e]?p.defineReadOnly(n,e,t):l.warn("WARNING: Multiple definitions for "+e),null==n.functions[e]&&(p.defineReadOnly(n.functions,e,t),p.defineReadOnly(n.estimate,e,w(n,e,!0)))})}r.Contract=M;var E=(S.prototype.getDeployTransaction=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r={};if(e.length===this.interface.deployFunction.inputs.length+1)for(var n in r=p.shallowCopy(e.pop()))if(!b[n])throw new Error("unknown transaction override "+n);return["data","from","to"].forEach(function(e){null!=r[e]&&l.throwError("cannot override "+e,l.UNSUPPORTED_OPERATION,{operation:e})}),l.checkArgumentCount(e.length,this.interface.deployFunction.inputs.length," in Contract constructor"),r.data=this.interface.deployFunction.encode(this.bytecode,e),r},S.prototype.deploy=function(){for(var r=this,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var n=this.getDeployTransaction.apply(this,e);return this.signer.sendTransaction(n).then(function(e){var t=new M(a.getContractAddress(e),r.interface,r.signer);return p.defineReadOnly(t,"deployTransaction",e),t})},S.prototype.attach=function(e){return new M(e,this.interface,this.signer)},S.prototype.connect=function(e){return new S(this.interface,this.bytecode,e)},S.fromSolidity=function(e,t){null==e&&l.throwError("missing compiler output",l.MISSING_ARGUMENT,{argument:"compilerOutput"}),"string"==typeof e&&(e=JSON.parse(e));var r=e.abi,n=null;return e.bytecode?n=e.bytecode:e.evm&&e.evm.bytecode&&(n=e.evm.bytecode),new S(r,n,t)},S);function S(e,t,r){var n=null;"string"==typeof t?n=t:c.isArrayish(t)?n=c.hexlify(t):"string"==typeof t.object?n=t.object:l.throwError("bytecode must be a valid hex string",l.INVALID_ARGUMENT,{arg:"bytecode",value:t}),"0x"!==n.substring(0,2)&&(n="0x"+n),c.isHexString(n)||l.throwError("bytecode must be a valid hex string",l.INVALID_ARGUMENT,{arg:"bytecode",value:t}),n.length%2!=0&&l.throwError("bytecode must be valid data (even length)",l.INVALID_ARGUMENT,{arg:"bytecode",value:t}),p.defineReadOnly(this,"bytecode",n),d.Interface.isInterface(e)?p.defineReadOnly(this,"interface",e):p.defineReadOnly(this,"interface",new d.Interface(e)),r&&!y.Signer.isSigner(r)&&l.throwError("invalid signer",l.INVALID_ARGUMENT,{arg:"signer",value:null}),p.defineReadOnly(this,"signer",r||null)}r.ContractFactory=E},{"./abstract-signer":2,"./constants":3,"./errors":5,"./providers/abstract-provider":50,"./utils/abi-coder":59,"./utils/address":60,"./utils/bignumber":63,"./utils/bytes":64,"./utils/interface":69,"./utils/properties":74}],5:[function(e,t,s){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var a=e("./_version");s.UNKNOWN_ERROR="UNKNOWN_ERROR",s.NOT_IMPLEMENTED="NOT_IMPLEMENTED",s.MISSING_NEW="MISSING_NEW",s.CALL_EXCEPTION="CALL_EXCEPTION",s.INVALID_ARGUMENT="INVALID_ARGUMENT",s.MISSING_ARGUMENT="MISSING_ARGUMENT",s.UNEXPECTED_ARGUMENT="UNEXPECTED_ARGUMENT",s.NUMERIC_FAULT="NUMERIC_FAULT",s.INSUFFICIENT_FUNDS="INSUFFICIENT_FUNDS",s.NONCE_EXPIRED="NONCE_EXPIRED",s.REPLACEMENT_UNDERPRICED="REPLACEMENT_UNDERPRICED";var r=!(s.UNSUPPORTED_OPERATION="UNSUPPORTED_OPERATION"),u=!1;function n(e,t,r){if(u)throw new Error("unknown error");t=t||s.UNKNOWN_ERROR,r=r||{};var n=[];Object.keys(r).forEach(function(t){try{n.push(t+"="+JSON.stringify(r[t]))}catch(e){n.push(t+"="+JSON.stringify(r[t].toString()))}}),n.push("version="+a.version);var i=e;n.length&&(e+=" ("+n.join(", ")+")");var o=new Error(e);throw o.reason=i,o.code=t,Object.keys(r).forEach(function(e){o[e]=r[e]}),o}s.throwError=n,s.checkNew=function(e,t){e instanceof t||n("missing new",s.MISSING_NEW,{name:t.name})},s.checkArgumentCount=function(e,t,r){r=r||"",e<t&&n("missing argument"+r,s.MISSING_ARGUMENT,{count:e,expectedCount:t}),t<e&&n("too many arguments"+r,s.UNEXPECTED_ARGUMENT,{count:e,expectedCount:t})},s.setCensorship=function(e,t){r&&n("error censorship permanent",s.UNSUPPORTED_OPERATION,{operation:"setCensorship"}),u=!!e,r=!!t},s.checkNormalize=function(){try{if(["NFD","NFC","NFKD","NFKC"].forEach(function(t){try{"test".normalize(t)}catch(e){throw new Error("missing "+t)}}),String.fromCharCode(233).normalize("NFD")!==String.fromCharCode(101,769))throw new Error("broken implementation")}catch(e){n("platform missing String.prototype.normalize",s.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:e.message})}};var i={debug:1,default:2,info:2,warn:3,error:4,off:5},o=i.default;function l(e,t){o>i[e]||console.log.apply(console,t)}function h(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];l("warn",e)}s.setLogLevel=function(e){var t=i[e];null!=t?o=t:h("invliad log level - "+e)},s.warn=h,s.info=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];l("info",e)}},{"./_version":1}],6:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("./contract");r.Contract=i.Contract,r.ContractFactory=i.ContractFactory,r.VoidSigner=i.VoidSigner;var o=e("./abstract-signer");r.Signer=o.Signer;var s=e("./wallet");r.Wallet=s.Wallet;var a=n(e("./constants"));r.constants=a;var u=n(e("./errors"));r.errors=u;var l=n(e("./providers"));r.providers=l;var h=n(e("./utils"));r.utils=h;var f=n(e("./wordlists"));r.wordlists=f;var c=e("./utils/shims");r.platform=c.platform;var d=e("./_version");r.version=d.version,r.getDefaultProvider=function(e){null==e&&(e="homestead");var t=h.getNetwork(e);return t&&t._defaultProvider||u.throwError("unsupported getDefaultProvider network",u.UNSUPPORTED_OPERATION,{operation:"getDefaultProvider",network:e}),t._defaultProvider(l)}},{"./_version":1,"./abstract-signer":2,"./constants":3,"./contract":4,"./errors":5,"./providers":54,"./utils":68,"./utils/shims":80,"./wallet":88,"./wordlists":89}],7:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("./ethers"));r.ethers=i,function(e){for(var t in e)r.hasOwnProperty(t)||(r[t]=e[t])}(e("./ethers"))},{"./ethers":6}],8:[function(e,C,L){"use strict";!function(e){function r(e){return parseInt(e)===e}function n(e){if(r(e.length)){for(var t=0;t<e.length;t++)if(!r(e[t])||e[t]<0||255<e[t])return;return 1}}function o(e,t){if(e.buffer&&ArrayBuffer.isView(e)&&"Uint8Array"===e.name)return t&&(e=e.slice?e.slice():Array.prototype.slice.call(e)),e;if(Array.isArray(e)){if(!n(e))throw new Error("Array contains invalid value: "+e);return new Uint8Array(e)}if(r(e.length)&&n(e))return new Uint8Array(e);throw new Error("unsupported array-like object")}function u(e){return new Uint8Array(e)}function s(e,t,r,n,i){null==n&&null==i||(e=e.slice?e.slice(n,i):Array.prototype.slice.call(e,n,i)),t.set(e,r)}var i,t={toBytes:function(e){var t=[],r=0;for(e=encodeURI(e);r<e.length;){var n=e.charCodeAt(r++);37===n?(t.push(parseInt(e.substr(r,2),16)),r+=2):t.push(n)}return o(t)},fromBytes:function(e){for(var t=[],r=0;r<e.length;){var n=e[r];n<128?(t.push(String.fromCharCode(n)),r++):191<n&&n<224?(t.push(String.fromCharCode((31&n)<<6|63&e[r+1])),r+=2):(t.push(String.fromCharCode((15&n)<<12|(63&e[r+1])<<6|63&e[r+2])),r+=3)}return t.join("")}},a=(i="0123456789abcdef",{toBytes:function(e){for(var t=[],r=0;r<e.length;r+=2)t.push(parseInt(e.substr(r,2),16));return t},fromBytes:function(e){for(var t=[],r=0;r<e.length;r++){var n=e[r];t.push(i[(240&n)>>4]+i[15&n])}return t.join("")}}),f={16:10,24:12,32:14},c=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],d=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],l=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],h=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],p=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],v=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],y=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],m=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],g=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],b=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],w=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],_=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],M=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],A=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],E=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function S(e){for(var t=[],r=0;r<e.length;r+=4)t.push(e[r]<<24|e[r+1]<<16|e[r+2]<<8|e[r+3]);return t}var k=function(e){if(!(this instanceof k))throw Error("AES must be instanitated with `new`");Object.defineProperty(this,"key",{value:o(e,!0)}),this._prepare()};k.prototype._prepare=function(){var e=f[this.key.length];if(null==e)throw new Error("invalid key size (must be 16, 24 or 32 bytes)");this._Ke=[],this._Kd=[];for(var t=0;t<=e;t++)this._Ke.push([0,0,0,0]),this._Kd.push([0,0,0,0]);for(var r,n=4*(e+1),i=this.key.length/4,o=S(this.key),t=0;t<i;t++)r=t>>2,this._Ke[r][t%4]=o[t],this._Kd[e-r][t%4]=o[t];for(var s,a=0,u=i;u<n;){if(s=o[i-1],o[0]^=d[s>>16&255]<<24^d[s>>8&255]<<16^d[255&s]<<8^d[s>>24&255]^c[a]<<24,a+=1,8!=i)for(t=1;t<i;t++)o[t]^=o[t-1];else{for(t=1;t<i/2;t++)o[t]^=o[t-1];s=o[i/2-1],o[i/2]^=d[255&s]^d[s>>8&255]<<8^d[s>>16&255]<<16^d[s>>24&255]<<24;for(t=i/2+1;t<i;t++)o[t]^=o[t-1]}for(t=0;t<i&&u<n;)l=u>>2,h=u%4,this._Ke[l][h]=o[t],this._Kd[e-l][h]=o[t++],u++}for(var l=1;l<e;l++)for(var h=0;h<4;h++)s=this._Kd[l][h],this._Kd[l][h]=_[s>>24&255]^M[s>>16&255]^A[s>>8&255]^E[255&s]},k.prototype.encrypt=function(e){if(16!=e.length)throw new Error("invalid plaintext size (must be 16 bytes)");for(var t=this._Ke.length-1,r=[0,0,0,0],n=S(e),i=0;i<4;i++)n[i]^=this._Ke[0][i];for(var o=1;o<t;o++){for(i=0;i<4;i++)r[i]=h[n[i]>>24&255]^p[n[(i+1)%4]>>16&255]^v[n[(i+2)%4]>>8&255]^y[255&n[(i+3)%4]]^this._Ke[o][i];n=r.slice()}for(var s,a=u(16),i=0;i<4;i++)s=this._Ke[t][i],a[4*i]=255&(d[n[i]>>24&255]^s>>24),a[4*i+1]=255&(d[n[(i+1)%4]>>16&255]^s>>16),a[4*i+2]=255&(d[n[(i+2)%4]>>8&255]^s>>8),a[4*i+3]=255&(d[255&n[(i+3)%4]]^s);return a},k.prototype.decrypt=function(e){if(16!=e.length)throw new Error("invalid ciphertext size (must be 16 bytes)");for(var t=this._Kd.length-1,r=[0,0,0,0],n=S(e),i=0;i<4;i++)n[i]^=this._Kd[0][i];for(var o=1;o<t;o++){for(i=0;i<4;i++)r[i]=m[n[i]>>24&255]^g[n[(i+3)%4]>>16&255]^b[n[(i+2)%4]>>8&255]^w[255&n[(i+1)%4]]^this._Kd[o][i];n=r.slice()}for(var s,a=u(16),i=0;i<4;i++)s=this._Kd[t][i],a[4*i]=255&(l[n[i]>>24&255]^s>>24),a[4*i+1]=255&(l[n[(i+3)%4]>>16&255]^s>>16),a[4*i+2]=255&(l[n[(i+2)%4]>>8&255]^s>>8),a[4*i+3]=255&(l[255&n[(i+1)%4]]^s);return a};var N=function(e){if(!(this instanceof N))throw Error("AES must be instanitated with `new`");this.description="Electronic Code Block",this.name="ecb",this._aes=new k(e)};N.prototype.encrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid plaintext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16)s(e,r,0,n,n+16),s(r=this._aes.encrypt(r),t,n);return t},N.prototype.decrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16)s(e,r,0,n,n+16),s(r=this._aes.decrypt(r),t,n);return t};var x=function(e,t){if(!(this instanceof x))throw Error("AES must be instanitated with `new`");if(this.description="Cipher Block Chaining",this.name="cbc",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 bytes)")}else t=u(16);this._lastCipherblock=o(t,!0),this._aes=new k(e)};x.prototype.encrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid plaintext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16){s(e,r,0,n,n+16);for(var i=0;i<16;i++)r[i]^=this._lastCipherblock[i];this._lastCipherblock=this._aes.encrypt(r),s(this._lastCipherblock,t,n)}return t},x.prototype.decrypt=function(e){if((e=o(e)).length%16!=0)throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");for(var t=u(e.length),r=u(16),n=0;n<e.length;n+=16){s(e,r,0,n,n+16),r=this._aes.decrypt(r);for(var i=0;i<16;i++)t[n+i]=r[i]^this._lastCipherblock[i];s(e,this._lastCipherblock,0,n,n+16)}return t};var P=function(e,t,r){if(!(this instanceof P))throw Error("AES must be instanitated with `new`");if(this.description="Cipher Feedback",this.name="cfb",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 size)")}else t=u(16);r=r||1,this.segmentSize=r,this._shiftRegister=o(t,!0),this._aes=new k(e)};P.prototype.encrypt=function(e){if(e.length%this.segmentSize!=0)throw new Error("invalid plaintext size (must be segmentSize bytes)");for(var t,r=o(e,!0),n=0;n<r.length;n+=this.segmentSize){t=this._aes.encrypt(this._shiftRegister);for(var i=0;i<this.segmentSize;i++)r[n+i]^=t[i];s(this._shiftRegister,this._shiftRegister,0,this.segmentSize),s(r,this._shiftRegister,16-this.segmentSize,n,n+this.segmentSize)}return r},P.prototype.decrypt=function(e){if(e.length%this.segmentSize!=0)throw new Error("invalid ciphertext size (must be segmentSize bytes)");for(var t,r=o(e,!0),n=0;n<r.length;n+=this.segmentSize){t=this._aes.encrypt(this._shiftRegister);for(var i=0;i<this.segmentSize;i++)r[n+i]^=t[i];s(this._shiftRegister,this._shiftRegister,0,this.segmentSize),s(e,this._shiftRegister,16-this.segmentSize,n,n+this.segmentSize)}return r};var I=function(e,t){if(!(this instanceof I))throw Error("AES must be instanitated with `new`");if(this.description="Output Feedback",this.name="ofb",t){if(16!=t.length)throw new Error("invalid initialation vector size (must be 16 bytes)")}else t=u(16);this._lastPrecipher=o(t,!0),this._lastPrecipherIndex=16,this._aes=new k(e)};I.prototype.encrypt=function(e){for(var t=o(e,!0),r=0;r<t.length;r++)16===this._lastPrecipherIndex&&(this._lastPrecipher=this._aes.encrypt(this._lastPrecipher),this._lastPrecipherIndex=0),t[r]^=this._lastPrecipher[this._lastPrecipherIndex++];return t},I.prototype.decrypt=I.prototype.encrypt;var T=function(e){if(!(this instanceof T))throw Error("Counter must be instanitated with `new`");0===e||e||(e=1),"number"==typeof e?(this._counter=u(16),this.setValue(e)):this.setBytes(e)};T.prototype.setValue=function(e){if("number"!=typeof e||parseInt(e)!=e)throw new Error("invalid counter value (must be an integer)");for(var t=15;0<=t;--t)this._counter[t]=e%256,e>>=8},T.prototype.setBytes=function(e){if(16!=(e=o(e,!0)).length)throw new Error("invalid counter bytes size (must be 16 bytes)");this._counter=e},T.prototype.increment=function(){for(var e=15;0<=e;e--){if(255!==this._counter[e]){this._counter[e]++;break}this._counter[e]=0}};var R=function(e,t){if(!(this instanceof R))throw Error("AES must be instanitated with `new`");this.description="Counter",this.name="ctr",t instanceof T||(t=new T(t)),this._counter=t,this._remainingCounter=null,this._remainingCounterIndex=16,this._aes=new k(e)};R.prototype.encrypt=function(e){for(var t=o(e,!0),r=0;r<t.length;r++)16===this._remainingCounterIndex&&(this._remainingCounter=this._aes.encrypt(this._counter._counter),this._remainingCounterIndex=0,this._counter.increment()),t[r]^=this._remainingCounter[this._remainingCounterIndex++];return t},R.prototype.decrypt=R.prototype.encrypt;var O={AES:k,Counter:T,ModeOfOperation:{ecb:N,cbc:x,cfb:P,ofb:I,ctr:R},utils:{hex:a,utf8:t},padding:{pkcs7:{pad:function(e){var t=16-(e=o(e,!0)).length%16,r=u(e.length+t);s(e,r);for(var n=e.length;n<r.length;n++)r[n]=t;return r},strip:function(e){if((e=o(e,!0)).length<16)throw new Error("PKCS#7 invalid length");var t=e[e.length-1];if(16<t)throw new Error("PKCS#7 padding byte out of range");for(var r=e.length-t,n=0;n<t;n++)if(e[r+n]!==t)throw new Error("PKCS#7 invalid padding byte");var i=u(r);return s(e,i,0,0,r),i}}},_arrayTest:{coerceArray:o,createArray:u,copyArray:s}};void 0!==L?C.exports=O:(e.aesjs&&(O._aesjs=e.aesjs),e.aesjs=O)}(this)},{}],9:[function(A,e,t){!function(e,t){"use strict";function y(e,t){if(!e)throw new Error(t||"Assertion failed")}function r(e,t){e.super_=t;function r(){}r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}function m(e,t,r){if(m.isBN(e))return e;this.negative=0,this.words=null,this.length=0,(this.red=null)!==e&&("le"!==t&&"be"!==t||(r=t,t=10),this._init(e||0,t||10,r||"be"))}var n;"object"==typeof e?e.exports=m:t.BN=m,(m.BN=m).wordSize=26;try{n=A("buffer").Buffer}catch(e){}function s(e,t,r){for(var n=0,i=Math.min(e.length,r),o=t;o<i;o++){var s=e.charCodeAt(o)-48;n<<=4,n|=49<=s&&s<=54?s-49+10:17<=s&&s<=22?s-17+10:15&s}return n}function f(e,t,r,n){for(var i=0,o=Math.min(e.length,r),s=t;s<o;s++){var a=e.charCodeAt(s)-48;i*=n,i+=49<=a?a-49+10:17<=a?a-17+10:a}return i}m.isBN=function(e){return e instanceof m||null!==e&&"object"==typeof e&&e.constructor.wordSize===m.wordSize&&Array.isArray(e.words)},m.max=function(e,t){return 0<e.cmp(t)?e:t},m.min=function(e,t){return e.cmp(t)<0?e:t},m.prototype._init=function(e,t,r){if("number"==typeof e)return this._initNumber(e,t,r);if("object"==typeof e)return this._initArray(e,t,r);"hex"===t&&(t=16),y(t===(0|t)&&2<=t&&t<=36);var n=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&n++,16===t?this._parseHex(e,n):this._parseBase(e,t,n),"-"===e[0]&&(this.negative=1),this.strip(),"le"===r&&this._initArray(this.toArray(),t,r)},m.prototype._initNumber=function(e,t,r){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(y(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===r&&this._initArray(this.toArray(),t,r)},m.prototype._initArray=function(e,t,r){if(y("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var n,i,o=0;o<this.length;o++)this.words[o]=0;var s=0;if("be"===r)for(o=e.length-1,n=0;0<=o;o-=3)i=e[o]|e[o-1]<<8|e[o-2]<<16,this.words[n]|=i<<s&67108863,this.words[n+1]=i>>>26-s&67108863,26<=(s+=24)&&(s-=26,n++);else if("le"===r)for(n=o=0;o<e.length;o+=3)i=e[o]|e[o+1]<<8|e[o+2]<<16,this.words[n]|=i<<s&67108863,this.words[n+1]=i>>>26-s&67108863,26<=(s+=24)&&(s-=26,n++);return this.strip()},m.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var r,n=0;n<this.length;n++)this.words[n]=0;for(var i=0,n=e.length-6,o=0;t<=n;n-=6)r=s(e,n,n+6),this.words[o]|=r<<i&67108863,this.words[o+1]|=r>>>26-i&4194303,26<=(i+=24)&&(i-=26,o++);n+6!==t&&(r=s(e,t,n+6),this.words[o]|=r<<i&67108863,this.words[o+1]|=r>>>26-i&4194303),this.strip()},m.prototype._parseBase=function(e,t,r){this.words=[0];for(var n=0,i=this.length=1;i<=67108863;i*=t)n++;n--,i=i/t|0;for(var o=e.length-r,s=o%n,a=Math.min(o,o-s)+r,u=0,l=r;l<a;l+=n)u=f(e,l,l+n,t),this.imuln(i),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u);if(0!=s){for(var h=1,u=f(e,l,e.length,t),l=0;l<s;l++)h*=t;this.imuln(h),this.words[0]+u<67108864?this.words[0]+=u:this._iaddn(u)}},m.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},m.prototype.clone=function(){var e=new m(null);return this.copy(e),e},m.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},m.prototype.strip=function(){for(;1<this.length&&0===this.words[this.length-1];)this.length--;return this._normSign()},m.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},m.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],d=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],p=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function i(e,t,r){r.negative=t.negative^e.negative;var n=e.length+t.length|0,n=(r.length=n)-1|0,i=67108863&(f=(0|e.words[0])*(0|t.words[0])),o=f/67108864|0;r.words[0]=i;for(var s=1;s<n;s++){for(var a=o>>>26,u=67108863&o,l=Math.min(s,t.length-1),h=Math.max(0,s-e.length+1);h<=l;h++){var f,c=s-h|0;a+=(f=(0|e.words[c])*(0|t.words[h])+u)/67108864|0,u=67108863&f}r.words[s]=0|u,o=0|a}return 0!==o?r.words[s]=0|o:r.length--,r.strip()}m.prototype.toString=function(e,t){if(t=0|t||1,16===(e=e||10)||"hex"===e){a="";for(var r=0,n=0,i=0;i<this.length;i++){var o=this.words[i],s=(16777215&(o<<r|n)).toString(16),a=0!==(n=o>>>24-r&16777215)||i!==this.length-1?c[6-s.length]+s+a:s+a;26<=(r+=2)&&(r-=26,i--)}for(0!==n&&(a=n.toString(16)+a);a.length%t!=0;)a="0"+a;return 0!==this.negative&&(a="-"+a),a}if(e===(0|e)&&2<=e&&e<=36){var u=d[e],l=p[e];for(a="",(h=this.clone()).negative=0;!h.isZero();){var h,f=h.modn(l).toString(e);a=(h=h.idivn(l)).isZero()?f+a:c[u-f.length]+f+a}for(this.isZero()&&(a="0"+a);a.length%t!=0;)a="0"+a;return 0!==this.negative&&(a="-"+a),a}y(!1,"Base should be between 2 and 36")},m.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:2<this.length&&y(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},m.prototype.toJSON=function(){return this.toString(16)},m.prototype.toBuffer=function(e,t){return y(void 0!==n),this.toArrayLike(n,e,t)},m.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},m.prototype.toArrayLike=function(e,t,r){var n=this.byteLength(),i=r||Math.max(1,n);y(n<=i,"byte array longer than desired length"),y(0<i,"Requested array length <= 0"),this.strip();var o,s,a="le"===t,u=new e(i),l=this.clone();if(a){for(s=0;!l.isZero();s++)o=l.andln(255),l.iushrn(8),u[s]=o;for(;s<i;s++)u[s]=0}else{for(s=0;s<i-n;s++)u[s]=0;for(s=0;!l.isZero();s++)o=l.andln(255),l.iushrn(8),u[i-s-1]=o}return u},Math.clz32?m.prototype._countBits=function(e){return 32-Math.clz32(e)}:m.prototype._countBits=function(e){var t=e,r=0;return 4096<=t&&(r+=13,t>>>=13),64<=t&&(r+=7,t>>>=7),8<=t&&(r+=4,t>>>=4),2<=t&&(r+=2,t>>>=2),r+t},m.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,r=0;return 0==(8191&t)&&(r+=13,t>>>=13),0==(127&t)&&(r+=7,t>>>=7),0==(15&t)&&(r+=4,t>>>=4),0==(3&t)&&(r+=2,t>>>=2),0==(1&t)&&r++,r},m.prototype.bitLength=function(){var e=this.words[this.length-1],t=this._countBits(e);return 26*(this.length-1)+t},m.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var r=this._zeroBits(this.words[t]);if(e+=r,26!==r)break}return e},m.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},m.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},m.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},m.prototype.isNeg=function(){return 0!==this.negative},m.prototype.neg=function(){return this.clone().ineg()},m.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},m.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},m.prototype.ior=function(e){return y(0==(this.negative|e.negative)),this.iuor(e)},m.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},m.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},m.prototype.iuand=function(e){for(var t=this.length>e.length?e:this,r=0;r<t.length;r++)this.words[r]=this.words[r]&e.words[r];return this.length=t.length,this.strip()},m.prototype.iand=function(e){return y(0==(this.negative|e.negative)),this.iuand(e)},m.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},m.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},m.prototype.iuxor=function(e){for(var t,r=this.length>e.length?(t=this,e):(t=e,this),n=0;n<r.length;n++)this.words[n]=t.words[n]^r.words[n];if(this!==t)for(;n<t.length;n++)this.words[n]=t.words[n];return this.length=t.length,this.strip()},m.prototype.ixor=function(e){return y(0==(this.negative|e.negative)),this.iuxor(e)},m.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},m.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},m.prototype.inotn=function(e){y("number"==typeof e&&0<=e);var t=0|Math.ceil(e/26),r=e%26;this._expand(t),0<r&&t--;for(var n=0;n<t;n++)this.words[n]=67108863&~this.words[n];return 0<r&&(this.words[n]=~this.words[n]&67108863>>26-r),this.strip()},m.prototype.notn=function(e){return this.clone().inotn(e)},m.prototype.setn=function(e,t){y("number"==typeof e&&0<=e);var r=e/26|0,n=e%26;return this._expand(1+r),this.words[r]=t?this.words[r]|1<<n:this.words[r]&~(1<<n),this.strip()},m.prototype.iadd=function(e){var t,r,n;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();n=this.length>e.length?(r=this,e):(r=e,this);for(var i=0,o=0;o<n.length;o++)t=(0|r.words[o])+(0|n.words[o])+i,this.words[o]=67108863&t,i=t>>>26;for(;0!==i&&o<r.length;o++)t=(0|r.words[o])+i,this.words[o]=67108863&t,i=t>>>26;if(this.length=r.length,0!==i)this.words[this.length]=i,this.length++;else if(r!==this)for(;o<r.length;o++)this.words[o]=r.words[o];return this},m.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},m.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var r,n,i=this.cmp(e);if(0===i)return this.negative=0,this.length=1,this.words[0]=0,this;n=0<i?(r=this,e):(r=e,this);for(var o=0,s=0;s<n.length;s++)o=(t=(0|r.words[s])-(0|n.words[s])+o)>>26,this.words[s]=67108863&t;for(;0!==o&&s<r.length;s++)o=(t=(0|r.words[s])+o)>>26,this.words[s]=67108863&t;if(0===o&&s<r.length&&r!==this)for(;s<r.length;s++)this.words[s]=r.words[s];return this.length=Math.max(this.length,s),r!==this&&(this.negative=1),this.strip()},m.prototype.sub=function(e){return this.clone().isub(e)};var o=function(e,t,r){var n,i,o,s=e.words,a=t.words,u=r.words,l=0|s[0],h=8191&l,f=l>>>13,c=0|s[1],d=8191&c,p=c>>>13,v=0|s[2],y=8191&v,m=v>>>13,g=0|s[3],b=8191&g,w=g>>>13,_=0|s[4],M=8191&_,A=_>>>13,E=0|s[5],S=8191&E,k=E>>>13,N=0|s[6],x=8191&N,P=N>>>13,I=0|s[7],T=8191&I,R=I>>>13,O=0|s[8],C=8191&O,L=O>>>13,B=0|s[9],D=8191&B,U=B>>>13,F=0|a[0],j=8191&F,G=F>>>13,H=0|a[1],z=8191&H,V=H>>>13,K=0|a[2],q=8191&K,W=K>>>13,Z=0|a[3],J=8191&Z,X=Z>>>13,$=0|a[4],Q=8191&$,Y=$>>>13,ee=0|a[5],te=8191&ee,re=ee>>>13,ne=0|a[6],ie=8191&ne,oe=ne>>>13,se=0|a[7],ae=8191&se,ue=se>>>13,le=0|a[8],he=8191&le,fe=le>>>13,ce=0|a[9],de=8191&ce,pe=ce>>>13;r.negative=e.negative^t.negative,r.length=19;var ve=(0+Math.imul(h,j)|0)+((8191&(i=Math.imul(h,G)+Math.imul(f,j)|0))<<13)|0,ye=(Math.imul(f,G)+(i>>>13)|0)+(ve>>>26)|0;ve&=67108863,n=Math.imul(d,j),i=Math.imul(d,G)+Math.imul(p,j)|0,o=Math.imul(p,G);var me=(ye+(n+Math.imul(h,z)|0)|0)+((8191&(i=(i+Math.imul(h,V)|0)+Math.imul(f,z)|0))<<13)|0;ye=((o+Math.imul(f,V)|0)+(i>>>13)|0)+(me>>>26)|0,me&=67108863,n=Math.imul(y,j),i=Math.imul(y,G)+Math.imul(m,j)|0,o=Math.imul(m,G),n=n+Math.imul(d,z)|0,i=(i+Math.imul(d,V)|0)+Math.imul(p,z)|0,o=o+Math.imul(p,V)|0;var ge=(ye+(n+Math.imul(h,q)|0)|0)+((8191&(i=(i+Math.imul(h,W)|0)+Math.imul(f,q)|0))<<13)|0;ye=((o+Math.imul(f,W)|0)+(i>>>13)|0)+(ge>>>26)|0,ge&=67108863,n=Math.imul(b,j),i=Math.imul(b,G)+Math.imul(w,j)|0,o=Math.imul(w,G),n=n+Math.imul(y,z)|0,i=(i+Math.imul(y,V)|0)+Math.imul(m,z)|0,o=o+Math.imul(m,V)|0,n=n+Math.imul(d,q)|0,i=(i+Math.imul(d,W)|0)+Math.imul(p,q)|0,o=o+Math.imul(p,W)|0;var be=(ye+(n+Math.imul(h,J)|0)|0)+((8191&(i=(i+Math.imul(h,X)|0)+Math.imul(f,J)|0))<<13)|0;ye=((o+Math.imul(f,X)|0)+(i>>>13)|0)+(be>>>26)|0,be&=67108863,n=Math.imul(M,j),i=Math.imul(M,G)+Math.imul(A,j)|0,o=Math.imul(A,G),n=n+Math.imul(b,z)|0,i=(i+Math.imul(b,V)|0)+Math.imul(w,z)|0,o=o+Math.imul(w,V)|0,n=n+Math.imul(y,q)|0,i=(i+Math.imul(y,W)|0)+Math.imul(m,q)|0,o=o+Math.imul(m,W)|0,n=n+Math.imul(d,J)|0,i=(i+Math.imul(d,X)|0)+Math.imul(p,J)|0,o=o+Math.imul(p,X)|0;var we=(ye+(n+Math.imul(h,Q)|0)|0)+((8191&(i=(i+Math.imul(h,Y)|0)+Math.imul(f,Q)|0))<<13)|0;ye=((o+Math.imul(f,Y)|0)+(i>>>13)|0)+(we>>>26)|0,we&=67108863,n=Math.imul(S,j),i=Math.imul(S,G)+Math.imul(k,j)|0,o=Math.imul(k,G),n=n+Math.imul(M,z)|0,i=(i+Math.imul(M,V)|0)+Math.imul(A,z)|0,o=o+Math.imul(A,V)|0,n=n+Math.imul(b,q)|0,i=(i+Math.imul(b,W)|0)+Math.imul(w,q)|0,o=o+Math.imul(w,W)|0,n=n+Math.imul(y,J)|0,i=(i+Math.imul(y,X)|0)+Math.imul(m,J)|0,o=o+Math.imul(m,X)|0,n=n+Math.imul(d,Q)|0,i=(i+Math.imul(d,Y)|0)+Math.imul(p,Q)|0,o=o+Math.imul(p,Y)|0;var _e=(ye+(n+Math.imul(h,te)|0)|0)+((8191&(i=(i+Math.imul(h,re)|0)+Math.imul(f,te)|0))<<13)|0;ye=((o+Math.imul(f,re)|0)+(i>>>13)|0)+(_e>>>26)|0,_e&=67108863,n=Math.imul(x,j),i=Math.imul(x,G)+Math.imul(P,j)|0,o=Math.imul(P,G),n=n+Math.imul(S,z)|0,i=(i+Math.imul(S,V)|0)+Math.imul(k,z)|0,o=o+Math.imul(k,V)|0,n=n+Math.imul(M,q)|0,i=(i+Math.imul(M,W)|0)+Math.imul(A,q)|0,o=o+Math.imul(A,W)|0,n=n+Math.imul(b,J)|0,i=(i+Math.imul(b,X)|0)+Math.imul(w,J)|0,o=o+Math.imul(w,X)|0,n=n+Math.imul(y,Q)|0,i=(i+Math.imul(y,Y)|0)+Math.imul(m,Q)|0,o=o+Math.imul(m,Y)|0,n=n+Math.imul(d,te)|0,i=(i+Math.imul(d,re)|0)+Math.imul(p,te)|0,o=o+Math.imul(p,re)|0;var Me=(ye+(n+Math.imul(h,ie)|0)|0)+((8191&(i=(i+Math.imul(h,oe)|0)+Math.imul(f,ie)|0))<<13)|0;ye=((o+Math.imul(f,oe)|0)+(i>>>13)|0)+(Me>>>26)|0,Me&=67108863,n=Math.imul(T,j),i=Math.imul(T,G)+Math.imul(R,j)|0,o=Math.imul(R,G),n=n+Math.imul(x,z)|0,i=(i+Math.imul(x,V)|0)+Math.imul(P,z)|0,o=o+Math.imul(P,V)|0,n=n+Math.imul(S,q)|0,i=(i+Math.imul(S,W)|0)+Math.imul(k,q)|0,o=o+Math.imul(k,W)|0,n=n+Math.imul(M,J)|0,i=(i+Math.imul(M,X)|0)+Math.imul(A,J)|0,o=o+Math.imul(A,X)|0,n=n+Math.imul(b,Q)|0,i=(i+Math.imul(b,Y)|0)+Math.imul(w,Q)|0,o=o+Math.imul(w,Y)|0,n=n+Math.imul(y,te)|0,i=(i+Math.imul(y,re)|0)+Math.imul(m,te)|0,o=o+Math.imul(m,re)|0,n=n+Math.imul(d,ie)|0,i=(i+Math.imul(d,oe)|0)+Math.imul(p,ie)|0,o=o+Math.imul(p,oe)|0;var Ae=(ye+(n+Math.imul(h,ae)|0)|0)+((8191&(i=(i+Math.imul(h,ue)|0)+Math.imul(f,ae)|0))<<13)|0;ye=((o+Math.imul(f,ue)|0)+(i>>>13)|0)+(Ae>>>26)|0,Ae&=67108863,n=Math.imul(C,j),i=Math.imul(C,G)+Math.imul(L,j)|0,o=Math.imul(L,G),n=n+Math.imul(T,z)|0,i=(i+Math.imul(T,V)|0)+Math.imul(R,z)|0,o=o+Math.imul(R,V)|0,n=n+Math.imul(x,q)|0,i=(i+Math.imul(x,W)|0)+Math.imul(P,q)|0,o=o+Math.imul(P,W)|0,n=n+Math.imul(S,J)|0,i=(i+Math.imul(S,X)|0)+Math.imul(k,J)|0,o=o+Math.imul(k,X)|0,n=n+Math.imul(M,Q)|0,i=(i+Math.imul(M,Y)|0)+Math.imul(A,Q)|0,o=o+Math.imul(A,Y)|0,n=n+Math.imul(b,te)|0,i=(i+Math.imul(b,re)|0)+Math.imul(w,te)|0,o=o+Math.imul(w,re)|0,n=n+Math.imul(y,ie)|0,i=(i+Math.imul(y,oe)|0)+Math.imul(m,ie)|0,o=o+Math.imul(m,oe)|0,n=n+Math.imul(d,ae)|0,i=(i+Math.imul(d,ue)|0)+Math.imul(p,ae)|0,o=o+Math.imul(p,ue)|0;var Ee=(ye+(n+Math.imul(h,he)|0)|0)+((8191&(i=(i+Math.imul(h,fe)|0)+Math.imul(f,he)|0))<<13)|0;ye=((o+Math.imul(f,fe)|0)+(i>>>13)|0)+(Ee>>>26)|0,Ee&=67108863,n=Math.imul(D,j),i=Math.imul(D,G)+Math.imul(U,j)|0,o=Math.imul(U,G),n=n+Math.imul(C,z)|0,i=(i+Math.imul(C,V)|0)+Math.imul(L,z)|0,o=o+Math.imul(L,V)|0,n=n+Math.imul(T,q)|0,i=(i+Math.imul(T,W)|0)+Math.imul(R,q)|0,o=o+Math.imul(R,W)|0,n=n+Math.imul(x,J)|0,i=(i+Math.imul(x,X)|0)+Math.imul(P,J)|0,o=o+Math.imul(P,X)|0,n=n+Math.imul(S,Q)|0,i=(i+Math.imul(S,Y)|0)+Math.imul(k,Q)|0,o=o+Math.imul(k,Y)|0,n=n+Math.imul(M,te)|0,i=(i+Math.imul(M,re)|0)+Math.imul(A,te)|0,o=o+Math.imul(A,re)|0,n=n+Math.imul(b,ie)|0,i=(i+Math.imul(b,oe)|0)+Math.imul(w,ie)|0,o=o+Math.imul(w,oe)|0,n=n+Math.imul(y,ae)|0,i=(i+Math.imul(y,ue)|0)+Math.imul(m,ae)|0,o=o+Math.imul(m,ue)|0,n=n+Math.imul(d,he)|0,i=(i+Math.imul(d,fe)|0)+Math.imul(p,he)|0,o=o+Math.imul(p,fe)|0;var Se=(ye+(n+Math.imul(h,de)|0)|0)+((8191&(i=(i+Math.imul(h,pe)|0)+Math.imul(f,de)|0))<<13)|0;ye=((o+Math.imul(f,pe)|0)+(i>>>13)|0)+(Se>>>26)|0,Se&=67108863,n=Math.imul(D,z),i=Math.imul(D,V)+Math.imul(U,z)|0,o=Math.imul(U,V),n=n+Math.imul(C,q)|0,i=(i+Math.imul(C,W)|0)+Math.imul(L,q)|0,o=o+Math.imul(L,W)|0,n=n+Math.imul(T,J)|0,i=(i+Math.imul(T,X)|0)+Math.imul(R,J)|0,o=o+Math.imul(R,X)|0,n=n+Math.imul(x,Q)|0,i=(i+Math.imul(x,Y)|0)+Math.imul(P,Q)|0,o=o+Math.imul(P,Y)|0,n=n+Math.imul(S,te)|0,i=(i+Math.imul(S,re)|0)+Math.imul(k,te)|0,o=o+Math.imul(k,re)|0,n=n+Math.imul(M,ie)|0,i=(i+Math.imul(M,oe)|0)+Math.imul(A,ie)|0,o=o+Math.imul(A,oe)|0,n=n+Math.imul(b,ae)|0,i=(i+Math.imul(b,ue)|0)+Math.imul(w,ae)|0,o=o+Math.imul(w,ue)|0,n=n+Math.imul(y,he)|0,i=(i+Math.imul(y,fe)|0)+Math.imul(m,he)|0,o=o+Math.imul(m,fe)|0;var ke=(ye+(n+Math.imul(d,de)|0)|0)+((8191&(i=(i+Math.imul(d,pe)|0)+Math.imul(p,de)|0))<<13)|0;ye=((o+Math.imul(p,pe)|0)+(i>>>13)|0)+(ke>>>26)|0,ke&=67108863,n=Math.imul(D,q),i=Math.imul(D,W)+Math.imul(U,q)|0,o=Math.imul(U,W),n=n+Math.imul(C,J)|0,i=(i+Math.imul(C,X)|0)+Math.imul(L,J)|0,o=o+Math.imul(L,X)|0,n=n+Math.imul(T,Q)|0,i=(i+Math.imul(T,Y)|0)+Math.imul(R,Q)|0,o=o+Math.imul(R,Y)|0,n=n+Math.imul(x,te)|0,i=(i+Math.imul(x,re)|0)+Math.imul(P,te)|0,o=o+Math.imul(P,re)|0,n=n+Math.imul(S,ie)|0,i=(i+Math.imul(S,oe)|0)+Math.imul(k,ie)|0,o=o+Math.imul(k,oe)|0,n=n+Math.imul(M,ae)|0,i=(i+Math.imul(M,ue)|0)+Math.imul(A,ae)|0,o=o+Math.imul(A,ue)|0,n=n+Math.imul(b,he)|0,i=(i+Math.imul(b,fe)|0)+Math.imul(w,he)|0,o=o+Math.imul(w,fe)|0;var Ne=(ye+(n+Math.imul(y,de)|0)|0)+((8191&(i=(i+Math.imul(y,pe)|0)+Math.imul(m,de)|0))<<13)|0;ye=((o+Math.imul(m,pe)|0)+(i>>>13)|0)+(Ne>>>26)|0,Ne&=67108863,n=Math.imul(D,J),i=Math.imul(D,X)+Math.imul(U,J)|0,o=Math.imul(U,X),n=n+Math.imul(C,Q)|0,i=(i+Math.imul(C,Y)|0)+Math.imul(L,Q)|0,o=o+Math.imul(L,Y)|0,n=n+Math.imul(T,te)|0,i=(i+Math.imul(T,re)|0)+Math.imul(R,te)|0,o=o+Math.imul(R,re)|0,n=n+Math.imul(x,ie)|0,i=(i+Math.imul(x,oe)|0)+Math.imul(P,ie)|0,o=o+Math.imul(P,oe)|0,n=n+Math.imul(S,ae)|0,i=(i+Math.imul(S,ue)|0)+Math.imul(k,ae)|0,o=o+Math.imul(k,ue)|0,n=n+Math.imul(M,he)|0,i=(i+Math.imul(M,fe)|0)+Math.imul(A,he)|0,o=o+Math.imul(A,fe)|0;var xe=(ye+(n+Math.imul(b,de)|0)|0)+((8191&(i=(i+Math.imul(b,pe)|0)+Math.imul(w,de)|0))<<13)|0;ye=((o+Math.imul(w,pe)|0)+(i>>>13)|0)+(xe>>>26)|0,xe&=67108863,n=Math.imul(D,Q),i=Math.imul(D,Y)+Math.imul(U,Q)|0,o=Math.imul(U,Y),n=n+Math.imul(C,te)|0,i=(i+Math.imul(C,re)|0)+Math.imul(L,te)|0,o=o+Math.imul(L,re)|0,n=n+Math.imul(T,ie)|0,i=(i+Math.imul(T,oe)|0)+Math.imul(R,ie)|0,o=o+Math.imul(R,oe)|0,n=n+Math.imul(x,ae)|0,i=(i+Math.imul(x,ue)|0)+Math.imul(P,ae)|0,o=o+Math.imul(P,ue)|0,n=n+Math.imul(S,he)|0,i=(i+Math.imul(S,fe)|0)+Math.imul(k,he)|0,o=o+Math.imul(k,fe)|0;var Pe=(ye+(n+Math.imul(M,de)|0)|0)+((8191&(i=(i+Math.imul(M,pe)|0)+Math.imul(A,de)|0))<<13)|0;ye=((o+Math.imul(A,pe)|0)+(i>>>13)|0)+(Pe>>>26)|0,Pe&=67108863,n=Math.imul(D,te),i=Math.imul(D,re)+Math.imul(U,te)|0,o=Math.imul(U,re),n=n+Math.imul(C,ie)|0,i=(i+Math.imul(C,oe)|0)+Math.imul(L,ie)|0,o=o+Math.imul(L,oe)|0,n=n+Math.imul(T,ae)|0,i=(i+Math.imul(T,ue)|0)+Math.imul(R,ae)|0,o=o+Math.imul(R,ue)|0,n=n+Math.imul(x,he)|0,i=(i+Math.imul(x,fe)|0)+Math.imul(P,he)|0,o=o+Math.imul(P,fe)|0;var Ie=(ye+(n+Math.imul(S,de)|0)|0)+((8191&(i=(i+Math.imul(S,pe)|0)+Math.imul(k,de)|0))<<13)|0;ye=((o+Math.imul(k,pe)|0)+(i>>>13)|0)+(Ie>>>26)|0,Ie&=67108863,n=Math.imul(D,ie),i=Math.imul(D,oe)+Math.imul(U,ie)|0,o=Math.imul(U,oe),n=n+Math.imul(C,ae)|0,i=(i+Math.imul(C,ue)|0)+Math.imul(L,ae)|0,o=o+Math.imul(L,ue)|0,n=n+Math.imul(T,he)|0,i=(i+Math.imul(T,fe)|0)+Math.imul(R,he)|0,o=o+Math.imul(R,fe)|0;var Te=(ye+(n+Math.imul(x,de)|0)|0)+((8191&(i=(i+Math.imul(x,pe)|0)+Math.imul(P,de)|0))<<13)|0;ye=((o+Math.imul(P,pe)|0)+(i>>>13)|0)+(Te>>>26)|0,Te&=67108863,n=Math.imul(D,ae),i=Math.imul(D,ue)+Math.imul(U,ae)|0,o=Math.imul(U,ue),n=n+Math.imul(C,he)|0,i=(i+Math.imul(C,fe)|0)+Math.imul(L,he)|0,o=o+Math.imul(L,fe)|0;var Re=(ye+(n+Math.imul(T,de)|0)|0)+((8191&(i=(i+Math.imul(T,pe)|0)+Math.imul(R,de)|0))<<13)|0;ye=((o+Math.imul(R,pe)|0)+(i>>>13)|0)+(Re>>>26)|0,Re&=67108863,n=Math.imul(D,he),i=Math.imul(D,fe)+Math.imul(U,he)|0,o=Math.imul(U,fe);var Oe=(ye+(n+Math.imul(C,de)|0)|0)+((8191&(i=(i+Math.imul(C,pe)|0)+Math.imul(L,de)|0))<<13)|0;ye=((o+Math.imul(L,pe)|0)+(i>>>13)|0)+(Oe>>>26)|0,Oe&=67108863;var Ce=(ye+Math.imul(D,de)|0)+((8191&(i=Math.imul(D,pe)+Math.imul(U,de)|0))<<13)|0;return ye=(Math.imul(U,pe)+(i>>>13)|0)+(Ce>>>26)|0,Ce&=67108863,u[0]=ve,u[1]=me,u[2]=ge,u[3]=be,u[4]=we,u[5]=_e,u[6]=Me,u[7]=Ae,u[8]=Ee,u[9]=Se,u[10]=ke,u[11]=Ne,u[12]=xe,u[13]=Pe,u[14]=Ie,u[15]=Te,u[16]=Re,u[17]=Oe,u[18]=Ce,0!=ye&&(u[19]=ye,r.length++),r};function a(e,t,r){return(new u).mulp(e,t,r)}function u(e,t){this.x=e,this.y=t}Math.imul||(o=i),m.prototype.mulTo=function(e,t){var r=this.length+e.length,n=(10===this.length&&10===e.length?o:r<63?i:r<1024?function(e,t,r){r.negative=t.negative^e.negative,r.length=e.length+t.length;for(var n=0,i=0,o=0;o<r.length-1;o++){for(var s=i,i=0,a=67108863&n,u=Math.min(o,t.length-1),l=Math.max(0,o-e.length+1);l<=u;l++){var h=o-l,f=(0|e.words[h])*(0|t.words[l]),c=67108863&f,a=67108863&(c=c+a|0);i+=(s=(s=s+(f/67108864|0)|0)+(c>>>26)|0)>>>26,s&=67108863}r.words[o]=a,n=s,s=i}return 0!==n?r.words[o]=n:r.length--,r.strip()}:a)(this,e,t);return n},u.prototype.makeRBT=function(e){for(var t=new Array(e),r=m.prototype._countBits(e)-1,n=0;n<e;n++)t[n]=this.revBin(n,r,e);return t},u.prototype.revBin=function(e,t,r){if(0===e||e===r-1)return e;for(var n=0,i=0;i<t;i++)n|=(1&e)<<t-i-1,e>>=1;return n},u.prototype.permute=function(e,t,r,n,i,o){for(var s=0;s<o;s++)n[s]=t[e[s]],i[s]=r[e[s]]},u.prototype.transform=function(e,t,r,n,i,o){this.permute(o,e,t,r,n,i);for(var s=1;s<i;s<<=1)for(var a=s<<1,u=Math.cos(2*Math.PI/a),l=Math.sin(2*Math.PI/a),h=0;h<i;h+=a)for(var f=u,c=l,d=0;d<s;d++){var p=r[h+d],v=n[h+d],y=f*(g=r[h+d+s])-c*(m=n[h+d+s]),m=f*m+c*g,g=y;r[h+d]=p+g,n[h+d]=v+m,r[h+d+s]=p-g,n[h+d+s]=v-m,d!==a&&(y=u*f-l*c,c=u*c+l*f,f=y)}},u.prototype.guessLen13b=function(e,t){for(var r=1&(i=1|Math.max(t,e)),n=0,i=i/2|0;i;i>>>=1)n++;return 1<<n+1+r},u.prototype.conjugate=function(e,t,r){if(!(r<=1))for(var n=0;n<r/2;n++){var i=e[n];e[n]=e[r-n-1],e[r-n-1]=i,i=t[n],t[n]=-t[r-n-1],t[r-n-1]=-i}},u.prototype.normalize13b=function(e,t){for(var r=0,n=0;n<t/2;n++){var i=8192*Math.round(e[2*n+1]/t)+Math.round(e[2*n]/t)+r;e[n]=67108863&i,r=i<67108864?0:i/67108864|0}return e},u.prototype.convert13b=function(e,t,r,n){for(var i=0,o=0;o<t;o++)i+=0|e[o],r[2*o]=8191&i,i>>>=13,r[2*o+1]=8191&i,i>>>=13;for(o=2*t;o<n;++o)r[o]=0;y(0===i),y(0==(-8192&i))},u.prototype.stub=function(e){for(var t=new Array(e),r=0;r<e;r++)t[r]=0;return t},u.prototype.mulp=function(e,t,r){var n=2*this.guessLen13b(e.length,t.length),i=this.makeRBT(n),o=this.stub(n),s=new Array(n),a=new Array(n),u=new Array(n),l=new Array(n),h=new Array(n),f=new Array(n),c=r.words;c.length=n,this.convert13b(e.words,e.length,s,n),this.convert13b(t.words,t.length,l,n),this.transform(s,o,a,u,n,i),this.transform(l,o,h,f,n,i);for(var d=0;d<n;d++){var p=a[d]*h[d]-u[d]*f[d];u[d]=a[d]*f[d]+u[d]*h[d],a[d]=p}return this.conjugate(a,u,n),this.transform(a,u,c,o,n,i),this.conjugate(c,o,n),this.normalize13b(c,n),r.negative=e.negative^t.negative,r.length=e.length+t.length,r.strip()},m.prototype.mul=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},m.prototype.mulf=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),a(this,e,t)},m.prototype.imul=function(e){return this.clone().mulTo(e,this)},m.prototype.imuln=function(e){y("number"==typeof e),y(e<67108864);for(var t=0,r=0;r<this.length;r++){var n=(0|this.words[r])*e,i=(67108863&n)+(67108863&t);t>>=26,t+=n/67108864|0,t+=i>>>26,this.words[r]=67108863&i}return 0!==t&&(this.words[r]=t,this.length++),this},m.prototype.muln=function(e){return this.clone().imuln(e)},m.prototype.sqr=function(){return this.mul(this)},m.prototype.isqr=function(){return this.imul(this.clone())},m.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),r=0;r<t.length;r++){var n=r/26|0,i=r%26;t[r]=(e.words[n]&1<<i)>>>i}return t}(e);if(0===t.length)return new m(1);for(var r=this,n=0;n<t.length&&0===t[n];n++,r=r.sqr());if(++n<t.length)for(var i=r.sqr();n<t.length;n++,i=i.sqr())0!==t[n]&&(r=r.mul(i));return r},m.prototype.iushln=function(e){y("number"==typeof e&&0<=e);var t=e%26,r=(e-t)/26,n=67108863>>>26-t<<26-t;if(0!=t){for(var i=0,o=0;o<this.length;o++){var s=this.words[o]&n,a=(0|this.words[o])-s<<t;this.words[o]=a|i,i=s>>>26-t}i&&(this.words[o]=i,this.length++)}if(0!=r){for(o=this.length-1;0<=o;o--)this.words[o+r]=this.words[o];for(o=0;o<r;o++)this.words[o]=0;this.length+=r}return this.strip()},m.prototype.ishln=function(e){return y(0===this.negative),this.iushln(e)},m.prototype.iushrn=function(e,t,r){var n;y("number"==typeof e&&0<=e),n=t?(t-t%26)/26:0;var i=e%26,o=Math.min((e-i)/26,this.length),s=67108863^67108863>>>i<<i,a=r;if(n-=o,n=Math.max(0,n),a){for(var u=0;u<o;u++)a.words[u]=this.words[u];a.length=o}if(0!==o)if(this.length>o)for(this.length-=o,u=0;u<this.length;u++)this.words[u]=this.words[u+o];else this.words[0]=0,this.length=1;for(var l=0,u=this.length-1;0<=u&&(0!==l||n<=u);u--){var h=0|this.words[u];this.words[u]=l<<26-i|h>>>i,l=h&s}return a&&0!==l&&(a.words[a.length++]=l),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},m.prototype.ishrn=function(e,t,r){return y(0===this.negative),this.iushrn(e,t,r)},m.prototype.shln=function(e){return this.clone().ishln(e)},m.prototype.ushln=function(e){return this.clone().iushln(e)},m.prototype.shrn=function(e){return this.clone().ishrn(e)},m.prototype.ushrn=function(e){return this.clone().iushrn(e)},m.prototype.testn=function(e){y("number"==typeof e&&0<=e);var t=e%26,r=(e-t)/26,n=1<<t;return!(this.length<=r)&&!!(this.words[r]&n)},m.prototype.imaskn=function(e){y("number"==typeof e&&0<=e);var t,r=e%26,n=(e-r)/26;return y(0===this.negative,"imaskn works only with positive numbers"),this.length<=n?this:(0!=r&&n++,this.length=Math.min(n,this.length),0!=r&&(t=67108863^67108863>>>r<<r,this.words[this.length-1]&=t),this.strip())},m.prototype.maskn=function(e){return this.clone().imaskn(e)},m.prototype.iaddn=function(e){return y("number"==typeof e),y(e<67108864),e<0?this.isubn(-e):0!==this.negative?(1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0):(this.negative=0,this.isubn(e),this.negative=1),this):this._iaddn(e)},m.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&67108864<=this.words[t];t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},m.prototype.isubn=function(e){if(y("number"==typeof e),y(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,--this.words[t+1];return this.strip()},m.prototype.addn=function(e){return this.clone().iaddn(e)},m.prototype.subn=function(e){return this.clone().isubn(e)},m.prototype.iabs=function(){return this.negative=0,this},m.prototype.abs=function(){return this.clone().iabs()},m.prototype._ishlnsubmul=function(e,t,r){var n,i=e.length+r;this._expand(i);for(var o=0,s=0;s<e.length;s++){n=(0|this.words[s+r])+o;var a=(0|e.words[s])*t,o=((n-=67108863&a)>>26)-(a/67108864|0);this.words[s+r]=67108863&n}for(;s<this.length-r;s++)o=(n=(0|this.words[s+r])+o)>>26,this.words[s+r]=67108863&n;if(0===o)return this.strip();for(y(-1===o),s=o=0;s<this.length;s++)o=(n=-(0|this.words[s])+o)>>26,this.words[s]=67108863&n;return this.negative=1,this.strip()},m.prototype._wordDiv=function(e,t){var r=this.length-e.length,n=this.clone(),i=e,o=0|i.words[i.length-1];0!=(r=26-this._countBits(o))&&(i=i.ushln(r),n.iushln(r),o=0|i.words[i.length-1]);var s,a=n.length-i.length;if("mod"!==t){(s=new m(null)).length=1+a,s.words=new Array(s.length);for(var u=0;u<s.length;u++)s.words[u]=0}var l=n.clone()._ishlnsubmul(i,1,a);0===l.negative&&(n=l,s&&(s.words[a]=1));for(var h=a-1;0<=h;h--){var f=67108864*(0|n.words[i.length+h])+(0|n.words[i.length+h-1]),f=Math.min(f/o|0,67108863);for(n._ishlnsubmul(i,f,h);0!==n.negative;)f--,n.negative=0,n._ishlnsubmul(i,1,h),n.isZero()||(n.negative^=1);s&&(s.words[h]=f)}return s&&s.strip(),n.strip(),"div"!==t&&0!=r&&n.iushrn(r),{div:s||null,mod:n}},m.prototype.divmod=function(e,t,r){return y(!e.isZero()),this.isZero()?{div:new m(0),mod:new m(0)}:0!==this.negative&&0===e.negative?(o=this.neg().divmod(e,t),"mod"!==t&&(n=o.div.neg()),"div"!==t&&(i=o.mod.neg(),r&&0!==i.negative&&i.iadd(e)),{div:n,mod:i}):0===this.negative&&0!==e.negative?(o=this.divmod(e.neg(),t),"mod"!==t&&(n=o.div.neg()),{div:n,mod:o.mod}):0!=(this.negative&e.negative)?(o=this.neg().divmod(e.neg(),t),"div"!==t&&(i=o.mod.neg(),r&&0!==i.negative&&i.isub(e)),{div:o.div,mod:i}):e.length>this.length||this.cmp(e)<0?{div:new m(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new m(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new m(this.modn(e.words[0]))}:this._wordDiv(e,t);var n,i,o},m.prototype.div=function(e){return this.divmod(e,"div",!1).div},m.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},m.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},m.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var r=0!==t.div.negative?t.mod.isub(e):t.mod,n=e.ushrn(1),i=e.andln(1),o=r.cmp(n);return o<0||1===i&&0===o?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},m.prototype.modn=function(e){y(e<=67108863);for(var t=(1<<26)%e,r=0,n=this.length-1;0<=n;n--)r=(t*r+(0|this.words[n]))%e;return r},m.prototype.idivn=function(e){y(e<=67108863);for(var t=0,r=this.length-1;0<=r;r--){var n=(0|this.words[r])+67108864*t;this.words[r]=n/e|0,t=n%e}return this.strip()},m.prototype.divn=function(e){return this.clone().idivn(e)},m.prototype.egcd=function(e){y(0===e.negative),y(!e.isZero());for(var t=this,r=e.clone(),t=0!==t.negative?t.umod(e):t.clone(),n=new m(1),i=new m(0),o=new m(0),s=new m(1),a=0;t.isEven()&&r.isEven();)t.iushrn(1),r.iushrn(1),++a;for(var u=r.clone(),l=t.clone();!t.isZero();){for(var h=0,f=1;0==(t.words[0]&f)&&h<26;++h,f<<=1);if(0<h)for(t.iushrn(h);0<h--;)(n.isOdd()||i.isOdd())&&(n.iadd(u),i.isub(l)),n.iushrn(1),i.iushrn(1);for(var c=0,d=1;0==(r.words[0]&d)&&c<26;++c,d<<=1);if(0<c)for(r.iushrn(c);0<c--;)(o.isOdd()||s.isOdd())&&(o.iadd(u),s.isub(l)),o.iushrn(1),s.iushrn(1);0<=t.cmp(r)?(t.isub(r),n.isub(o),i.isub(s)):(r.isub(t),o.isub(n),s.isub(i))}return{a:o,b:s,gcd:r.iushln(a)}},m.prototype._invmp=function(e){y(0===e.negative),y(!e.isZero());for(var t,r=this,n=e.clone(),r=0!==r.negative?r.umod(e):r.clone(),i=new m(1),o=new m(0),s=n.clone();0<r.cmpn(1)&&0<n.cmpn(1);){for(var a=0,u=1;0==(r.words[0]&u)&&a<26;++a,u<<=1);if(0<a)for(r.iushrn(a);0<a--;)i.isOdd()&&i.iadd(s),i.iushrn(1);for(var l=0,h=1;0==(n.words[0]&h)&&l<26;++l,h<<=1);if(0<l)for(n.iushrn(l);0<l--;)o.isOdd()&&o.iadd(s),o.iushrn(1);0<=r.cmp(n)?(r.isub(n),i.isub(o)):(n.isub(r),o.isub(i))}return(t=0===r.cmpn(1)?i:o).cmpn(0)<0&&t.iadd(e),t},m.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),r=e.clone();t.negative=0;for(var n=r.negative=0;t.isEven()&&r.isEven();n++)t.iushrn(1),r.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;r.isEven();)r.iushrn(1);var i=t.cmp(r);if(i<0)var o=t,t=r,r=o;else if(0===i||0===r.cmpn(1))break;t.isub(r)}return r.iushln(n)},m.prototype.invm=function(e){return this.egcd(e).a.umod(e)},m.prototype.isEven=function(){return 0==(1&this.words[0])},m.prototype.isOdd=function(){return 1==(1&this.words[0])},m.prototype.andln=function(e){return this.words[0]&e},m.prototype.bincn=function(e){y("number"==typeof e);var t=e%26,r=(e-t)/26,n=1<<t;if(this.length<=r)return this._expand(1+r),this.words[r]|=n,this;for(var i=n,o=r;0!==i&&o<this.length;o++){var s=0|this.words[o],i=(s+=i)>>>26;s&=67108863,this.words[o]=s}return 0!==i&&(this.words[o]=i,this.length++),this},m.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},m.prototype.cmpn=function(e){var t,r,n=e<0;return 0===this.negative||n?0===this.negative&&n?1:(this.strip(),r=1<this.length?1:(n&&(e=-e),y(e<=67108863,"Number is too big"),(t=0|this.words[0])===e?0:t<e?-1:1),0!==this.negative?0|-r:r):-1},m.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;var t=this.ucmp(e);return 0!==this.negative?0|-t:t},m.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,r=this.length-1;0<=r;r--){var n=0|this.words[r],i=0|e.words[r];if(n!=i){n<i?t=-1:i<n&&(t=1);break}}return t},m.prototype.gtn=function(e){return 1===this.cmpn(e)},m.prototype.gt=function(e){return 1===this.cmp(e)},m.prototype.gten=function(e){return 0<=this.cmpn(e)},m.prototype.gte=function(e){return 0<=this.cmp(e)},m.prototype.ltn=function(e){return-1===this.cmpn(e)},m.prototype.lt=function(e){return-1===this.cmp(e)},m.prototype.lten=function(e){return this.cmpn(e)<=0},m.prototype.lte=function(e){return this.cmp(e)<=0},m.prototype.eqn=function(e){return 0===this.cmpn(e)},m.prototype.eq=function(e){return 0===this.cmp(e)},m.red=function(e){return new _(e)},m.prototype.toRed=function(e){return y(!this.red,"Already a number in reduction context"),y(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},m.prototype.fromRed=function(){return y(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},m.prototype._forceRed=function(e){return this.red=e,this},m.prototype.forceRed=function(e){return y(!this.red,"Already a number in reduction context"),this._forceRed(e)},m.prototype.redAdd=function(e){return y(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},m.prototype.redIAdd=function(e){return y(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},m.prototype.redSub=function(e){return y(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},m.prototype.redISub=function(e){return y(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},m.prototype.redShl=function(e){return y(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},m.prototype.redMul=function(e){return y(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},m.prototype.redIMul=function(e){return y(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},m.prototype.redSqr=function(){return y(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},m.prototype.redISqr=function(){return y(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},m.prototype.redSqrt=function(){return y(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},m.prototype.redInvm=function(){return y(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},m.prototype.redNeg=function(){return y(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},m.prototype.redPow=function(e){return y(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var l={k256:null,p224:null,p192:null,p25519:null};function h(e,t){this.name=e,this.p=new m(t,16),this.n=this.p.bitLength(),this.k=new m(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function v(){h.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function g(){h.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function b(){h.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function w(){h.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function _(e){var t;"string"==typeof e?(t=m._prime(e),this.m=t.p,this.prime=t):(y(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null)}function M(e){_.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new m(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}h.prototype._tmp=function(){var e=new m(null);return e.words=new Array(Math.ceil(this.n/13)),e},h.prototype.ireduce=function(e){for(var t,r=e;this.split(r,this.tmp),(t=(r=(r=this.imulK(r)).iadd(this.tmp)).bitLength())>this.n;);var n=t<this.n?-1:r.ucmp(this.p);return 0===n?(r.words[0]=0,r.length=1):0<n?r.isub(this.p):void 0!==r.strip?r.strip():r._strip(),r},h.prototype.split=function(e,t){e.iushrn(this.n,0,t)},h.prototype.imulK=function(e){return e.imul(this.k)},r(v,h),v.prototype.split=function(e,t){for(var r=Math.min(e.length,9),n=0;n<r;n++)t.words[n]=e.words[n];if(t.length=r,e.length<=9)return e.words[0]=0,void(e.length=1);var i=e.words[9];for(t.words[t.length++]=4194303&i,n=10;n<e.length;n++){var o=0|e.words[n];e.words[n-10]=(4194303&o)<<4|i>>>22,i=o}i>>>=22,0===(e.words[n-10]=i)&&10<e.length?e.length-=10:e.length-=9},v.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,r=0;r<e.length;r++){var n=0|e.words[r];t+=977*n,e.words[r]=67108863&t,t=64*n+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},r(g,h),r(b,h),r(w,h),w.prototype.imulK=function(e){for(var t=0,r=0;r<e.length;r++){var n=19*(0|e.words[r])+t,i=67108863&n;n>>>=26,e.words[r]=i,t=n}return 0!==t&&(e.words[e.length++]=t),e},m._prime=function(e){if(l[e])return l[e];var t;if("k256"===e)t=new v;else if("p224"===e)t=new g;else if("p192"===e)t=new b;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new w}return l[e]=t},_.prototype._verify1=function(e){y(0===e.negative,"red works only with positives"),y(e.red,"red works only with red numbers")},_.prototype._verify2=function(e,t){y(0==(e.negative|t.negative),"red works only with positives"),y(e.red&&e.red===t.red,"red works only with red numbers")},_.prototype.imod=function(e){return this.prime?this.prime.ireduce(e)._forceRed(this):e.umod(this.m)._forceRed(this)},_.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},_.prototype.add=function(e,t){this._verify2(e,t);var r=e.add(t);return 0<=r.cmp(this.m)&&r.isub(this.m),r._forceRed(this)},_.prototype.iadd=function(e,t){this._verify2(e,t);var r=e.iadd(t);return 0<=r.cmp(this.m)&&r.isub(this.m),r},_.prototype.sub=function(e,t){this._verify2(e,t);var r=e.sub(t);return r.cmpn(0)<0&&r.iadd(this.m),r._forceRed(this)},_.prototype.isub=function(e,t){this._verify2(e,t);var r=e.isub(t);return r.cmpn(0)<0&&r.iadd(this.m),r},_.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},_.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},_.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},_.prototype.isqr=function(e){return this.imul(e,e.clone())},_.prototype.sqr=function(e){return this.mul(e,e)},_.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(y(t%2==1),3===t){var r=this.m.add(new m(1)).iushrn(2);return this.pow(e,r)}for(var n=this.m.subn(1),i=0;!n.isZero()&&0===n.andln(1);)i++,n.iushrn(1);y(!n.isZero());for(var o=new m(1).toRed(this),s=o.redNeg(),a=this.m.subn(1).iushrn(1),u=new m(2*(u=this.m.bitLength())*u).toRed(this);0!==this.pow(u,a).cmp(s);)u.redIAdd(s);for(var l=this.pow(u,n),h=this.pow(e,n.addn(1).iushrn(1)),f=this.pow(e,n),c=i;0!==f.cmp(o);){for(var d=f,p=0;0!==d.cmp(o);p++)d=d.redSqr();y(p<c);var v=this.pow(l,new m(1).iushln(c-p-1)),h=h.redMul(v),l=v.redSqr(),f=f.redMul(l),c=p}return h},_.prototype.invm=function(e){var t=e._invmp(this.m);return 0!==t.negative?(t.negative=0,this.imod(t).redNeg()):this.imod(t)},_.prototype.pow=function(e,t){if(t.isZero())return new m(1).toRed(this);if(0===t.cmpn(1))return e.clone();var r=new Array(16);r[0]=new m(1).toRed(this),r[1]=e;for(var n=2;n<r.length;n++)r[n]=this.mul(r[n-1],e);var i=r[0],o=0,s=0,a=t.bitLength()%26;for(0===a&&(a=26),n=t.length-1;0<=n;n--){for(var u=t.words[n],l=a-1;0<=l;l--){var h=u>>l&1;i!==r[0]&&(i=this.sqr(i)),0!=h||0!==o?(o<<=1,o|=h,(4===++s||0===n&&0===l)&&(i=this.mul(i,r[o]),o=s=0)):s=0}a=26}return i},_.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},_.prototype.convertFrom=function(e){var t=e.clone();return t.red=null,t},m.mont=function(e){return new M(e)},r(M,_),M.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},M.prototype.convertFrom=function(e){var t=this.imod(e.mul(this.rinv));return t.red=null,t},M.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;var r=e.imul(t),n=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),i=r.isub(n).iushrn(this.shift),o=i;return 0<=i.cmp(this.m)?o=i.isub(this.m):i.cmpn(0)<0&&(o=i.iadd(this.m)),o._forceRed(this)},M.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new m(0)._forceRed(this);var r=e.mul(t),n=r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),i=r.isub(n).iushrn(this.shift),o=i;return 0<=i.cmp(this.m)?o=i.isub(this.m):i.cmpn(0)<0&&(o=i.iadd(this.m)),o._forceRed(this)},M.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(void 0===e||e,this)},{buffer:11}],10:[function(e,t,r){(function(r){t.exports=function(e){var t=new Uint8Array(e);return(r.crypto||r.msCrypto).getRandomValues(t),t}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],11:[function(e,t,r){},{}],12:[function(e,t,r){"use strict";var n=r;n.version=e("../package.json").version,n.utils=e("./elliptic/utils"),n.rand=e("brorand"),n.curve=e("./elliptic/curve"),n.curves=e("./elliptic/curves"),n.ec=e("./elliptic/ec"),n.eddsa=e("./elliptic/eddsa")},{"../package.json":25,"./elliptic/curve":15,"./elliptic/curves":18,"./elliptic/ec":19,"./elliptic/eddsa":22,"./elliptic/utils":24,brorand:10}],13:[function(e,t,r){"use strict";var n=e("bn.js"),i=e("../utils"),S=i.getNAF,k=i.getJSF,f=i.assert;function o(e,t){this.type=e,this.p=new n(t.p,16),this.red=t.prime?n.red(t.prime):n.mont(this.p),this.zero=new n(0).toRed(this.red),this.one=new n(1).toRed(this.red),this.two=new n(2).toRed(this.red),this.n=t.n&&new n(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4),this._bitLength=this.n?this.n.bitLength():0;var r=this.n&&this.p.div(this.n);!r||0<r.cmpn(100)?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function s(e,t){this.curve=e,this.type=t,this.precomputed=null}(t.exports=o).prototype.point=function(){throw new Error("Not implemented")},o.prototype.validate=function(){throw new Error("Not implemented")},o.prototype._fixedNafMul=function(e,t){f(e.precomputed);var r=e._getDoubles(),n=S(t,1,this._bitLength),i=(1<<r.step+1)-(r.step%2==0?2:1);i/=3;for(var o=[],s=0;s<n.length;s+=r.step){for(var a=0,t=s+r.step-1;s<=t;t--)a=(a<<1)+n[t];o.push(a)}for(var u=this.jpoint(null,null,null),l=this.jpoint(null,null,null),h=i;0<h;h--){for(s=0;s<o.length;s++){(a=o[s])===h?l=l.mixedAdd(r.points[s]):a===-h&&(l=l.mixedAdd(r.points[s].neg()))}u=u.add(l)}return u.toP()},o.prototype._wnafMul=function(e,t){for(var r=e._getNAFPoints(4),n=r.wnd,i=r.points,o=S(t,n,this._bitLength),s=this.jpoint(null,null,null),a=o.length-1;0<=a;a--){for(t=0;0<=a&&0===o[a];a--)t++;if(0<=a&&t++,s=s.dblp(t),a<0)break;var u=o[a];f(0!==u),s="affine"===e.type?0<u?s.mixedAdd(i[u-1>>1]):s.mixedAdd(i[-u-1>>1].neg()):0<u?s.add(i[u-1>>1]):s.add(i[-u-1>>1].neg())}return"affine"===e.type?s.toP():s},o.prototype._wnafMulAdd=function(e,t,r,n,i){for(var o=this._wnafT1,s=this._wnafT2,a=this._wnafT3,u=0,l=0;l<n;l++){var h=(A=t[l])._getNAFPoints(e);o[l]=h.wnd,s[l]=h.points}for(l=n-1;1<=l;l-=2){var f=l-1,c=l;if(1===o[f]&&1===o[c]){var d=[t[f],null,null,t[c]];0===t[f].y.cmp(t[c].y)?(d[1]=t[f].add(t[c]),d[2]=t[f].toJ().mixedAdd(t[c].neg())):0===t[f].y.cmp(t[c].y.redNeg())?(d[1]=t[f].toJ().mixedAdd(t[c]),d[2]=t[f].add(t[c].neg())):(d[1]=t[f].toJ().mixedAdd(t[c]),d[2]=t[f].toJ().mixedAdd(t[c].neg()));var p=[-3,-1,-5,-7,0,7,5,1,3],v=k(r[f],r[c]),u=Math.max(v[0].length,u);a[f]=new Array(u),a[c]=new Array(u);for(var y=0;y<u;y++){var m=0|v[0][y],g=0|v[1][y];a[f][y]=p[3*(1+m)+(1+g)],a[c][y]=0,s[f]=d}}else a[f]=S(r[f],o[f],this._bitLength),a[c]=S(r[c],o[c],this._bitLength),u=Math.max(a[f].length,u),u=Math.max(a[c].length,u)}for(var b=this.jpoint(null,null,null),w=this._wnafT4,l=u;0<=l;l--){for(var _=0;0<=l;){for(var M=!0,y=0;y<n;y++)w[y]=0|a[y][l],0!==w[y]&&(M=!1);if(!M)break;_++,l--}if(0<=l&&_++,b=b.dblp(_),l<0)break;for(y=0;y<n;y++){var A,E=w[y];0!==E&&(0<E?A=s[y][E-1>>1]:E<0&&(A=s[y][-E-1>>1].neg()),b="affine"===A.type?b.mixedAdd(A):b.add(A))}}for(l=0;l<n;l++)s[l]=null;return i?b:b.toP()},(o.BasePoint=s).prototype.eq=function(){throw new Error("Not implemented")},s.prototype.validate=function(){return this.curve.validate(this)},o.prototype.decodePoint=function(e,t){e=i.toArray(e,t);var r=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*r)return 6===e[0]?f(e[e.length-1]%2==0):7===e[0]&&f(e[e.length-1]%2==1),this.point(e.slice(1,1+r),e.slice(1+r,1+2*r));if((2===e[0]||3===e[0])&&e.length-1===r)return this.pointFromX(e.slice(1,1+r),3===e[0]);throw new Error("Unknown point format")},s.prototype.encodeCompressed=function(e){return this.encode(e,!0)},s.prototype._encode=function(e){var t=this.curve.p.byteLength(),r=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(r):[4].concat(r,this.getY().toArray("be",t))},s.prototype.encode=function(e,t){return i.encode(this._encode(t),e)},s.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},s.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return!!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},s.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var r=[this],n=this,i=0;i<t;i+=e){for(var o=0;o<e;o++)n=n.dbl();r.push(n)}return{step:e,points:r}},s.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],r=(1<<e)-1,n=1==r?null:this.dbl(),i=1;i<r;i++)t[i]=t[i-1].add(n);return{wnd:e,points:t}},s.prototype._getBeta=function(){return null},s.prototype.dblp=function(e){for(var t=this,r=0;r<e;r++)t=t.dbl();return t}},{"../utils":24,"bn.js":9}],14:[function(e,t,r){t.exports={}},{}],15:[function(e,t,r){"use strict";var n=r;n.base=e("./base"),n.short=e("./short"),n.mont=e("./mont"),n.edwards=e("./edwards")},{"./base":13,"./edwards":14,"./mont":16,"./short":17}],16:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],17:[function(e,t,r){"use strict";var n=e("../utils"),_=e("bn.js"),i=e("inherits"),o=e("./base"),s=n.assert;function a(e){o.call(this,"short",e),this.a=new _(e.a,16).toRed(this.red),this.b=new _(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function u(e,t,r,n){o.BasePoint.call(this,e,"affine"),null===t&&null===r?(this.x=null,this.y=null,this.inf=!0):(this.x=new _(t,16),this.y=new _(r,16),n&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function l(e,t,r,n){o.BasePoint.call(this,e,"jacobian"),null===t&&null===r&&null===n?(this.x=this.curve.one,this.y=this.curve.one,this.z=new _(0)):(this.x=new _(t,16),this.y=new _(r,16),this.z=new _(n,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}i(a,o),(t.exports=a).prototype._getEndomorphism=function(e){var t,r,n,i;if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3))return n=e.beta?new _(e.beta,16).toRed(this.red):(n=(r=this._getEndoRoots(this.p))[0].cmp(r[1])<0?r[0]:r[1]).toRed(this.red),e.lambda?t=new _(e.lambda,16):(i=this._getEndoRoots(this.n),0===this.g.mul(i[0]).x.cmp(this.g.x.redMul(n))?t=i[0]:(t=i[1],s(0===this.g.mul(t).x.cmp(this.g.x.redMul(n))))),{beta:n,lambda:t,basis:e.basis?e.basis.map(function(e){return{a:new _(e.a,16),b:new _(e.b,16)}}):this._getEndoBasis(t)}},a.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:_.mont(e),r=new _(2).toRed(t).redInvm(),n=r.redNeg(),i=new _(3).toRed(t).redNeg().redSqrt().redMul(r);return[n.redAdd(i).fromRed(),n.redSub(i).fromRed()]},a.prototype._getEndoBasis=function(e){for(var t,r,n,i,o,s,a,u=this.n.ushrn(Math.floor(this.n.bitLength()/2)),l=e,h=this.n.clone(),f=new _(1),c=new _(0),d=new _(0),p=new _(1),v=0;0!==l.cmpn(0);){var y=h.div(l),m=h.sub(y.mul(l)),g=d.sub(y.mul(f)),b=p.sub(y.mul(c));if(!n&&m.cmp(u)<0)t=a.neg(),r=f,n=m.neg(),i=g;else if(n&&2==++v)break;h=l,l=a=m,d=f,f=g,p=c,c=b}o=m.neg(),s=g;var w=n.sqr().add(i.sqr());return 0<=o.sqr().add(s.sqr()).cmp(w)&&(o=t,s=r),n.negative&&(n=n.neg(),i=i.neg()),o.negative&&(o=o.neg(),s=s.neg()),[{a:n,b:i},{a:o,b:s}]},a.prototype._endoSplit=function(e){var t=this.endo.basis,r=t[0],n=t[1],i=n.b.mul(e).divRound(this.n),o=r.b.neg().mul(e).divRound(this.n),s=i.mul(r.a),a=o.mul(n.a),u=i.mul(r.b),l=o.mul(n.b);return{k1:e.sub(s).sub(a),k2:u.add(l).neg()}},a.prototype.pointFromX=function(e,t){(e=new _(e,16)).red||(e=e.toRed(this.red));var r=e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),n=r.redSqrt();if(0!==n.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");var i=n.fromRed().isOdd();return(t&&!i||!t&&i)&&(n=n.redNeg()),this.point(e,n)},a.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,r=e.y,n=this.a.redMul(t),i=t.redSqr().redMul(t).redIAdd(n).redIAdd(this.b);return 0===r.redSqr().redISub(i).cmpn(0)},a.prototype._endoWnafMulAdd=function(e,t,r){for(var n=this._endoWnafT1,i=this._endoWnafT2,o=0;o<e.length;o++){var s=this._endoSplit(t[o]),a=e[o],u=a._getBeta();s.k1.negative&&(s.k1.ineg(),a=a.neg(!0)),s.k2.negative&&(s.k2.ineg(),u=u.neg(!0)),n[2*o]=a,n[2*o+1]=u,i[2*o]=s.k1,i[2*o+1]=s.k2}for(var l=this._wnafMulAdd(1,n,i,2*o,r),h=0;h<2*o;h++)n[h]=null,i[h]=null;return l},i(u,o.BasePoint),a.prototype.point=function(e,t,r){return new u(this,e,t,r)},a.prototype.pointFromJSON=function(e,t){return u.fromJSON(this,e,t)},u.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t,r,n=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);return e&&(t=this.curve,r=function(e){return t.point(e.x.redMul(t.endo.beta),e.y)},(e.beta=n).precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(r)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(r)}}),n}},u.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},u.fromJSON=function(t,e,r){"string"==typeof e&&(e=JSON.parse(e));var n=t.point(e[0],e[1],r);if(!e[2])return n;function i(e){return t.point(e[0],e[1],r)}var o=e[2];return n.precomputed={beta:null,doubles:o.doubles&&{step:o.doubles.step,points:[n].concat(o.doubles.points.map(i))},naf:o.naf&&{wnd:o.naf.wnd,points:[n].concat(o.naf.points.map(i))}},n},u.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},u.prototype.isInfinity=function(){return this.inf},u.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y);0!==t.cmpn(0)&&(t=t.redMul(this.x.redSub(e.x).redInvm()));var r=t.redSqr().redISub(this.x).redISub(e.x),n=t.redMul(this.x.redSub(r)).redISub(this.y);return this.curve.point(r,n)},u.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,r=this.x.redSqr(),n=e.redInvm(),i=r.redAdd(r).redIAdd(r).redIAdd(t).redMul(n),o=i.redSqr().redISub(this.x.redAdd(this.x)),s=i.redMul(this.x.redSub(o)).redISub(this.y);return this.curve.point(o,s)},u.prototype.getX=function(){return this.x.fromRed()},u.prototype.getY=function(){return this.y.fromRed()},u.prototype.mul=function(e){return e=new _(e,16),this.isInfinity()?this:this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},u.prototype.mulAdd=function(e,t,r){var n=[this,t],i=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(n,i):this.curve._wnafMulAdd(1,n,i,2)},u.prototype.jmulAdd=function(e,t,r){var n=[this,t],i=[e,r];return this.curve.endo?this.curve._endoWnafMulAdd(n,i,!0):this.curve._wnafMulAdd(1,n,i,2,!0)},u.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},u.prototype.neg=function(e){if(this.inf)return this;var t,r,n=this.curve.point(this.x,this.y.redNeg());return e&&this.precomputed&&(t=this.precomputed,r=function(e){return e.neg()},n.precomputed={naf:t.naf&&{wnd:t.naf.wnd,points:t.naf.points.map(r)},doubles:t.doubles&&{step:t.doubles.step,points:t.doubles.points.map(r)}}),n},u.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},i(l,o.BasePoint),a.prototype.jpoint=function(e,t,r){return new l(this,e,t,r)},l.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),r=this.x.redMul(t),n=this.y.redMul(t).redMul(e);return this.curve.point(r,n)},l.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},l.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),r=this.z.redSqr(),n=this.x.redMul(t),i=e.x.redMul(r),o=this.y.redMul(t.redMul(e.z)),s=e.y.redMul(r.redMul(this.z)),a=n.redSub(i),u=o.redSub(s);if(0===a.cmpn(0))return 0!==u.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var l=a.redSqr(),h=l.redMul(a),f=n.redMul(l),c=u.redSqr().redIAdd(h).redISub(f).redISub(f),d=u.redMul(f.redISub(c)).redISub(o.redMul(h)),p=this.z.redMul(e.z).redMul(a);return this.curve.jpoint(c,d,p)},l.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),r=this.x,n=e.x.redMul(t),i=this.y,o=e.y.redMul(t).redMul(this.z),s=r.redSub(n),a=i.redSub(o);if(0===s.cmpn(0))return 0!==a.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var u=s.redSqr(),l=u.redMul(s),h=r.redMul(u),f=a.redSqr().redIAdd(l).redISub(h).redISub(h),c=a.redMul(h.redISub(f)).redISub(i.redMul(l)),d=this.z.redMul(s);return this.curve.jpoint(f,c,d)},l.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,r=0;r<e;r++)t=t.dbl();return t}for(var n=this.curve.a,i=this.curve.tinv,o=this.x,s=this.y,a=this.z,u=a.redSqr().redSqr(),l=s.redAdd(s),r=0;r<e;r++){var h=o.redSqr(),f=l.redSqr(),c=f.redSqr(),d=h.redAdd(h).redIAdd(h).redIAdd(n.redMul(u)),p=o.redMul(f),v=d.redSqr().redISub(p.redAdd(p)),y=p.redISub(v),m=(m=d.redMul(y)).redIAdd(m).redISub(c),g=l.redMul(a);r+1<e&&(u=u.redMul(c)),o=v,a=g,l=m}return this.curve.jpoint(o,l.redMul(i),a)},l.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},l.prototype._zeroDbl=function(){var e,t,r,n,i,o,s,a,u,l,h,f,c,d,p,v,y=this.zOne?(r=this.x.redSqr(),i=(n=this.y.redSqr()).redSqr(),o=(o=this.x.redAdd(n).redSqr().redISub(r).redISub(i)).redIAdd(o),a=(s=r.redAdd(r).redIAdd(r)).redSqr().redISub(o).redISub(o),u=(u=(u=i.redIAdd(i)).redIAdd(u)).redIAdd(u),e=a,t=s.redMul(o.redISub(a)).redISub(u),this.y.redAdd(this.y)):(l=this.x.redSqr(),f=(h=this.y.redSqr()).redSqr(),c=(c=this.x.redAdd(h).redSqr().redISub(l).redISub(f)).redIAdd(c),p=(d=l.redAdd(l).redIAdd(l)).redSqr(),v=(v=(v=f.redIAdd(f)).redIAdd(v)).redIAdd(v),e=p.redISub(c).redISub(c),t=d.redMul(c.redISub(e)).redISub(v),(y=this.y.redMul(this.z)).redIAdd(y));return this.curve.jpoint(e,t,y)},l.prototype._threeDbl=function(){var e,t,r,n,i,o,s,a,u,l,h,f,c,d,p,v,y;return this.zOne?(r=this.x.redSqr(),i=(n=this.y.redSqr()).redSqr(),o=(o=this.x.redAdd(n).redSqr().redISub(r).redISub(i)).redIAdd(o),u=a=(s=r.redAdd(r).redIAdd(r).redIAdd(this.curve.a)).redSqr().redISub(o).redISub(o),l=(l=(l=i.redIAdd(i)).redIAdd(l)).redIAdd(l),e=s.redMul(o.redISub(a)).redISub(l),t=this.y.redAdd(this.y)):(h=this.z.redSqr(),f=this.y.redSqr(),c=this.x.redMul(f),d=(d=this.x.redSub(h).redMul(this.x.redAdd(h))).redAdd(d).redIAdd(d),v=(p=(p=c.redIAdd(c)).redIAdd(p)).redAdd(p),u=d.redSqr().redISub(v),t=this.y.redAdd(this.z).redSqr().redISub(f).redISub(h),y=(y=(y=(y=f.redSqr()).redIAdd(y)).redIAdd(y)).redIAdd(y),e=d.redMul(p.redISub(u)).redISub(y)),this.curve.jpoint(u,e,t)},l.prototype._dbl=function(){var e=this.curve.a,t=this.x,r=this.y,n=this.z,i=n.redSqr().redSqr(),o=t.redSqr(),s=r.redSqr(),a=o.redAdd(o).redIAdd(o).redIAdd(e.redMul(i)),u=t.redAdd(t),l=(u=u.redIAdd(u)).redMul(s),h=a.redSqr().redISub(l.redAdd(l)),f=l.redISub(h),c=s.redSqr();c=(c=(c=c.redIAdd(c)).redIAdd(c)).redIAdd(c);var d=a.redMul(f).redISub(c),p=r.redAdd(r).redMul(n);return this.curve.jpoint(h,d,p)},l.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),r=this.z.redSqr(),n=t.redSqr(),i=e.redAdd(e).redIAdd(e),o=i.redSqr(),s=this.x.redAdd(t).redSqr().redISub(e).redISub(n),a=(s=(s=(s=s.redIAdd(s)).redAdd(s).redIAdd(s)).redISub(o)).redSqr(),u=n.redIAdd(n);u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var l=i.redIAdd(s).redSqr().redISub(o).redISub(a).redISub(u),h=t.redMul(l);h=(h=h.redIAdd(h)).redIAdd(h);var f=this.x.redMul(a).redISub(h);f=(f=f.redIAdd(f)).redIAdd(f);var c=this.y.redMul(l.redMul(u.redISub(l)).redISub(s.redMul(a)));c=(c=(c=c.redIAdd(c)).redIAdd(c)).redIAdd(c);var d=this.z.redAdd(s).redSqr().redISub(r).redISub(a);return this.curve.jpoint(f,c,d)},l.prototype.mul=function(e,t){return e=new _(e,t),this.curve._wnafMul(this,e)},l.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),r=e.z.redSqr();if(0!==this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0))return!1;var n=t.redMul(this.z),i=r.redMul(e.z);return 0===this.y.redMul(i).redISub(e.y.redMul(n)).cmpn(0)},l.prototype.eqXToP=function(e){var t=this.z.redSqr(),r=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(r))return!0;for(var n=e.clone(),i=this.curve.redN.redMul(t);;){if(n.iadd(this.curve.n),0<=n.cmp(this.curve.p))return!1;if(r.redIAdd(i),0===this.x.cmp(r))return!0}},l.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},l.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},{"../utils":24,"./base":13,"bn.js":9,inherits:39}],18:[function(e,t,r){"use strict";var n,i=r,o=e("hash.js"),s=e("./curve"),a=e("./utils").assert;function u(e){"short"===e.type?this.curve=new s.short(e):"edwards"===e.type?this.curve=new s.edwards(e):this.curve=new s.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,a(this.g.validate(),"Invalid curve"),a(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function l(t,r){Object.defineProperty(i,t,{configurable:!0,enumerable:!0,get:function(){var e=new u(r);return Object.defineProperty(i,t,{configurable:!0,enumerable:!0,value:e}),e}})}i.PresetCurve=u,l("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:o.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),l("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:o.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),l("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:o.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),l("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:o.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),l("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:o.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),l("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["9"]}),l("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{n=e("./precomputed/secp256k1")}catch(e){n=void 0}l("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:o.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",n]})},{"./curve":15,"./precomputed/secp256k1":23,"./utils":24,"hash.js":26}],19:[function(e,t,r){"use strict";var y=e("bn.js"),m=e("hmac-drbg"),n=e("../utils"),i=e("../curves"),o=e("brorand"),d=n.assert,s=e("./key"),g=e("./signature");function a(e){if(!(this instanceof a))return new a(e);"string"==typeof e&&(d(i.hasOwnProperty(e),"Unknown curve "+e),e=i[e]),e instanceof i.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash}(t.exports=a).prototype.keyPair=function(e){return new s(this,e)},a.prototype.keyFromPrivate=function(e,t){return s.fromPrivate(this,e,t)},a.prototype.keyFromPublic=function(e,t){return s.fromPublic(this,e,t)},a.prototype.genKeyPair=function(e){e=e||{};for(var t=new m({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||o(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),r=this.n.byteLength(),n=this.n.sub(new y(2));;){var i=new y(t.generate(r));if(!(0<i.cmp(n)))return i.iaddn(1),this.keyFromPrivate(i)}},a.prototype._truncateToN=function(e,t){var r=8*e.byteLength()-this.n.bitLength();return 0<r&&(e=e.ushrn(r)),!t&&0<=e.cmp(this.n)?e.sub(this.n):e},a.prototype.sign=function(e,t,r,n){"object"==typeof r&&(n=r,r=null),n=n||{},t=this.keyFromPrivate(t,r),e=this._truncateToN(new y(e,16));for(var i=this.n.byteLength(),o=t.getPrivate().toArray("be",i),s=e.toArray("be",i),a=new m({hash:this.hash,entropy:o,nonce:s,pers:n.pers,persEnc:n.persEnc||"utf8"}),u=this.n.sub(new y(1)),l=0;;l++){var h=n.k?n.k(l):new y(a.generate(this.n.byteLength()));if(!((h=this._truncateToN(h,!0)).cmpn(1)<=0||0<=h.cmp(u))){var f=this.g.mul(h);if(!f.isInfinity()){var c=f.getX(),d=c.umod(this.n);if(0!==d.cmpn(0)){var p=h.invm(this.n).mul(d.mul(t.getPrivate()).iadd(e));if(0!==(p=p.umod(this.n)).cmpn(0)){var v=(f.getY().isOdd()?1:0)|(0!==c.cmp(d)?2:0);return n.canonical&&0<p.cmp(this.nh)&&(p=this.n.sub(p),v^=1),new g({r:d,s:p,recoveryParam:v})}}}}}},a.prototype.verify=function(e,t,r,n){e=this._truncateToN(new y(e,16)),r=this.keyFromPublic(r,n);var i=(t=new g(t,"hex")).r,o=t.s;if(i.cmpn(1)<0||0<=i.cmp(this.n))return!1;if(o.cmpn(1)<0||0<=o.cmp(this.n))return!1;var s,a=o.invm(this.n),u=a.mul(e).umod(this.n),l=a.mul(i).umod(this.n);return this.curve._maxwellTrick?!(s=this.g.jmulAdd(u,r.getPublic(),l)).isInfinity()&&s.eqXToP(i):!(s=this.g.mulAdd(u,r.getPublic(),l)).isInfinity()&&0===s.getX().umod(this.n).cmp(i)},a.prototype.recoverPubKey=function(e,t,r,n){d((3&r)===r,"The recovery param is more than two bits"),t=new g(t,n);var i=this.n,o=new y(e),s=t.r,a=t.s,u=1&r,l=r>>1;if(0<=s.cmp(this.curve.p.umod(this.curve.n))&&l)throw new Error("Unable to find sencond key candinate");s=l?this.curve.pointFromX(s.add(this.curve.n),u):this.curve.pointFromX(s,u);var h=t.r.invm(i),f=i.sub(o).mul(h).umod(i),c=a.mul(h).umod(i);return this.g.mulAdd(f,s,c)},a.prototype.getKeyRecoveryParam=function(e,t,r,n){if(null!==(t=new g(t,n)).recoveryParam)return t.recoveryParam;for(var i,o=0;o<4;o++){try{i=this.recoverPubKey(e,t,o)}catch(e){continue}if(i.eq(r))return o}throw new Error("Unable to find valid recovery factor")}},{"../curves":18,"../utils":24,"./key":20,"./signature":21,"bn.js":9,brorand:10,"hmac-drbg":38}],20:[function(e,t,r){"use strict";var n=e("bn.js"),i=e("../utils").assert;function o(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}(t.exports=o).fromPublic=function(e,t,r){return t instanceof o?t:new o(e,{pub:t,pubEnc:r})},o.fromPrivate=function(e,t,r){return t instanceof o?t:new o(e,{priv:t,privEnc:r})},o.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},o.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},o.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},o.prototype._importPrivate=function(e,t){this.priv=new n(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},o.prototype._importPublic=function(e,t){if(e.x||e.y)return"mont"===this.ec.curve.type?i(e.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||i(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y));this.pub=this.ec.curve.decodePoint(e,t)},o.prototype.derive=function(e){return e.mul(this.priv).getX()},o.prototype.sign=function(e,t,r){return this.ec.sign(e,this,t,r)},o.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},o.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},{"../utils":24,"bn.js":9}],21:[function(e,t,r){"use strict";var u=e("bn.js"),l=e("../utils"),n=l.assert;function i(e,t){if(e instanceof i)return e;this._importDER(e,t)||(n(e.r&&e.s,"Signature without r or s"),this.r=new u(e.r,16),this.s=new u(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam)}function h(){this.place=0}function f(e,t){var r=e[t.place++];if(!(128&r))return r;var n=15&r;if(0==n||4<n)return!1;for(var i=0,o=0,s=t.place;o<n;o++,s++)i<<=8,i|=e[s],i>>>=0;return!(i<=127)&&(t.place=s,i)}function s(e){for(var t=0,r=e.length-1;!e[t]&&!(128&e[t+1])&&t<r;)t++;return 0===t?e:e.slice(t)}function a(e,t){if(t<128)e.push(t);else{var r=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|r);--r;)e.push(t>>>(r<<3)&255);e.push(t)}}(t.exports=i).prototype._importDER=function(e,t){e=l.toArray(e,t);var r=new h;if(48!==e[r.place++])return!1;var n=f(e,r);if(!1===n)return!1;if(n+r.place!==e.length)return!1;if(2!==e[r.place++])return!1;var i=f(e,r);if(!1===i)return!1;var o=e.slice(r.place,i+r.place);if(r.place+=i,2!==e[r.place++])return!1;var s=f(e,r);if(!1===s)return!1;if(e.length!==s+r.place)return!1;var a=e.slice(r.place,s+r.place);if(0===o[0]){if(!(128&o[1]))return!1;o=o.slice(1)}if(0===a[0]){if(!(128&a[1]))return!1;a=a.slice(1)}return this.r=new u(o),this.s=new u(a),!(this.recoveryParam=null)},i.prototype.toDER=function(e){var t=this.r.toArray(),r=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&r[0]&&(r=[0].concat(r)),t=s(t),r=s(r);!(r[0]||128&r[1]);)r=r.slice(1);var n=[2];a(n,t.length),(n=n.concat(t)).push(2),a(n,r.length);var i=n.concat(r),o=[48];return a(o,i.length),o=o.concat(i),l.encode(o,e)}},{"../utils":24,"bn.js":9}],22:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],23:[function(e,t,r){t.exports=void 0},{}],24:[function(e,t,r){"use strict";var n=r,i=e("bn.js"),o=e("minimalistic-assert"),s=e("minimalistic-crypto-utils");n.assert=o,n.toArray=s.toArray,n.zero2=s.zero2,n.toHex=s.toHex,n.encode=s.encode,n.getNAF=function(e,t,r){var n=new Array(Math.max(e.bitLength(),r)+1);n.fill(0);for(var i=1<<t+1,o=e.clone(),s=0;s<n.length;s++){var a,u=o.andln(i-1);o.isOdd()?(a=(i>>1)-1<u?(i>>1)-u:u,o.isubn(a)):a=0,n[s]=a,o.iushrn(1)}return n},n.getJSF=function(e,t){var r=[[],[]];e=e.clone(),t=t.clone();for(var n=0,i=0;0<e.cmpn(-n)||0<t.cmpn(-i);){var o,s,a,u=e.andln(3)+n&3,l=t.andln(3)+i&3;3===u&&(u=-1),3===l&&(l=-1),o=0==(1&u)?0:3!==(s=e.andln(7)+n&7)&&5!==s||2!==l?u:-u,r[0].push(o),a=0==(1&l)?0:3!==(s=t.andln(7)+i&7)&&5!==s||2!==u?l:-l,r[1].push(a),2*n===o+1&&(n=1-n),2*i===a+1&&(i=1-i),e.iushrn(1),t.iushrn(1)}return r},n.cachedProperty=function(e,t,r){var n="_"+t;e.prototype[t]=function(){return void 0!==this[n]?this[n]:this[n]=r.call(this)}},n.parseBytes=function(e){return"string"==typeof e?n.toArray(e,"hex"):e},n.intFromLE=function(e){return new i(e,"hex","le")}},{"bn.js":9,"minimalistic-assert":41,"minimalistic-crypto-utils":42}],25:[function(e,t,r){t.exports={version:"6.5.3"}},{}],26:[function(e,t,r){var n=r;n.utils=e("./hash/utils"),n.common=e("./hash/common"),n.sha=e("./hash/sha"),n.ripemd=e("./hash/ripemd"),n.hmac=e("./hash/hmac"),n.sha1=n.sha.sha1,n.sha256=n.sha.sha256,n.sha224=n.sha.sha224,n.sha384=n.sha.sha384,n.sha512=n.sha.sha512,n.ripemd160=n.ripemd.ripemd160},{"./hash/common":27,"./hash/hmac":28,"./hash/ripemd":29,"./hash/sha":30,"./hash/utils":37}],27:[function(e,t,r){"use strict";var i=e("./utils"),n=e("minimalistic-assert");function o(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}(r.BlockHash=o).prototype.update=function(e,t){if(e=i.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){var r=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-r,e.length),0===this.pending.length&&(this.pending=null),e=i.join32(e,0,e.length-r,this.endian);for(var n=0;n<e.length;n+=this._delta32)this._update(e,n,n+this._delta32)}return this},o.prototype.digest=function(e){return this.update(this._pad()),n(null===this.pending),this._digest(e)},o.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,r=t-(e+this.padLength)%t,n=new Array(r+this.padLength);n[0]=128;for(var i=1;i<r;i++)n[i]=0;if(e<<=3,"big"===this.endian){for(var o=8;o<this.padLength;o++)n[i++]=0;n[i++]=0,n[i++]=0,n[i++]=0,n[i++]=0,n[i++]=e>>>24&255,n[i++]=e>>>16&255,n[i++]=e>>>8&255,n[i++]=255&e}else for(n[i++]=255&e,n[i++]=e>>>8&255,n[i++]=e>>>16&255,n[i++]=e>>>24&255,n[i++]=0,n[i++]=0,n[i++]=0,n[i++]=0,o=8;o<this.padLength;o++)n[i++]=0;return n}},{"./utils":37,"minimalistic-assert":41}],28:[function(e,t,r){"use strict";var n=e("./utils"),i=e("minimalistic-assert");function o(e,t,r){if(!(this instanceof o))return new o(e,t,r);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(n.toArray(t,r))}(t.exports=o).prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),i(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},o.prototype.update=function(e,t){return this.inner.update(e,t),this},o.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},{"./utils":37,"minimalistic-assert":41}],29:[function(e,t,r){"use strict";var n=e("./utils"),i=e("./common"),y=n.rotl32,m=n.sum32,g=n.sum32_3,b=n.sum32_4,o=i.BlockHash;function s(){if(!(this instanceof s))return new s;o.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function w(e,t,r,n){return e<=15?t^r^n:e<=31?t&r|~t&n:e<=47?(t|~r)^n:e<=63?t&n|r&~n:t^(r|~n)}n.inherits(s,o),(r.ripemd160=s).blockSize=512,s.outSize=160,s.hmacStrength=192,s.padLength=64,s.prototype._update=function(e,t){for(var r,n,i=f=this.h[0],o=v=this.h[1],s=p=this.h[2],a=d=this.h[3],u=c=this.h[4],l=0;l<80;l++)var h=m(y(b(f,w(l,v,p,d),e[_[l]+t],(n=l)<=15?0:n<=31?1518500249:n<=47?1859775393:n<=63?2400959708:2840853838),A[l]),c),f=c,c=d,d=y(p,10),p=v,v=h,h=m(y(b(i,w(79-l,o,s,a),e[M[l]+t],(r=l)<=15?1352829926:r<=31?1548603684:r<=47?1836072691:r<=63?2053994217:0),E[l]),u),i=u,u=a,a=y(s,10),s=o,o=h;h=g(this.h[1],p,a),this.h[1]=g(this.h[2],d,u),this.h[2]=g(this.h[3],c,i),this.h[3]=g(this.h[4],f,o),this.h[4]=g(this.h[0],v,s),this.h[0]=h},s.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"little"):n.split32(this.h,"little")};var _=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],M=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],A=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],E=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},{"./common":27,"./utils":37}],30:[function(e,t,r){"use strict";r.sha1=e("./sha/1"),r.sha224=e("./sha/224"),r.sha256=e("./sha/256"),r.sha384=e("./sha/384"),r.sha512=e("./sha/512")},{"./sha/1":31,"./sha/224":32,"./sha/256":33,"./sha/384":34,"./sha/512":35}],31:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],32:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],33:[function(e,t,r){"use strict";var n=e("../utils"),i=e("../common"),o=e("./common"),p=e("minimalistic-assert"),v=n.sum32,y=n.sum32_4,m=n.sum32_5,g=o.ch32,b=o.maj32,w=o.s0_256,_=o.s1_256,M=o.g0_256,A=o.g1_256,s=i.BlockHash,a=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function u(){if(!(this instanceof u))return new u;s.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=a,this.W=new Array(64)}n.inherits(u,s),(t.exports=u).blockSize=512,u.outSize=256,u.hmacStrength=192,u.padLength=64,u.prototype._update=function(e,t){for(var r=this.W,n=0;n<16;n++)r[n]=e[t+n];for(;n<r.length;n++)r[n]=y(A(r[n-2]),r[n-7],M(r[n-15]),r[n-16]);var i=this.h[0],o=this.h[1],s=this.h[2],a=this.h[3],u=this.h[4],l=this.h[5],h=this.h[6],f=this.h[7];for(p(this.k.length===r.length),n=0;n<r.length;n++)var c=m(f,_(u),g(u,l,h),this.k[n],r[n]),d=v(w(i),b(i,o,s)),f=h,h=l,l=u,u=v(a,c),a=s,s=o,o=i,i=v(c,d);this.h[0]=v(this.h[0],i),this.h[1]=v(this.h[1],o),this.h[2]=v(this.h[2],s),this.h[3]=v(this.h[3],a),this.h[4]=v(this.h[4],u),this.h[5]=v(this.h[5],l),this.h[6]=v(this.h[6],h),this.h[7]=v(this.h[7],f)},u.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"big"):n.split32(this.h,"big")}},{"../common":27,"../utils":37,"./common":36,"minimalistic-assert":41}],34:[function(e,t,r){arguments[4][14][0].apply(r,arguments)},{dup:14}],35:[function(e,t,r){"use strict";var n=e("../utils"),i=e("../common"),C=e("minimalistic-assert"),L=n.rotr64_hi,B=n.rotr64_lo,c=n.shr64_hi,d=n.shr64_lo,D=n.sum64,U=n.sum64_hi,F=n.sum64_lo,p=n.sum64_4_hi,v=n.sum64_4_lo,j=n.sum64_5_hi,G=n.sum64_5_lo,o=i.BlockHash,s=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function a(){if(!(this instanceof a))return new a;o.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=s,this.W=new Array(160)}n.inherits(a,o),(t.exports=a).blockSize=1024,a.outSize=512,a.hmacStrength=192,a.padLength=128,a.prototype._prepareBlock=function(e,t){for(var r=this.W,n=0;n<32;n++)r[n]=e[t+n];for(;n<r.length;n+=2){var i=function(e,t){var r=L(e,t,19),n=L(t,e,29),i=c(e,t,6),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-4],r[n-3]),o=function(e,t){var r=B(e,t,19),n=B(t,e,29),i=d(e,t,6),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-4],r[n-3]),s=r[n-14],a=r[n-13],u=function(e,t){var r=L(e,t,1),n=L(e,t,8),i=c(e,t,7),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-30],r[n-29]),l=function(e,t){var r=B(e,t,1),n=B(e,t,8),i=d(e,t,7),o=r^n^i;o<0&&(o+=4294967296);return o}(r[n-30],r[n-29]),h=r[n-32],f=r[n-31];r[n]=p(i,o,s,a,u,l,h,f),r[n+1]=v(i,o,s,a,u,l,h,f)}},a.prototype._update=function(e,t){this._prepareBlock(e,t);var r=this.W,n=this.h[0],i=this.h[1],o=this.h[2],s=this.h[3],a=this.h[4],u=this.h[5],l=this.h[6],h=this.h[7],f=this.h[8],c=this.h[9],d=this.h[10],p=this.h[11],v=this.h[12],y=this.h[13],m=this.h[14],g=this.h[15];C(this.k.length===r.length);for(var b=0;b<r.length;b+=2)var w=m,_=g,M=function(e,t){var r=L(e,t,14),n=L(e,t,18),i=L(t,e,9),o=r^n^i;o<0&&(o+=4294967296);return o}(f,c),A=function(e,t){var r=B(e,t,14),n=B(e,t,18),i=B(t,e,9),o=r^n^i;o<0&&(o+=4294967296);return o}(f,c),E=function(e,t,r){var n=e&t^~e&r;n<0&&(n+=4294967296);return n}(f,d,v),S=function(e,t,r){var n=e&t^~e&r;n<0&&(n+=4294967296);return n}(c,p,y),k=this.k[b],N=this.k[b+1],x=r[b],P=r[b+1],I=j(w,_,M,A,E,S,k,N,x,P),T=G(w,_,M,A,E,S,k,N,x,P),w=function(e,t){var r=L(e,t,28),n=L(t,e,2),i=L(t,e,7),o=r^n^i;o<0&&(o+=4294967296);return o}(n,i),_=function(e,t){var r=B(e,t,28),n=B(t,e,2),i=B(t,e,7),o=r^n^i;o<0&&(o+=4294967296);return o}(n,i),M=function(e,t,r){var n=e&t^e&r^t&r;n<0&&(n+=4294967296);return n}(n,o,a),A=function(e,t,r){var n=e&t^e&r^t&r;n<0&&(n+=4294967296);return n}(i,s,u),R=U(w,_,M,A),O=F(w,_,M,A),m=v,g=y,v=d,y=p,d=f,p=c,f=U(l,h,I,T),c=F(h,h,I,T),l=a,h=u,a=o,u=s,o=n,s=i,n=U(I,T,R,O),i=F(I,T,R,O);D(this.h,0,n,i),D(this.h,2,o,s),D(this.h,4,a,u),D(this.h,6,l,h),D(this.h,8,f,c),D(this.h,10,d,p),D(this.h,12,v,y),D(this.h,14,m,g)},a.prototype._digest=function(e){return"hex"===e?n.toHex32(this.h,"big"):n.split32(this.h,"big")}},{"../common":27,"../utils":37,"minimalistic-assert":41}],36:[function(e,t,r){"use strict";var n=e("../utils").rotr32;function i(e,t,r){return e&t^~e&r}function o(e,t,r){return e&t^e&r^t&r}function s(e,t,r){return e^t^r}r.ft_1=function(e,t,r,n){return 0===e?i(t,r,n):1===e||3===e?t^r^n:2===e?o(t,r,n):void 0},r.ch32=i,r.maj32=o,r.p32=s,r.s0_256=function(e){return n(e,2)^n(e,13)^n(e,22)},r.s1_256=function(e){return n(e,6)^n(e,11)^n(e,25)},r.g0_256=function(e){return n(e,7)^n(e,18)^e>>>3},r.g1_256=function(e){return n(e,17)^n(e,19)^e>>>10}},{"../utils":37}],37:[function(e,t,r){"use strict";var l=e("minimalistic-assert"),n=e("inherits");function o(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function i(e){return 1===e.length?"0"+e:e}function s(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}r.inherits=n,r.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),n=0;n<e.length;n+=2)r.push(parseInt(e[n]+e[n+1],16))}else for(var n=0;n<e.length;n++){var i=e.charCodeAt(n),o=i>>8,s=255&i;o?r.push(o,s):r.push(s)}else for(n=0;n<e.length;n++)r[n]=0|e[n];return r},r.toHex=function(e){for(var t="",r=0;r<e.length;r++)t+=i(e[r].toString(16));return t},r.htonl=o,r.toHex32=function(e,t){for(var r="",n=0;n<e.length;n++){var i=e[n];"little"===t&&(i=o(i)),r+=s(i.toString(16))}return r},r.zero2=i,r.zero8=s,r.join32=function(e,t,r,n){var i=r-t;l(i%4==0);for(var o=new Array(i/4),s=0,a=t;s<o.length;s++,a+=4){var u="big"===n?e[a]<<24|e[a+1]<<16|e[a+2]<<8|e[a+3]:e[a+3]<<24|e[a+2]<<16|e[a+1]<<8|e[a];o[s]=u>>>0}return o},r.split32=function(e,t){for(var r=new Array(4*e.length),n=0,i=0;n<e.length;n++,i+=4){var o=e[n];"big"===t?(r[i]=o>>>24,r[i+1]=o>>>16&255,r[i+2]=o>>>8&255,r[i+3]=255&o):(r[i+3]=o>>>24,r[i+2]=o>>>16&255,r[i+1]=o>>>8&255,r[i]=255&o)}return r},r.rotr32=function(e,t){return e>>>t|e<<32-t},r.rotl32=function(e,t){return e<<t|e>>>32-t},r.sum32=function(e,t){return e+t>>>0},r.sum32_3=function(e,t,r){return e+t+r>>>0},r.sum32_4=function(e,t,r,n){return e+t+r+n>>>0},r.sum32_5=function(e,t,r,n,i){return e+t+r+n+i>>>0},r.sum64=function(e,t,r,n){var i=e[t],o=n+e[t+1]>>>0,s=(o<n?1:0)+r+i;e[t]=s>>>0,e[t+1]=o},r.sum64_hi=function(e,t,r,n){return(t+n>>>0<t?1:0)+e+r>>>0},r.sum64_lo=function(e,t,r,n){return t+n>>>0},r.sum64_4_hi=function(e,t,r,n,i,o,s,a){var u=0,l=t;return u+=(l=l+n>>>0)<t?1:0,u+=(l=l+o>>>0)<o?1:0,e+r+i+s+(u+=(l=l+a>>>0)<a?1:0)>>>0},r.sum64_4_lo=function(e,t,r,n,i,o,s,a){return t+n+o+a>>>0},r.sum64_5_hi=function(e,t,r,n,i,o,s,a,u,l){var h=0,f=t;return h+=(f=f+n>>>0)<t?1:0,h+=(f=f+o>>>0)<o?1:0,h+=(f=f+a>>>0)<a?1:0,e+r+i+s+u+(h+=(f=f+l>>>0)<l?1:0)>>>0},r.sum64_5_lo=function(e,t,r,n,i,o,s,a,u,l){return t+n+o+a+l>>>0},r.rotr64_hi=function(e,t,r){return(t<<32-r|e>>>r)>>>0},r.rotr64_lo=function(e,t,r){return(e<<32-r|t>>>r)>>>0},r.shr64_hi=function(e,t,r){return e>>>r},r.shr64_lo=function(e,t,r){return(e<<32-r|t>>>r)>>>0}},{inherits:39,"minimalistic-assert":41}],38:[function(e,t,r){"use strict";var n=e("hash.js"),s=e("minimalistic-crypto-utils"),i=e("minimalistic-assert");function o(e){if(!(this instanceof o))return new o(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=s.toArray(e.entropy,e.entropyEnc||"hex"),r=s.toArray(e.nonce,e.nonceEnc||"hex"),n=s.toArray(e.pers,e.persEnc||"hex");i(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,r,n)}(t.exports=o).prototype._init=function(e,t,r){var n=e.concat(t).concat(r);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var i=0;i<this.V.length;i++)this.K[i]=0,this.V[i]=1;this._update(n),this._reseed=1,this.reseedInterval=281474976710656},o.prototype._hmac=function(){return new n.hmac(this.hash,this.K)},o.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest())},o.prototype.reseed=function(e,t,r,n){"string"!=typeof t&&(n=r,r=t,t=null),e=s.toArray(e,t),r=s.toArray(r,n),i(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(r||[])),this._reseed=1},o.prototype.generate=function(e,t,r,n){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(n=r,r=t,t=null),r&&(r=s.toArray(r,n||"hex"),this._update(r));for(var i=[];i.length<e;)this.V=this._hmac().update(this.V).digest(),i=i.concat(this.V);var o=i.slice(0,e);return this._update(r),this._reseed++,s.encode(o,t)}},{"hash.js":26,"minimalistic-assert":41,"minimalistic-crypto-utils":42}],39:[function(e,t,r){"function"==typeof Object.create?t.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(e,t){var r;t&&(e.super_=t,(r=function(){}).prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e)}},{}],40:[function(e,_,t){(function(b,w){!function(){"use strict";var e="object"==typeof window?window:{};!e.JS_SHA3_NO_NODE_JS&&"object"==typeof b&&b.versions&&b.versions.node&&(e=w);for(var t=!e.JS_SHA3_NO_COMMON_JS&&"object"==typeof _&&_.exports,u="0123456789abcdef".split(""),h=[0,8,16,24],he=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],r=[224,256,384,512],o=["hex","buffer","arrayBuffer","array"],s=function(t,r,n){return function(e){return new m(t,r,t).update(e)[n]()}},a=function(r,n,i){return function(e,t){return new m(r,n,t).update(e)[i]()}},n=function(e,t){var r=s(e,t,"hex");r.create=function(){return new m(e,t,e)},r.update=function(e){return r.create().update(e)};for(var n=0;n<o.length;++n){var i=o[n];r[i]=s(e,t,i)}return r},i=[{name:"keccak",padding:[1,256,65536,16777216],bits:r,createMethod:n},{name:"sha3",padding:[6,1536,393216,100663296],bits:r,createMethod:n},{name:"shake",padding:[31,7936,2031616,520093696],bits:[128,256],createMethod:function(t,r){var n=a(t,r,"hex");n.create=function(e){return new m(t,r,e)},n.update=function(e,t){return n.create(t).update(e)};for(var e=0;e<o.length;++e){var i=o[e];n[i]=a(t,r,i)}return n}}],l={},f=[],c=0;c<i.length;++c)for(var d=i[c],p=d.bits,v=0;v<p.length;++v){var y=d.name+"_"+p[v];f.push(y),l[y]=d.createMethod(p[v],d.padding)}function m(e,t,r){this.blocks=[],this.s=[],this.padding=t,this.outputBits=r,this.reset=!0,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=r>>5,this.extraBytes=(31&r)>>3;for(var n=0;n<50;++n)this.s[n]=0}m.prototype.update=function(e){var t="string"!=typeof e;t&&e.constructor===ArrayBuffer&&(e=new Uint8Array(e));for(var r,n,i=e.length,o=this.blocks,s=this.byteCount,a=this.blockCount,u=0,l=this.s;u<i;){if(this.reset)for(this.reset=!1,o[0]=this.block,r=1;r<a+1;++r)o[r]=0;if(t)for(r=this.start;u<i&&r<s;++u)o[r>>2]|=e[u]<<h[3&r++];else for(r=this.start;u<i&&r<s;++u)(n=e.charCodeAt(u))<128?o[r>>2]|=n<<h[3&r++]:(n<2048?o[r>>2]|=(192|n>>6)<<h[3&r++]:(n<55296||57344<=n?o[r>>2]|=(224|n>>12)<<h[3&r++]:(n=65536+((1023&n)<<10|1023&e.charCodeAt(++u)),o[r>>2]|=(240|n>>18)<<h[3&r++],o[r>>2]|=(128|n>>12&63)<<h[3&r++]),o[r>>2]|=(128|n>>6&63)<<h[3&r++]),o[r>>2]|=(128|63&n)<<h[3&r++]);if(s<=(this.lastByteIndex=r)){for(this.start=r-s,this.block=o[a],r=0;r<a;++r)l[r]^=o[r];g(l),this.reset=!0}else this.start=r}return this},m.prototype.finalize=function(){var e=this.blocks,t=this.lastByteIndex,r=this.blockCount,n=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[r],t=1;t<r+1;++t)e[t]=0;for(e[r-1]|=2147483648,t=0;t<r;++t)n[t]^=e[t];g(n)},m.prototype.toString=m.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,r=this.s,n=this.outputBlocks,i=this.extraBytes,o=0,s=0,a="";s<n;){for(o=0;o<t&&s<n;++o,++s)e=r[o],a+=u[e>>4&15]+u[15&e]+u[e>>12&15]+u[e>>8&15]+u[e>>20&15]+u[e>>16&15]+u[e>>28&15]+u[e>>24&15];s%t==0&&(g(r),o=0)}return i&&(e=r[o],0<i&&(a+=u[e>>4&15]+u[15&e]),1<i&&(a+=u[e>>12&15]+u[e>>8&15]),2<i&&(a+=u[e>>20&15]+u[e>>16&15])),a},m.prototype.buffer=m.prototype.arrayBuffer=function(){this.finalize();for(var e=this.blockCount,t=this.s,r=this.outputBlocks,n=this.extraBytes,i=0,o=0,s=this.outputBits>>3,a=n?new ArrayBuffer(r+1<<2):new ArrayBuffer(s),u=new Uint32Array(a);o<r;){for(i=0;i<e&&o<r;++i,++o)u[o]=t[i];o%e==0&&g(t)}return n&&(u[i]=t[i],a=a.slice(0,s)),a},m.prototype.digest=m.prototype.array=function(){this.finalize();for(var e,t,r=this.blockCount,n=this.s,i=this.outputBlocks,o=this.extraBytes,s=0,a=0,u=[];a<i;){for(s=0;s<r&&a<i;++s,++a)e=a<<2,t=n[s],u[e]=255&t,u[e+1]=t>>8&255,u[e+2]=t>>16&255,u[e+3]=t>>24&255;a%r==0&&g(n)}return o&&(e=a<<2,t=n[s],0<o&&(u[e]=255&t),1<o&&(u[e+1]=t>>8&255),2<o&&(u[e+2]=t>>16&255)),u};var g=function(e){for(var t,r,n,i,o,s,a,u,l,h,f,c,d,p,v,y,m,g,b,w,_,M,A,E,S,k,N,x,P,I,T,R,O,C,L,B,D,U,F,j,G,H,z,V,K,q,W,Z,J,X,$,Q,Y,ee,te,re,ne,ie,oe,se,ae,ue,le=0;le<48;le+=2)n=e[0]^e[10]^e[20]^e[30]^e[40],i=e[1]^e[11]^e[21]^e[31]^e[41],o=e[2]^e[12]^e[22]^e[32]^e[42],s=e[3]^e[13]^e[23]^e[33]^e[43],a=e[4]^e[14]^e[24]^e[34]^e[44],u=e[5]^e[15]^e[25]^e[35]^e[45],l=e[6]^e[16]^e[26]^e[36]^e[46],h=e[7]^e[17]^e[27]^e[37]^e[47],t=(f=e[8]^e[18]^e[28]^e[38]^e[48])^(o<<1|s>>>31),r=(c=e[9]^e[19]^e[29]^e[39]^e[49])^(s<<1|o>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=n^(a<<1|u>>>31),r=i^(u<<1|a>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=o^(l<<1|h>>>31),r=s^(h<<1|l>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=a^(f<<1|c>>>31),r=u^(c<<1|f>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=l^(n<<1|i>>>31),r=h^(i<<1|n>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,d=e[0],p=e[1],K=e[11]<<4|e[10]>>>28,q=e[10]<<4|e[11]>>>28,N=e[20]<<3|e[21]>>>29,x=e[21]<<3|e[20]>>>29,oe=e[31]<<9|e[30]>>>23,se=e[30]<<9|e[31]>>>23,G=e[40]<<18|e[41]>>>14,H=e[41]<<18|e[40]>>>14,O=e[2]<<1|e[3]>>>31,C=e[3]<<1|e[2]>>>31,v=e[13]<<12|e[12]>>>20,y=e[12]<<12|e[13]>>>20,W=e[22]<<10|e[23]>>>22,Z=e[23]<<10|e[22]>>>22,P=e[33]<<13|e[32]>>>19,I=e[32]<<13|e[33]>>>19,ae=e[42]<<2|e[43]>>>30,ue=e[43]<<2|e[42]>>>30,Y=e[5]<<30|e[4]>>>2,ee=e[4]<<30|e[5]>>>2,L=e[14]<<6|e[15]>>>26,B=e[15]<<6|e[14]>>>26,m=e[25]<<11|e[24]>>>21,g=e[24]<<11|e[25]>>>21,J=e[34]<<15|e[35]>>>17,X=e[35]<<15|e[34]>>>17,T=e[45]<<29|e[44]>>>3,R=e[44]<<29|e[45]>>>3,A=e[6]<<28|e[7]>>>4,E=e[7]<<28|e[6]>>>4,te=e[17]<<23|e[16]>>>9,re=e[16]<<23|e[17]>>>9,D=e[26]<<25|e[27]>>>7,U=e[27]<<25|e[26]>>>7,b=e[36]<<21|e[37]>>>11,w=e[37]<<21|e[36]>>>11,$=e[47]<<24|e[46]>>>8,Q=e[46]<<24|e[47]>>>8,z=e[8]<<27|e[9]>>>5,V=e[9]<<27|e[8]>>>5,S=e[18]<<20|e[19]>>>12,k=e[19]<<20|e[18]>>>12,ne=e[29]<<7|e[28]>>>25,ie=e[28]<<7|e[29]>>>25,F=e[38]<<8|e[39]>>>24,j=e[39]<<8|e[38]>>>24,_=e[48]<<14|e[49]>>>18,M=e[49]<<14|e[48]>>>18,e[0]=d^~v&m,e[1]=p^~y&g,e[10]=A^~S&N,e[11]=E^~k&x,e[20]=O^~L&D,e[21]=C^~B&U,e[30]=z^~K&W,e[31]=V^~q&Z,e[40]=Y^~te&ne,e[41]=ee^~re&ie,e[2]=v^~m&b,e[3]=y^~g&w,e[12]=S^~N&P,e[13]=k^~x&I,e[22]=L^~D&F,e[23]=B^~U&j,e[32]=K^~W&J,e[33]=q^~Z&X,e[42]=te^~ne&oe,e[43]=re^~ie&se,e[4]=m^~b&_,e[5]=g^~w&M,e[14]=N^~P&T,e[15]=x^~I&R,e[24]=D^~F&G,e[25]=U^~j&H,e[34]=W^~J&$,e[35]=Z^~X&Q,e[44]=ne^~oe&ae,e[45]=ie^~se&ue,e[6]=b^~_&d,e[7]=w^~M&p,e[16]=P^~T&A,e[17]=I^~R&E,e[26]=F^~G&O,e[27]=j^~H&C,e[36]=J^~$&z,e[37]=X^~Q&V,e[46]=oe^~ae&Y,e[47]=se^~ue&ee,e[8]=_^~d&v,e[9]=M^~p&y,e[18]=T^~A&S,e[19]=R^~E&k,e[28]=G^~O&L,e[29]=H^~C&B,e[38]=$^~z&K,e[39]=Q^~V&q,e[48]=ae^~Y&te,e[49]=ue^~ee&re,e[0]^=he[le],e[1]^=he[le+1]};if(t)_.exports=l;else for(c=0;c<f.length;++c)e[f[c]]=l[f[c]]}()}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{_process:43}],41:[function(e,t,r){function n(e,t){if(!e)throw new Error(t||"Assertion failed")}(t.exports=n).equal=function(e,t,r){if(e!=t)throw new Error(r||"Assertion failed: "+e+" != "+t)}},{}],42:[function(e,t,r){"use strict";var n=r;function i(e){return 1===e.length?"0"+e:e}function o(e){for(var t="",r=0;r<e.length;r++)t+=i(e[r].toString(16));return t}n.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var r=[];if("string"!=typeof e){for(var n=0;n<e.length;n++)r[n]=0|e[n];return r}if("hex"===t){(e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e);for(n=0;n<e.length;n+=2)r.push(parseInt(e[n]+e[n+1],16))}else for(n=0;n<e.length;n++){var i=e.charCodeAt(n),o=i>>8,s=255&i;o?r.push(o,s):r.push(s)}return r},n.zero2=i,n.toHex=o,n.encode=function(e,t){return"hex"===t?o(e):e}},{}],43:[function(e,t,r){t.exports={browser:!0}},{}],44:[function(e,r,o){(function(n){"use strict";function l(e){var y=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],m=1779033703,g=3144134277,b=1013904242,w=2773480762,_=1359893119,M=2600822924,A=528734635,E=1541459225,S=new Array(64);function t(e){for(var t=0,r=e.length;64<=r;){for(var n,i,o,s,a=m,u=g,l=b,h=w,f=_,c=M,d=A,p=E,v=0;v<16;v++)i=t+4*v,S[v]=(255&e[i])<<24|(255&e[i+1])<<16|(255&e[i+2])<<8|255&e[i+3];for(v=16;v<64;v++)o=((n=S[v-2])>>>17|n<<15)^(n>>>19|n<<13)^n>>>10,s=((n=S[v-15])>>>7|n<<25)^(n>>>18|n<<14)^n>>>3,S[v]=(o+S[v-7]|0)+(s+S[v-16]|0)|0;for(v=0;v<64;v++)o=(((f>>>6|f<<26)^(f>>>11|f<<21)^(f>>>25|f<<7))+(f&c^~f&d)|0)+(p+(y[v]+S[v]|0)|0)|0,s=((a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10))+(a&u^a&l^u&l)|0,p=d,d=c,c=f,f=h+o|0,h=l,l=u,u=a,a=o+s|0;m=m+a|0,g=g+u|0,b=b+l|0,w=w+h|0,_=_+f|0,M=M+c|0,A=A+d|0,E=E+p|0,t+=64,r-=64}}t(e);var r,n=e.length%64,i=e.length/536870912|0,o=e.length<<3,s=n<56?56:120,a=e.slice(e.length-n,e.length);for(a.push(128),r=1+n;r<s;r++)a.push(0);return a.push(i>>>24&255),a.push(i>>>16&255),a.push(i>>>8&255),a.push(i>>>0&255),a.push(o>>>24&255),a.push(o>>>16&255),a.push(o>>>8&255),a.push(o>>>0&255),t(a),[m>>>24&255,m>>>16&255,m>>>8&255,m>>>0&255,g>>>24&255,g>>>16&255,g>>>8&255,g>>>0&255,b>>>24&255,b>>>16&255,b>>>8&255,b>>>0&255,w>>>24&255,w>>>16&255,w>>>8&255,w>>>0&255,_>>>24&255,_>>>16&255,_>>>8&255,_>>>0&255,M>>>24&255,M>>>16&255,M>>>8&255,M>>>0&255,A>>>24&255,A>>>16&255,A>>>8&255,A>>>0&255,E>>>24&255,E>>>16&255,E>>>8&255,E>>>0&255]}function P(e,t,r){e=e.length<=64?e:l(e);for(var n=64+t.length+4,i=new Array(n),o=new Array(64),s=[],a=0;a<64;a++)i[a]=54;for(a=0;a<e.length;a++)i[a]^=e[a];for(a=0;a<t.length;a++)i[64+a]=t[a];for(a=n-4;a<n;a++)i[a]=0;for(a=0;a<64;a++)o[a]=92;for(a=0;a<e.length;a++)o[a]^=e[a];function u(){for(var e=n-1;n-4<=e;e--){if(i[e]++,i[e]<=255)return;i[e]=0}}for(;32<=r;)u(),s=s.concat(l(o.concat(l(i)))),r-=32;return 0<r&&(u(),s=s.concat(l(o.concat(l(i))).slice(0,r))),s}function I(e,t,r,n,i){var o;for(R(e,16*(2*r-1),i,0,16),o=0;o<2*r;o++)T(e,16*o,i,16),function(e,t){R(e,0,t,0,16);for(var r=8;0<r;r-=2)t[4]^=s(t[0]+t[12],7),t[8]^=s(t[4]+t[0],9),t[12]^=s(t[8]+t[4],13),t[0]^=s(t[12]+t[8],18),t[9]^=s(t[5]+t[1],7),t[13]^=s(t[9]+t[5],9),t[1]^=s(t[13]+t[9],13),t[5]^=s(t[1]+t[13],18),t[14]^=s(t[10]+t[6],7),t[2]^=s(t[14]+t[10],9),t[6]^=s(t[2]+t[14],13),t[10]^=s(t[6]+t[2],18),t[3]^=s(t[15]+t[11],7),t[7]^=s(t[3]+t[15],9),t[11]^=s(t[7]+t[3],13),t[15]^=s(t[11]+t[7],18),t[1]^=s(t[0]+t[3],7),t[2]^=s(t[1]+t[0],9),t[3]^=s(t[2]+t[1],13),t[0]^=s(t[3]+t[2],18),t[6]^=s(t[5]+t[4],7),t[7]^=s(t[6]+t[5],9),t[4]^=s(t[7]+t[6],13),t[5]^=s(t[4]+t[7],18),t[11]^=s(t[10]+t[9],7),t[8]^=s(t[11]+t[10],9),t[9]^=s(t[8]+t[11],13),t[10]^=s(t[9]+t[8],18),t[12]^=s(t[15]+t[14],7),t[13]^=s(t[12]+t[15],9),t[14]^=s(t[13]+t[12],13),t[15]^=s(t[14]+t[13],18);for(r=0;r<16;++r)e[r]+=t[r]}(i,n),R(i,0,e,t+16*o,16);for(o=0;o<r;o++)R(e,t+2*o*16,e,16*o,16);for(o=0;o<r;o++)R(e,t+16*(2*o+1),e,16*(o+r),16)}function s(e,t){return e<<t|e>>>32-t}function T(e,t,r,n){for(var i=0;i<n;i++)r[i]^=e[t+i]}function R(e,t,r,n,i){for(;i--;)r[n++]=e[t++]}function i(e){if(e&&"number"==typeof e.length){for(var t=0;t<e.length;t++){if("number"!=typeof e[t])return;var r=parseInt(e[t]);if(r!=e[t]||r<0||256<=r)return}return 1}}function O(e,t){var r=parseInt(e);if(e!=r)throw new Error("invalid "+t);return r}function e(o,e,s,a,u,l,h){if(!h)throw new Error("missing callback");if(s=O(s,"N"),a=O(a,"r"),u=O(u,"p"),l=O(l,"dkLen"),0===s||0!=(s&s-1))throw new Error("N must be power of 2");if(C/128/a<s)throw new Error("N too large");if(C/128/u<a)throw new Error("r too large");if(!i(o))throw new Error("password must be an array or buffer");if(o=Array.prototype.slice.call(o),!i(e))throw new Error("salt must be an array or buffer");e=Array.prototype.slice.call(e);for(var f=P(o,e,128*u*a),c=new Uint32Array(32*u*a),t=0;t<c.length;t++){var r=4*t;c[t]=(255&f[3+r])<<24|(255&f[2+r])<<16|(255&f[1+r])<<8|(255&f[0+r])<<0}var d,p,v=new Uint32Array(64*a),y=new Uint32Array(32*a*s),m=32*a,g=new Uint32Array(16),b=new Uint32Array(16),w=u*s*2,_=0,M=null,A=!1,E=0,S=0,k=parseInt(1e3/a),N=void 0!==n?n:setTimeout,x=function(){if(A)return h(new Error("cancelled"),_/w);switch(E){case 0:R(c,p=32*S*a,v,0,m),E=1,d=0;case 1:k<(t=s-d)&&(t=k);for(var e=0;e<t;e++)R(v,0,y,(d+e)*m,m),I(v,m,a,g,b);if(d+=t,_+=t,(r=parseInt(1e3*_/w))!==M){if(A=h(null,_/w))break;M=r}if(d<s)break;d=0,E=2;case 2:var t;k<(t=s-d)&&(t=k);for(var r,e=0;e<t;e++){var n=v[16*(2*a-1)]&s-1;T(y,n*m,v,m),I(v,m,a,g,b)}if(d+=t,_+=t,(r=parseInt(1e3*_/w))!==M){if(A=h(null,_/w))break;M=r}if(d<s)break;if(R(v,0,c,p,m),++S<u){E=0;break}f=[];for(e=0;e<c.length;e++)f.push(c[e]>>0&255),f.push(c[e]>>8&255),f.push(c[e]>>16&255),f.push(c[e]>>24&255);var i=P(o,f,l);return h(null,1,i)}N(x)};x()}var t,C;t=this,C=2147483647,void 0!==o?r.exports=e:t&&(t.scrypt&&(t._scrypt=t.scrypt),t.scrypt=e)}).call(this,e("timers").setImmediate)},{timers:46}],45:[function(e,t,r){(function(y,e,t){!function(r,n){"use strict";var t,i,o,s,e,a,u,l,h;function f(e){return i[t]=c.apply(n,e),t++}function c(e){var t=[].slice.call(arguments,1);return function(){"function"==typeof e?e.apply(n,t):new Function(""+e)()}}function d(e){if(o)setTimeout(c(d,e),0);else{var t=i[e];if(t){o=!0;try{t()}finally{p(e),o=!1}}}}function p(e){delete i[e]}function v(e){e.source===r&&"string"==typeof e.data&&0===e.data.indexOf(l)&&d(+e.data.slice(l.length))}r.setImmediate||(t=1,o=!(i={}),s=r.document,h=(h=Object.getPrototypeOf&&Object.getPrototypeOf(r))&&h.setTimeout?h:r,e="[object process]"==={}.toString.call(r.process)?function(){var e=f(arguments);return y.nextTick(c(d,e)),e}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1},r.postMessage("","*"),r.onmessage=t,e}}()?(l="setImmediate$"+Math.random()+"$",r.addEventListener?r.addEventListener("message",v,!1):r.attachEvent("onmessage",v),function(){var e=f(arguments);return r.postMessage(l+e,"*"),e}):r.MessageChannel?((u=new MessageChannel).port1.onmessage=function(e){d(e.data)},function(){var e=f(arguments);return u.port2.postMessage(e),e}):s&&"onreadystatechange"in s.createElement("script")?(a=s.documentElement,function(){var e=f(arguments),t=s.createElement("script");return t.onreadystatechange=function(){d(e),t.onreadystatechange=null,a.removeChild(t),t=null},a.appendChild(t),e}):function(){var e=f(arguments);return setTimeout(c(d,e),0),e},h.setImmediate=e,h.clearImmediate=p)}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,e("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("timers").clearImmediate)},{_process:43,timers:46}],46:[function(e,t,r){(function(e){t.exports={setImmediate:e.setImmediate}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],47:[function(e,i,t){(function(e){var t,r,n;e.crypto&&crypto.getRandomValues&&(t=new Uint8Array(16),r=function(){return crypto.getRandomValues(t),t}),r||(n=new Array(16),r=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),n[t]=e>>>((3&t)<<3)&255;return n}),i.exports=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],48:[function(e,t,r){for(var s=e("./rng"),n=[],o={},i=0;i<256;i++)n[i]=(i+256).toString(16).substr(1),o[n[i]]=i;function d(e,t){var r=t||0;return n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+"-"+n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]+n[e[r++]]}var a=s(),p=[1|a[0],a[1],a[2],a[3],a[4],a[5]],v=16383&(a[6]<<8|a[7]),y=0,m=0;function u(e,t,r){var n=t&&r||0;"string"==typeof e&&(t="binary"==e?new Array(16):null,e=null);var i=(e=e||{}).random||(e.rng||s)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t)for(var o=0;o<16;o++)t[n+o]=i[o];return t||d(i)}var l=u;l.v1=function(e,t,r){var n=t&&r||0,i=t||[],o=void 0!==(e=e||{}).clockseq?e.clockseq:v,s=void 0!==e.msecs?e.msecs:(new Date).getTime(),a=void 0!==e.nsecs?e.nsecs:m+1,u=s-y+(a-m)/1e4;if(u<0&&void 0===e.clockseq&&(o=o+1&16383),(u<0||y<s)&&void 0===e.nsecs&&(a=0),1e4<=a)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");y=s,v=o;var l=(1e4*(268435455&(s+=122192928e5))+(m=a))%4294967296;i[n++]=l>>>24&255,i[n++]=l>>>16&255,i[n++]=l>>>8&255,i[n++]=255&l;var h=s/4294967296*1e4&268435455;i[n++]=h>>>8&255,i[n++]=255&h,i[n++]=h>>>24&15|16,i[n++]=h>>>16&255,i[n++]=o>>>8|128,i[n++]=255&o;for(var f=e.node||p,c=0;c<6;c++)i[n+c]=f[c];return t||d(i)},l.v4=u,l.parse=function(e,t,r){var n=t&&r||0,i=0;for(t=t||[],e.toLowerCase().replace(/[0-9a-f]{2}/g,function(e){i<16&&(t[n+i++]=o[e])});i<16;)t[n+i++]=0;return t},l.unparse=d,t.exports=l},{"./rng":47}],49:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});try{t.exports.XMLHttpRequest=XMLHttpRequest}catch(e){console.log("Warning: XMLHttpRequest is not defined"),t.exports.XMLHttpRequest=null}},{}],50:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("../utils/properties"),i=(o.isProvider=function(e){return n.isType(e,"Provider")},o);function o(){n.setType(this,"Provider")}r.Provider=i},{"../utils/properties":74}],51:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("../utils/address"),a=e("../utils/bignumber"),u=e("../utils/bytes"),l=e("../constants"),h=e("../utils/hash"),f=e("../utils/networks"),c=e("../utils/properties"),d=e("../utils/rlp"),p=e("../utils/transaction"),v=e("../utils/utf8"),y=e("../utils/web"),m=o(e("../errors")),g=e("./abstract-provider");function b(e,t){var r={};for(var n in e)try{var i=e[n](t[n]);void 0!==i&&(r[n]=i)}catch(e){throw e.checkKey=n,e.checkValue=t[n],e}return r}function w(t,r){return function(e){return null==e?r:t(e)}}function _(r){return function(e){if(!Array.isArray(e))throw new Error("not an array");var t=[];return e.forEach(function(e){t.push(r(e))}),t}}function M(e,t){return"string"==typeof e&&(t||"0x"===e.substring(0,2)||(e="0x"+e),32===u.hexDataLength(e))?e.toLowerCase():(m.throwError("invalid hash",m.INVALID_ARGUMENT,{arg:"hash",value:e}),null)}function A(e){return a.bigNumberify(e).toNumber()}function E(e){if(!u.isHexString(e))throw new Error("invalid uint256");for(;e.length<66;)e="0x0"+e.substring(2);return e}function S(e){if(null==e)return"latest";if("earliest"===e)return"0x0";if("latest"===e||"pending"===e)return e;if("number"==typeof e)return u.hexStripZeros(u.hexlify(e));if(u.isHexString(e))return u.hexStripZeros(e);throw new Error("invalid blockTag")}var k={hash:M,blockHash:w(M,null),blockNumber:w(A,null),transactionIndex:w(A,null),confirmations:w(A,null),from:s.getAddress,gasPrice:a.bigNumberify,gasLimit:a.bigNumberify,to:w(s.getAddress,null),value:a.bigNumberify,nonce:A,data:u.hexlify,r:w(E),s:w(E),v:w(A),creates:w(s.getAddress,null),raw:w(u.hexlify)};function N(e){var t;null!=e.gas&&null==e.gasLimit&&(e.gasLimit=e.gas),e.to&&a.bigNumberify(e.to).isZero()&&(e.to="0x0000000000000000000000000000000000000000"),null!=e.input&&null==e.data&&(e.data=e.input),null==e.to&&null==e.creates&&(e.creates=s.getContractAddress(e)),e.raw||e.v&&e.r&&e.s&&(t=[u.stripZeros(u.hexlify(e.nonce)),u.stripZeros(u.hexlify(e.gasPrice)),u.stripZeros(u.hexlify(e.gasLimit)),e.to||"0x",u.stripZeros(u.hexlify(e.value||"0x")),u.hexlify(e.data||"0x"),u.stripZeros(u.hexlify(e.v||"0x")),u.stripZeros(u.hexlify(e.r)),u.stripZeros(u.hexlify(e.s))],e.raw=d.encode(t));var r=b(k,e),n=e.networkId;return null!=e.chainId&&null==n&&null==r.v&&(n=e.chainId),u.isHexString(n)&&(n=a.bigNumberify(n).toNumber()),"number"!=typeof n&&null!=r.v&&((n=(r.v-35)/2)<0&&(n=0),n=parseInt(n)),"number"!=typeof n&&(n=0),r.networkId=n,null==r.chainId&&null!=n&&(r.chainId=n),r.blockHash&&"x"===r.blockHash.replace(/0/g,"")&&(r.blockHash=null),r}var x={hash:M,parentHash:M,number:A,timestamp:A,nonce:w(u.hexlify),difficulty:function(e){var t=a.bigNumberify(e);try{return t.toNumber()}catch(e){}return null},gasLimit:a.bigNumberify,gasUsed:a.bigNumberify,miner:s.getAddress,extraData:u.hexlify,transactions:w(_(M))},P=c.shallowCopy(x);function I(e,t){return null!=e.author&&null==e.miner&&(e.miner=e.author),b(t?P:x,e)}P.transactions=w(_(N));var T={from:w(s.getAddress),nonce:w(A),gasLimit:w(a.bigNumberify),gasPrice:w(a.bigNumberify),to:w(s.getAddress),value:w(a.bigNumberify),data:w(u.hexlify)};function R(e){return b(T,e)}var O={transactionLogIndex:w(A),transactionIndex:A,blockNumber:A,transactionHash:M,address:s.getAddress,topics:_(M),data:u.hexlify,logIndex:A,blockHash:M};var C={to:w(s.getAddress,null),from:w(s.getAddress,null),contractAddress:w(s.getAddress,null),transactionIndex:A,root:w(M),gasUsed:a.bigNumberify,logsBloom:w(u.hexlify),blockHash:M,transactionHash:M,logs:_(function(e){return b(O,e)}),blockNumber:A,confirmations:w(A,null),cumulativeGasUsed:a.bigNumberify,status:w(A)};function L(e){return Array.isArray(e)?e.forEach(function(e){L(e)}):null!=e&&M(e),e}var B={fromBlock:w(S,void 0),toBlock:w(S,void 0),address:w(s.getAddress,void 0),topics:w(L,void 0)},D={blockHash:w(M,void 0),address:w(s.getAddress,void 0),topics:w(L,void 0)};var U,F,j={blockNumber:w(A),blockHash:w(M),transactionIndex:A,removed:w(function(e){if("boolean"==typeof e)return e;if("string"==typeof e){if("true"===e)return!0;if("false"===e)return!1}throw new Error("invaid boolean - "+e)}),address:s.getAddress,data:(U=u.hexlify,F="0x",function(e){return e?U(e):F}),topics:_(M),transactionHash:M,logIndex:A};function G(e){return b(j,e)}function H(e){return e.map(function(e){return"string"==typeof e?e:Array.isArray(e)?(e.forEach(function(e){null!==e&&32!==u.hexDataLength(e)&&m.throwError("invalid topic",m.INVALID_ARGUMENT,{argument:"topic",value:e})}),e.join(",")):null===e?"":m.throwError("invalid topic value",m.INVALID_ARGUMENT,{argument:"topic",value:e})}).join("&")}function z(e){if("string"==typeof e){if(20===u.hexDataLength(e))return"address:"+s.getAddress(e);if(e=e.toLowerCase(),32===u.hexDataLength(e))return"tx:"+e;if(-1===e.indexOf(":"))return e}else{if(Array.isArray(e))return"filter::"+H(e);if(e&&"object"==typeof e)return"filter:"+(e.address||"")+":"+H(e.topics||[])}throw new Error("invalid event - "+e)}function V(){return(new Date).getTime()}var K,q=(K=g.Provider,i(W,K),W.prototype._doPoll=function(){var u=this;this.getBlockNumber().then(function(s){if(u.polling&&(u._setFastBlockNumber(s),s!==u._lastBlockNumber)){-2===u._emitted.block&&(u._emitted.block=s-1);for(var e=u._emitted.block+1;e<=s;e++)u.emit("block",e);u._emitted.block!==s&&(u._emitted.block=s,Object.keys(u._emitted).forEach(function(e){var t;"block"===e||"pending"!==(t=u._emitted[e])&&12<s-t&&delete u._emitted[e]})),-2===u._lastBlockNumber&&(u._lastBlockNumber=s-1);var a={},t={};return u._events.forEach(function(e){t[e.tag]=!0}),Object.keys(t).forEach(function(e){var t=e.split(":");switch(t[0]){case"tx":var r=t[1];u.getTransactionReceipt(r).then(function(e){return e&&null!=e.blockNumber&&(u._emitted["t:"+r]=e.blockNumber,u.emit(r,e)),null}).catch(function(e){u.emit("error",e)});break;case"address":var n=t[1];u._balances[n]&&(a[n]=u._balances[n]),u.getBalance(n,"latest").then(function(e){var t=u._balances[n];if(!t||!e.eq(t))return u._balances[n]=e,u.emit(n,e),null}).catch(function(e){u.emit("error",e)});break;case"filter":var i=t[2].split(/&/g).map(function(e){var t=e.split(",");return 1===t.length?""===t[0]?null:e:t.map(function(e){return""===e?null:e})}),o={address:t[1],fromBlock:u._lastBlockNumber+1,toBlock:s,topics:i};o.address||delete o.address,u.getLogs(o).then(function(e){if(0!==e.length)return e.forEach(function(e){u._emitted["b:"+e.blockHash]=e.blockNumber,u._emitted["t:"+e.transactionHash]=e.blockNumber,u.emit(o,e)}),null}).catch(function(e){u.emit("error",e)})}}),u._lastBlockNumber=s,u._balances=a,null}}).catch(function(e){}),this.doPoll()},W.prototype.resetEventsBlock=function(e){this._lastBlockNumber=e-1,this.polling&&this._doPoll()},Object.defineProperty(W.prototype,"network",{get:function(){return this._network},enumerable:!0,configurable:!0}),W.prototype.getNetwork=function(){return this.ready},Object.defineProperty(W.prototype,"blockNumber",{get:function(){return this._fastBlockNumber},enumerable:!0,configurable:!0}),Object.defineProperty(W.prototype,"polling",{get:function(){return null!=this._poller},set:function(e){var t=this;setTimeout(function(){e&&!t._poller?(t._poller=setInterval(t._doPoll.bind(t),t.pollingInterval),t._doPoll()):!e&&t._poller&&(clearInterval(t._poller),t._poller=null)},0)},enumerable:!0,configurable:!0}),Object.defineProperty(W.prototype,"pollingInterval",{get:function(){return this._pollingInterval},set:function(e){var t=this;if("number"!=typeof e||e<=0||parseInt(String(e))!=e)throw new Error("invalid polling interval");this._pollingInterval=e,this._poller&&(clearInterval(this._poller),this._poller=setInterval(function(){t._doPoll()},this._pollingInterval))},enumerable:!0,configurable:!0}),W.prototype._getFastBlockNumber=function(){var t=this,e=V();return e-this._fastQueryDate>2*this._pollingInterval&&(this._fastQueryDate=e,this._fastBlockNumberPromise=this.getBlockNumber().then(function(e){return(null==t._fastBlockNumber||e>t._fastBlockNumber)&&(t._fastBlockNumber=e),t._fastBlockNumber})),this._fastBlockNumberPromise},W.prototype._setFastBlockNumber=function(e){null!=this._fastBlockNumber&&e<this._fastBlockNumber||(this._fastQueryDate=V(),(null==this._fastBlockNumber||e>this._fastBlockNumber)&&(this._fastBlockNumber=e,this._fastBlockNumberPromise=Promise.resolve(e)))},W.prototype.waitForTransaction=function(n,i){var o=this;return null==i&&(i=1),this.getTransactionReceipt(n).then(function(e){return 0===i||e&&e.confirmations>=i?e:new Promise(function(t){var r=function(e){e.confirmations<i||(o.removeListener(n,r),t(e))};o.on(n,r)})})},W.prototype.getBlockNumber=function(){var r=this;return this.ready.then(function(){return r.perform("getBlockNumber",{}).then(function(e){var t=parseInt(e);if(t!=e)throw new Error("invalid response - getBlockNumber");return r._setFastBlockNumber(t),t})})},W.prototype.getGasPrice=function(){var e=this;return this.ready.then(function(){return e.perform("getGasPrice",{}).then(function(e){return a.bigNumberify(e)})})},W.prototype.getBalance=function(e,t){var n=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,blockTag:t}).then(function(e){var t=e.addressOrName,r=e.blockTag;return n._getAddress(t).then(function(e){var t={address:e,blockTag:S(r)};return n.perform("getBalance",t).then(function(e){return a.bigNumberify(e)})})})})},W.prototype.getTransactionCount=function(e,t){var n=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,blockTag:t}).then(function(e){var t=e.addressOrName,r=e.blockTag;return n._getAddress(t).then(function(e){var t={address:e,blockTag:S(r)};return n.perform("getTransactionCount",t).then(function(e){return a.bigNumberify(e).toNumber()})})})})},W.prototype.getCode=function(e,t){var n=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,blockTag:t}).then(function(e){var t=e.addressOrName,r=e.blockTag;return n._getAddress(t).then(function(e){var t={address:e,blockTag:S(r)};return n.perform("getCode",t).then(function(e){return u.hexlify(e)})})})})},W.prototype.getStorageAt=function(e,t,r){var i=this;return this.ready.then(function(){return c.resolveProperties({addressOrName:e,position:t,blockTag:r}).then(function(e){var t=e.addressOrName,r=e.position,n=e.blockTag;return i._getAddress(t).then(function(e){var t={address:e,blockTag:S(n),position:u.hexStripZeros(u.hexlify(r))};return i.perform("getStorageAt",t).then(function(e){return u.hexlify(e)})})})})},W.prototype.sendTransaction=function(e){var n=this;return this.ready.then(function(){return c.resolveProperties({signedTransaction:e}).then(function(e){var t=e.signedTransaction,r={signedTransaction:u.hexlify(t)};return n.perform("sendTransaction",r).then(function(e){return n._wrapTransaction(p.parse(t),e)},function(e){throw e.transaction=p.parse(t),e.transaction.hash&&(e.transactionHash=e.transaction.hash),e})})})},W.prototype._wrapTransaction=function(r,e){var n=this;if(null!=e&&32!==u.hexDataLength(e))throw new Error("invalid response - sendTransaction");var t=r;return null!=e&&r.hash!==e&&m.throwError("Transaction hash mismatch from Provider.sendTransaction.",m.UNKNOWN_ERROR,{expectedHash:r.hash,returnedHash:e}),t.wait=function(t){return 0!==t&&(n._emitted["t:"+r.hash]="pending"),n.waitForTransaction(r.hash,t).then(function(e){return null==e&&0===t?null:(n._emitted["t:"+r.hash]=e.blockNumber,0===e.status&&m.throwError("transaction failed",m.CALL_EXCEPTION,{transactionHash:r.hash,transaction:r}),e)})},t},W.prototype.call=function(e,t){var n=this,r=c.shallowCopy(e);return this.ready.then(function(){return c.resolveProperties({blockTag:t,tx:r}).then(function(e){var r=e.blockTag,t=e.tx;return n._resolveNames(t,["to","from"]).then(function(e){var t={blockTag:S(r),transaction:R(e)};return n.perform("call",t).then(function(e){return u.hexlify(e)})})})})},W.prototype.estimateGas=function(e){var r=this,t={to:e.to,from:e.from,data:e.data,gasPrice:e.gasPrice,value:e.value};return this.ready.then(function(){return c.resolveProperties(t).then(function(e){return r._resolveNames(e,["to","from"]).then(function(e){var t={transaction:R(e)};return r.perform("estimateGas",t).then(function(e){return a.bigNumberify(e)})})})})},W.prototype.getBlock=function(e,o){var s=this;return this.ready.then(function(){return c.resolveProperties({blockHashOrBlockTag:e}).then(function(e){var t=e.blockHashOrBlockTag;try{var r=u.hexlify(t);if(32===u.hexDataLength(r))return y.poll(function(){return s.perform("getBlock",{blockHash:r,includeTransactions:!!o}).then(function(e){return null==e?null==s._emitted["b:"+r]?null:void 0:I(e,o)})},{onceBlock:s})}catch(e){}try{var n=-128,i=S(t);return u.isHexString(i)&&(n=parseInt(i.substring(2),16)),y.poll(function(){return s.perform("getBlock",{blockTag:i,includeTransactions:!!o}).then(function(e){return null!=e?I(e,o):n<=s._emitted.block?void 0:null})},{onceBlock:s})}catch(e){}throw new Error("invalid block hash or block tag")})})},W.prototype.getTransaction=function(e){var n=this;return this.ready.then(function(){return c.resolveProperties({transactionHash:e}).then(function(e){var t=e.transactionHash,r={transactionHash:M(t,!0)};return y.poll(function(){return n.perform("getTransaction",r).then(function(e){if(null==e)return null==n._emitted["t:"+t]?null:void 0;var r=W.checkTransactionResponse(e);if(null==r.blockNumber)r.confirmations=0;else if(null==r.confirmations)return n._getFastBlockNumber().then(function(e){var t=e-r.blockNumber+1;return t<=0&&(t=1),r.confirmations=t,n._wrapTransaction(r)});return n._wrapTransaction(r)})},{onceBlock:n})})})},W.prototype.getTransactionReceipt=function(e){var o=this;return this.ready.then(function(){return c.resolveProperties({transactionHash:e}).then(function(e){var i=e.transactionHash,t={transactionHash:M(i,!0)};return y.poll(function(){return o.perform("getTransactionReceipt",t).then(function(e){if(null==e)return null==o._emitted["t:"+i]?null:void 0;if(null!=e.blockHash){var t,r,n=((r=b(C,t=e)).logs.forEach(function(e,t){null==e.transactionLogIndex&&(e.transactionLogIndex=t)}),null!=t.status&&(r.byzantium=!0),r);if(null==n.blockNumber)n.confirmations=0;else if(null==n.confirmations)return o._getFastBlockNumber().then(function(e){var t=e-n.blockNumber+1;return t<=0&&(t=1),n.confirmations=t,n});return n}})},{onceBlock:o})})})},W.prototype.getLogs=function(e){var n=this;return this.ready.then(function(){return c.resolveProperties(e).then(function(e){return n._resolveNames(e,["address"]).then(function(e){var t,r={filter:(t=e)&&t.blockHash?b(D,t):b(B,t)};return n.perform("getLogs",r).then(function(e){return _(G)(e)})})})})},W.prototype.getEtherPrice=function(){var e=this;return this.ready.then(function(){return e.perform("getEtherPrice",{}).then(function(e){return e})})},W.prototype._getAddress=function(t){return this.resolveName(t).then(function(e){return null==e&&m.throwError("ENS name not configured",m.UNSUPPORTED_OPERATION,{operation:"resolveName("+JSON.stringify(t)+")"}),e})},W.prototype._resolveNames=function(e,t){var r=[],n=c.shallowCopy(e);return t.forEach(function(t){null!=n[t]&&r.push(this._getAddress(n[t]).then(function(e){n[t]=e}))},this),Promise.all(r).then(function(){return n})},W.prototype._getResolver=function(n){var i=this;return this.getNetwork().then(function(e){e.ensAddress||m.throwError("network does not support ENS",m.UNSUPPORTED_OPERATION,{operation:"ENS",network:e.name});var t="0x0178b8bf"+h.namehash(n).substring(2),r={to:e.ensAddress,data:t};return i.call(r).then(function(e){if(32!==u.hexDataLength(e))return null;var t=s.getAddress(u.hexDataSlice(e,12));return t===l.AddressZero?null:t})})},W.prototype.resolveName=function(t){var r=this;if(t instanceof Promise)return t.then(function(e){return r.resolveName(e)});try{return Promise.resolve(s.getAddress(t))}catch(e){if(u.isHexString(t))throw e}var n=this,i=h.namehash(t);return this._getResolver(t).then(function(e){if(null==e)return null;var t={to:e,data:"0x3b3b57de"+i.substring(2)};return n.call(t)}).then(function(e){if(32!==u.hexDataLength(e))return null;var t=s.getAddress(u.hexDataSlice(e,12));return t===l.AddressZero?null:t})},W.prototype.lookupAddress=function(n){var t=this;if(n instanceof Promise)return n.then(function(e){return t.lookupAddress(e)});var e=(n=s.getAddress(n)).substring(2)+".addr.reverse",r=h.namehash(e),i=this;return this._getResolver(e).then(function(e){if(!e)return null;var t={to:e,data:"0x691f3431"+r.substring(2)};return i.call(t)}).then(function(e){if(null==e)return null;if((e=e.substring(2)).length<64)return null;if((e=e.substring(64)).length<64)return null;var t=a.bigNumberify("0x"+e.substring(0,64)).toNumber();if(2*t>(e=e.substring(64)).length)return null;var r=v.toUtf8String("0x"+e.substring(0,2*t));return i.resolveName(r).then(function(e){return e!=n?null:r})})},W.checkTransactionResponse=N,W.prototype.doPoll=function(){},W.prototype.perform=function(e,t){return m.throwError(e+" not implemented",m.NOT_IMPLEMENTED,{operation:e}),null},W.prototype._startPending=function(){m.warn("WARNING: this provider does not support pending events")},W.prototype._stopPending=function(){},W.prototype._addEventListener=function(e,t,r){this._events.push({tag:z(e),listener:t,once:r}),"pending"===e&&this._startPending(),this.polling=!0},W.prototype.on=function(e,t){return this._addEventListener(e,t,!1),this},W.prototype.once=function(e,t){return this._addEventListener(e,t,!0),this},W.prototype.addEventListener=function(e,t){return this.on(e,t)},W.prototype.emit=function(e){for(var t=this,r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];var i=!1,o=z(e);return this._events=this._events.filter(function(e){return e.tag!==o||(setTimeout(function(){e.listener.apply(t,r)},0),i=!0,!e.once)}),0===this.listenerCount()&&(this.polling=!1),i},W.prototype.listenerCount=function(e){if(!e)return this._events.length;var t=z(e);return this._events.filter(function(e){return e.tag===t}).length},W.prototype.listeners=function(e){var t=z(e);return this._events.filter(function(e){return e.tag===t}).map(function(e){return e.listener})},W.prototype.removeAllListeners=function(e){var t;return null==e?(this._events=[],this._stopPending()):(t=z(e),this._events=this._events.filter(function(e){return e.tag!==t}),"pending"===e&&this._stopPending()),0===this._events.length&&(this.polling=!1),this},W.prototype.removeListener=function(e,t){var r=!1,n=z(e);return this._events=this._events.filter(function(e){return e.tag!==n||e.listener!=t||(!!r||!(r=!0))}),"pending"===e&&0===this.listenerCount("pending")&&this._stopPending(),0===this.listenerCount()&&(this.polling=!1),this},W);function W(e){var t,r=K.call(this)||this;return m.checkNew(r,g.Provider),e instanceof Promise?(c.defineReadOnly(r,"ready",e.then(function(e){return c.defineReadOnly(r,"_network",e),e})),r.ready.catch(function(e){})):(t=f.getNetwork(null==e?"homestead":e))?(c.defineReadOnly(r,"_network",t),c.defineReadOnly(r,"ready",Promise.resolve(r._network))):m.throwError("invalid network",m.INVALID_ARGUMENT,{arg:"network",value:e}),r._lastBlockNumber=-2,r._balances={},r._events=[],r._pollingInterval=4e3,r._emitted={block:-2},r._fastQueryDate=0,r}r.BaseProvider=q,c.defineReadOnly(g.Provider,"inherits",c.inheritable(g.Provider))},{"../constants":3,"../errors":5,"../utils/address":60,"../utils/bignumber":63,"../utils/bytes":64,"../utils/hash":65,"../utils/networks":72,"../utils/properties":74,"../utils/rlp":76,"../utils/transaction":83,"../utils/utf8":85,"../utils/web":86,"./abstract-provider":50}],52:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("./base-provider"),a=e("../utils/bytes"),u=e("../utils/properties"),l=e("../utils/web"),h=o(e("../errors"));function f(e){var t,r=[];for(var n in e){null!=e[n]&&(t=a.hexlify(e[n]),{gasLimit:!0,gasPrice:!0,nonce:!0,value:!0}[n]&&(t=a.hexStripZeros(t)),r.push(n+"="+t))}return r.join("&")}function c(e){if(0==e.status&&("No records found"===e.message||"No transactions found"===e.message))return e.result;if(1==e.status&&"OK"==e.message)return e.result;var t=new Error("invalid response");throw t.result=JSON.stringify(e),t}function d(e){if("2.0"!=e.jsonrpc)throw(t=new Error("invalid response")).result=JSON.stringify(e),t;if(e.error){var t=new Error(e.error.message||"unknown error");throw e.error.code&&(t.code=e.error.code),e.error.data&&(t.data=e.error.data),t}return e.result}function p(e){if("pending"===e)throw new Error("pending not supported");return"latest"===e?e:parseInt(e.substring(2),16)}var v,y="8FG3JMZ9USS4NTA6YKEKHINU56SEPPVBJR",m=(v=s.BaseProvider,i(g,v),g.prototype.perform=function(e,t){var r=this,n=this.baseUrl,i="";this.apiKey&&(i+="&apikey="+this.apiKey);function o(t,e){return l.fetchJson(t,null,e||d).then(function(e){return r.emit("debug",{action:"perform",request:t,response:e,provider:r}),e})}var s;switch(e){case"getBlockNumber":return o(n+="/api?module=proxy&action=eth_blockNumber"+i);case"getGasPrice":return o(n+="/api?module=proxy&action=eth_gasPrice"+i);case"getBalance":return n+="/api?module=account&action=balance&address="+t.address,o(n+="&tag="+t.blockTag+i,c);case"getTransactionCount":return n+="/api?module=proxy&action=eth_getTransactionCount&address="+t.address,o(n+="&tag="+t.blockTag+i);case"getCode":return n+="/api?module=proxy&action=eth_getCode&address="+t.address,o(n+="&tag="+t.blockTag+i,d);case"getStorageAt":return n+="/api?module=proxy&action=eth_getStorageAt&address="+t.address,n+="&position="+t.position,o(n+="&tag="+t.blockTag+i,d);case"sendTransaction":return n+="/api?module=proxy&action=eth_sendRawTransaction&hex="+t.signedTransaction,o(n+=i).catch(function(e){throw e.responseText&&(0<=e.responseText.toLowerCase().indexOf("insufficient funds")&&h.throwError("insufficient funds",h.INSUFFICIENT_FUNDS,{}),0<=e.responseText.indexOf("same hash was already imported")&&h.throwError("nonce has already been used",h.NONCE_EXPIRED,{}),0<=e.responseText.indexOf("another transaction with same nonce")&&h.throwError("replacement fee too low",h.REPLACEMENT_UNDERPRICED,{})),e});case"getBlock":return t.blockTag?(n+="/api?module=proxy&action=eth_getBlockByNumber&tag="+t.blockTag,t.includeTransactions?n+="&boolean=true":n+="&boolean=false",o(n+=i)):Promise.reject(new Error("getBlock by blockHash not implemeneted"));case"getTransaction":return n+="/api?module=proxy&action=eth_getTransactionByHash&txhash="+t.transactionHash,o(n+=i);case"getTransactionReceipt":return n+="/api?module=proxy&action=eth_getTransactionReceipt&txhash="+t.transactionHash,o(n+=i);case"call":return(n+="/api?module=proxy&action=eth_call"+(s=(s=f(t.transaction))&&"&"+s),"latest"!==t.blockTag)?Promise.reject(new Error("EtherscanProvider does not support blockTag for call")):o(n+=i);case"estimateGas":return n+="/api?module=proxy&action=eth_estimateGas&"+(s=(s=f(t.transaction))&&"&"+s),o(n+=i);case"getLogs":n+="/api?module=logs&action=getLogs";try{if(t.filter.fromBlock&&(n+="&fromBlock="+p(t.filter.fromBlock)),t.filter.toBlock&&(n+="&toBlock="+p(t.filter.toBlock)),t.filter.blockHash)try{h.throwError("Etherscan does not support blockHash filters",h.UNSUPPORTED_OPERATION,{operation:"getLogs(blockHash)"})}catch(e){return Promise.reject(e)}if(t.filter.address&&(n+="&address="+t.filter.address),t.filter.topics&&0<t.filter.topics.length){if(1<t.filter.topics.length)throw new Error("unsupported topic format");var a=t.filter.topics[0];if("string"!=typeof a||66!==a.length)throw new Error("unsupported topic0 format");n+="&topic0="+a}}catch(e){return Promise.reject(e)}var u=this;return o(n+=i,c).then(function(e){var r={},n=Promise.resolve();return e.forEach(function(t){n=n.then(function(){return null!=t.blockHash?null:(t.blockHash=r[t.transactionHash],null==t.blockHash?u.getTransaction(t.transactionHash).then(function(e){return r[t.transactionHash]=e.blockHash,t.blockHash=e.blockHash,null}):null)})}),n.then(function(){return e})});case"getEtherPrice":return"homestead"!==this.network.name?Promise.resolve(0):(n+="/api?module=stats&action=ethprice",o(n+=i,c).then(function(e){return parseFloat(e.ethusd)}))}return v.prototype.perform.call(this,e,t)},g.prototype.getHistory=function(e,t,r){var n=this,i=this.baseUrl,o="";return this.apiKey&&(o+="&apikey="+this.apiKey),null==t&&(t=0),null==r&&(r=99999999),this.resolveName(e).then(function(e){return i+="/api?module=account&action=txlist&address="+e,i+="&startblock="+t,i+="&endblock="+r,i+="&sort=asc"+o,l.fetchJson(i,null,c).then(function(e){n.emit("debug",{action:"getHistory",request:i,response:e,provider:n});var r=[];return e.forEach(function(t){["contractAddress","to"].forEach(function(e){""==t[e]&&delete t[e]}),null==t.creates&&null!=t.contractAddress&&(t.creates=t.contractAddress);var e=s.BaseProvider.checkTransactionResponse(t);t.timeStamp&&(e.timestamp=parseInt(t.timeStamp)),r.push(e)}),r})})},g);function g(e,t){var r=v.call(this,e)||this;h.checkNew(r,g);var n="invalid";r.network&&(n=r.network.name);var i=null;switch(n){case"homestead":i="https://api.etherscan.io";break;case"ropsten":i="https://api-ropsten.etherscan.io";break;case"rinkeby":i="https://api-rinkeby.etherscan.io";break;case"kovan":i="https://api-kovan.etherscan.io";break;case"goerli":i="https://api-goerli.etherscan.io";break;default:throw new Error("unsupported network")}return u.defineReadOnly(r,"baseUrl",i),u.defineReadOnly(r,"apiKey",t||y),r}r.EtherscanProvider=m},{"../errors":5,"../utils/bytes":64,"../utils/properties":74,"../utils/web":86,"./base-provider":51}],53:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("./base-provider"),a=o(e("../errors"));function u(t){var r=!0,n=null;return t.forEach(function(e){null!=e?null!=n?n.name===e.name&&n.chainId===e.chainId&&(n.ensAddress===e.ensAddress||null==n.ensAddress&&null==e.ensAddress)||a.throwError("provider mismatch",a.INVALID_ARGUMENT,{arg:"networks",value:t}):n=e:r=!1}),r}var l,h=(l=s.BaseProvider,i(f,l),Object.defineProperty(f.prototype,"providers",{get:function(){return this._providers.slice(0)},enumerable:!0,configurable:!0}),f.prototype.perform=function(i,o){var s=this.providers;return new Promise(function(r,e){var n=null;!function t(){s.length?s.shift().perform(i,o).then(function(e){return r(e)}).catch(function(e){n=n||e,setTimeout(t,0)}):e(n)}()})},f);function f(e){var t,r=this;if(0===e.length)throw new Error("no providers");return r=u(e.map(function(e){return e.network}))?l.call(this,e[0].network)||this:(t=Promise.all(e.map(function(e){return e.getNetwork()})).then(function(e){return u(e)||a.throwError("getNetwork returned null",a.UNKNOWN_ERROR,{}),e[0]}),l.call(this,t)||this),a.checkNew(r,f),r._providers=e.slice(0),r}r.FallbackProvider=h},{"../errors":5,"./base-provider":51}],54:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./abstract-provider");r.Provider=n.Provider;var i=e("./base-provider");r.BaseProvider=i.BaseProvider;var o=e("./etherscan-provider");r.EtherscanProvider=o.EtherscanProvider;var s=e("./fallback-provider");r.FallbackProvider=s.FallbackProvider;var a=e("./ipc-provider");r.IpcProvider=a.IpcProvider;var u=e("./infura-provider");r.InfuraProvider=u.InfuraProvider;var l=e("./json-rpc-provider");r.JsonRpcProvider=l.JsonRpcProvider,r.JsonRpcSigner=l.JsonRpcSigner;var h=e("./web3-provider");r.Web3Provider=h.Web3Provider},{"./abstract-provider":50,"./base-provider":51,"./etherscan-provider":52,"./fallback-provider":53,"./infura-provider":55,"./ipc-provider":56,"./json-rpc-provider":57,"./web3-provider":58}],55:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,a=e("./json-rpc-provider"),u=e("../utils/bytes"),l=e("../utils/networks"),h=e("../utils/properties"),f=o(e("../errors")),c="7d0d81d0919f4f05b9ab6634be01ee73",d=(s=a.JsonRpcProvider,i(p,s),p.prototype._startPending=function(){f.warn("WARNING: INFURA does not support pending filters")},p.prototype.getSigner=function(e){return f.throwError("INFURA does not support signing",f.UNSUPPORTED_OPERATION,{operation:"getSigner"})},p.prototype.listAccounts=function(){return Promise.resolve([])},p);function p(e,t){var r=this,n=l.getNetwork(null==e?"homestead":e);null==t&&(t=c);var i=null;switch(n.name){case"homestead":i="mainnet.infura.io";break;case"ropsten":i="ropsten.infura.io";break;case"rinkeby":i="rinkeby.infura.io";break;case"goerli":i="goerli.infura.io";break;case"kovan":i="kovan.infura.io";break;default:f.throwError("unsupported network",f.INVALID_ARGUMENT,{argument:"network",value:e})}return u.isHexString("0x"+t,16)?(r=s.call(this,"https://"+i+"/v3/"+t,n)||this,h.defineReadOnly(r,"apiAccessToken",null),h.defineReadOnly(r,"projectId",t)):(f.warn("The legacy INFURA apiAccesToken API is deprecated; please upgrade to a Project ID instead (see INFURA dshboard; https://infura.io)"),r=s.call(this,"https://"+i+"/"+t,n)||this,h.defineReadOnly(r,"apiAccessToken",t),h.defineReadOnly(r,"projectId",null)),f.checkNew(r,p),r}r.InfuraProvider=d},{"../errors":5,"../utils/bytes":64,"../utils/networks":72,"../utils/properties":74,"./json-rpc-provider":57}],56:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0})},{}],57:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("./base-provider"),a=e("../abstract-signer"),u=o(e("../errors")),l=e("../utils/address"),h=e("../utils/bytes"),f=e("../utils/networks"),c=e("../utils/properties"),d=e("../utils/utf8"),p=e("../utils/web");function v(e){if(e.error){var t=new Error(e.error.message);throw t.code=e.error.code,t.data=e.error.data,t}return e.result}function y(e){return e?e.toLowerCase():e}var m,g={},b=42,w=(m=a.Signer,i(_,m),_.prototype.getAddress=function(){var t=this;return this._address?Promise.resolve(this._address):this.provider.send("eth_accounts",[]).then(function(e){return e.length<=t._index&&u.throwError("unknown account #"+t._index,u.UNSUPPORTED_OPERATION,{operation:"getAddress"}),t._address=l.getAddress(e[t._index]),t._address})},_.prototype.getBalance=function(e){return this.provider.getBalance(this.getAddress(),e)},_.prototype.getTransactionCount=function(e){return this.provider.getTransactionCount(this.getAddress(),e)},_.prototype.sendUncheckedTransaction=function(e){var n=this;e=c.shallowCopy(e);var t,r=this.getAddress().then(function(e){return e=e&&e.toLowerCase()});return null==e.gasLimit&&((t=c.shallowCopy(e)).from=r,e.gasLimit=this.provider.estimateGas(t)),Promise.all([c.resolveProperties(e),r]).then(function(e){var t=e[0],r=E.hexlifyTransaction(t);return r.from=e[1],n.provider.send("eth_sendTransaction",[r]).then(function(e){return e},function(e){throw e.responseText&&(0<=e.responseText.indexOf("insufficient funds")&&u.throwError("insufficient funds",u.INSUFFICIENT_FUNDS,{transaction:t}),0<=e.responseText.indexOf("nonce too low")&&u.throwError("nonce has already been used",u.NONCE_EXPIRED,{transaction:t}),0<=e.responseText.indexOf("replacement transaction underpriced")&&u.throwError("replacement fee too low",u.REPLACEMENT_UNDERPRICED,{transaction:t})),e})})},_.prototype.sendTransaction=function(e){var r=this;return this.sendUncheckedTransaction(e).then(function(t){return p.poll(function(){return r.provider.getTransaction(t).then(function(e){if(null!==e)return r.provider._wrapTransaction(e,t)})},{fastRetry:250,onceBlock:r.provider}).catch(function(e){throw e.transactionHash=t,e})})},_.prototype.signMessage=function(e){var t=this,r="string"==typeof e?d.toUtf8Bytes(e):e;return this.getAddress().then(function(e){return t.provider.send("eth_sign",[e.toLowerCase(),h.hexlify(r)])})},_.prototype.unlock=function(t){var r=this.provider;return this.getAddress().then(function(e){return r.send("personal_unlockAccount",[e.toLowerCase(),t,null])})},_);function _(e,t,r){var n=m.call(this)||this;if(u.checkNew(n,_),e!==g)throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");return c.defineReadOnly(n,"provider",t),r?"string"==typeof r?c.defineReadOnly(n,"_address",l.getAddress(r)):"number"==typeof r?c.defineReadOnly(n,"_index",r):u.throwError("invalid address or index",u.INVALID_ARGUMENT,{argument:"addressOrIndex",value:r}):c.defineReadOnly(n,"_index",0),n}r.JsonRpcSigner=w;var M,A={chainId:!0,data:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0},E=(M=s.BaseProvider,i(S,M),S.prototype.getSigner=function(e){return new w(g,this,e)},S.prototype.listAccounts=function(){return this.send("eth_accounts",[]).then(function(e){return e.map(function(e){return l.getAddress(e)})})},S.prototype.send=function(e,t){var r=this,n={method:e,params:t,id:b++,jsonrpc:"2.0"};return p.fetchJson(this.connection,JSON.stringify(n),v).then(function(e){return r.emit("debug",{action:"send",request:n,response:e,provider:r}),e})},S.prototype.perform=function(e,t){switch(e){case"getBlockNumber":return this.send("eth_blockNumber",[]);case"getGasPrice":return this.send("eth_gasPrice",[]);case"getBalance":return this.send("eth_getBalance",[y(t.address),t.blockTag]);case"getTransactionCount":return this.send("eth_getTransactionCount",[y(t.address),t.blockTag]);case"getCode":return this.send("eth_getCode",[y(t.address),t.blockTag]);case"getStorageAt":return this.send("eth_getStorageAt",[y(t.address),t.position,t.blockTag]);case"sendTransaction":return this.send("eth_sendRawTransaction",[t.signedTransaction]).catch(function(e){throw e.responseText&&(0<e.responseText.indexOf("insufficient funds")&&u.throwError("insufficient funds",u.INSUFFICIENT_FUNDS,{}),0<e.responseText.indexOf("nonce too low")&&u.throwError("nonce has already been used",u.NONCE_EXPIRED,{}),0<e.responseText.indexOf("replacement transaction underpriced")&&u.throwError("replacement fee too low",u.REPLACEMENT_UNDERPRICED,{})),e});case"getBlock":return t.blockTag?this.send("eth_getBlockByNumber",[t.blockTag,!!t.includeTransactions]):t.blockHash?this.send("eth_getBlockByHash",[t.blockHash,!!t.includeTransactions]):Promise.reject(new Error("invalid block tag or block hash"));case"getTransaction":return this.send("eth_getTransactionByHash",[t.transactionHash]);case"getTransactionReceipt":return this.send("eth_getTransactionReceipt",[t.transactionHash]);case"call":return this.send("eth_call",[S.hexlifyTransaction(t.transaction,{from:!0}),t.blockTag]);case"estimateGas":return this.send("eth_estimateGas",[S.hexlifyTransaction(t.transaction,{from:!0})]);case"getLogs":return t.filter&&null!=t.filter.address&&(t.filter.address=y(t.filter.address)),this.send("eth_getLogs",[t.filter])}return u.throwError(e+" not implemented",u.NOT_IMPLEMENTED,{operation:e}),null},S.prototype._startPending=function(){var r,n;null==this._pendingFilter&&(n=(r=this).send("eth_newPendingTransactionFilter",[]),(this._pendingFilter=n).then(function(t){return function e(){r.send("eth_getFilterChanges",[t]).then(function(e){if(r._pendingFilter!=n)return null;var t=Promise.resolve();return e.forEach(function(e){r._emitted["t:"+e.toLowerCase()]="pending",t=t.then(function(){return r.getTransaction(e).then(function(e){return r.emit("pending",e),null})})}),t.then(function(){return t=1e3,new Promise(function(e){setTimeout(function(){e()},t)});var t})}).then(function(){return r._pendingFilter==n?(setTimeout(function(){e()},0),null):void r.send("eth_uninstallFilter",[t])}).catch(function(e){})}(),t}).catch(function(e){}))},S.prototype._stopPending=function(){this._pendingFilter=null},S.hexlifyTransaction=function(r,e){var t=c.shallowCopy(A);if(e)for(var n in e)e[n]&&(t[n]=!0);c.checkProperties(r,t);var i={};return["gasLimit","gasPrice","nonce","value"].forEach(function(e){var t;null!=r[e]&&(t=h.hexStripZeros(h.hexlify(r[e])),"gasLimit"===e&&(e="gas"),i[e]=t)}),["from","to","data"].forEach(function(e){null!=r[e]&&(i[e]=h.hexlify(r[e]))}),i},S);function S(e,t){var r,n=this;return"string"==typeof e&&null===t&&f.getNetwork(e)&&(t=e,e=null),n=t?M.call(this,t)||this:(r=new Promise(function(t,r){setTimeout(function(){n.send("net_version",[]).then(function(e){return t(f.getNetwork(parseInt(e)))}).catch(function(e){r(e)})})}),M.call(this,r)||this),u.checkNew(n,S),e=e||"http://localhost:8545",n.connection="string"==typeof e?{url:e}:e,n}r.JsonRpcProvider=E},{"../abstract-signer":2,"../errors":5,"../utils/address":60,"../utils/bytes":64,"../utils/networks":72,"../utils/properties":74,"../utils/utf8":85,"../utils/web":86,"./base-provider":51}],58:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,a=e("./json-rpc-provider"),u=e("../utils/properties"),l=o(e("../errors")),h=42,f=(s=a.JsonRpcProvider,i(c,s),c.prototype.send=function(t,r){var o=this;return"eth_sign"==t&&this._web3Provider.isMetaMask&&(t="personal_sign",r=[r[1],r[0]]),new Promise(function(n,i){var e={method:t,params:r,id:h++,jsonrpc:"2.0"};o._sendAsync(e,function(e,t){if(e)i(e);else{if(t.error){var r=new Error(t.error.message);return r.code=t.error.code,r.data=t.error.data,void i(r)}n(t.result)}})})},c);function c(e,t){var r=s.call(this,e.host||e.path||"",t)||this;return l.checkNew(r,c),e&&(e.sendAsync?r._sendAsync=e.sendAsync.bind(e):e.send&&(r._sendAsync=e.send.bind(e))),e&&r._sendAsync||l.throwError("invalid web3Provider",l.INVALID_ARGUMENT,{arg:"web3Provider",value:e}),u.defineReadOnly(r,"_web3Provider",e),u.defineReadOnly(r,"provider",e),r}r.Web3Provider=f},{"../errors":5,"../utils/properties":74,"./json-rpc-provider":57}],59:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s=e("../constants"),l=o(e("../errors")),a=e("./address"),u=e("./bignumber"),h=e("./bytes"),f=e("./utf8"),c=e("./properties"),d=new RegExp(/^bytes([0-9]*)$/),p=new RegExp(/^(u?int)([0-9]*)$/),v=new RegExp(/^(.*)\[([0-9]*)\]$/);r.defaultCoerceFunc=function(e,t){var r=e.match(p);return r&&parseInt(r[2])<=48?t.toNumber():t};var y=new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$"),m=new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");function g(e){return e.match(/^uint($|[^1-9])/)?e="uint256"+e.substring(4):e.match(/^int($|[^1-9])/)&&(e="int256"+e.substring(3)),e}function b(e,t){var r=e;function n(e){throw new Error('unexpected character "'+r[e]+'" at position '+e+' in "'+r+'"')}e=e.replace(/\s/g," ");for(var i={type:"",name:"",state:{allowType:!0}},o=i,s=0;s<e.length;s++){var a=e[s];switch(a){case"(":o.state.allowParams||n(s),o.state.allowType=!1,o.type=g(o.type),o.components=[{type:"",name:"",parent:o,state:{allowType:!0}}],o=o.components[0];break;case")":delete o.state,t&&"indexed"===o.name&&(o.indexed=!0,o.name=""),o.type=g(o.type);var u=o;(o=o.parent)||n(s),delete u.parent,o.state.allowParams=!1,o.state.allowName=!0,o.state.allowArray=!0;break;case",":delete o.state,t&&"indexed"===o.name&&(o.indexed=!0,o.name=""),o.type=g(o.type);var l={type:"",name:"",parent:o.parent,state:{allowType:!0}};o.parent.components.push(l),delete o.parent,o=l;break;case" ":o.state.allowType&&""!==o.type&&(o.type=g(o.type),delete o.state.allowType,o.state.allowName=!0,o.state.allowParams=!0),o.state.allowName&&""!==o.name&&(t&&"indexed"===o.name?(o.indexed=!0,o.name=""):o.state.allowName=!1);break;case"[":o.state.allowArray||n(s),o.type+=a,o.state.allowArray=!1,o.state.allowName=!1,o.state.readArray=!0;break;case"]":o.state.readArray||n(s),o.type+=a,o.state.readArray=!1,o.state.allowArray=!0,o.state.allowName=!0;break;default:o.state.allowType?(o.type+=a,o.state.allowParams=!0,o.state.allowArray=!0):o.state.allowName?(o.name+=a,delete o.state.allowArray):o.state.readArray?o.type+=a:n(s)}}if(o.parent)throw new Error("unexpected eof");return delete i.state,t&&"indexed"===o.name&&(o.indexed=!0,o.name=""),i.type=g(i.type),i}function w(e){return se(r.defaultCoerceFunc,e).type}r.parseParamType=function(e){return b(e,!0)},r.formatParamType=w,r.formatSignature=function(e){return e.name+"("+e.inputs.map(w).join(",")+")"},r.parseSignature=function(e){if("string"==typeof e)return"event "===(e=(e=(e=e.replace(/\s/g," ")).replace(/\(/g," (").replace(/\)/g,") ").replace(/\s+/g," ")).trim()).substring(0,6)?function(e){var t={anonymous:!1,inputs:[],name:"",type:"event"},r=e.match(y);if(!r)throw new Error("invalid event: "+e);if(t.name=r[1].trim(),ie(r[2]).forEach(function(e){(e=b(e,!0)).indexed=!!e.indexed,t.inputs.push(e)}),r[3].split(" ").forEach(function(e){switch(e){case"anonymous":t.anonymous=!0;break;case"":break;default:l.info("unknown modifier: "+e)}}),t.name&&!t.name.match(m))throw new Error('invalid identifier: "'+t.name+'"');return t}(e.substring(6).trim()):("function "===e.substring(0,9)&&(e=e.substring(9)),function(e){var t={constant:!1,gas:null,inputs:[],name:"",outputs:[],payable:!1,stateMutability:null,type:"function"},r=e.split("@");if(1!==r.length){if(2<r.length)throw new Error("invalid signature");if(!r[1].match(/^[0-9]+$/))throw new Error("invalid signature gas");t.gas=u.bigNumberify(r[1]),e=r[0]}var n=(r=e.split(" returns "))[0].match(y);if(!n)throw new Error("invalid signature");if(t.name=n[1].trim(),!t.name.match(m))throw new Error('invalid identifier: "'+n[1]+'"');if(ie(n[2]).forEach(function(e){t.inputs.push(b(e))}),n[3].split(" ").forEach(function(e){switch(e){case"constant":t.constant=!0;break;case"payable":t.payable=!0,t.stateMutability="payable";break;case"pure":t.constant=!0,t.stateMutability="pure";break;case"view":t.constant=!0,t.stateMutability="view";break;case"external":case"public":case"":break;default:l.info("unknown modifier: "+e)}}),1<r.length){var i=r[1].match(y);if(""!=i[1].trim()||""!=i[3].trim())throw new Error("unexpected tokens");ie(i[2]).forEach(function(e){t.outputs.push(b(e))})}if("constructor"===t.name){if(t.type="constructor",t.outputs.length)throw new Error("constructor may not have outputs");delete t.name,delete t.outputs}return t}(e.trim()));throw new Error("unknown signature")};function _(e,t,r,n,i){this.coerceFunc=e,this.name=t,this.type=r,this.localName=n,this.dynamic=i}var M,A=(i(E,M=_),E.prototype.encode=function(e){return this.coder.encode(e)},E.prototype.decode=function(e,t){return this.coder.decode(e,t)},E);function E(e){var t=M.call(this,e.coerceFunc,e.name,e.type,void 0,e.dynamic)||this;return c.defineReadOnly(t,"coder",e),t}var S,k=(i(N,S=_),N.prototype.encode=function(e){return h.arrayify([])},N.prototype.decode=function(e,t){if(t>e.length)throw new Error("invalid null");return{consumed:0,value:this.coerceFunc("null",void 0)}},N);function N(e,t){return S.call(this,e,"null","",t,!1)||this}var x,P=(i(I,x=_),I.prototype.encode=function(t){try{var e=u.bigNumberify(t);if(this.signed){var r=s.MaxUint256.maskn(8*this.size-1);if(e.gt(r))throw new Error("out-of-bounds");if(r=r.add(s.One).mul(s.NegativeOne),e.lt(r))throw new Error("out-of-bounds")}else if(e.lt(s.Zero)||e.gt(s.MaxUint256.maskn(8*this.size)))throw new Error("out-of-bounds");return e=e.toTwos(8*this.size).maskn(8*this.size),this.signed&&(e=e.fromTwos(8*this.size).toTwos(256)),h.padZeros(h.arrayify(e),32)}catch(e){l.throwError("invalid number value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:t})}return null},I.prototype.decode=function(e,t){e.length<t+32&&l.throwError("insufficient data for "+this.name+" type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:h.hexlify(e.slice(t,t+32))});var r=32-this.size,n=u.bigNumberify(e.slice(t+r,t+32)),n=this.signed?n.fromTwos(8*this.size):n.maskn(8*this.size);return{consumed:32,value:this.coerceFunc(this.name,n)}},I);function I(e,t,r,n){var i=this,o=(r?"int":"uint")+8*t;return(i=x.call(this,e,o,o,n,!1)||this).size=t,i.signed=r,i}var T,R=new P(function(e,t){return t},32,!1,"none"),O=(i(C,T=_),C.prototype.encode=function(e){return R.encode(e?1:0)},C.prototype.decode=function(e,t){try{var r=R.decode(e,t)}catch(e){throw"insufficient data for uint256 type"===e.reason&&l.throwError("insufficient data for boolean type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"boolean",value:e.value}),e}return{consumed:r.consumed,value:this.coerceFunc("bool",!r.value.isZero())}},C);function C(e,t){return T.call(this,e,"bool","bool",t,!1)||this}var L,B=(i(D,L=_),D.prototype.encode=function(t){var e=new Uint8Array(32);try{var r=h.arrayify(t);if(r.length!==this.length)throw new Error("incorrect data length");e.set(r)}catch(e){l.throwError("invalid "+this.name+" value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:e.value||t})}return e},D.prototype.decode=function(e,t){return e.length<t+32&&l.throwError("insufficient data for "+this.name+" type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:this.name,value:h.hexlify(e.slice(t,t+32))}),{consumed:32,value:this.coerceFunc(this.name,h.hexlify(e.slice(t,t+this.length)))}},D);function D(e,t,r){var n=this,i="bytes"+t;return(n=L.call(this,e,i,i,r,!1)||this).length=t,n}var U,F=(i(j,U=_),j.prototype.encode=function(t){var e=new Uint8Array(32);try{e.set(h.arrayify(a.getAddress(t)),12)}catch(e){l.throwError("invalid address",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"address",value:t})}return e},j.prototype.decode=function(e,t){return e.length<t+32&&l.throwError("insufficient data for address type",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"address",value:h.hexlify(e.slice(t,t+32))}),{consumed:32,value:this.coerceFunc("address",a.getAddress(h.hexlify(e.slice(t+12,t+32))))}},j);function j(e,t){return U.call(this,e,"address","address",t,!1)||this}function G(e){var t=32*Math.ceil(e.length/32),r=new Uint8Array(t-e.length);return h.concat([R.encode(e.length),e,r])}function H(e,t,r){e.length<t+32&&l.throwError("insufficient data for dynamicBytes length",l.INVALID_ARGUMENT,{arg:r,coderType:"dynamicBytes",value:h.hexlify(e.slice(t,t+32))});var n=R.decode(e,t).value;try{n=n.toNumber()}catch(e){l.throwError("dynamic bytes count too large",l.INVALID_ARGUMENT,{arg:r,coderType:"dynamicBytes",value:n.toString()})}return e.length<t+32+n&&l.throwError("insufficient data for dynamicBytes type",l.INVALID_ARGUMENT,{arg:r,coderType:"dynamicBytes",value:h.hexlify(e.slice(t,t+32+n))}),{consumed:32+32*Math.ceil(n/32),value:e.slice(t+32,t+32+n)}}var z,V=(i(K,z=_),K.prototype.encode=function(e){try{return G(h.arrayify(e))}catch(e){l.throwError("invalid bytes value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"bytes",value:e.value})}return null},K.prototype.decode=function(e,t){var r=H(e,t,this.localName);return r.value=this.coerceFunc("bytes",h.hexlify(r.value)),r},K);function K(e,t){return z.call(this,e,"bytes","bytes",t,!0)||this}var q,W=(i(Z,q=_),Z.prototype.encode=function(e){return"string"!=typeof e&&l.throwError("invalid string value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"string",value:e}),G(f.toUtf8Bytes(e))},Z.prototype.decode=function(e,t){var r=H(e,t,this.localName);return r.value=this.coerceFunc("string",f.toUtf8String(r.value)),r},Z);function Z(e,t){return q.call(this,e,"string","string",t,!0)||this}function J(e){return 32*Math.ceil(e/32)}function X(e,r){var t;Array.isArray(r)||(r&&"object"==typeof r?(t=[],e.forEach(function(e){t.push(r[e.localName])}),r=t):l.throwError("invalid tuple value",l.INVALID_ARGUMENT,{coderType:"tuple",value:r})),e.length!==r.length&&l.throwError("types/value length mismatch",l.INVALID_ARGUMENT,{coderType:"tuple",value:r});var n=[];e.forEach(function(e,t){n.push({dynamic:e.dynamic,value:e.encode(r[t])})});var i=0,o=0;n.forEach(function(e){e.dynamic?(i+=32,o+=J(e.value.length)):i+=J(e.value.length)});var s=0,a=i,u=new Uint8Array(i+o);return n.forEach(function(e){e.dynamic?(u.set(R.encode(a),s),s+=32,u.set(e.value,a),a+=J(e.value.length)):(u.set(e.value,s),s+=J(e.value.length))}),u}function $(e,n,i){var o=i,s=0,a=[];return e.forEach(function(e){var t,r;e.dynamic?(t=R.decode(n,i),(r=e.decode(n,o+t.value.toNumber())).consumed=t.consumed):r=e.decode(n,i),null!=r.value&&a.push(r.value),i+=r.consumed,s+=r.consumed}),e.forEach(function(e,t){var r=e.localName;r&&("length"===r&&(r="_length"),null==a[r]&&(a[r]=a[t]))}),{value:a,consumed:s}}var Q,Y=(i(ee,Q=_),ee.prototype.encode=function(e){Array.isArray(e)||l.throwError("expected array value",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"array",value:e});var t=this.length,r=new Uint8Array(0);-1===t&&(t=e.length,r=R.encode(t)),l.checkArgumentCount(t,e.length," in coder array"+(this.localName?" "+this.localName:""));for(var n=[],i=0;i<e.length;i++)n.push(this.coder);return h.concat([r,X(n,e)])},ee.prototype.decode=function(e,t){var r=0,n=this.length;if(-1===n){try{var i=R.decode(e,t)}catch(e){l.throwError("insufficient data for dynamic array length",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"array",value:e.value})}try{n=i.value.toNumber()}catch(e){l.throwError("array count too large",l.INVALID_ARGUMENT,{arg:this.localName,coderType:"array",value:i.value.toString()})}r+=i.consumed,t+=i.consumed}for(var o=[],s=0;s<n;s++)o.push(new A(this.coder));var a=$(o,e,t);return a.consumed+=r,a.value=this.coerceFunc(this.type,a.value),a},ee);function ee(e,t,r,n){var i=this,o=t.type+"["+(0<=r?r:"")+"]",s=-1===r||t.dynamic;return(i=Q.call(this,e,"array",o,n,s)||this).coder=t,i.length=r,i}var te,re=(i(ne,te=_),ne.prototype.encode=function(e){return X(this.coders,e)},ne.prototype.decode=function(e,t){var r=$(this.coders,e,t);return r.value=this.coerceFunc(this.type,r.value),r},ne);function ne(e,t,r){var n=this,i=!1,o=[];t.forEach(function(e){e.dynamic&&(i=!0),o.push(e.type)});var s="tuple("+o.join(",")+")";return(n=te.call(this,e,"tuple",s,r,i)||this).coders=t,n}function ie(e){e=e.trim();for(var t=[],r="",n=0,i=0;i<e.length;i++){var o=e[i];if(","===o&&0===n)t.push(r),r="";else if(r+=o,"("===o)n++;else if(")"===o&&-1===--n)throw new Error("unbalanced parenthsis")}return r&&t.push(r),t}var oe={address:F,bool:O,string:W,bytes:V};function se(e,t){var r=oe[t.type];if(r)return new r(e,t.name);var n,i,o,s,a=t.type.match(p);if(a)return(0===(u=parseInt(a[2]||"256"))||256<u||u%8!=0)&&l.throwError("invalid "+a[1]+" bit length",l.INVALID_ARGUMENT,{arg:"param",value:t}),new P(e,u/8,"int"===a[1],t.name);if(a=t.type.match(d))return(0===(u=parseInt(a[1]))||32<u)&&l.throwError("invalid bytes length",l.INVALID_ARGUMENT,{arg:"param",value:t}),new B(e,u,t.name);if(a=t.type.match(v)){var u=parseInt(a[2]||"-1");return(t=c.shallowCopy(t)).type=a[1],t=c.deepCopy(t),new Y(e,se(e,t),u,t.name)}return"tuple"===t.type.substring(0,5)?(n=e,i=t.components,o=t.name,s=[],(i=i||[]).forEach(function(e){s.push(se(n,e))}),new re(n,s,o)):""===t.type?new k(e,t.name):(l.throwError("invalid type",l.INVALID_ARGUMENT,{arg:"type",value:t.type}),null)}var ae=(ue.prototype.encode=function(e,t){e.length!==t.length&&l.throwError("types/values length mismatch",l.INVALID_ARGUMENT,{count:{types:e.length,values:t.length},value:{types:e,values:t}});var r=[];return e.forEach(function(e){var t=null,t="string"==typeof e?b(e):e;r.push(se(this.coerceFunc,t))},this),h.hexlify(new re(this.coerceFunc,r,"_").encode(t))},ue.prototype.decode=function(e,t){var r=[];return e.forEach(function(e){var t=null,t="string"==typeof e?b(e):c.deepCopy(e);r.push(se(this.coerceFunc,t))},this),new re(this.coerceFunc,r,"_").decode(h.arrayify(t),0).value},ue);function ue(e){l.checkNew(this,ue),e=e||r.defaultCoerceFunc,c.defineReadOnly(this,"coerceFunc",e)}r.AbiCoder=ae,r.defaultAbiCoder=new ae},{"../constants":3,"../errors":5,"./address":60,"./bignumber":63,"./bytes":64,"./properties":74,"./utf8":85}],60:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("bn.js")),o=e("./bytes"),s=e("./keccak256"),a=e("./rlp"),u=e("../errors");function l(e){"string"==typeof e&&e.match(/^0x[0-9A-Fa-f]{40}$/)||u.throwError("invalid address",u.INVALID_ARGUMENT,{arg:"address",value:e});for(var t=(e=e.toLowerCase()).substring(2).split(""),r=new Uint8Array(40),n=0;n<40;n++)r[n]=t[n].charCodeAt(0);r=o.arrayify(s.keccak256(r));for(var i=0;i<40;i+=2)8<=r[i>>1]>>4&&(t[i]=t[i].toUpperCase()),8<=(15&r[i>>1])&&(t[i+1]=t[i+1].toUpperCase());return"0x"+t.join("")}for(var h={},f=0;f<10;f++)h[String(f)]=String(f);for(f=0;f<26;f++)h[String.fromCharCode(65+f)]=String(10+f);var c,d=Math.floor((c=9007199254740991,Math.log10?Math.log10(c):Math.log(c)/Math.LN10));function p(e){e=(e=e.toUpperCase()).substring(4)+e.substring(0,2)+"00";var t="";for(e.split("").forEach(function(e){t+=h[e]});t.length>=d;)var r=t.substring(0,d),t=parseInt(r,10)%97+t.substring(r.length);for(var n=String(98-parseInt(t,10)%97);n.length<2;)n="0"+n;return n}function v(e){var t=null;if("string"!=typeof e&&u.throwError("invalid address",u.INVALID_ARGUMENT,{arg:"address",value:e}),e.match(/^(0x)?[0-9a-fA-F]{40}$/))"0x"!==e.substring(0,2)&&(e="0x"+e),t=l(e),e.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&t!==e&&u.throwError("bad address checksum",u.INVALID_ARGUMENT,{arg:"address",value:e});else if(e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){for(e.substring(2,4)!==p(e)&&u.throwError("bad icap checksum",u.INVALID_ARGUMENT,{arg:"address",value:e}),t=new i.default.BN(e.substring(4),36).toString(16);t.length<40;)t="0"+t;t=l("0x"+t)}else u.throwError("invalid address",u.INVALID_ARGUMENT,{arg:"address",value:e});return t}r.getAddress=v,r.getIcapAddress=function(e){for(var t=new i.default.BN(v(e).substring(2),16).toString(36).toUpperCase();t.length<30;)t="0"+t;return"XE"+p("XE00"+t)+t},r.getContractAddress=function(e){if(!e.from)throw new Error("missing from address");var t=e.nonce;return v("0x"+s.keccak256(a.encode([v(e.from),o.stripZeros(o.hexlify(t))])).substring(26))},r.getCreate2Address=function(e){var t=e.initCodeHash;e.initCode&&(t?s.keccak256(e.initCode)!==t&&u.throwError("initCode/initCodeHash mismatch",u.INVALID_ARGUMENT,{arg:"options",value:e}):t=s.keccak256(e.initCode)),t||u.throwError("missing initCode or initCodeHash",u.INVALID_ARGUMENT,{arg:"options",value:e});var r=v(e.from),n=o.arrayify(e.salt);return 32!==n.length&&u.throwError("invalid salt",u.INVALID_ARGUMENT,{arg:"options",value:e}),v("0x"+s.keccak256(o.concat(["0xff",r,n,t])).substring(26))}},{"../errors":5,"./bytes":64,"./keccak256":71,"./rlp":76,"bn.js":9}],61:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("../utils/bytes");t.exports={decode:function(e){e=atob(e);for(var t=[],r=0;r<e.length;r++)t.push(e.charCodeAt(r));return n.arrayify(t)},encode:function(e){e=n.arrayify(e);for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return btoa(t)}}},{"../utils/bytes":64}],62:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var l=e("./bytes"),n=e("./properties"),i=(o.prototype.encode=function(e){var t=l.arrayify(e);if(0===t.length)return"";for(var r=[0],n=0;n<t.length;++n){for(var i=t[n],o=0;o<r.length;++o)i+=r[o]<<8,r[o]=i%this.base,i=i/this.base|0;for(;0<i;)r.push(i%this.base),i=i/this.base|0}for(var s="",a=0;0===t[a]&&a<t.length-1;++a)s+=this._leader;for(var u=r.length-1;0<=u;--u)s+=this.alphabet[r[u]];return s},o.prototype.decode=function(e){if("string"!=typeof e)throw new TypeError("Expected String");var t=[];if(0===e.length)return new Uint8Array(t);t.push(0);for(var r=0;r<e.length;r++){var n=this._alphabetMap[e[r]];if(void 0===n)throw new Error("Non-base"+this.base+" character");for(var i=n,o=0;o<t.length;++o)i+=t[o]*this.base,t[o]=255&i,i>>=8;for(;0<i;)t.push(255&i),i>>=8}for(var s=0;e[s]===this._leader&&s<e.length-1;++s)t.push(0);return l.arrayify(new Uint8Array(t.reverse()))},o);function o(e){n.defineReadOnly(this,"alphabet",e),n.defineReadOnly(this,"base",e.length),n.defineReadOnly(this,"_alphabetMap",{}),n.defineReadOnly(this,"_leader",e.charAt(0));for(var t=0;t<e.length;t++)this._alphabetMap[e.charAt(t)]=t}var s=new(r.BaseX=i)("abcdefghijklmnopqrstuvwxyz234567");r.Base32=s;var a=new i("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");r.Base58=a},{"./bytes":64,"./properties":74}],63:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var o=n(e("bn.js")),s=e("./bytes"),a=e("./properties"),u=i(e("../errors")),l=new o.default.BN(-1);function h(e){var t=e.toString(16);return"-"===t[0]?t.length%2==0?"-0x0"+t.substring(1):"-0x"+t.substring(1):t.length%2==1?"0x0"+t:"0x"+t}function f(e){return d(y(e))}function c(e){return new p(h(e))}function d(e){var t=e._hex;return"-"===t[0]?new o.default.BN(t.substring(3),16).mul(l):new o.default.BN(t.substring(2),16)}var p=(v.prototype.fromTwos=function(e){return c(d(this).fromTwos(e))},v.prototype.toTwos=function(e){return c(d(this).toTwos(e))},v.prototype.abs=function(){return"-"===this._hex[0]?c(d(this).mul(l)):this},v.prototype.add=function(e){return c(d(this).add(f(e)))},v.prototype.sub=function(e){return c(d(this).sub(f(e)))},v.prototype.div=function(e){return y(e).isZero()&&u.throwError("division by zero",u.NUMERIC_FAULT,{operation:"divide",fault:"division by zero"}),c(d(this).div(f(e)))},v.prototype.mul=function(e){return c(d(this).mul(f(e)))},v.prototype.mod=function(e){return c(d(this).mod(f(e)))},v.prototype.pow=function(e){return c(d(this).pow(f(e)))},v.prototype.maskn=function(e){return c(d(this).maskn(e))},v.prototype.eq=function(e){return d(this).eq(f(e))},v.prototype.lt=function(e){return d(this).lt(f(e))},v.prototype.lte=function(e){return d(this).lte(f(e))},v.prototype.gt=function(e){return d(this).gt(f(e))},v.prototype.gte=function(e){return d(this).gte(f(e))},v.prototype.isZero=function(){return d(this).isZero()},v.prototype.toNumber=function(){try{return d(this).toNumber()}catch(e){u.throwError("overflow",u.NUMERIC_FAULT,{operation:"setValue",fault:"overflow",details:e.message})}return null},v.prototype.toString=function(){return d(this).toString(10)},v.prototype.toHexString=function(){return this._hex},v.isBigNumber=function(e){return a.isType(e,"BigNumber")},v);function v(e){if(u.checkNew(this,v),a.setType(this,"BigNumber"),"string"==typeof e)s.isHexString(e)?("0x"==e&&(e="0x0"),a.defineReadOnly(this,"_hex",e)):"-"===e[0]&&s.isHexString(e.substring(1))?a.defineReadOnly(this,"_hex",e):e.match(/^-?[0-9]*$/)?(""==e&&(e="0"),a.defineReadOnly(this,"_hex",h(new o.default.BN(e)))):u.throwError("invalid BigNumber string value",u.INVALID_ARGUMENT,{arg:"value",value:e});else if("number"==typeof e){parseInt(String(e))!==e&&u.throwError("underflow",u.NUMERIC_FAULT,{operation:"setValue",fault:"underflow",value:e,outputValue:parseInt(String(e))});try{a.defineReadOnly(this,"_hex",h(new o.default.BN(e)))}catch(e){u.throwError("overflow",u.NUMERIC_FAULT,{operation:"setValue",fault:"overflow",details:e.message})}}else e instanceof v?a.defineReadOnly(this,"_hex",e._hex):e.toHexString?a.defineReadOnly(this,"_hex",h(f(e.toHexString()))):e._hex&&s.isHexString(e._hex)?a.defineReadOnly(this,"_hex",e._hex):s.isArrayish(e)?a.defineReadOnly(this,"_hex",h(new o.default.BN(s.hexlify(e).substring(2),16))):u.throwError("invalid BigNumber value",u.INVALID_ARGUMENT,{arg:"value",value:e})}function y(e){return p.isBigNumber(e)?e:new p(e)}r.BigNumber=p,r.bigNumberify=y},{"../errors":5,"./bytes":64,"./properties":74,"bn.js":9}],64:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var a=n(e("../errors"));function s(e){return!!e.toHexString}function u(t){return t.slice||(t.slice=function(){var e=Array.prototype.slice.call(arguments);return u(new Uint8Array(Array.prototype.slice.apply(t,e)))}),t}function l(e){if(!e||parseInt(String(e.length))!=e.length||"string"==typeof e)return!1;for(var t=0;t<e.length;t++){var r=e[t];if(r<0||256<=r||parseInt(String(r))!=r)return!1}return!0}function h(e){if(null==e&&a.throwError("cannot convert null value to array",a.INVALID_ARGUMENT,{arg:"value",value:e}),s(e)&&(e=e.toHexString()),"string"!=typeof e)return l(e)?u(new Uint8Array(e)):(a.throwError("invalid arrayify value",null,{arg:"value",value:e,type:typeof e}),null);var t=e.match(/^(0x)?[0-9a-fA-F]*$/);t||a.throwError("invalid hexidecimal string",a.INVALID_ARGUMENT,{arg:"value",value:e}),"0x"!==t[1]&&a.throwError("hex string must have 0x prefix",a.INVALID_ARGUMENT,{arg:"value",value:e}),(e=e.substring(2)).length%2&&(e="0"+e);for(var r=[],n=0;n<e.length;n+=2)r.push(parseInt(e.substr(n,2),16));return u(new Uint8Array(r))}function i(e){for(var t=[],r=0,n=0;n<e.length;n++){var i=h(e[n]);t.push(i),r+=i.length}for(var o=new Uint8Array(r),s=0,n=0;n<t.length;n++)o.set(t[n],s),s+=t[n].length;return u(o)}function o(e,t){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))&&(!t||e.length===2+2*t)}r.isHexable=s,r.isArrayish=l,r.arrayify=h,r.concat=i,r.stripZeros=function(e){var t=h(e);if(0===t.length)return t;for(var r=0;0===t[r];)r++;return r&&(t=t.slice(r)),t},r.padZeros=function(e,t){if(t<(e=h(e)).length)throw new Error("cannot pad");var r=new Uint8Array(t);return r.set(e,t-e.length),u(r)},r.isHexString=o;var f="0123456789abcdef";function c(e){if(s(e))return e.toHexString();if("number"==typeof e){e<0&&a.throwError("cannot hexlify negative value",a.INVALID_ARGUMENT,{arg:"value",value:e}),9007199254740991<=e&&a.throwError("out-of-range",a.NUMERIC_FAULT,{operartion:"hexlify",fault:"out-of-safe-range"});for(var t="";e;)t=f[15&e]+t,e=Math.floor(e/16);return t.length?(t.length%2&&(t="0"+t),"0x"+t):"0x00"}if("string"==typeof e){var r=e.match(/^(0x)?[0-9a-fA-F]*$/);return r||a.throwError("invalid hexidecimal string",a.INVALID_ARGUMENT,{arg:"value",value:e}),"0x"!==r[1]&&a.throwError("hex string must have 0x prefix",a.INVALID_ARGUMENT,{arg:"value",value:e}),e.length%2&&(e="0x0"+e.substring(2)),e}if(l(e)){for(var n=[],i=0;i<e.length;i++){var o=e[i];n.push(f[(240&o)>>4]+f[15&o])}return"0x"+n.join("")}return a.throwError("invalid hexlify value",null,{arg:"value",value:e}),"never"}function d(e,t){for(o(e)||a.throwError("invalid hex string",a.INVALID_ARGUMENT,{arg:"value",value:e});e.length<2*t+2;)e="0x0"+e.substring(2);return e}function p(e){var t,r=0,n="0x",i="0x";if((t=e)&&null!=t.r&&null!=t.s){null==e.v&&null==e.recoveryParam&&a.throwError("at least on of recoveryParam or v must be specified",a.INVALID_ARGUMENT,{argument:"signature",value:e}),n=d(e.r,32),i=d(e.s,32),"string"==typeof(r=e.v)&&(r=parseInt(r,16));var o=e.recoveryParam;null==o&&null!=e.v&&(o=1-r%2),r=27+o}else{var s=h(e);if(65!==s.length)throw new Error("invalid signature");n=c(s.slice(0,32)),i=c(s.slice(32,64)),27!==(r=s[64])&&28!==r&&(r=27+r%2)}return{r:n,s:i,recoveryParam:r-27,v:r}}r.hexlify=c,r.hexDataLength=function(e){return o(e)&&e.length%2==0?(e.length-2)/2:null},r.hexDataSlice=function(e,t,r){return o(e)||a.throwError("invalid hex data",a.INVALID_ARGUMENT,{arg:"value",value:e}),e.length%2!=0&&a.throwError("hex data length must be even",a.INVALID_ARGUMENT,{arg:"value",value:e}),t=2+2*t,null!=r?"0x"+e.substring(t,2+2*r):"0x"+e.substring(t)},r.hexStripZeros=function(e){for(o(e)||a.throwError("invalid hex string",a.INVALID_ARGUMENT,{arg:"value",value:e});3<e.length&&"0x0"===e.substring(0,3);)e="0x"+e.substring(3);return e},r.hexZeroPad=d,r.splitSignature=p,r.joinSignature=function(e){return c(i([(e=p(e)).r,e.s,e.recoveryParam?"0x1c":"0x1b"]))}},{"../errors":5}],65:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("../errors")),o=e("./bytes"),s=e("./utf8"),a=e("./keccak256"),u=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),l=new RegExp("^((.*)\\.)?([^.]+)$"),h=new RegExp("^[a-z0-9.-]*$");r.namehash=function(e){"string"!=typeof e&&i.throwError("invalid address - "+String(e),i.INVALID_ARGUMENT,{argument:"name",value:e}),(e=e.toLowerCase()).match(h)||i.throwError("contains invalid UseSTD3ASCIIRules characters",i.INVALID_ARGUMENT,{argument:"name",value:e});for(var t=u;e.length;){var r=e.match(l),n=s.toUtf8Bytes(r[3]),t=a.keccak256(o.concat([t,a.keccak256(n)]));e=r[2]||""}return o.hexlify(t)},r.id=function(e){return a.keccak256(s.toUtf8Bytes(e))},r.hashMessage=function(e){return a.keccak256(o.concat([s.toUtf8Bytes("\x19Ethereum Signed Message:\n"),s.toUtf8Bytes(String(e.length)),"string"==typeof e?s.toUtf8Bytes(e):e]))}},{"../errors":5,"./bytes":64,"./keccak256":71,"./utf8":85}],66:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var f=n(e("../errors")),c=e("../wordlists/lang-en"),a=e("./basex"),d=e("./bytes"),l=e("./bignumber"),i=e("./utf8"),o=e("./pbkdf2"),h=e("./hmac"),p=e("./properties"),v=e("./secp256k1"),y=e("./sha2"),m=l.bigNumberify("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),s=i.toUtf8Bytes("Bitcoin seed"),g=2147483648;function b(e){return(1<<e)-1<<8-e}function w(e){return d.hexZeroPad(d.hexlify(e),32)}function u(e){var t=d.hexDataSlice(y.sha256(y.sha256(e)),0,4);return a.Base58.encode(d.concat([e,t]))}var _={};r.defaultPath="m/44'/60'/0'/0/0";var M=(Object.defineProperty(A.prototype,"extendedKey",{get:function(){if(256<=this.depth)throw new Error("Depth too large!");return u(d.concat([null!=this.privateKey?"0x0488ADE4":"0x0488B21E",d.hexlify(this.depth),this.parentFingerprint,d.hexZeroPad(d.hexlify(this.index),4),this.chainCode,null!=this.privateKey?d.concat(["0x00",this.privateKey]):this.publicKey]))},enumerable:!0,configurable:!0}),A.prototype.neuter=function(){return new A(_,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,null,this.path)},A.prototype._derive=function(e){if(4294967295<e)throw new Error("invalid index - "+String(e));var t=this.path;t&&(t+="/"+(e&~g));var r=new Uint8Array(37);if(e&g){if(!this.privateKey)throw new Error("cannot derive child of neutered node");r.set(d.arrayify(this.privateKey),1),t&&(t+="'")}else r.set(d.arrayify(this.publicKey));for(var n=24;0<=n;n-=8)r[33+(n>>3)]=e>>24-n&255;var i=h.computeHmac(h.SupportedAlgorithms.sha512,this.chainCode,r),o=i.slice(0,32),s=i.slice(32),a=null,u=null;return this.privateKey?a=w(l.bigNumberify(o).add(this.privateKey).mod(m)):u=new v.KeyPair(d.hexlify(o))._addPoint(this.publicKey),new A(_,a,u,this.fingerprint,w(s),e,this.depth+1,this.mnemonic,t)},A.prototype.derivePath=function(e){var t=e.split("/");if(0===t.length||"m"===t[0]&&0!==this.depth)throw new Error("invalid path - "+e);"m"===t[0]&&t.shift();for(var r=this,n=0;n<t.length;n++){var i=t[n];if(i.match(/^[0-9]+'$/)){var o=parseInt(i.substring(0,i.length-1));if(g<=o)throw new Error("invalid path index - "+i);r=r._derive(g+o)}else{if(!i.match(/^[0-9]+$/))throw new Error("invalid path component - "+i);o=parseInt(i);if(g<=o)throw new Error("invalid path index - "+i);r=r._derive(o)}}return r},A.isHDNode=function(e){return p.isType(e,"HDNode")},A);function A(e,t,r,n,i,o,s,a,u){if(f.checkNew(this,A),e!==_)throw new Error("HDNode constructor cannot be called directly");var l;t?(l=new v.KeyPair(t),p.defineReadOnly(this,"privateKey",l.privateKey),p.defineReadOnly(this,"publicKey",l.compressedPublicKey)):(p.defineReadOnly(this,"privateKey",null),p.defineReadOnly(this,"publicKey",d.hexlify(r))),p.defineReadOnly(this,"parentFingerprint",n),p.defineReadOnly(this,"fingerprint",d.hexDataSlice(y.ripemd160(y.sha256(this.publicKey)),0,4)),p.defineReadOnly(this,"address",v.computeAddress(this.publicKey)),p.defineReadOnly(this,"chainCode",i),p.defineReadOnly(this,"index",o),p.defineReadOnly(this,"depth",s),p.defineReadOnly(this,"mnemonic",a),p.defineReadOnly(this,"path",u),p.setType(this,"HDNode")}function E(e,t){var r=d.arrayify(e);if(r.length<16||64<r.length)throw new Error("invalid seed");var n=d.arrayify(h.computeHmac(h.SupportedAlgorithms.sha512,s,r));return new M(_,w(n.slice(0,32)),null,"0x00000000",w(n.slice(32)),0,0,t,"m")}function S(e,t){t=t||"";var r=i.toUtf8Bytes("mnemonic"+t,i.UnicodeNormalizationForm.NFKD);return d.hexlify(o.pbkdf2(i.toUtf8Bytes(e,i.UnicodeNormalizationForm.NFKD),r,2048,64,"sha512"))}function k(e,t){t=t||c.langEn,f.checkNormalize();var r=t.split(e);if(r.length%3!=0)throw new Error("invalid mnemonic");for(var n=d.arrayify(new Uint8Array(Math.ceil(11*r.length/8))),i=0,o=0;o<r.length;o++){var s=t.getWordIndex(r[o].normalize("NFKD"));if(-1===s)throw new Error("invalid mnemonic");for(var a=0;a<11;a++)s&1<<10-a&&(n[i>>3]|=1<<7-i%8),i++}var u=32*r.length/3,l=b(r.length/3),h=d.arrayify(y.sha256(n.slice(0,u/8)))[0];if((h&=l)!=(n[n.length-1]&l))throw new Error("invalid checksum");return d.hexlify(n.slice(0,u/8))}function N(e,t){if((e=d.arrayify(e)).length%4!=0||e.length<16||32<e.length)throw new Error("invalid entropy");for(var r=[0],n=11,i=0;i<e.length;i++)8<n?(r[r.length-1]<<=8,r[r.length-1]|=e[i],n-=8):(r[r.length-1]<<=n,r[r.length-1]|=e[i]>>8-n,r.push(e[i]&(1<<8-n)-1),n+=3);var o=d.arrayify(y.sha256(e))[0],s=e.length/4;return o&=b(s),r[r.length-1]<<=s,r[r.length-1]|=o>>8-s,(t=t||c.langEn).join(r.map(function(e){return t.getWord(e)}))}r.HDNode=M,r.fromExtendedKey=function(e){var t=a.Base58.decode(e);82===t.length&&u(t.slice(0,78))===e||f.throwError("invalid extended key",f.INVALID_ARGUMENT,{argument:"extendedKey",value:"[REDACTED]"});var r=t[4],n=d.hexlify(t.slice(5,9)),i=parseInt(d.hexlify(t.slice(9,13)).substring(2),16),o=d.hexlify(t.slice(13,45)),s=t.slice(45,78);switch(d.hexlify(t.slice(0,4))){case"0x0488b21e":case"0x043587cf":return new M(_,null,d.hexlify(s),n,o,i,r,null,null);case"0x0488ade4":case"0x04358394":if(0!==s[0])break;return new M(_,d.hexlify(s.slice(1)),null,n,o,i,r,null,null)}return f.throwError("invalid extended key",f.INVALID_ARGUMENT,{argument:"extendedKey",value:"[REDACTED]"})},r.fromMnemonic=function(e,t,r){return E(S(e=N(k(e,t),t),r),e)},r.fromSeed=function(e){return E(e,null)},r.mnemonicToSeed=S,r.mnemonicToEntropy=k,r.entropyToMnemonic=N,r.isValidMnemonic=function(e,t){try{return k(e,t),!0}catch(e){}return!1}},{"../errors":5,"../wordlists/lang-en":90,"./basex":62,"./bignumber":63,"./bytes":64,"./hmac":67,"./pbkdf2":73,"./properties":74,"./secp256k1":77,"./sha2":79,"./utf8":85}],67:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i,o,s=n(e("hash.js")),a=e("../utils/bytes"),u=n(e("../errors"));(o=i=r.SupportedAlgorithms||(r.SupportedAlgorithms={})).sha256="sha256",o.sha512="sha512",r.computeHmac=function(e,t,r){return i[e]||u.throwError("unsupported algorithm "+e,u.UNSUPPORTED_OPERATION,{operation:"hmac",algorithm:e}),a.arrayify(s.hmac(s[e],a.arrayify(t)).update(a.arrayify(r)).digest())}},{"../errors":5,"../utils/bytes":64,"hash.js":26}],68:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("./abi-coder");r.AbiCoder=i.AbiCoder,r.defaultAbiCoder=i.defaultAbiCoder,r.formatSignature=i.formatSignature,r.formatParamType=i.formatParamType,r.parseSignature=i.parseSignature,r.parseParamType=i.parseParamType;var o=e("./address");r.getAddress=o.getAddress,r.getContractAddress=o.getContractAddress,r.getCreate2Address=o.getCreate2Address,r.getIcapAddress=o.getIcapAddress;var s=n(e("./base64"));r.base64=s;var a=e("./bignumber");r.BigNumber=a.BigNumber,r.bigNumberify=a.bigNumberify;var u=e("./bytes");r.arrayify=u.arrayify,r.concat=u.concat,r.hexDataSlice=u.hexDataSlice,r.hexDataLength=u.hexDataLength,r.hexlify=u.hexlify,r.hexStripZeros=u.hexStripZeros,r.hexZeroPad=u.hexZeroPad,r.isHexString=u.isHexString,r.joinSignature=u.joinSignature,r.padZeros=u.padZeros,r.splitSignature=u.splitSignature,r.stripZeros=u.stripZeros;var l=e("./hash");r.hashMessage=l.hashMessage,r.id=l.id,r.namehash=l.namehash;var h=n(e("./hdnode"));r.HDNode=h;var f=e("./interface");r.Interface=f.Interface;var c=e("./json-wallet");r.getJsonWalletAddress=c.getJsonWalletAddress;var d=e("./keccak256");r.keccak256=d.keccak256;var p=e("./sha2");r.sha256=p.sha256;var v=e("./solidity");r.solidityKeccak256=v.keccak256,r.solidityPack=v.pack,r.soliditySha256=v.sha256;var y=e("./random-bytes");r.randomBytes=y.randomBytes;var m=e("./networks");r.getNetwork=m.getNetwork;var g=e("./properties");r.checkProperties=g.checkProperties,r.deepCopy=g.deepCopy,r.defineReadOnly=g.defineReadOnly,r.resolveProperties=g.resolveProperties,r.shallowCopy=g.shallowCopy;var b=n(e("./rlp"));r.RLP=b;var w=e("./secp256k1");r.computeAddress=w.computeAddress,r.computePublicKey=w.computePublicKey,r.recoverAddress=w.recoverAddress,r.recoverPublicKey=w.recoverPublicKey,r.verifyMessage=w.verifyMessage;var _=e("./signing-key");r.SigningKey=_.SigningKey;var M=e("./transaction");r.populateTransaction=M.populateTransaction;var A=e("./transaction");r.parseTransaction=A.parse,r.serializeTransaction=A.serialize;var E=e("./utf8");r.formatBytes32String=E.formatBytes32String,r.parseBytes32String=E.parseBytes32String,r.toUtf8Bytes=E.toUtf8Bytes,r.toUtf8String=E.toUtf8String;var S=e("./units");r.commify=S.commify,r.formatEther=S.formatEther,r.parseEther=S.parseEther,r.formatUnits=S.formatUnits,r.parseUnits=S.parseUnits;var k=e("./web");r.fetchJson=k.fetchJson,r.poll=k.poll;var N=e("./hmac");r.SupportedAlgorithms=N.SupportedAlgorithms;var x=e("./utf8");r.UnicodeNormalizationForm=x.UnicodeNormalizationForm;var P=e("./wordlist");r.Wordlist=P.Wordlist},{"./abi-coder":59,"./address":60,"./base64":61,"./bignumber":63,"./bytes":64,"./hash":65,"./hdnode":66,"./hmac":67,"./interface":69,"./json-wallet":70,"./keccak256":71,"./networks":72,"./properties":74,"./random-bytes":75,"./rlp":76,"./secp256k1":77,"./sha2":79,"./signing-key":81,"./solidity":82,"./transaction":83,"./units":84,"./utf8":85,"./web":86,"./wordlist":87}],69:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});function s(e){for(var t in p.setType(this,"Description"),e)p.defineReadOnly(this,t,p.deepCopy(e[t],!0));Object.freeze(this)}var a,u=e("./address"),f=e("./abi-coder"),l=e("./bignumber"),c=e("./bytes"),h=e("./hash"),d=e("./keccak256"),p=e("./properties"),v=o(e("../errors")),y=function(e){p.setType(this,"Indexed"),p.defineReadOnly(this,"hash",e)},m=(i(g,a=s),g.prototype.encode=function(e,t){c.isHexString(e)||v.throwError("invalid contract bytecode",v.INVALID_ARGUMENT,{arg:"bytecode",value:e}),v.checkArgumentCount(t.length,this.inputs.length," in Interface constructor");try{return e+f.defaultAbiCoder.encode(this.inputs,t).substring(2)}catch(e){v.throwError("invalid constructor argument",v.INVALID_ARGUMENT,{arg:e.arg,reason:e.reason,value:e.value})}return null},g);function g(){return null!==a&&a.apply(this,arguments)||this}var b,w=(i(_,b=s),_.prototype.encode=function(e){v.checkArgumentCount(e.length,this.inputs.length," in interface function "+this.name);try{return this.sighash+f.defaultAbiCoder.encode(this.inputs,e).substring(2)}catch(e){v.throwError("invalid input argument",v.INVALID_ARGUMENT,{arg:e.arg,reason:e.reason,value:e.value})}return null},_.prototype.decode=function(t){try{return f.defaultAbiCoder.decode(this.outputs,c.arrayify(t))}catch(e){v.throwError("invalid data for function output",v.INVALID_ARGUMENT,{arg:"data",errorArg:e.arg,errorValue:e.value,value:t,reason:e.reason})}},_);function _(){return null!==b&&b.apply(this,arguments)||this}var M,A=(i(E,M=s),E);function E(){return null!==M&&M.apply(this,arguments)||this}var S,k=(i(N,S=s),N.prototype.encodeTopics=function(e){var n=this;e.length>this.inputs.length&&v.throwError("too many arguments for "+this.name,v.UNEXPECTED_ARGUMENT,{maxCount:e.length,expectedCount:this.inputs.length});var i=[];for(this.anonymous||i.push(this.topic),e.forEach(function(e,t){var r=n.inputs[t];r.indexed?null==e?i.push(null):"string"===r.type?i.push(h.id(e)):"bytes"===r.type?i.push(d.keccak256(e)):-1!==r.type.indexOf("[")||"tuple"===r.type.substring(0,5)?v.throwError("filtering with tuples or arrays not implemented yet; bug us on GitHub",v.NOT_IMPLEMENTED,{operation:"filter(array|tuple)"}):("address"===r.type&&u.getAddress(e),i.push(c.hexZeroPad(c.hexlify(e),32).toLowerCase())):null!=e&&v.throwError("cannot filter non-indexed parameters; must be null",v.INVALID_ARGUMENT,{argument:r.name||t,value:e})});i.length&&null===i[i.length-1];)i.pop();return i},N.prototype.decode=function(e,r){null==r||this.anonymous||(r=r.slice(1));var n,i=[],o=[],s=[];this.inputs.forEach(function(e,t){e.indexed?"string"===e.type||"bytes"===e.type||0<=e.type.indexOf("[")||"tuple"===e.type.substring(0,5)?(i.push({type:"bytes32",name:e.name||""}),s.push(!0)):(i.push(e),s.push(!1)):(o.push(e),s.push(!1))}),null!=r&&(n=f.defaultAbiCoder.decode(i,c.concat(r)));var a=f.defaultAbiCoder.decode(o,c.arrayify(e)),u={},l=0,h=0;return this.inputs.forEach(function(e,t){e.indexed?null==r?u[t]=new y(null):s[t]?u[t]=new y(n[h++]):u[t]=n[h++]:u[t]=a[l++],e.name&&(u[e.name]=u[t])}),u.length=this.inputs.length,new A(u)},N);function N(){return null!==S&&S.apply(this,arguments)||this}var x,P=(i(I,x=s),I);function I(){return null!==x&&x.apply(this,arguments)||this}var T,R=(i(O,T=s),O);function O(){return null!==T&&T.apply(this,arguments)||this}function C(e){switch(e.type){case"constructor":var t=new m({inputs:e.inputs,payable:null==e.payable||!!e.payable});this.deployFunction||(this.deployFunction=t);break;case"function":var r=f.formatSignature(e).replace(/tuple/g,""),n=h.id(r).substring(0,10),i=!1;null!=e.constant?i=e.constant:null!=e.stateMutability&&(i="view"==e.stateMutability||"pure"==e.stateMutability);t=new w({inputs:e.inputs,outputs:e.outputs,gas:e.gas,payable:null==e.payable||!!e.payable,type:i?"call":"transaction",name:e.name,signature:r,sighash:n});e.name&&(null==this.functions[e.name]?p.defineReadOnly(this.functions,e.name,t):v.warn("WARNING: Multiple definitions for "+e.name)),null==this.functions[t.signature]&&p.defineReadOnly(this.functions,t.signature,t);break;case"event":r=f.formatSignature(e).replace(/tuple/g,""),t=new k({name:e.name,signature:r,inputs:e.inputs,topic:h.id(r),anonymous:!!e.anonymous});e.name&&null==this.events[e.name]&&p.defineReadOnly(this.events,e.name,t),null==this.events[t.signature]&&p.defineReadOnly(this.events,t.signature,t);break;case"receive":case"fallback":break;default:v.warn("WARNING: unsupported ABI type - "+e.type)}}var L=(B.prototype.parseTransaction=function(e){var t=e.data.substring(0,10).toLowerCase();for(var r in this.functions)if(-1!==r.indexOf("(")){var n=this.functions[r];if(n.sighash===t){var i=f.defaultAbiCoder.decode(n.inputs,"0x"+e.data.substring(10));return new P({args:i,decode:n.decode,name:n.name,signature:n.signature,sighash:n.sighash,value:l.bigNumberify(e.value||"0")})}}return null},B.prototype.parseLog=function(e){for(var t in this.events)if(-1!==t.indexOf("(")){var r=this.events[t];if(!r.anonymous&&r.topic===e.topics[0])return new R({decode:r.decode,name:r.name,signature:r.signature,topic:r.topic,values:r.decode(e.data,e.topics)})}return null},B.isInterface=function(e){return p.isType(e,"Interface")},B.isIndexed=function(e){return p.isType(e,"Indexed")},B);function B(t){if(v.checkNew(this,B),"string"==typeof t){try{t=JSON.parse(t)}catch(e){v.throwError("could not parse ABI JSON",v.INVALID_ARGUMENT,{arg:"abi",errorMessage:e.message,value:t})}if(!Array.isArray(t))return v.throwError("invalid abi",v.INVALID_ARGUMENT,{arg:"abi",value:t}),null}p.defineReadOnly(this,"functions",{}),p.defineReadOnly(this,"events",{});var r=[];t.forEach(function(e){"string"==typeof e&&(e=f.parseSignature(e)),r.push(e)}),p.defineReadOnly(this,"abi",p.deepCopy(r,!0)),r.forEach(C,this),this.deployFunction||C.call(this,{type:"constructor",inputs:[]}),p.setType(this,"Interface")}r.Interface=L},{"../errors":5,"./abi-coder":59,"./address":60,"./bignumber":63,"./bytes":64,"./hash":65,"./keccak256":71,"./properties":74}],70:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("./address");function i(e){try{var t=JSON.parse(e)}catch(e){return!1}return t.encseed&&t.ethaddr}function o(e){try{var t=JSON.parse(e)}catch(e){return!1}return!(!t.version||parseInt(t.version)!==t.version||3!==parseInt(t.version))}r.isCrowdsaleWallet=i,r.isSecretStorageWallet=o,r.getJsonWalletAddress=function(e){if(i(e))try{return n.getAddress(JSON.parse(e).ethaddr)}catch(e){return null}if(o(e))try{return n.getAddress(JSON.parse(e).address)}catch(e){return null}return null}},{"./address":60}],71:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("js-sha3"),i=e("./bytes");r.keccak256=function(e){return"0x"+n.keccak_256(i.arrayify(e))}},{"./bytes":64,"js-sha3":40}],72:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var o=n(e("../errors"));function i(r){return function(e){var t=[];return e.InfuraProvider&&t.push(new e.InfuraProvider(r)),e.EtherscanProvider&&t.push(new e.EtherscanProvider(r)),0===t.length?null:e.FallbackProvider?new e.FallbackProvider(t):t[0]}}function s(t,r){return function(e){return e.JsonRpcProvider?new e.JsonRpcProvider(t,r):null}}var a={chainId:1,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"homestead",_defaultProvider:i("homestead")},u={chainId:3,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"ropsten",_defaultProvider:i("ropsten")},l={unspecified:{chainId:0,name:"unspecified"},homestead:a,mainnet:a,morden:{chainId:2,name:"morden"},ropsten:u,testnet:u,rinkeby:{chainId:4,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"rinkeby",_defaultProvider:i("rinkeby")},goerli:{chainId:5,ensAddress:"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",name:"goerli",_defaultProvider:i("goerli")},kovan:{chainId:42,name:"kovan",_defaultProvider:i("kovan")},classic:{chainId:61,name:"classic",_defaultProvider:s("https://web3.gastracker.io","classic")},classicTestnet:{chainId:62,name:"classicTestnet",_defaultProvider:s("https://web3.gastracker.io/morden","classicTestnet")}};r.getNetwork=function(e){if(null==e)return null;if("number"==typeof e){for(var t in l){var r=l[t];if(r.chainId===e)return{name:r.name,chainId:r.chainId,ensAddress:r.ensAddress||null,_defaultProvider:r._defaultProvider||null}}return{chainId:e,name:"unknown"}}if("string"==typeof e){var n=l[e];return null==n?null:{name:n.name,chainId:n.chainId,ensAddress:n.ensAddress,_defaultProvider:n._defaultProvider||null}}var i=l[e.name];return i?(0!==e.chainId&&e.chainId!==i.chainId&&o.throwError("network chainId mismatch",o.INVALID_ARGUMENT,{arg:"network",value:e}),{name:e.name,chainId:i.chainId,ensAddress:e.ensAddress||i.ensAddress||null,_defaultProvider:e._defaultProvider||i._defaultProvider||null}):("number"!=typeof e.chainId&&o.throwError("invalid network chainId",o.INVALID_ARGUMENT,{arg:"network",value:e}),e)}},{"../errors":5}],73:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var m=e("../utils/bytes"),g=e("./hmac");r.pbkdf2=function(e,t,r,n,i){var o;e=m.arrayify(e),t=m.arrayify(t);var s,a,u=1,l=new Uint8Array(n),h=new Uint8Array(t.length+4);h.set(t);for(var f=1;f<=u;f++){h[t.length]=f>>24&255,h[t.length+1]=f>>16&255,h[t.length+2]=f>>8&255,h[t.length+3]=255&f;var c=g.computeHmac(i,e,h);o||(o=c.length,a=new Uint8Array(o),s=n-((u=Math.ceil(n/o))-1)*o),a.set(c);for(var d=1;d<r;d++){c=g.computeHmac(i,e,c);for(var p=0;p<o;p++)a[p]^=c[p]}var v=(f-1)*o,y=f===u?s:o;l.set(m.arrayify(a).slice(0,y),v)}return m.arrayify(l)}},{"../utils/bytes":64,"./hmac":67}],74:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("../errors"));function s(e,t,r){Object.defineProperty(e,t,{enumerable:!0,value:r,writable:!1})}function a(e,t){return e&&e._ethersType===t}r.defineReadOnly=s,r.setType=function(e,t){Object.defineProperty(e,"_ethersType",{configurable:!1,value:t,writable:!1})},r.isType=a,r.resolveProperties=function(r){var n={},i=[];return Object.keys(r).forEach(function(t){var e=r[t];e instanceof Promise?i.push(e.then(function(e){return n[t]=e,null})):n[t]=e}),Promise.all(i).then(function(){return n})},r.checkProperties=function(t,r){t&&"object"==typeof t||i.throwError("invalid object",i.INVALID_ARGUMENT,{argument:"object",value:t}),Object.keys(t).forEach(function(e){r[e]||i.throwError("invalid object key - "+e,i.INVALID_ARGUMENT,{argument:"transaction",value:t,key:e})})},r.shallowCopy=function(e){var t={};for(var r in e)t[r]=e[r];return t};var u={boolean:!0,number:!0,string:!0};r.deepCopy=function t(e,r){if(null==e||u[typeof e])return e;if(Array.isArray(e)){var n=e.map(function(e){return t(e,r)});return r&&Object.freeze(n),n}if("object"==typeof e){if(a(e,"BigNumber"))return e;if(a(e,"Description"))return e;if(a(e,"Indexed"))return e;for(var i in n={},e){var o=e[i];void 0!==o&&s(n,i,t(o,r))}return r&&Object.freeze(n),n}if("function"==typeof e)return e;throw new Error("Cannot deepCopy "+typeof e)},r.inheritable=function n(i){return function(e){var t,r;r=i,(t=e).super_=r,t.prototype=Object.create(r.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),s(e,"inherits",n(e))}}},{"../errors":5}],75:[function(o,e,s){(function(e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var r=o("../utils/bytes"),t=o("../utils/properties"),n=e.crypto||e.msCrypto;function i(e){if(e<=0||1024<e||parseInt(String(e))!=e)throw new Error("invalid length");var t=new Uint8Array(e);return n.getRandomValues(t),r.arrayify(t)}n&&n.getRandomValues||(console.log("WARNING: Missing strong random number source; using weak randomBytes"),n={getRandomValues:function(e){for(var t=0;t<20;t++)for(var r=0;r<e.length;r++)t?e[r]^=Math.trunc(256*Math.random()):e[r]=Math.trunc(256*Math.random());return e},_weakCrypto:!0}),s.randomBytes=i,!0===n._weakCrypto&&t.defineReadOnly(i,"_weakCrypto",!0)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../utils/bytes":64,"../utils/properties":74}],76:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var o=e("./bytes");function s(e){for(var t=[];e;)t.unshift(255&e),e>>=8;return t}function i(e,t,r){for(var n=0,i=0;i<r;i++)n=256*n+e[t+i];return n}function a(e,t,r,n){for(var i=[];r<t+1+n;){var o=u(e,r);if(i.push(o.result),t+1+n<(r+=o.consumed))throw new Error("invalid rlp")}return{consumed:1+n,result:i}}function u(e,t){if(0===e.length)throw new Error("invalid rlp data");if(248<=e[t]){if(t+1+(r=e[t]-247)>e.length)throw new Error("too short");if(t+1+r+(n=i(e,t+1,r))>e.length)throw new Error("to short");return a(e,t,t+1+r,r+n)}if(192<=e[t]){if(t+1+(n=e[t]-192)>e.length)throw new Error("invalid rlp data");return a(e,t,t+1,n)}if(184<=e[t]){var r;if(t+1+(r=e[t]-183)>e.length)throw new Error("invalid rlp data");if(t+1+r+(n=i(e,t+1,r))>e.length)throw new Error("invalid rlp data");return{consumed:1+r+n,result:o.hexlify(e.slice(t+1+r,t+1+r+n))}}if(128<=e[t]){var n;if(t+1+(n=e[t]-128)>e.length)throw new Error("invalid rlp data");return{consumed:1+n,result:o.hexlify(e.slice(t+1,t+1+n))}}return{consumed:1,result:o.hexlify(e[t])}}r.encode=function(e){return o.hexlify(function t(e){if(Array.isArray(e)){var r=[];return e.forEach(function(e){r=r.concat(t(e))}),r.length<=55?(r.unshift(192+r.length),r):((n=s(r.length)).unshift(247+n.length),n.concat(r))}var n,i=Array.prototype.slice.call(o.arrayify(e));return 1===i.length&&i[0]<=127?i:i.length<=55?(i.unshift(128+i.length),i):((n=s(i.length)).unshift(183+n.length),n.concat(i))}(e))},r.decode=function(e){var t=o.arrayify(e),r=u(t,0);if(r.consumed!==t.length)throw new Error("invalid rlp data");return r.result}},{"./bytes":64}],77:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("elliptic"),o=e("./address"),s=e("./bytes"),a=e("./hash"),u=e("./keccak256"),l=e("./properties"),h=n(e("../errors")),f=null;function c(){return f=f||new i.ec("secp256k1")}var d=(p.prototype.sign=function(e){var t=c().keyFromPrivate(s.arrayify(this.privateKey)).sign(s.arrayify(e),{canonical:!0});return{recoveryParam:t.recoveryParam,r:s.hexZeroPad("0x"+t.r.toString(16),32),s:s.hexZeroPad("0x"+t.s.toString(16),32),v:27+t.recoveryParam}},p.prototype.computeSharedSecret=function(e){var t=c().keyFromPrivate(s.arrayify(this.privateKey)),r=c().keyFromPublic(s.arrayify(v(e)));return s.hexZeroPad("0x"+t.derive(r.getPublic()).toString(16),32)},p.prototype._addPoint=function(e){var t=c().keyFromPublic(s.arrayify(this.publicKey)),r=c().keyFromPublic(s.arrayify(e));return"0x"+t.pub.add(r.pub).encodeCompressed("hex")},p);function p(e){var t=c().keyFromPrivate(s.arrayify(e));l.defineReadOnly(this,"privateKey",s.hexlify(t.priv.toArray("be",32))),l.defineReadOnly(this,"publicKey","0x"+t.getPublic(!1,"hex")),l.defineReadOnly(this,"compressedPublicKey","0x"+t.getPublic(!0,"hex")),l.defineReadOnly(this,"publicKeyBytes",t.getPublic().encode(null,!0))}function v(e,t){var r=s.arrayify(e);if(32!==r.length)return 33===r.length?t?s.hexlify(r):"0x"+c().keyFromPublic(r).getPublic(!1,"hex"):65===r.length?t?"0x"+c().keyFromPublic(r).getPublic(!0,"hex"):s.hexlify(r):(h.throwError("invalid public or private key",h.INVALID_ARGUMENT,{arg:"key",value:"[REDACTED]"}),null);var n=new d(r);return t?n.compressedPublicKey:n.publicKey}function y(e){var t="0x"+v(e).slice(4);return o.getAddress("0x"+u.keccak256(t).substring(26))}function m(e,t){var r=s.splitSignature(t),n={r:s.arrayify(r.r),s:s.arrayify(r.s)};return"0x"+c().recoverPubKey(s.arrayify(e),n,r.recoveryParam).encode("hex",!1)}function g(e,t){return y(m(s.arrayify(e),t))}r.KeyPair=d,r.computePublicKey=v,r.computeAddress=y,r.recoverPublicKey=m,r.recoverAddress=g,r.verifyMessage=function(e,t){return g(a.hashMessage(e),t)}},{"../errors":5,"./address":60,"./bytes":64,"./hash":65,"./keccak256":71,"./properties":74,elliptic:12}],78:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var R=n(e("aes-js")),y=n(e("scrypt-js")),O=n(e("uuid")),C=e("./signing-key"),g=i(e("./hdnode")),b=e("./address"),L=e("./bytes"),w=e("./pbkdf2"),B=e("./keccak256"),p=e("./utf8"),D=e("./random-bytes");function _(e){return"string"==typeof e&&"0x"!==e.substring(0,2)&&(e="0x"+e),L.arrayify(e)}function U(e,t){for(e=String(e);e.length<t;)e="0"+e;return e}function F(e){return"string"==typeof e?p.toUtf8Bytes(e,p.UnicodeNormalizationForm.NFKC):L.arrayify(e)}function M(e,t){for(var r=e,n=t.toLowerCase().split("/"),i=0;i<n.length;i++){var o=null;for(var s in r)if(s.toLowerCase()===n[i]){o=r[s];break}if(null===o)return null;r=o}return r}r.decryptCrowdsale=function(e,t){var r=JSON.parse(e);t=F(t);var n=b.getAddress(M(r,"ethaddr")),i=_(M(r,"encseed"));if(!i||i.length%16!=0)throw new Error("invalid encseed");for(var o=w.pbkdf2(t,t,2e3,32,"sha256").slice(0,16),s=i.slice(0,16),a=i.slice(16),u=new R.default.ModeOfOperation.cbc(o,s),l=L.arrayify(u.decrypt(a)),l=R.default.padding.pkcs7.strip(l),h="",f=0;f<l.length;f++)h+=String.fromCharCode(l[f]);var c=p.toUtf8Bytes(h),d=new C.SigningKey(B.keccak256(c));if(d.address!==n)throw new Error("corrupt crowdsale wallet");return d},r.decrypt=function(e,t,d){function p(e,t){var r,n,i=_(M(m,"crypto/ciphertext"));if(L.hexlify((r=e.slice(16,32),n=i,B.keccak256(L.concat([r,n])))).substring(2)!==M(m,"crypto/mac").toLowerCase())return t(new Error("invalid password")),null;var o=function(e,t){if("aes-128-ctr"!==M(m,"crypto/cipher"))return null;var r=_(M(m,"crypto/cipherparams/iv")),n=new R.default.Counter(r),i=new R.default.ModeOfOperation.ctr(e,n);return L.arrayify(i.decrypt(t))}(e.slice(0,16),i),s=e.slice(32,64);if(!o)return t(new Error("unsupported cipher")),null;var a=new C.SigningKey(o);if(m.address&&a.address!==b.getAddress(m.address))return t(new Error("address mismatch")),null;var u=M(m,"x-ethers/locale");if("0.1"===M(m,"x-ethers/version")&&(null==u||"en"===u)){var l=_(M(m,"x-ethers/mnemonicCiphertext")),h=_(M(m,"x-ethers/mnemonicCounter")),f=new R.default.Counter(h),c=new R.default.ModeOfOperation.ctr(s,f),d=M(m,"x-ethers/path")||g.defaultPath,p=L.arrayify(c.decrypt(l)),v=g.entropyToMnemonic(p),y=g.fromMnemonic(v).derivePath(d);if(y.privateKey!=L.hexlify(o))return t(new Error("mnemonic mismatch")),null;a=new C.SigningKey(y)}return a}var m=JSON.parse(e),v=F(t);return new Promise(function(i,o){var e=M(m,"crypto/kdf");if(e&&"string"==typeof e)if("scrypt"===e.toLowerCase()){var t=_(M(m,"crypto/kdfparams/salt")),r=parseInt(M(m,"crypto/kdfparams/n")),n=parseInt(M(m,"crypto/kdfparams/r")),s=parseInt(M(m,"crypto/kdfparams/p"));if(!r||!n||!s)return void o(new Error("unsupported key-derivation function parameters"));if(0!=(r&r-1))return void o(new Error("unsupported key-derivation function parameter value for N"));if(32!==(l=parseInt(M(m,"crypto/kdfparams/dklen"))))return void o(new Error("unsupported key-derivation derived-key length"));d&&d(0),y.default(v,t,r,n,s,64,function(e,t,r){if(e)e.progress=t,o(e);else if(r){r=L.arrayify(r);var n=p(r,o);if(!n)return;d&&d(1),i(n)}else if(d)return d(t)})}else if("pbkdf2"===e.toLowerCase()){var t=_(M(m,"crypto/kdfparams/salt")),a=null,u=M(m,"crypto/kdfparams/prf");if("hmac-sha256"===u)a="sha256";else{if("hmac-sha512"!==u)return void o(new Error("unsupported prf"));a="sha512"}var l,h=parseInt(M(m,"crypto/kdfparams/c"));if(32!==(l=parseInt(M(m,"crypto/kdfparams/dklen"))))return void o(new Error("unsupported key-derivation derived-key length"));var f=w.pbkdf2(v,t,h,l,a),c=p(f,o);if(!c)return;i(c)}else o(new Error("unsupported key-derivation function"));else o(new Error("unsupported key-derivation function"))})},r.encrypt=function(e,t,w,_){"function"!=typeof w||_||(_=w,w={}),w=w||{};var M=null;if(32!==(M=C.SigningKey.isSigningKey(e)?L.arrayify(e.privateKey):L.arrayify(e)).length)throw new Error("invalid private key");var r=F(t),A=null;if(w.entropy&&(A=L.arrayify(w.entropy)),w.mnemonic)if(A){if(g.entropyToMnemonic(A)!==w.mnemonic)throw new Error("entropy and mnemonic mismatch")}else A=L.arrayify(g.mnemonicToEntropy(w.mnemonic,w.wordlist));var E=w.path;A&&!E&&(E=g.defaultPath);var S=(S=w.client)||"ethers.js",k=null,k=w.salt?L.arrayify(w.salt):D.randomBytes(32),N=null;if(w.iv){if(16!==(N=L.arrayify(w.iv)).length)throw new Error("invalid iv")}else N=D.randomBytes(16);var x=null;if(w.uuid){if(16!==(x=L.arrayify(w.uuid)).length)throw new Error("invalid uuid")}else x=D.randomBytes(16);var P=1<<17,I=8,T=1;return w.scrypt&&(w.scrypt.N&&(P=w.scrypt.N),w.scrypt.r&&(I=w.scrypt.r),w.scrypt.p&&(T=w.scrypt.p)),new Promise(function(g,b){_&&_(0),y.default(r,k,P,I,T,64,function(e,t,r){if(e)e.progress=t,b(e);else if(r){var n,i,o,s,a,u,l=(r=L.arrayify(r)).slice(0,16),h=r.slice(16,32),f=r.slice(32,64),c=new C.SigningKey(M).address,d=new R.default.Counter(N),p=new R.default.ModeOfOperation.ctr(l,d),v=L.arrayify(p.encrypt(M)),y=B.keccak256(L.concat([h,v])),m={address:c.substring(2).toLowerCase(),id:O.default.v4({random:x}),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:L.hexlify(N).substring(2)},ciphertext:L.hexlify(v).substring(2),kdf:"scrypt",kdfparams:{salt:L.hexlify(k).substring(2),n:P,dklen:32,p:T,r:I},mac:y.substring(2)}};A&&(n=D.randomBytes(16),i=new R.default.Counter(n),o=new R.default.ModeOfOperation.ctr(f,i),s=L.arrayify(o.encrypt(A)),u=(a=new Date).getUTCFullYear()+"-"+U(a.getUTCMonth()+1,2)+"-"+U(a.getUTCDate(),2)+"T"+U(a.getUTCHours(),2)+"-"+U(a.getUTCMinutes(),2)+"-"+U(a.getUTCSeconds(),2)+".0Z",m["x-ethers"]={client:S,gethFilename:"UTC--"+u+"--"+m.address,mnemonicCounter:L.hexlify(n).substring(2),mnemonicCiphertext:L.hexlify(s).substring(2),path:E,version:"0.1"},w.wordlist&&"string"==typeof w.wordlist.locale&&(m["x-ethers"].locale=w.wordlist.locale)),_&&_(1),g(JSON.stringify(m))}else if(_)return _(t)})})}},{"./address":60,"./bytes":64,"./hdnode":66,"./keccak256":71,"./pbkdf2":73,"./random-bytes":75,"./signing-key":81,"./utf8":85,"aes-js":8,"scrypt-js":44,uuid:48}],79:[function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(r,"__esModule",{value:!0});var i=n(e("hash.js")),o=e("./bytes");r.ripemd160=function(e){return"0x"+i.default.ripemd160().update(o.arrayify(e)).digest("hex")},r.sha256=function(e){return"0x"+i.default.sha256().update(o.arrayify(e)).digest("hex")},r.sha512=function(e){return"0x"+i.default.sha512().update(o.arrayify(e)).digest("hex")}},{"./bytes":64,"hash.js":26}],80:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),e("setimmediate"),r.platform="browser"},{setimmediate:45}],81:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("./hdnode"),o=e("./bytes"),s=e("./properties"),a=e("./secp256k1"),u=n(e("../errors")),l=(h.prototype.signDigest=function(e){return this.keyPair.sign(e)},h.prototype.computeSharedSecret=function(e){return this.keyPair.computeSharedSecret(o.arrayify(e))},h.isSigningKey=function(e){return s.isType(e,"SigningKey")},h);function h(e){u.checkNew(this,h);var t=null,t=i.HDNode.isHDNode(e)?(s.defineReadOnly(this,"mnemonic",e.mnemonic),s.defineReadOnly(this,"path",e.path),o.arrayify(e.privateKey)):("string"==typeof e&&e.match(/^[0-9a-f]*$/i)&&64===e.length&&(e="0x"+e),o.arrayify(e));try{32!==t.length&&u.throwError("exactly 32 bytes required",u.INVALID_ARGUMENT,{arg:"privateKey",value:"[REDACTED]"})}catch(e){var r={arg:"privateKey",reason:e.reason,value:"[REDACTED]"};e.value&&("number"==typeof e.value.length&&(r.length=e.value.length),r.type=typeof e.value),u.throwError("invalid private key",e.code,r)}s.defineReadOnly(this,"privateKey",o.hexlify(t)),s.defineReadOnly(this,"keyPair",new a.KeyPair(t)),s.defineReadOnly(this,"publicKey",this.keyPair.publicKey),s.defineReadOnly(this,"address",a.computeAddress(this.keyPair.publicKey)),s.setType(this,"SigningKey")}r.SigningKey=l},{"../errors":5,"./bytes":64,"./hdnode":66,"./properties":74,"./secp256k1":77}],82:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var u=e("./bignumber"),l=e("./bytes"),h=e("./utf8"),n=e("./keccak256"),i=e("./sha2"),f=new RegExp("^bytes([0-9]+)$"),c=new RegExp("^(u?int)([0-9]*)$"),d=new RegExp("^(.*)\\[([0-9]*)\\]$"),p="0000000000000000000000000000000000000000000000000000000000000000";function o(e,r){if(e.length!=r.length)throw new Error("type/value count mismatch");var n=[];return e.forEach(function(e,t){n.push(function t(e,r,n){switch(e){case"address":return n?l.padZeros(r,32):l.arrayify(r);case"string":return h.toUtf8Bytes(r);case"bytes":return l.arrayify(r);case"bool":return r=r?"0x01":"0x00",n?l.padZeros(r,32):l.arrayify(r)}var i=e.match(c);if(i){if((o=parseInt(i[2]||"256"))%8!=0||0===o||256<o)throw new Error("invalid number type - "+e);return n&&(o=256),r=u.bigNumberify(r).toTwos(o),l.padZeros(r,o/8)}if(i=e.match(f)){var o=parseInt(i[1]);if(String(o)!=i[1]||0===o||32<o)throw new Error("invalid number type - "+e);if(l.arrayify(r).byteLength!==o)throw new Error("invalid value for "+e);return n?l.arrayify((r+p).substring(0,66)):r}if((i=e.match(d))&&Array.isArray(r)){var s=i[1];if(parseInt(i[2]||String(r.length))!=r.length)throw new Error("invalid value for "+e);var a=[];return r.forEach(function(e){a.push(t(s,e,!0))}),l.concat(a)}throw new Error("unknown type - "+e)}(e,r[t]))}),l.hexlify(l.concat(n))}r.pack=o,r.keccak256=function(e,t){return n.keccak256(o(e,t))},r.sha256=function(e,t){return i.sha256(o(e,t))}},{"./bignumber":63,"./bytes":64,"./keccak256":71,"./sha2":79,"./utf8":85}],83:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i=e("../constants"),a=n(e("../errors")),u=e("./secp256k1"),l=e("./address"),h=e("./bignumber"),f=e("./bytes"),c=e("./keccak256"),s=e("./properties"),d=n(e("./rlp")),o=e("../providers/abstract-provider");function p(e){return"0x"===e?i.Zero:h.bigNumberify(e)}var v=[{name:"nonce",maxLength:32},{name:"gasPrice",maxLength:32},{name:"gasLimit",maxLength:32},{name:"to",length:20},{name:"value",maxLength:32},{name:"data"}],y={chainId:!0,data:!0,gasLimit:!0,gasPrice:!0,nonce:!0,to:!0,value:!0};r.serialize=function(r,e){s.checkProperties(r,y);var n=[];v.forEach(function(e){var t=r[e.name]||[],t=f.arrayify(f.hexlify(t));e.length&&t.length!==e.length&&0<t.length&&a.throwError("invalid length for "+e.name,a.INVALID_ARGUMENT,{arg:"transaction"+e.name,value:t}),e.maxLength&&(t=f.stripZeros(t)).length>e.maxLength&&a.throwError("invalid length for "+e.name,a.INVALID_ARGUMENT,{arg:"transaction"+e.name,value:t}),n.push(f.hexlify(t))}),null!=r.chainId&&0!==r.chainId&&(n.push(f.hexlify(r.chainId)),n.push("0x"),n.push("0x"));var t=d.encode(n);if(!e)return t;var i=f.splitSignature(e),o=27+i.recoveryParam;return 9===n.length&&(n.pop(),n.pop(),n.pop(),o+=2*r.chainId+8),n.push(f.hexlify(o)),n.push(f.stripZeros(f.arrayify(i.r))),n.push(f.stripZeros(f.arrayify(i.s))),d.encode(n)},r.parse=function(e){var t=d.decode(e);9!==t.length&&6!==t.length&&a.throwError("invalid raw transaction",a.INVALID_ARGUMENT,{arg:"rawTransactin",value:e});var r,n={nonce:p(t[0]).toNumber(),gasPrice:p(t[1]),gasLimit:p(t[2]),to:"0x"===(r=t[3])?null:l.getAddress(r),value:p(t[4]),data:t[5],chainId:0};if(6===t.length)return n;try{n.v=h.bigNumberify(t[6]).toNumber()}catch(e){return a.info(e),n}if(n.r=f.hexZeroPad(t[7],32),n.s=f.hexZeroPad(t[8],32),h.bigNumberify(n.r).isZero()&&h.bigNumberify(n.s).isZero())n.chainId=n.v,n.v=0;else{n.chainId=Math.floor((n.v-35)/2),n.chainId<0&&(n.chainId=0);var i=n.v-27,o=t.slice(0,6);0!==n.chainId&&(o.push(f.hexlify(n.chainId)),o.push("0x"),o.push("0x"),i-=2*n.chainId+8);var s=c.keccak256(d.encode(o));try{n.from=u.recoverAddress(s,{r:f.hexlify(n.r),s:f.hexlify(n.s),recoveryParam:i})}catch(e){a.info(e)}n.hash=c.keccak256(e)}return n},r.populateTransaction=function(e,t,r){o.Provider.isProvider(t)||a.throwError("missing provider",a.INVALID_ARGUMENT,{argument:"provider",value:t}),s.checkProperties(e,y);var n,i=s.shallowCopy(e);return null!=i.to&&(i.to=t.resolveName(i.to)),null==i.gasPrice&&(i.gasPrice=t.getGasPrice()),null==i.nonce&&(i.nonce=t.getTransactionCount(r)),null==i.gasLimit&&((n=s.shallowCopy(i)).from=r,i.gasLimit=t.estimateGas(n)),null==i.chainId&&(i.chainId=t.getNetwork().then(function(e){return e.chainId})),s.resolveProperties(i)}},{"../constants":3,"../errors":5,"../providers/abstract-provider":50,"./address":60,"./bignumber":63,"./bytes":64,"./keccak256":71,"./properties":74,"./rlp":76,"./secp256k1":77}],84:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var i,h=e("../constants"),f=n(e("../errors")),c=e("./bignumber"),o={};function s(e){return{decimals:e.length-1,tenPower:c.bigNumberify(e)}}function d(e){var t=o[String(e).toLowerCase()];if(!t&&"number"==typeof e&&parseInt(String(e))==e&&0<=e&&e<=256){for(var r="1",n=0;n<e;n++)r+="0";t=s(r)}return t||f.throwError("invalid unitType",f.INVALID_ARGUMENT,{argument:"name",value:e}),t}function a(e,t){var r=d(t),n=(e=c.bigNumberify(e)).lt(h.Zero);n&&(e=e.mul(h.NegativeOne));for(var i=e.mod(r.tenPower).toString();i.length<r.decimals;)i="0"+i;return i=i.match(/^([0-9]*[1-9]|0)(0*)/)[1],e=e.div(r.tenPower).toString()+"."+i,n&&(e="-"+e),e}function u(e,t){null==t&&(t=18);var r=d(t);if("string"==typeof e&&e.match(/^-?[0-9.,]+$/)||f.throwError("invalid decimal value",f.INVALID_ARGUMENT,{arg:"value",value:e}),0===r.decimals)return c.bigNumberify(e);var n="-"===e.substring(0,1);n&&(e=e.substring(1)),"."===e&&f.throwError("missing value",f.INVALID_ARGUMENT,{arg:"value",value:e});var i=e.split(".");2<i.length&&f.throwError("too many decimal points",f.INVALID_ARGUMENT,{arg:"value",value:e});var o=i[0],s=i[1],o=o||"0";for((s=s||"0").length>r.decimals&&f.throwError("underflow occurred",f.NUMERIC_FAULT,{operation:"division",fault:"underflow"});s.length<r.decimals;)s+="0";var a=c.bigNumberify(o),u=c.bigNumberify(s),l=a.mul(r.tenPower).add(u);return n&&(l=l.mul(h.NegativeOne)),l}i="1",["wei","kwei","Mwei","Gwei","szabo","finney","ether"].forEach(function(e){var t=s(i);o[e.toLowerCase()]=t,o[String(t.decimals)]=t,i+="000"}),r.commify=function(e){var t=String(e).split(".");(2<t.length||!t[0].match(/^-?[0-9]*$/)||t[1]&&!t[1].match(/^[0-9]*$/)||"."===e||"-."===e)&&f.throwError("invalid value",f.INVALID_ARGUMENT,{argument:"value",value:e});var r=t[0],n="";for("-"===r.substring(0,1)&&(n="-",r=r.substring(1));"0"===r.substring(0,1);)r=r.substring(1);""===r&&(r="0");var i="";2===t.length&&(i="."+(t[1]||"0"));for(var o=[];r.length;){if(r.length<=3){o.unshift(r);break}var s=r.length-3;o.unshift(r.substring(s)),r=r.substring(0,s)}return n+o.join(",")+i},r.formatUnits=a,r.parseUnits=u,r.formatEther=function(e){return a(e,18)},r.parseEther=function(e){return u(e,18)}},{"../constants":3,"../errors":5,"./bignumber":63}],85:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var s,n,i=e("../constants"),a=e("../errors"),h=e("./bytes");function o(e,t){void 0===t&&(t=s.current),t!=s.current&&(a.checkNormalize(),e=e.normalize(t));for(var r=[],n=0;n<e.length;n++){var i=e.charCodeAt(n);if(i<128)r.push(i);else if(i<2048)r.push(i>>6|192),r.push(63&i|128);else if(55296==(64512&i)){n++;var o=e.charCodeAt(n);if(n>=e.length||56320!=(64512&o))throw new Error("invalid utf-8 string");i=65536+((1023&i)<<10)+(1023&o),r.push(i>>18|240),r.push(i>>12&63|128),r.push(i>>6&63|128),r.push(63&i|128)}else r.push(i>>12|224),r.push(i>>6&63|128),r.push(63&i|128)}return h.arrayify(r)}function u(e,t){e=h.arrayify(e);for(var r="",n=0;n<e.length;){var i=e[n++];if(i>>7!=0){var o=null,s=null;if(192==(224&i))o=1,s=127;else if(224==(240&i))o=2,s=2047;else{if(240!=(248&i)){if(t)continue;if(128==(192&i))throw new Error("invalid utf8 byte sequence; unexpected continuation byte");throw new Error("invalid utf8 byte sequence; invalid prefix")}o=3,s=65535}if(n+o>e.length){if(!t)throw new Error("invalid utf8 byte sequence; too short");for(;n<e.length&&e[n]>>6==2;n++);}else{for(var a=i&(1<<8-o-1)-1,u=0;u<o;u++){var l=e[n];if(128!=(192&l)){a=null;break}a=a<<6|63&l,n++}if(null!==a)if(a<=s){if(!t)throw new Error("invalid utf8 byte sequence; overlong")}else if(1114111<a){if(!t)throw new Error("invalid utf8 byte sequence; out-of-range")}else if(55296<=a&&a<=57343){if(!t)throw new Error("invalid utf8 byte sequence; utf-16 surrogate")}else a<=65535?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296+(a>>10&1023),56320+(1023&a)));else if(!t)throw new Error("invalid utf8 byte sequence; invalid continuation byte")}}else r+=String.fromCharCode(i)}return r}(n=s=r.UnicodeNormalizationForm||(r.UnicodeNormalizationForm={})).current="",n.NFC="NFC",n.NFD="NFD",n.NFKC="NFKC",n.NFKD="NFKD",r.toUtf8Bytes=o,r.toUtf8String=u,r.formatBytes32String=function(e){var t=o(e);if(31<t.length)throw new Error("bytes32 string must be less than 32 bytes");return h.hexlify(h.concat([t,i.HashZero]).slice(0,32))},r.parseBytes32String=function(e){var t=h.arrayify(e);if(32!==t.length)throw new Error("invalid bytes32 - not 32 bytes long");if(0!==t[31])throw new Error("invalid bytes32 string - no null terminator");for(var r=31;0===t[r-1];)r--;return u(t.slice(0,r))}},{"../constants":3,"../errors":5,"./bytes":64}],86:[function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var f=e("xmlhttprequest"),i=e("./base64"),o=e("./properties"),s=e("./utf8"),c=n(e("../errors"));r.fetchJson=function(e,a,u){var t,r={},l=null,h=12e4;if("string"==typeof e)l=e;else if("object"==typeof e){if(null==e.url&&c.throwError("missing URL",c.MISSING_ARGUMENT,{arg:"url"}),l=e.url,"number"==typeof e.timeout&&0<e.timeout&&(h=e.timeout),e.headers)for(var n in e.headers)r[n.toLowerCase()]={key:n,value:String(e.headers[n])};null!=e.user&&null!=e.password&&("https:"!==l.substring(0,6)&&!0!==e.allowInsecure&&c.throwError("basic authentication requires a secure https url",c.INVALID_ARGUMENT,{arg:"url",url:l,user:e.user,password:"[REDACTED]"}),t=e.user+":"+e.password,r.authorization={key:"Authorization",value:"Basic "+i.encode(s.toUtf8Bytes(t))})}return new Promise(function(n,i){function o(){null!=e&&(clearTimeout(e),e=null)}var s=new f.XMLHttpRequest,e=null,e=setTimeout(function(){null!=e&&(e=null,i(new Error("timeout")),setTimeout(function(){s.abort()},0))},h);a?(s.open("POST",l,!0),r["content-type"]={key:"Content-Type",value:"application/json"}):s.open("GET",l,!0),Object.keys(r).forEach(function(e){var t=r[e];s.setRequestHeader(t.key,t.value)}),s.onreadystatechange=function(){if(4===s.readyState){if(200!=s.status){o();var e=new Error("invalid response - "+s.status);return e.statusCode=s.status,s.responseText&&(e.responseText=s.responseText),void i(e)}var t=null;try{t=JSON.parse(s.responseText)}catch(e){o();var r=new Error("invalid json response");return r.orginialError=e,r.responseText=s.responseText,null!=a&&(r.requestBody=a),r.url=l,void i(r)}if(u)try{t=u(t)}catch(e){return o(),e.url=l,e.body=a,e.responseText=s.responseText,void i(e)}o(),n(t)}},s.onerror=function(e){o(),i(e)};try{null!=a?s.send(a):s.send()}catch(e){o();var t=new Error("connection error");t.error=e,i(t)}})},r.poll=function(u,l){return l=l||{},null==(l=o.shallowCopy(l)).floor&&(l.floor=0),null==l.ceiling&&(l.ceiling=1e4),null==l.interval&&(l.interval=250),new Promise(function(n,t){var e=null,i=!1,o=function(){return!i&&(i=!0,e&&clearTimeout(e),!0)};l.timeout&&(e=setTimeout(function(){o()&&t(new Error("timeout"))},l.timeout));var s=l.fastRetry||null,a=0;!function r(){return u().then(function(e){var t;return void 0!==e?o()&&n(e):l.onceBlock?l.onceBlock.once("block",r):i||(a++,(t=l.interval*parseInt(String(Math.random()*Math.pow(2,a))))<l.floor&&(t=l.floor),t>l.ceiling&&(t=l.ceiling),s&&(a--,t=s,s=null),setTimeout(r,t)),null},function(e){o()&&t(e)})}()})}},{"../errors":5,"./base64":61,"./properties":74,"./utf8":85,xmlhttprequest:49}],87:[function(o,e,s){(function(e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var i=o("../utils/hash"),t=o("../utils/properties");s.check=function(e){for(var t=[],r=0;r<2048;r++){var n=e.getWord(r);if(r!==e.getWordIndex(n))return"0x";t.push(n)}return i.id(t.join("\n")+"\n")};var r=(n.prototype.split=function(e){return e.toLowerCase().split(/ +/g)},n.prototype.join=function(e){return e.join(" ")},n);function n(e){t.defineReadOnly(this,"locale",e)}s.Wordlist=r,s.register=function(e,t){t=t||e.locale}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../utils/hash":65,"../utils/properties":74}],88:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(r,"__esModule",{value:!0});var s,a=e("./utils/bytes"),u=e("./utils/hash"),l=e("./utils/hdnode"),h=e("./utils/json-wallet"),f=e("./utils/keccak256"),c=e("./utils/properties"),d=e("./utils/random-bytes"),p=o(e("./utils/secret-storage")),v=e("./utils/signing-key"),y=e("./utils/transaction"),m=e("./abstract-signer"),g=e("./providers/abstract-provider"),b=o(e("./errors")),w=(s=m.Signer,i(_,s),Object.defineProperty(_.prototype,"address",{get:function(){return this.signingKey.address},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"mnemonic",{get:function(){return this.signingKey.mnemonic},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"path",{get:function(){return this.signingKey.path},enumerable:!0,configurable:!0}),Object.defineProperty(_.prototype,"privateKey",{get:function(){return this.signingKey.privateKey},enumerable:!0,configurable:!0}),_.prototype.connect=function(e){return g.Provider.isProvider(e)||b.throwError("invalid provider",b.INVALID_ARGUMENT,{argument:"provider",value:e}),new _(this.signingKey,e)},_.prototype.getAddress=function(){return Promise.resolve(this.address)},_.prototype.sign=function(e){var n=this;return c.resolveProperties(e).then(function(e){var t=y.serialize(e),r=n.signingKey.signDigest(f.keccak256(t));return y.serialize(e,r)})},_.prototype.signMessage=function(e){return Promise.resolve(a.joinSignature(this.signingKey.signDigest(u.hashMessage(e))))},_.prototype.getBalance=function(e){if(!this.provider)throw new Error("missing provider");return this.provider.getBalance(this.address,e)},_.prototype.getTransactionCount=function(e){if(!this.provider)throw new Error("missing provider");return this.provider.getTransactionCount(this.address,e)},_.prototype.sendTransaction=function(e){var t=this;if(!this.provider)throw new Error("missing provider");return null==e.nonce&&((e=c.shallowCopy(e)).nonce=this.getTransactionCount("pending")),y.populateTransaction(e,this.provider,this.address).then(function(e){return t.sign(e).then(function(e){return t.provider.sendTransaction(e)})})},_.prototype.encrypt=function(e,t,r){if("function"!=typeof t||r||(r=t,t={}),r&&"function"!=typeof r)throw new Error("invalid callback");return t=t||{},this.mnemonic&&((t=c.shallowCopy(t)).mnemonic=this.mnemonic,t.path=this.path),p.encrypt(this.privateKey,e,t,r)},_.createRandom=function(e){var t=d.randomBytes(16);(e=e||{}).extraEntropy&&(t=a.arrayify(f.keccak256(a.concat([t,e.extraEntropy])).substring(0,34)));var r=l.entropyToMnemonic(t,e.locale);return _.fromMnemonic(r,e.path,e.locale)},_.fromEncryptedJson=function(e,t,r){if(h.isCrowdsaleWallet(e))try{r&&r(0);var n=p.decryptCrowdsale(e,t);return r&&r(1),Promise.resolve(new _(n))}catch(e){return Promise.reject(e)}else if(h.isSecretStorageWallet(e))return p.decrypt(e,t,r).then(function(e){return new _(e)});return Promise.reject("invalid wallet JSON")},_.fromMnemonic=function(e,t,r){return t=t||l.defaultPath,new _(l.fromMnemonic(e,r).derivePath(t))},_);function _(e,t){var r=s.call(this)||this;return b.checkNew(r,_),v.SigningKey.isSigningKey(e)?c.defineReadOnly(r,"signingKey",e):c.defineReadOnly(r,"signingKey",new v.SigningKey(e)),c.defineReadOnly(r,"provider",t),r}r.Wallet=w},{"./abstract-signer":2,"./errors":5,"./providers/abstract-provider":50,"./utils/bytes":64,"./utils/hash":65,"./utils/hdnode":66,"./utils/json-wallet":70,"./utils/keccak256":71,"./utils/properties":74,"./utils/random-bytes":75,"./utils/secret-storage":78,"./utils/signing-key":81,"./utils/transaction":83}],89:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n=e("../wordlists/lang-en").langEn;r.en=n},{"../wordlists/lang-en":90}],90:[function(e,t,r){"use strict";var n,i=this&&this.__extends||(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(r,"__esModule",{value:!0});var o,s=e("../utils/wordlist"),a="AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo",u=null;function l(e){if(null==u&&(u=a.replace(/([A-Z])/g," $1").toLowerCase().substring(1).split(" "),"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"!==s.check(e)))throw u=null,new Error("BIP39 Wordlist for en (English) FAILED")}function h(){return o.call(this,"en")||this}var f=new(o=s.Wordlist,i(h,o),h.prototype.getWord=function(e){return l(this),u[e]},h.prototype.getWordIndex=function(e){return l(this),u.indexOf(e)},h);r.langEn=f,s.register(f)},{"../utils/wordlist":87}]},{},[7])(7)});
//# sourceMappingURL=ethers.min.js.map

      };
    };
  }
}, {package:"ethers",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/3box/node_modules/ethers/dist/ethers.min.js",}],
["/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha256/src/sha256.js", {"_process":"/home/clarisco/Desktop/metamask-extension-develop/node_modules/process/browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: /home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha256/src/sha256.js
      return function (require, module, exports) {
(function (process){(function (){
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) {
    var method = createOutputMethod('hex', is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) {
    var crypto = (0,eval)("require('crypto')");
    var Buffer = (0,eval)("require('buffer').Buffer");
    var algorithm = is224 ? 'sha224' : 'sha256';
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) {
    var method = createHmacOutputMethod('hex', is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else { // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
          blocks[4] = blocks[5] = blocks[6] = blocks[7] =
          blocks[8] = blocks[9] = blocks[10] = blocks[11] =
          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

    for (j = 16; j < 64; ++j) {
      // rightrotate
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = t1 - 150054599 << 0;
          d = t1 + 24177077 << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = t1 - 1521486534 << 0;
          d = t1 + 143694565 << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = d + t1 << 0;
        d = t1 + t2 << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = c + t1 << 0;
      c = t1 + t2 << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = b + t1 << 0;
      b = t1 + t2 << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = a + t1 << 0;
      a = t1 + t2 << 0;
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
    this.h5 = this.h5 + f << 0;
    this.h6 = this.h6 + g << 0;
    this.h7 = this.h7 + h << 0;
  };

  Sha256.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
    if (!this.is224) {
      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var arr = [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
    ];
    if (!this.is224) {
      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) {
    var i, type = typeof key;
    if (type === 'string') {
      var bytes = [], length = key.length, index = 0, code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    } else {
      if (type === 'object') {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = (new Sha256(is224, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"js-sha256",file:"/home/clarisco/Desktop/metamask-extension-develop/node_modules/js-sha256/src/sha256.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucy90eC1zdGF0ZS1tYW5hZ2VyLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL3BlbmRpbmctdHgtdHJhY2tlci5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3Blcm1pc3Npb25zL2VudW1zLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvcGVybWlzc2lvbnMvYmFja2dyb3VuZC1hcGkuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wZXJtaXNzaW9ucy9zZWxlY3RvcnMuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wZXJtaXNzaW9ucy9jYXZlYXQtbXV0YXRvcnMuanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9wZXJtaXNzaW9ucy9wZXJtaXNzaW9uLWxvZy5qcyIsImFwcC9zY3JpcHRzL2NvbnRyb2xsZXJzL3Blcm1pc3Npb25zL3NwZWNpZmljYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2FuYWx5dGljcy1ub2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L3RoaXJkcGFydHkuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9uZXR3b3JrL25ldHdvcmsuanMiLCJub2RlX21vZHVsZXMvZXRoLXRyZXpvci1rZXlyaW5nL25vZGVfbW9kdWxlcy9oZGtleS9saWIvaGRrZXkuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9oZGtleS9saWIvaGRrZXkuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyQXNNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9ibG9jay10cmFja2VyLWluc3BlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZmxpZ2h0LWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvZmV0Y2guanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcmV0cnlPbkVtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcHJvdmlkZXJGcm9tRW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLXJld3JpdGUuanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC93YWxsZXQuanMiLCJub2RlX21vZHVsZXMvZXRoLWxhdHRpY2Uta2V5cmluZy9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9zdWJqZWN0LW1ldGFkYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc25hcHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9yZXNvdXJjZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NlcnZpY2VzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvZGlzdC9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMiLCJkZXZlbG9wbWVudC9tb2NrLTNib3guanMiLCJhcHAvc2NyaXB0cy9jb250cm9sbGVycy9uZXR3b3JrL2NyZWF0ZU1ldGFtYXNrTWlkZGxld2FyZS5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi8zYm94LmpzIiwiYXBwL3NjcmlwdHMvbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZS9jcmVhdGVNZXRob2RNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvc3JjL3Byb2ZpbGVzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYW5hbHl0aWNzLW5vZGUvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3JlbW92ZS10cmFpbGluZy1zbGFzaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guaXNzdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYW5hbHl0aWNzLW5vZGUvbm9kZV9tb2R1bGVzL3V1aWQvdjQuanMiLCJub2RlX21vZHVsZXMvbWQ1L21kNS5qcyIsIm5vZGVfbW9kdWxlcy9Ac2VnbWVudC9sb29zZWx5LXZhbGlkYXRlLWV2ZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zLXJldHJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zY3J5cHRzeS9saWIvc2NyeXB0LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9jcmVhdGVKc29uUnBjQ2xpZW50LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9jcmVhdGVJbmZ1cmFDbGllbnQuanMiLCJub2RlX21vZHVsZXMvY29pbnN0cmluZy9saWIvY29pbnN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvZW52L2Jyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC91dGlscy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvcGlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9zcmMvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc3ViamVjdC1tZXRhZGF0YS9TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc25hcHMvU25hcENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9yZXNvdXJjZS9FeHRlcm5hbFJlc291cmNlQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NlcnZpY2VzL0V4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3NlcnZpY2VzL1dlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvUGVybWlzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL0NhdmVhdC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3JwYy1tZXRob2RzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvUGVybWlzc2lvbkNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2luZGV4LmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay9taWRkbGV3YXJlL3BlbmRpbmcuanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvcHJpdmF0ZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL2Rpc3Qvc3RvcmUubGVnYWN5LmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliL3NwYWNlLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1wdWJzdWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliLzNpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi92ZXJpZmllZC5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi91dGlscy9pZC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvcHVibGljU3RvcmUuanMiLCJub2RlX21vZHVsZXMvM2JveC1vcmJpdGRiLXBsdWdpbnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29yYml0LWRiL3NyYy9PcmJpdERCLmpzIiwibm9kZV9tb2R1bGVzL2lwZnMvc3JjL2NvcmUvaW5kZXguanMiLCJhcHAvc2NyaXB0cy9saWIvcnBjLW1ldGhvZC1taWRkbGV3YXJlL2hhbmRsZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtbWV0aG9kcy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0LWpzb24tcGF0Y2gvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9jaWRzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYi1lbmNvZGluZy9zcmMvbGliLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy1iYXNlNjQvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvaW50LXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvcHJpbnQuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy92YXJpbnQtdGFibGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2FuYWx5dGljcy1ub2RlL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ybmctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9hbmFseXRpY3Mtbm9kZS9ub2RlX21vZHVsZXMvdXVpZC9saWIvYnl0ZXNUb1V1aWQuanMiLCJub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanMiLCJub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC10eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pvaW4tY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zLXJldHJ5L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9ieXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtd2FsbGV0L25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxdjMtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXdhbGxldC9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZXRoZXJldW1qcy13YWxsZXQvbm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2NyZWF0ZUV2ZW50RW1pdHRlclByb3h5LmpzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2NyZWF0ZVN3YXBwYWJsZVByb3h5LmpzIiwibm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29pbnN0cmluZy9ub2RlX21vZHVsZXMvYnM1OC9saWIvYnM1OC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvcGFyYW1zLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9hY2NvdW50LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy90cmV6b3IvbWFuYWdlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvYml0Y29pbi5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvYmluYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvY29pbkluZm8uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2Vvcy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvZXRoZXJldW0uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL3JpcHBsZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3Mvc3RlbGxhci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvbmVtLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy90ZXpvcy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvYmFja2VuZC90cmFuc2FjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2NhcmRhbm8uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy90cmV6b3IvZGV2aWNlLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9iYWNrZW5kL2Jsb2NrY2hhaW4uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9ibG9ja2NoYWluLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvZGV2aWNlLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvaWZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvbmV0d29yay5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL3BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvdWkuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9jYXJkYW5vLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi93ZWJ1c2IvYnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi91dGlscy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvbWVzc2FnZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvaWZyYW1lL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL21lc3NhZ2UvYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvZGF0YS9Db25uZWN0U2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3BvcHVwL1BvcHVwTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoanMtdXRpbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2tlY2Nhay9qcy5qcyIsIm5vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9zcmMvYml0Y29pbi5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvc3JjL2V0aGVyZXVtQWJpLmpzIiwibm9kZV9tb2R1bGVzL2dyaWRwbHVzLXNkay9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvYml0d2lzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkcGx1cy1zZGsvc3JjL2V0aGVyZXVtLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzL2Rpc3Qvc25hcHMvaW5saW5lU25hcHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvbm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5icm93c2VyLmNqcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbmFwLXdvcmtlcnMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9ub2RlX21vZHVsZXMvanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JqZWN0LW11bHRpcGxleC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9wb3N0LW1lc3NhZ2Utc3RyZWFtL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9ycGMtbWV0aG9kcy9nZXRQZXJtaXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc25hcC1jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3JwYy1tZXRob2RzL3JlcXVlc3RQZXJtaXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWZyZWV6ZS1zdHJpY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9wZXJtaXNzaW9uLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L0NvbXBvc2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9NZXJnZWRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoL2Rpc3QvYmMtdXItcmVnaXN0cnktZXRoLmNqcy5wcm9kdWN0aW9uLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL2Rpc3QvYmFzZS1ldGgta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2Jhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwiYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvbmV0d29yay91dGlsLmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbGliL2tleVZhbHVlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3JjL3N0b3JlLWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9wbHVnaW5zL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9vcmJpdC1kYi9zcmMvb3JiaXQtZGItYWRkcmVzcy5qcyIsIm5vZGVfbW9kdWxlcy8zYm94L2xpYi90aHJlYWQuanMiLCJub2RlX21vZHVsZXMvM2JveC9saWIvdXRpbHMvdmVyaWZpZXIuanMiLCJub2RlX21vZHVsZXMvZ3JhcGhxbC1yZXF1ZXN0L2Rpc3Qvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzLzNib3gvbm9kZV9tb2R1bGVzL2V0aGVycy9kaXN0L2V0aGVycy5taW4uanMiLCJub2RlX21vZHVsZXMvanMtc2hhMjU2L3NyYy9zaGEyNTYuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU0sdUJBQU4sU0FBc0MseUJBQXRDLENBQW1EO0FBQ2hFLEVBQUEsV0FBVyxDQUFDO0FBQUUsSUFBQSxTQUFGO0FBQWEsSUFBQSxjQUFiO0FBQTZCLElBQUEsVUFBN0I7QUFBeUMsSUFBQTtBQUF6QyxHQUFELEVBQStEO0FBQ3hFO0FBRUEsU0FBSyxLQUFMLEdBQWEsSUFBSSx5QkFBSjtBQUNYLE1BQUEsWUFBWSxFQUFFO0FBREgsT0FFUixTQUZRLEVBQWI7QUFJQSxTQUFLLGNBQUwsR0FBc0IsY0FBdEI7QUFDQSxTQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxTQUFLLGlCQUFMLEdBQXlCLGlCQUF6QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxjQUFjLENBQUMsSUFBSSxHQUFHLEVBQVIsRUFBWTtBQUN4QixVQUFNLEtBQUssR0FBRyxLQUFLLFVBQUwsRUFBZDtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssaUJBQUwsRUFBaEI7O0FBQ0EsUUFBSSxLQUFLLEtBQUssU0FBZCxFQUF5QjtBQUN2QixZQUFNLElBQUksS0FBSixDQUFVLHNEQUFWLENBQU47QUFDRDs7QUFFRCxRQUFJLG9CQUFvQixHQUFHLElBQTNCLENBUHdCLENBU3hCO0FBQ0E7QUFDQTs7QUFDQSxRQUNFLElBQUksQ0FBQyxRQUFMLElBQ0EsT0FBTyxJQUFJLENBQUMsTUFBWixLQUF1QixRQUR2QixJQUVBLElBQUksQ0FBQyxNQUFMLEtBQWdCLFVBSGxCLEVBSUU7QUFDQSxVQUFJLE9BQU8sSUFBSSxDQUFDLFFBQUwsQ0FBYyxRQUFyQixLQUFrQyxXQUF0QyxFQUFtRDtBQUNqRCxRQUFBLG9CQUFvQixHQUFHO0FBQ3JCLFVBQUEsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFMLENBQWM7QUFESCxTQUF2QjtBQUdELE9BSkQsTUFJTyxJQUNMLE9BQU8sSUFBSSxDQUFDLFFBQUwsQ0FBYyxZQUFyQixLQUFzQyxXQUF0QyxJQUNBLE9BQU8sSUFBSSxDQUFDLFFBQUwsQ0FBYyxvQkFBckIsS0FBOEMsV0FGekMsRUFHTDtBQUNBLFFBQUEsb0JBQW9CLEdBQUc7QUFDckIsVUFBQSxvQkFBb0IsRUFBRSxJQUFJLENBQUMsUUFBTCxDQUFjLG9CQURmO0FBRXJCLFVBQUEsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFMLENBQWM7QUFGUCxTQUF2QjtBQUlEOztBQUVELFVBQUksT0FBTyxJQUFJLENBQUMsUUFBTCxDQUFjLEdBQXJCLEtBQTZCLFdBQWpDLEVBQThDO0FBQzVDLFFBQUEsb0JBQW9CLG1DQUNmLG9CQURlO0FBRWxCLFVBQUEsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFMLENBQWM7QUFGRCxVQUFwQjtBQUlEO0FBQ0Y7O0FBRUQ7QUFDRSxNQUFBLEVBQUUsRUFBRSx3QkFETjtBQUVFLE1BQUEsSUFBSSxFQUFFLElBQUksSUFBSixHQUFXLE9BQVgsRUFGUjtBQUdFLE1BQUEsTUFBTSxFQUFFLGtDQUFxQixVQUgvQjtBQUlFLE1BQUEsaUJBQWlCLEVBQUUsS0FKckI7QUFLRSxNQUFBLE9BTEY7QUFNRSxNQUFBLGVBQWUsRUFBRSxJQU5uQjtBQU9FLE1BQUE7QUFQRixPQVFLLElBUkw7QUFVRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsbUJBQW1CLEdBQUc7QUFDcEIsVUFBTSxPQUFPLEdBQUcsS0FBSyxpQkFBTCxFQUFoQjtBQUNBLFVBQU0sT0FBTyxHQUFHLEtBQUssVUFBTCxFQUFoQjtBQUNBLFdBQU8sb0JBQ0wsS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixZQURqQixFQUVKLFdBQUQsSUFDRSxXQUFXLENBQUMsTUFBWixLQUF1QixrQ0FBcUIsVUFBNUMsSUFDQSw2Q0FBMEIsV0FBMUIsRUFBdUMsT0FBdkMsRUFBZ0QsT0FBaEQsQ0FKRyxDQUFQO0FBTUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLHVCQUF1QixDQUFDLE9BQUQsRUFBVTtBQUMvQixVQUFNLGNBQWMsR0FBRztBQUFFLE1BQUEsTUFBTSxFQUFFLGtDQUFxQjtBQUEvQixLQUF2Qjs7QUFDQSxRQUFJLE9BQUosRUFBYTtBQUNYLE1BQUEsY0FBYyxDQUFDLElBQWYsR0FBc0IsT0FBdEI7QUFDRDs7QUFDRCxXQUFPLEtBQUssZUFBTCxDQUFxQjtBQUFFLE1BQUE7QUFBRixLQUFyQixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLHNCQUFzQixDQUFDLE9BQUQsRUFBVTtBQUM5QixVQUFNLGNBQWMsR0FBRztBQUFFLE1BQUEsTUFBTSxFQUFFLGtDQUFxQjtBQUEvQixLQUF2Qjs7QUFDQSxRQUFJLE9BQUosRUFBYTtBQUNYLE1BQUEsY0FBYyxDQUFDLElBQWYsR0FBc0IsT0FBdEI7QUFDRDs7QUFDRCxXQUFPLEtBQUssZUFBTCxDQUFxQjtBQUFFLE1BQUE7QUFBRixLQUFyQixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLHdCQUF3QixDQUFDLE9BQUQsRUFBVTtBQUNoQyxVQUFNLGNBQWMsR0FBRztBQUFFLE1BQUEsTUFBTSxFQUFFLGtDQUFxQjtBQUEvQixLQUF2Qjs7QUFDQSxRQUFJLE9BQUosRUFBYTtBQUNYLE1BQUEsY0FBYyxDQUFDLElBQWYsR0FBc0IsT0FBdEI7QUFDRDs7QUFDRCxXQUFPLEtBQUssZUFBTCxDQUFxQjtBQUFFLE1BQUE7QUFBRixLQUFyQixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxjQUFjLENBQUMsTUFBRCxFQUFTO0FBQ3JCO0FBQ0EsUUFBSSxNQUFNLENBQUMsUUFBWCxFQUFxQjtBQUNuQixNQUFBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLHdDQUE2QixNQUFNLENBQUMsUUFBcEMsRUFBOEMsS0FBOUMsQ0FBbEI7QUFDRDs7QUFFRCxTQUFLLElBQUwsQ0FBVyxHQUFFLE1BQU0sQ0FBQyxFQUFHLFNBQXZCLEVBQWlDLE1BQU07QUFDckMsV0FBSyxrQkFBTCxDQUF5QixHQUFFLE1BQU0sQ0FBQyxFQUFHLFdBQXJDO0FBQ0QsS0FGRDtBQUdBLFNBQUssSUFBTCxDQUFXLEdBQUUsTUFBTSxDQUFDLEVBQUcsV0FBdkIsRUFBbUMsTUFBTTtBQUN2QyxXQUFLLGtCQUFMLENBQXlCLEdBQUUsTUFBTSxDQUFDLEVBQUcsU0FBckM7QUFDRCxLQUZELEVBVHFCLENBWXJCOztBQUNBLElBQUEsTUFBTSxDQUFDLE9BQVAsR0FBaUIsRUFBakIsQ0FicUIsQ0FjckI7O0FBQ0EsVUFBTSxRQUFRLEdBQUcsK0NBQW1CLE1BQW5CLENBQWpCO0FBQ0EsSUFBQSxNQUFNLENBQUMsT0FBUCxDQUFlLElBQWYsQ0FBb0IsUUFBcEI7QUFFQSxVQUFNLFlBQVksR0FBRyxLQUFLLGVBQUwsQ0FBcUI7QUFDeEMsTUFBQSxzQkFBc0IsRUFBRTtBQURnQixLQUFyQixDQUFyQjtBQUdBLFVBQU07QUFBRSxNQUFBO0FBQUYsUUFBcUIsSUFBM0IsQ0FyQnFCLENBdUJyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQU0sZUFBZSxHQUFHLElBQUksR0FBSixFQUF4QjtBQUNBLFVBQU0sV0FBVyxHQUFHLFlBQVksQ0FDN0IsT0FEaUIsR0FFakIsTUFGaUIsQ0FFVCxFQUFELElBQVE7QUFDZCxZQUFNO0FBQUUsUUFBQTtBQUFGLFVBQVksRUFBRSxDQUFDLFFBQXJCO0FBQ0EsWUFBTTtBQUFFLFFBQUEsT0FBRjtBQUFXLFFBQUEsaUJBQVg7QUFBOEIsUUFBQTtBQUE5QixVQUF5QyxFQUEvQztBQUNBLFlBQU0sR0FBRyxHQUFJLEdBQUUsS0FBTSxJQUFHLE9BQVosYUFBWSxPQUFaLGNBQVksT0FBWixHQUF1QixpQkFBa0IsRUFBckQ7O0FBQ0EsVUFBSSxlQUFlLENBQUMsR0FBaEIsQ0FBb0IsR0FBcEIsQ0FBSixFQUE4QjtBQUM1QixlQUFPLEtBQVA7QUFDRCxPQUZELE1BRU8sSUFDTCxlQUFlLENBQUMsSUFBaEIsR0FBdUIsY0FBYyxHQUFHLENBQXhDLElBQ0EsNEJBQWlCLFFBQWpCLENBQTBCLE1BQTFCLE1BQXNDLEtBRmpDLEVBR0w7QUFDQSxRQUFBLGVBQWUsQ0FBQyxHQUFoQixDQUFvQixHQUFwQjtBQUNBLGVBQU8sS0FBUDtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNELEtBaEJpQixFQWlCakIsR0FqQmlCLENBaUJaLEVBQUQsSUFBUSxFQUFFLENBQUMsRUFqQkUsQ0FBcEI7O0FBbUJBLFNBQUssbUJBQUwsQ0FBeUIsV0FBekI7O0FBQ0EsU0FBSyx1QkFBTCxDQUE2QixDQUFDLE1BQUQsQ0FBN0I7O0FBQ0EsV0FBTyxNQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLGNBQWMsQ0FBQyxJQUFELEVBQU87QUFDbkIsVUFBTTtBQUFFLE1BQUE7QUFBRixRQUFtQixLQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXpCO0FBQ0EsV0FBTyxZQUFZLENBQUMsSUFBRCxDQUFuQjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxpQkFBaUIsQ0FBQyxNQUFELEVBQVMsSUFBVCxFQUFlO0FBQzlCO0FBQ0EsUUFBSSxNQUFNLENBQUMsUUFBWCxFQUFxQjtBQUNuQixNQUFBLE1BQU0sQ0FBQyxRQUFQLEdBQWtCLHdDQUE2QixNQUFNLENBQUMsUUFBcEMsRUFBOEMsS0FBOUMsQ0FBbEI7QUFDRCxLQUo2QixDQU05Qjs7O0FBQ0EsVUFBTSxZQUFZLEdBQUcsK0NBQW1CLE1BQW5CLENBQXJCLENBUDhCLENBUTlCOztBQUNBLFVBQU0sYUFBYSxHQUFHLDBDQUFjLE1BQU0sQ0FBQyxPQUFyQixDQUF0QixDQVQ4QixDQVU5Qjs7QUFDQSxVQUFNLEtBQUssR0FBRyxpREFBcUIsYUFBckIsRUFBb0MsWUFBcEMsRUFBa0QsSUFBbEQsQ0FBZDs7QUFDQSxRQUFJLEtBQUssQ0FBQyxNQUFWLEVBQWtCO0FBQ2hCLE1BQUEsTUFBTSxDQUFDLE9BQVAsQ0FBZSxJQUFmLENBQW9CLEtBQXBCO0FBQ0QsS0FkNkIsQ0FnQjlCOzs7QUFDQSxVQUFNLElBQUksR0FBRyxNQUFNLENBQUMsRUFBcEI7QUFDQSxTQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLE1BQUEsWUFBWSxrQ0FDUCxLQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCLFlBRGY7QUFFVixTQUFDLElBQUQsR0FBUTtBQUZFO0FBRFMsS0FBdkI7QUFNRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLGVBQWUsQ0FBQztBQUNkLElBQUEsY0FBYyxHQUFHLEVBREg7QUFFZCxJQUFBLFdBRmM7QUFHZCxJQUFBLHNCQUFzQixHQUFHLElBSFg7QUFJZCxJQUFBO0FBSmMsTUFLWixFQUxXLEVBS1A7QUFDTixVQUFNLE9BQU8sR0FBRyxLQUFLLGlCQUFMLEVBQWhCO0FBQ0EsVUFBTSxPQUFPLEdBQUcsS0FBSyxVQUFMLEVBQWhCLENBRk0sQ0FHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBTSxnQkFBZ0IsR0FBRyx1QkFBVSxjQUFWLEVBQTJCLFNBQUQsSUFBZTtBQUNoRSxhQUFPLE9BQU8sU0FBUCxLQUFxQixVQUFyQixHQUNILFNBREcsR0FFRixDQUFELElBQU8sQ0FBQyxLQUFLLFNBRmpCO0FBR0QsS0FKd0IsQ0FBekIsQ0FUTSxDQWVOO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQU0sb0JBQW9CLEdBQUcsV0FBVyxHQUNwQyxtQkFBTSxXQUFOLEVBQW1CLElBQW5CLENBRG9DLEdBRXBDLEtBQUssS0FBTCxDQUFXLFFBQVgsR0FBc0IsWUFGMUIsQ0FuQk0sQ0F1Qk47QUFDQTs7QUFDQSxVQUFNLG9CQUFvQixHQUFHLG9CQUMzQixvQkFBTyxvQkFBUCxFQUE4QixXQUFELElBQWlCO0FBQzVDO0FBQ0E7QUFDQSxVQUNFLHNCQUFzQixJQUN0Qiw2Q0FBMEIsV0FBMUIsRUFBdUMsT0FBdkMsRUFBZ0QsT0FBaEQsTUFBNkQsS0FGL0QsRUFHRTtBQUNBLGVBQU8sS0FBUDtBQUNELE9BUjJDLENBUzVDO0FBQ0E7OztBQUNBLFdBQUssTUFBTSxDQUFDLEdBQUQsRUFBTSxTQUFOLENBQVgsSUFBK0IsTUFBTSxDQUFDLE9BQVAsQ0FBZSxnQkFBZixDQUEvQixFQUFpRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLFFBQXZCLEVBQWlDO0FBQy9CLGNBQUksU0FBUyxDQUFDLFdBQVcsQ0FBQyxRQUFaLENBQXFCLEdBQXJCLENBQUQsQ0FBVCxLQUF5QyxLQUE3QyxFQUFvRDtBQUNsRCxtQkFBTyxLQUFQO0FBQ0Q7QUFDRixTQUpELE1BSU8sSUFBSSxTQUFTLENBQUMsV0FBVyxDQUFDLEdBQUQsQ0FBWixDQUFULEtBQWdDLEtBQXBDLEVBQTJDO0FBQ2hELGlCQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELGFBQU8sSUFBUDtBQUNELEtBM0JELENBRDJCLEVBNkIzQixNQTdCMkIsQ0FBN0I7O0FBK0JBLFFBQUksS0FBSyxLQUFLLFNBQWQsRUFBeUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUosRUFBZjtBQUNBLFlBQU0sR0FBRyxHQUFHLEVBQVosQ0FOdUIsQ0FPdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxXQUFLLElBQUksQ0FBQyxHQUFHLG9CQUFvQixDQUFDLE1BQXJCLEdBQThCLENBQTNDLEVBQThDLENBQUMsR0FBRyxDQUFDLENBQW5ELEVBQXNELENBQUMsRUFBdkQsRUFBMkQ7QUFDekQsY0FBTSxNQUFNLEdBQUcsb0JBQW9CLENBQUMsQ0FBRCxDQUFuQztBQUNBLGNBQU07QUFBRSxVQUFBO0FBQUYsWUFBWSxNQUFNLENBQUMsUUFBekI7O0FBQ0EsWUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFQLENBQVcsS0FBWCxDQUFMLEVBQXdCO0FBQ3RCLGNBQUksTUFBTSxDQUFDLElBQVAsR0FBYyxLQUFsQixFQUF5QjtBQUN2QixZQUFBLE1BQU0sQ0FBQyxHQUFQLENBQVcsS0FBWDtBQUNELFdBRkQsTUFFTztBQUNMO0FBQ0Q7QUFDRixTQVR3RCxDQVV6RDtBQUNBOzs7QUFDQSxRQUFBLEdBQUcsQ0FBQyxPQUFKLENBQVksTUFBWjtBQUNEOztBQUNELGFBQU8sR0FBUDtBQUNEOztBQUNELFdBQU8sb0JBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLG1CQUFtQixDQUFDLElBQUQsRUFBTztBQUN4QixTQUFLLHFCQUFMLENBQTJCLElBQTNCLEVBQWlDLGtDQUFxQixRQUF0RDs7QUFDQSxTQUFLLGtCQUFMLENBQXdCLElBQXhCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLHFCQUFxQixDQUFDLElBQUQsRUFBTztBQUMxQixTQUFLLHFCQUFMLENBQTJCLElBQTNCLEVBQWlDLGtDQUFxQixVQUF0RDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxtQkFBbUIsQ0FBQyxJQUFELEVBQU87QUFDeEIsU0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxrQ0FBcUIsUUFBdEQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPO0FBQ3RCLFNBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsa0NBQXFCLE1BQXREO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsb0JBQW9CLENBQUMsSUFBRCxFQUFPO0FBQ3pCLFVBQU0sTUFBTSxHQUFHLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUFmO0FBQ0EsSUFBQSxNQUFNLENBQUMsYUFBUCxHQUF1QixJQUFJLElBQUosR0FBVyxPQUFYLEVBQXZCO0FBQ0EsU0FBSyxpQkFBTCxDQUF1QixNQUF2QixFQUErQiwyQ0FBL0I7O0FBQ0EsU0FBSyxxQkFBTCxDQUEyQixJQUEzQixFQUFpQyxrQ0FBcUIsU0FBdEQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsb0JBQW9CLENBQUMsSUFBRCxFQUFPO0FBQ3pCLFNBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsa0NBQXFCLFNBQXREO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLGtCQUFrQixDQUFDLElBQUQsRUFBTztBQUN2QixTQUFLLHFCQUFMLENBQTJCLElBQTNCLEVBQWlDLGtDQUFxQixPQUF0RDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWTtBQUFBOztBQUMzQixVQUFNLEtBQUssR0FBRyxHQUFHLElBQUksSUFBSSxLQUFKLENBQVUsMkJBQVYsQ0FBckI7QUFFQSxVQUFNLE1BQU0sR0FBRyxLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBZjtBQUNBLElBQUEsTUFBTSxDQUFDLEdBQVAsR0FBYTtBQUNYLE1BQUEsT0FBTyxFQUFFLG1CQUFBLEtBQUssQ0FBQyxPQUFOLGtFQUFlLFFBQWYsT0FBNkIsS0FBSyxDQUFDLFFBQU4sRUFEM0I7QUFFWCxNQUFBLEdBQUcsRUFBRSxLQUFLLENBQUMsS0FGQTtBQUdYLE1BQUEsS0FBSyxFQUFFLEtBQUssQ0FBQztBQUhGLEtBQWI7QUFLQSxTQUFLLGlCQUFMLENBQ0UsTUFERixFQUVFLGdEQUZGOztBQUlBLFNBQUsscUJBQUwsQ0FBMkIsSUFBM0IsRUFBaUMsa0NBQXFCLE1BQXREO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxnQkFBZ0IsQ0FBQyxPQUFELEVBQVU7QUFDeEI7QUFDQSxVQUFNO0FBQUUsTUFBQTtBQUFGLFFBQW1CLEtBQUssS0FBTCxDQUFXLFFBQVgsRUFBekI7QUFDQSxVQUFNLE9BQU8sR0FBRyxLQUFLLFVBQUwsRUFBaEI7QUFDQSxVQUFNLE9BQU8sR0FBRyxLQUFLLGlCQUFMLEVBQWhCLENBSndCLENBTXhCOztBQUNBLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFDckIsTUFBQSxZQUFZLEVBQUUsb0JBQ1osWUFEWSxFQUVYLFdBQUQsSUFDRSxXQUFXLENBQUMsUUFBWixDQUFxQixJQUFyQixLQUE4QixPQUE5QixJQUNBLDZDQUEwQixXQUExQixFQUF1QyxPQUF2QyxFQUFnRCxPQUFoRCxDQUpVO0FBRE8sS0FBdkI7QUFRRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0UsRUFBQSxrQkFBa0IsR0FBRztBQUNuQixTQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXVCO0FBQ3JCLE1BQUEsWUFBWSxFQUFFLG9CQUNaLEtBQUssS0FBTCxDQUFXLFFBQVgsR0FBc0IsWUFEVixFQUVYLFdBQUQsSUFBaUIsV0FBVyxDQUFDLE1BQVosS0FBdUIsa0NBQXFCLFVBRmpEO0FBRE8sS0FBdkI7QUFNRCxHQXRnQitELENBd2dCaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxxQkFBcUIsQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlO0FBQ2xDLFVBQU0sTUFBTSxHQUFHLEtBQUssY0FBTCxDQUFvQixJQUFwQixDQUFmOztBQUVBLFFBQUksQ0FBQyxNQUFMLEVBQWE7QUFDWDtBQUNEOztBQUVELElBQUEsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsTUFBaEI7O0FBQ0EsUUFBSTtBQUNGLFdBQUssaUJBQUwsQ0FDRSxNQURGLEVBRUcscUNBQW9DLE1BQU8sRUFGOUM7QUFJQSxXQUFLLElBQUwsQ0FBVyxHQUFFLE1BQU0sQ0FBQyxFQUFHLElBQUcsTUFBTyxFQUFqQyxFQUFvQyxJQUFwQztBQUNBLFdBQUssSUFBTCxDQUFXLGtCQUFYLEVBQThCLElBQTlCLEVBQW9DLE1BQXBDOztBQUNBLFVBQ0UsQ0FDRSxrQ0FBcUIsU0FEdkIsRUFFRSxrQ0FBcUIsUUFGdkIsRUFHRSxrQ0FBcUIsTUFIdkIsRUFJRSxRQUpGLENBSVcsTUFKWCxDQURGLEVBTUU7QUFDQSxhQUFLLElBQUwsQ0FBVyxHQUFFLE1BQU0sQ0FBQyxFQUFHLFdBQXZCLEVBQW1DLE1BQW5DO0FBQ0Q7O0FBQ0QsV0FBSyxJQUFMLENBQVUsK0NBQTJCLFlBQXJDO0FBQ0QsS0FqQkQsQ0FpQkUsT0FBTyxLQUFQLEVBQWM7QUFDZCx3QkFBSSxLQUFKLENBQVUsS0FBVjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSx1QkFBdUIsQ0FBQyxZQUFELEVBQWU7QUFDcEMsU0FBSyxLQUFMLENBQVcsV0FBWCxDQUF1QjtBQUNyQixNQUFBLFlBQVksRUFBRSxZQUFZLENBQUMsTUFBYixDQUFvQixDQUFDLE1BQUQsRUFBUyxLQUFULEtBQW1CO0FBQ25ELFFBQUEsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFQLENBQU4sR0FBbUIsS0FBbkI7QUFDQSxlQUFPLE1BQVA7QUFDRCxPQUhhLEVBR1gsS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixZQUhYO0FBRE8sS0FBdkI7QUFNRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxrQkFBa0IsQ0FBQyxtQkFBRCxFQUFzQjtBQUN0QyxVQUFNO0FBQUUsTUFBQTtBQUFGLFFBQW1CLEtBQUssS0FBTCxDQUFXLFFBQVgsRUFBekI7QUFDQSxXQUFPLFlBQVksQ0FBQyxtQkFBRCxDQUFuQjtBQUNBLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFDckIsTUFBQTtBQURxQixLQUF2QjtBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLG1CQUFtQixDQUFDLG9CQUFELEVBQXVCO0FBQ3hDLFVBQU07QUFBRSxNQUFBO0FBQUYsUUFBbUIsS0FBSyxLQUFMLENBQVcsUUFBWCxFQUF6QjtBQUNBLElBQUEsb0JBQW9CLENBQUMsT0FBckIsQ0FBOEIsYUFBRCxJQUFtQjtBQUM5QyxhQUFPLFlBQVksQ0FBQyxhQUFELENBQW5CO0FBQ0QsS0FGRDtBQUdBLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFDckIsTUFBQTtBQURxQixLQUF2QjtBQUdEOztBQXBuQitEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbERsRTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFZSxNQUFNLHlCQUFOLFNBQXdDLHlCQUF4QyxDQUFxRDtBQUNsRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSxFQUFBLFdBQVcsQ0FBQyxNQUFELEVBQVM7QUFDbEI7QUFEa0IsZ0VBVkcsQ0FVSDtBQUFBLHFFQUZRLElBQUksR0FBSixFQUVSO0FBRWxCLFNBQUssS0FBTCxHQUFhLE1BQU0sQ0FBQyxLQUFQLElBQWdCLElBQUksbUJBQUosQ0FBYSxNQUFNLENBQUMsUUFBcEIsQ0FBN0I7QUFDQSxTQUFLLFlBQUwsR0FBb0IsTUFBTSxDQUFDLFlBQTNCO0FBQ0EsU0FBSyxzQkFBTCxHQUE4QixNQUFNLENBQUMsc0JBQXJDO0FBQ0EsU0FBSyx3QkFBTCxHQUFnQyxNQUFNLENBQUMsd0JBQXZDO0FBQ0EsU0FBSyxrQkFBTCxHQUEwQixNQUFNLENBQUMsa0JBQWpDO0FBQ0EsU0FBSyxrQkFBTCxHQUEwQixNQUFNLENBQUMsa0JBQWpDO0FBQ0EsU0FBSyxrQkFBTCxHQUEwQixNQUFNLENBQUMsa0JBQWpDO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7OztBQUN3QixRQUFoQixnQkFBZ0IsR0FBRztBQUN2QjtBQUNBLFVBQU0sZUFBZSxHQUFHLE1BQU0sS0FBSyxZQUFMLENBQWtCLGFBQWxCLEVBQTlCOztBQUNBLFFBQUk7QUFDRixZQUFNLFVBQVUsR0FBRyxLQUFLLHNCQUFMLEVBQW5CO0FBQ0EsWUFBTSxPQUFPLENBQUMsR0FBUixDQUNKLFVBQVUsQ0FBQyxHQUFYLENBQWdCLE1BQUQsSUFBWSxLQUFLLGVBQUwsQ0FBcUIsTUFBckIsQ0FBM0IsQ0FESSxDQUFOO0FBR0QsS0FMRCxDQUtFLE9BQU8sR0FBUCxFQUFZO0FBQ1osd0JBQUksS0FBSixDQUNFLGlFQURGOztBQUdBLHdCQUFJLEtBQUosQ0FBVSxHQUFWO0FBQ0Q7O0FBQ0QsSUFBQSxlQUFlLENBQUMsV0FBaEI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQzBCLFFBQWxCLGtCQUFrQixDQUFDLFdBQUQsRUFBYztBQUNwQyxVQUFNLE9BQU8sR0FBRyxLQUFLLHNCQUFMLEVBQWhCOztBQUNBLFFBQUksQ0FBQyxPQUFPLENBQUMsTUFBYixFQUFxQjtBQUNuQjtBQUNEOztBQUNELFNBQUssTUFBTSxNQUFYLElBQXFCLE9BQXJCLEVBQThCO0FBQzVCLFVBQUk7QUFDRixjQUFNLEtBQUssV0FBTCxDQUFpQixNQUFqQixFQUF5QixXQUF6QixDQUFOO0FBQ0QsT0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQUE7O0FBQ1osY0FBTSxZQUFZLEdBQ2hCLGVBQUEsR0FBRyxDQUFDLEtBQUosZ0ZBQVcsT0FBWCwwRUFBb0IsV0FBcEIsT0FBcUMsR0FBRyxDQUFDLE9BQUosQ0FBWSxXQUFaLEVBRHZDO0FBRUEsY0FBTSxTQUFTLEdBQ2I7QUFDQSxRQUFBLFlBQVksQ0FBQyxRQUFiLENBQXNCLHFDQUF0QixLQUNBLFlBQVksQ0FBQyxRQUFiLENBQXNCLG1CQUF0QixDQURBLElBRUE7QUFDQSxRQUFBLFlBQVksQ0FBQyxRQUFiLENBQXNCLDhCQUF0QixDQUhBLElBSUEsWUFBWSxDQUFDLFFBQWIsQ0FDRSxxREFERixDQUpBLElBT0E7QUFDQSxRQUFBLFlBQVksQ0FBQyxRQUFiLENBQXNCLGlCQUF0QixDQVJBLElBU0EsWUFBWSxDQUFDLFFBQWIsQ0FBc0IsZUFBdEIsQ0FYRixDQUhZLENBZVo7O0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDYjtBQUNELFNBbEJXLENBbUJaOzs7QUFDQSxRQUFBLE1BQU0sQ0FBQyxPQUFQLEdBQWlCO0FBQ2YsVUFBQSxLQUFLLEVBQUUsWUFEUTtBQUVmLFVBQUEsT0FBTyxFQUFFO0FBRk0sU0FBakI7QUFJQSxhQUFLLElBQUwsQ0FBVSxZQUFWLEVBQXdCLE1BQXhCLEVBQWdDLEdBQWhDO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDbUIsUUFBWCxXQUFXLENBQUMsTUFBRCxFQUFTLGlCQUFULEVBQTRCO0FBQzNDLFFBQUksQ0FBQyxNQUFNLENBQUMscUJBQVosRUFBbUM7QUFDakMsV0FBSyxJQUFMLENBQVUsaUJBQVYsRUFBNkIsTUFBN0IsRUFBcUMsaUJBQXJDO0FBQ0Q7O0FBRUQsVUFBTSxxQkFBcUIsR0FDekIsTUFBTSxDQUFDLHFCQUFQLElBQWdDLGlCQURsQztBQUVBLFVBQU0sZUFBZSxHQUNuQixNQUFNLENBQUMsUUFBUCxDQUFnQixpQkFBaEIsRUFBbUMsRUFBbkMsSUFDQSxNQUFNLENBQUMsUUFBUCxDQUFnQixxQkFBaEIsRUFBdUMsRUFBdkMsQ0FGRjtBQUlBLFVBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFQLElBQXFCLENBQXhDLENBWDJDLENBYTNDOztBQUNBLFFBQUksZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsRUFBVCxFQUFhLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxFQUFZLFVBQVosQ0FBYixDQUF0QixFQUE2RDtBQUMzRCxhQUFPLFNBQVA7QUFDRCxLQWhCMEMsQ0FrQjNDOzs7QUFDQSxRQUFJLEVBQUUsV0FBVyxNQUFiLENBQUosRUFBMEI7QUFDeEIsYUFBTyxLQUFLLGtCQUFMLENBQXdCLE1BQU0sQ0FBQyxFQUEvQixDQUFQO0FBQ0Q7O0FBRUQsVUFBTTtBQUFFLE1BQUE7QUFBRixRQUFZLE1BQWxCO0FBQ0EsVUFBTSxNQUFNLEdBQUcsTUFBTSxLQUFLLGtCQUFMLENBQXdCLEtBQXhCLENBQXJCLENBeEIyQyxDQTBCM0M7O0FBQ0EsU0FBSyxJQUFMLENBQVUsVUFBVixFQUFzQixNQUF0QjtBQUNBLFdBQU8sTUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUV1QixRQUFmLGVBQWUsQ0FBQyxNQUFELEVBQVM7QUFDNUIsVUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQXRCO0FBQ0EsVUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQXBCLENBRjRCLENBSTVCOztBQUNBLFFBQUksTUFBTSxDQUFDLE1BQVAsS0FBa0Isa0NBQXFCLFNBQTNDLEVBQXNEO0FBQ3BEO0FBQ0QsS0FQMkIsQ0FTNUI7QUFDQTs7O0FBQ0EsUUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLFlBQU0sV0FBVyxHQUFHLElBQUksS0FBSixDQUNsQixzRUFEa0IsQ0FBcEI7QUFHQSxNQUFBLFdBQVcsQ0FBQyxJQUFaLEdBQW1CLGVBQW5CO0FBQ0EsV0FBSyxJQUFMLENBQVUsV0FBVixFQUF1QixJQUF2QixFQUE2QixXQUE3QjtBQUVBO0FBQ0Q7O0FBRUQsUUFBSSxNQUFNLEtBQUssb0JBQUwsQ0FBMEIsTUFBMUIsQ0FBVixFQUE2QztBQUMzQyxXQUFLLElBQUwsQ0FBVSxZQUFWLEVBQXdCLElBQXhCO0FBQ0E7QUFDRDs7QUFFRCxRQUFJO0FBQ0YsWUFBTSxrQkFBa0IsR0FBRyxNQUFNLEtBQUssS0FBTCxDQUFXLHFCQUFYLENBQWlDLE1BQWpDLENBQWpDOztBQUNBLFVBQUksa0JBQUosYUFBSSxrQkFBSixlQUFJLGtCQUFrQixDQUFFLFdBQXhCLEVBQXFDO0FBQ25DLGNBQU07QUFDSixVQUFBLGFBREk7QUFFSixVQUFBLFNBQVMsRUFBRTtBQUZQLFlBR0YsTUFBTSxLQUFLLEtBQUwsQ0FBVyxjQUFYLENBQ1Isa0JBRFEsYUFDUixrQkFEUSx1QkFDUixrQkFBa0IsQ0FBRSxTQURaLEVBRVIsS0FGUSxDQUhWO0FBUUEsYUFBSyxJQUFMLENBQ0UsY0FERixFQUVFLElBRkYsRUFHRSxrQkFIRixFQUlFLGFBSkYsRUFLRSxjQUxGO0FBT0E7QUFDRDtBQUNGLEtBcEJELENBb0JFLE9BQU8sR0FBUCxFQUFZO0FBQ1osTUFBQSxNQUFNLENBQUMsT0FBUCxHQUFpQjtBQUNmLFFBQUEsS0FBSyxFQUFFLEdBQUcsQ0FBQyxPQURJO0FBRWYsUUFBQSxPQUFPLEVBQUU7QUFGTSxPQUFqQjtBQUlBLFdBQUssSUFBTCxDQUFVLFlBQVYsRUFBd0IsTUFBeEIsRUFBZ0MsR0FBaEM7QUFDQTtBQUNEOztBQUVELFFBQUksTUFBTSxLQUFLLG9CQUFMLENBQTBCLE1BQTFCLENBQVYsRUFBNkM7QUFDM0MsV0FBSyxJQUFMLENBQVUsWUFBVixFQUF3QixJQUF4QjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQzRCLFFBQXBCLG9CQUFvQixDQUFDLE1BQUQsRUFBUztBQUNqQyxVQUFNO0FBQ0osTUFBQSxJQUFJLEVBQUUsTUFERjtBQUVKLE1BQUEsUUFBUSxFQUFFO0FBQUUsUUFBQSxLQUFGO0FBQVMsUUFBQTtBQUFUO0FBRk4sUUFHRixNQUhKO0FBSUEsVUFBTSxnQkFBZ0IsR0FBRyxNQUFNLEtBQUssS0FBTCxDQUFXLG1CQUFYLENBQStCLElBQS9CLENBQS9COztBQUVBLFFBQUksUUFBUSxDQUFDLEtBQUQsRUFBUSxFQUFSLENBQVIsSUFBdUIsZ0JBQWdCLENBQUMsUUFBakIsRUFBM0IsRUFBd0Q7QUFDdEQsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDLEtBQUsseUJBQUwsQ0FBK0IsR0FBL0IsQ0FBbUMsTUFBbkMsQ0FBTCxFQUFpRDtBQUMvQyxXQUFLLHlCQUFMLENBQStCLEdBQS9CLENBQW1DLE1BQW5DLEVBQTJDLENBQTNDO0FBQ0Q7O0FBRUQsVUFBTSxrQkFBa0IsR0FBRyxLQUFLLHlCQUFMLENBQStCLEdBQS9CLENBQW1DLE1BQW5DLENBQTNCOztBQUVBLFFBQUksa0JBQWtCLEdBQUcsS0FBSyxvQkFBOUIsRUFBb0Q7QUFDbEQsV0FBSyx5QkFBTCxDQUErQixHQUEvQixDQUFtQyxNQUFuQyxFQUEyQyxrQkFBa0IsR0FBRyxDQUFoRTtBQUNBLGFBQU8sS0FBUDtBQUNEOztBQUVELFNBQUsseUJBQUwsQ0FBK0IsTUFBL0IsQ0FBc0MsTUFBdEM7QUFDQSxXQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQzRCLFFBQXBCLG9CQUFvQixDQUFDLE1BQUQsRUFBUztBQUNqQyxVQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsUUFBUCxDQUFnQixJQUFoQztBQUNBLFVBQU0sU0FBUyxHQUFHLEtBQUssd0JBQUwsQ0FBOEIsT0FBOUIsQ0FBbEI7QUFDQSxXQUFPLFNBQVMsQ0FBQyxJQUFWLEVBQ0w7QUFDQTtBQUNBO0FBQ0MsSUFBQSxLQUFELElBQ0UsRUFBRSxLQUFLLENBQUMsRUFBTixLQUFhLE1BQU0sQ0FBQyxFQUF0QixLQUNBLEtBQUssQ0FBQyxRQUFOLENBQWUsS0FBZixLQUF5QixNQUFNLENBQUMsUUFBUCxDQUFnQixLQU50QyxDQUFQO0FBUUQ7O0FBaFFpRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQjdELE1BQU0sYUFBYSxHQUFHLFNBQXRCOztBQUVBLE1BQU0sa0JBQWtCLEdBQUc7QUFDaEMsRUFBQSxlQUFlLEVBQUUsMEJBRGU7QUFFaEMsRUFBQSxrQkFBa0IsRUFBRSw2QkFGWTtBQUdoQyxFQUFBLFlBQVksRUFBRTtBQUhrQixDQUEzQjs7QUFNQSxNQUFNLGtCQUFrQixHQUFHLENBQ2hDLDJCQURnQyxFQUVoQyxtQkFGZ0MsQ0FBM0I7O0FBS0EsTUFBTSxnQkFBZ0IsR0FBRztBQUM5QixFQUFBLFVBQVUsRUFBRSxZQURrQjtBQUU5QixFQUFBLFFBQVEsRUFBRTtBQUZvQixDQUF6QjtBQUtQO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTSxTQUFTLEdBQUcsR0FBbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJQOztBQUtPLFNBQVMsaUNBQVQsQ0FBMkMsb0JBQTNDLEVBQWlFO0FBQ3RFLFNBQU87QUFDTCxJQUFBLG1CQUFtQixFQUFFLENBQUMsTUFBRCxFQUFTLE9BQVQsS0FBcUI7QUFDeEMsWUFBTSxRQUFRLEdBQUcsb0JBQW9CLENBQUMsU0FBckIsQ0FDZixNQURlLEVBRWYsK0JBQWtCLFlBRkgsRUFHZix5QkFBWSx3QkFIRyxDQUFqQjs7QUFNQSxVQUFJLFFBQVEsQ0FBQyxLQUFULENBQWUsUUFBZixDQUF3QixPQUF4QixDQUFKLEVBQXNDO0FBQ3BDLGNBQU0sSUFBSSxLQUFKLENBQ0gsdUNBQXNDLE1BQU8sOEJBQTZCLE9BQVEsSUFEL0UsQ0FBTjtBQUdEOztBQUVELE1BQUEsb0JBQW9CLENBQUMsWUFBckIsQ0FDRSxNQURGLEVBRUUsK0JBQWtCLFlBRnBCLEVBR0UseUJBQVksd0JBSGQsRUFJRSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQWIsRUFBb0IsT0FBcEIsQ0FKRjtBQU1ELEtBcEJJO0FBc0JMLElBQUEsc0JBQXNCLEVBQUUsQ0FBQyxNQUFELEVBQVMsT0FBVCxLQUFxQjtBQUMzQyxZQUFNLFFBQVEsR0FBRyxvQkFBb0IsQ0FBQyxTQUFyQixDQUNmLE1BRGUsRUFFZiwrQkFBa0IsWUFGSCxFQUdmLHlCQUFZLHdCQUhHLENBQWpCOztBQU1BLFVBQUksQ0FBQyxRQUFRLENBQUMsS0FBVCxDQUFlLFFBQWYsQ0FBd0IsT0FBeEIsQ0FBTCxFQUF1QztBQUNyQyxjQUFNLElBQUksS0FBSixDQUNILHVDQUFzQyxNQUFPLHNDQUFxQyxPQUFRLElBRHZGLENBQU47QUFHRDs7QUFFRCxZQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxLQUFULENBQWUsTUFBZixDQUN2QixlQUFELElBQXFCLGVBQWUsS0FBSyxPQURqQixDQUExQjs7QUFJQSxVQUFJLGlCQUFpQixDQUFDLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2xDLFFBQUEsb0JBQW9CLENBQUMsZ0JBQXJCLENBQ0UsTUFERixFQUVFLCtCQUFrQixZQUZwQjtBQUlELE9BTEQsTUFLTztBQUNMLFFBQUEsb0JBQW9CLENBQUMsWUFBckIsQ0FDRSxNQURGLEVBRUUsK0JBQWtCLFlBRnBCLEVBR0UseUJBQVksd0JBSGQsRUFJRSxpQkFKRjtBQU1EO0FBQ0YsS0FwREk7QUFzREwsSUFBQSwrQkFBK0IsRUFBRSxNQUFPLE1BQVAsSUFBa0I7QUFDakQsWUFBTSxHQUFHO0FBQUUsUUFBQTtBQUFGLE9BQUgsSUFBYSxNQUFNLG9CQUFvQixDQUFDLGtCQUFyQixDQUN2QjtBQUFFLFFBQUE7QUFBRixPQUR1QixFQUV2QjtBQUNFLFFBQUEsWUFBWSxFQUFFO0FBRGhCLE9BRnVCLENBQXpCO0FBTUEsYUFBTyxFQUFQO0FBQ0Q7QUE5REksR0FBUDtBQWdFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFRDs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsR0FBSSxLQUFELElBQVcsS0FBSyxDQUFDLFFBQXJDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLE1BQU0sNEJBQTRCLEdBQUcsOEJBQzFDLFdBRDBDLEVBRXpDLFFBQUQsSUFBYztBQUNaLFNBQU8sTUFBTSxDQUFDLE1BQVAsQ0FBYyxRQUFkLEVBQXdCLE1BQXhCLENBQStCLENBQUMsbUJBQUQsRUFBc0IsT0FBdEIsS0FBa0M7QUFBQTs7QUFDdEUsVUFBTSxNQUFNLDJCQUFHLE9BQU8sQ0FBQyxXQUFYLGtGQUFHLHFCQUFxQixZQUF4QiwwREFBRyxzQkFBbUMsT0FBbkMsQ0FBMkMsSUFBM0MsQ0FDYixDQUFDO0FBQUUsTUFBQTtBQUFGLEtBQUQsS0FBYyxJQUFJLEtBQUsseUJBQVksd0JBRHRCLENBQWY7O0FBSUEsUUFBSSxNQUFKLEVBQVk7QUFDVixNQUFBLG1CQUFtQixDQUFDLEdBQXBCLENBQXdCLE9BQU8sQ0FBQyxNQUFoQyxFQUF3QyxNQUFNLENBQUMsS0FBL0M7QUFDRDs7QUFDRCxXQUFPLG1CQUFQO0FBQ0QsR0FUTSxFQVNKLElBQUksR0FBSixFQVRJLENBQVA7QUFVRCxDQWJ5QyxDQUFyQztBQWdCUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ08sTUFBTSxrQkFBa0IsR0FBRyxDQUFDLGNBQUQsRUFBaUIsbUJBQWpCLEtBQXlDO0FBQ3pFLE1BQUksbUJBQW1CLEtBQUssU0FBNUIsRUFBdUM7QUFDckMsV0FBTyxjQUFQO0FBQ0Q7O0FBRUQsUUFBTSxlQUFlLEdBQUcsSUFBSSxHQUFKLEVBQXhCOztBQUNBLE1BQUksY0FBYyxLQUFLLG1CQUF2QixFQUE0QztBQUMxQyxXQUFPLGVBQVA7QUFDRDs7QUFFRCxRQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUosQ0FBUSxDQUFDLEdBQUcsY0FBYyxDQUFDLElBQWYsRUFBSixDQUFSLENBQW5COztBQUVBLE9BQUssTUFBTSxNQUFYLElBQXFCLG1CQUFtQixDQUFDLElBQXBCLEVBQXJCLEVBQWlEO0FBQUE7O0FBQy9DLFVBQU0sV0FBVywwQkFBRyxjQUFjLENBQUMsR0FBZixDQUFtQixNQUFuQixDQUFILHFFQUFpQyxFQUFsRCxDQUQrQyxDQUcvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFFBQUksbUJBQW1CLENBQUMsR0FBcEIsQ0FBd0IsTUFBeEIsTUFBb0MsV0FBeEMsRUFBcUQ7QUFDbkQsTUFBQSxlQUFlLENBQUMsR0FBaEIsQ0FBb0IsTUFBcEIsRUFBNEIsV0FBNUI7QUFDRDs7QUFFRCxJQUFBLFVBQVUsQ0FBQyxNQUFYLENBQWtCLE1BQWxCO0FBQ0QsR0F6QndFLENBMkJ6RTtBQUNBOzs7QUFDQSxPQUFLLE1BQU0sTUFBWCxJQUFxQixVQUFVLENBQUMsSUFBWCxFQUFyQixFQUF3QztBQUN0QyxJQUFBLGVBQWUsQ0FBQyxHQUFoQixDQUFvQixNQUFwQixFQUE0QixjQUFjLENBQUMsR0FBZixDQUFtQixNQUFuQixDQUE1QjtBQUNEOztBQUNELFNBQU8sZUFBUDtBQUNELENBakNNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRFA7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHNCQUFzQixHQUFHO0FBQ3BDLEdBQUMseUJBQVksd0JBQWIsR0FBd0M7QUFDdEMsSUFBQTtBQURzQztBQURKLENBQS9CO0FBTVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBLFNBQVMsYUFBVCxDQUF1QixhQUF2QixFQUFzQyxnQkFBdEMsRUFBd0Q7QUFDdEQsUUFBTSxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsTUFBakIsQ0FDakIsT0FBRCxJQUFhLE9BQU8sS0FBSyxhQURQLENBQXBCOztBQUlBLE1BQUksV0FBVyxDQUFDLE1BQVosS0FBdUIsZ0JBQWdCLENBQUMsTUFBNUMsRUFBb0Q7QUFDbEQsV0FBTztBQUFFLE1BQUEsU0FBUyxFQUFFLHdDQUF1QjtBQUFwQyxLQUFQO0FBQ0QsR0FGRCxNQUVPLElBQUksV0FBVyxDQUFDLE1BQVosR0FBcUIsQ0FBekIsRUFBNEI7QUFDakMsV0FBTztBQUNMLE1BQUEsU0FBUyxFQUFFLHdDQUF1QixXQUQ3QjtBQUVMLE1BQUEsS0FBSyxFQUFFO0FBRkYsS0FBUDtBQUlEOztBQUNELFNBQU87QUFBRSxJQUFBLFNBQVMsRUFBRSx3Q0FBdUI7QUFBcEMsR0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDRDs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHVCQUFOLENBQThCO0FBQ25DO0FBQ0Y7QUFDQTtBQUNFLEVBQUEsV0FBVyxDQUFDO0FBQUUsSUFBQSxpQkFBRjtBQUFxQixJQUFBO0FBQXJCLEdBQUQsRUFBbUM7QUFDNUMsU0FBSyxpQkFBTCxHQUF5QixpQkFBekI7QUFDQSxTQUFLLEtBQUwsR0FBYSxJQUFJLHlCQUFKO0FBQ1gsTUFBQSxpQkFBaUIsRUFBRSxFQURSO0FBRVgsTUFBQSxxQkFBcUIsRUFBRTtBQUZaLE9BR1IsU0FIUSxFQUFiO0FBS0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLGNBQWMsR0FBRztBQUNmLFdBQU8sS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixxQkFBN0I7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPO0FBQ3RCLFNBQUssS0FBTCxDQUFXLFdBQVgsQ0FBdUI7QUFBRSxNQUFBLHFCQUFxQixFQUFFO0FBQXpCLEtBQXZCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLFVBQVUsR0FBRztBQUNYLFdBQU8sS0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixpQkFBN0I7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsYUFBYSxDQUFDLE9BQUQsRUFBVTtBQUNyQixTQUFLLEtBQUwsQ0FBVyxXQUFYLENBQXVCO0FBQUUsTUFBQSxpQkFBaUIsRUFBRTtBQUFyQixLQUF2QjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLHFCQUFxQixDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CO0FBQ3RDLFFBQUksUUFBUSxDQUFDLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekI7QUFDRDs7QUFFRCxVQUFNLGdCQUFnQixHQUFHLG1CQUFtQixDQUFDLFFBQUQsRUFBVyxJQUFJLENBQUMsR0FBTCxFQUFYLENBQTVDO0FBRUEsU0FBSyxnQkFBTCxDQUFzQixNQUF0QixFQUE4QjtBQUM1QixNQUFBLFlBQVksRUFBRTtBQUNaLFFBQUEsUUFBUSxFQUFFO0FBREU7QUFEYyxLQUE5QjtBQUtEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsZ0JBQWdCLEdBQUc7QUFDakIsV0FBTyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsSUFBWCxFQUFpQixJQUFqQixLQUEwQjtBQUMvQixVQUFJLGFBQUosRUFBbUIsZ0JBQW5CO0FBQ0EsWUFBTTtBQUFFLFFBQUEsTUFBRjtBQUFVLFFBQUE7QUFBVixVQUFxQixHQUEzQjtBQUNBLFlBQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFQLENBQWtCLG9CQUFsQixDQUFuQixDQUgrQixDQUsvQjs7QUFDQSxVQUNFLENBQUMsMEJBQW1CLFFBQW5CLENBQTRCLE1BQTVCLENBQUQsS0FDQyxVQUFVLElBQUksS0FBSyxpQkFBTCxDQUF1QixHQUF2QixDQUEyQixNQUEzQixDQURmLENBREYsRUFHRTtBQUNBLFFBQUEsYUFBYSxHQUFHLEtBQUssVUFBTCxDQUFnQixHQUFoQixFQUFxQixVQUFyQixDQUFoQjs7QUFFQSxZQUFJLE1BQU0sS0FBTSxHQUFFLG9CQUFjLG9CQUFoQyxFQUFxRDtBQUNuRDtBQUNBO0FBQ0EsVUFBQSxnQkFBZ0IsR0FBRyxLQUFLLG1CQUFMLENBQXlCLEdBQXpCLENBQW5CO0FBQ0Q7QUFDRixPQVhELE1BV08sSUFBSSxNQUFNLEtBQUsscUJBQWYsRUFBc0M7QUFDM0M7QUFDQTtBQUNBLFFBQUEsYUFBYSxHQUFHLEtBQUssVUFBTCxDQUFnQixHQUFoQixFQUFxQixVQUFyQixDQUFoQjtBQUNBLFFBQUEsZ0JBQWdCLEdBQUcsQ0FBQyxjQUFELENBQW5CO0FBQ0QsT0FMTSxNQUtBO0FBQ0w7QUFDQSxRQUFBLElBQUk7QUFDSjtBQUNELE9BMUI4QixDQTRCL0I7OztBQUNBLE1BQUEsSUFBSSxDQUFFLEVBQUQsSUFBUTtBQUNYLGNBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFMLEVBQWI7QUFDQSxhQUFLLFdBQUwsQ0FBaUIsYUFBakIsRUFBZ0MsR0FBaEMsRUFBcUMsSUFBckM7O0FBRUEsWUFBSSxnQkFBZ0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUF6QixJQUFrQyxHQUFHLENBQUMsTUFBMUMsRUFBa0Q7QUFDaEQ7QUFDQTtBQUNBLGVBQUsscUJBQUwsQ0FDRSxnQkFERixFQUVFLE1BRkYsRUFHRSxHQUFHLENBQUMsTUFITixFQUlFLElBSkYsRUFLRSxNQUFNLEtBQUsscUJBTGI7QUFPRDs7QUFDRCxRQUFBLEVBQUU7QUFDSCxPQWhCRyxDQUFKO0FBaUJELEtBOUNEO0FBK0NEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLFVBQVUsQ0FBQyxPQUFELEVBQVUsVUFBVixFQUFzQjtBQUM5QixVQUFNLGFBQWEsR0FBRztBQUNwQixNQUFBLEVBQUUsRUFBRSxPQUFPLENBQUMsRUFEUTtBQUVwQixNQUFBLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFGSTtBQUdwQixNQUFBLFVBQVUsRUFBRSxVQUFVLEdBQ2xCLHdCQUFpQixRQURDLEdBRWxCLHdCQUFpQixVQUxEO0FBTXBCLE1BQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQU5JO0FBT3BCLE1BQUEsT0FBTyxFQUFFLGdDQUFVLE9BQVYsRUFBbUIsSUFBbkIsRUFBeUIsQ0FBekIsQ0FQVztBQVFwQixNQUFBLFdBQVcsRUFBRSxJQUFJLENBQUMsR0FBTCxFQVJPO0FBU3BCLE1BQUEsUUFBUSxFQUFFLElBVFU7QUFVcEIsTUFBQSxZQUFZLEVBQUUsSUFWTTtBQVdwQixNQUFBLE9BQU8sRUFBRTtBQVhXLEtBQXRCO0FBYUEsU0FBSyxpQkFBTCxDQUF1QixhQUF2QjtBQUNBLFdBQU8sYUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxXQUFXLENBQUMsS0FBRCxFQUFRLFFBQVIsRUFBa0IsSUFBbEIsRUFBd0I7QUFDakMsUUFBSSxDQUFDLEtBQUQsSUFBVSxDQUFDLFFBQWYsRUFBeUI7QUFDdkI7QUFDRDs7QUFFRCxJQUFBLEtBQUssQ0FBQyxRQUFOLEdBQWlCLGdDQUFVLFFBQVYsRUFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsQ0FBakI7QUFDQSxJQUFBLEtBQUssQ0FBQyxZQUFOLEdBQXFCLElBQXJCO0FBQ0EsSUFBQSxLQUFLLENBQUMsT0FBTixHQUFnQixDQUFDLFFBQVEsQ0FBQyxLQUExQjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxFQUFBLGlCQUFpQixDQUFDLEtBQUQsRUFBUTtBQUN2QixVQUFNLElBQUksR0FBRyxLQUFLLGNBQUwsRUFBYixDQUR1QixDQUd2Qjs7QUFDQSxJQUFBLElBQUksQ0FBQyxJQUFMLENBQVUsS0FBVixFQUp1QixDQU12Qjs7QUFDQSxRQUFJLElBQUksQ0FBQyxNQUFMLEdBQWMsZ0JBQWxCLEVBQTZCO0FBQzNCLE1BQUEsSUFBSSxDQUFDLEtBQUw7QUFDRDs7QUFFRCxTQUFLLGlCQUFMLENBQXVCLElBQXZCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEscUJBQXFCLENBQ25CLGdCQURtQixFQUVuQixNQUZtQixFQUduQixNQUhtQixFQUluQixJQUptQixFQUtuQixvQkFMbUIsRUFNbkI7QUFDQSxRQUFJLFFBQUosRUFBYyxVQUFkOztBQUVBLFFBQUksb0JBQUosRUFBMEI7QUFDeEIsTUFBQSxRQUFRLEdBQUcsTUFBWDtBQUNBLFlBQU0sZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUMsUUFBRCxFQUFXLElBQVgsQ0FBNUM7QUFFQSxNQUFBLFVBQVUsR0FBRztBQUNYLFFBQUEsWUFBWSxFQUFFO0FBQ1osVUFBQSxRQUFRLEVBQUUsZ0JBREU7QUFFWixVQUFBLFlBQVksRUFBRTtBQUZGO0FBREgsT0FBYjtBQU1ELEtBVkQsTUFVTztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUEsVUFBVSxHQUFHLE1BQU0sQ0FDaEIsR0FEVSxDQUNMLElBQUQsSUFBVTtBQUNiLFlBQUksSUFBSSxDQUFDLGdCQUFMLEtBQTBCLGNBQTlCLEVBQThDO0FBQzVDLFVBQUEsUUFBUSxHQUFHLEtBQUsseUJBQUwsQ0FBK0IsSUFBL0IsQ0FBWDtBQUNEOztBQUVELGVBQU8sSUFBSSxDQUFDLGdCQUFaO0FBQ0QsT0FQVSxFQVFWLE1BUlUsQ0FRSCxDQUFDLEdBQUQsRUFBTSxNQUFOLEtBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxZQUFJLGdCQUFnQixDQUFDLFFBQWpCLENBQTBCLE1BQTFCLENBQUosRUFBdUM7QUFDckMsY0FBSSxNQUFNLEtBQUssY0FBZixFQUErQjtBQUM3QixrQkFBTSxnQkFBZ0IsR0FBRyxtQkFBbUIsQ0FBQyxRQUFELEVBQVcsSUFBWCxDQUE1QztBQUVBLFlBQUEsR0FBRyxDQUFDLE1BQUQsQ0FBSCxHQUFjO0FBQ1osY0FBQSxZQUFZLEVBQUUsSUFERjtBQUVaLGNBQUEsUUFBUSxFQUFFO0FBRkUsYUFBZDtBQUlELFdBUEQsTUFPTztBQUNMLFlBQUEsR0FBRyxDQUFDLE1BQUQsQ0FBSCxHQUFjO0FBQUUsY0FBQSxZQUFZLEVBQUU7QUFBaEIsYUFBZDtBQUNEO0FBQ0Y7O0FBRUQsZUFBTyxHQUFQO0FBQ0QsT0F6QlUsRUF5QlIsRUF6QlEsQ0FBYjtBQTBCRDs7QUFFRCxRQUFJLE1BQU0sQ0FBQyxJQUFQLENBQVksVUFBWixFQUF3QixNQUF4QixHQUFpQyxDQUFyQyxFQUF3QztBQUN0QyxXQUFLLGdCQUFMLENBQXNCLE1BQXRCLEVBQThCLFVBQTlCO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNFLEVBQUEsZ0JBQWdCLENBQUMsTUFBRCxFQUFTLFVBQVQsRUFBcUI7QUFDbkM7QUFDQSxVQUFNLE9BQU8sR0FBRyxLQUFLLFVBQUwsRUFBaEI7O0FBQ0EsVUFBTSxnQkFBZ0IsbUNBQ2pCLE9BQU8sQ0FBQyxNQUFELENBRFUsR0FFakIsVUFGaUIsQ0FBdEIsQ0FIbUMsQ0FRbkM7QUFDQTs7O0FBQ0EsVUFBTSx3QkFBd0IsR0FDNUIsT0FBTyxDQUFDLE1BQUQsQ0FBUCxJQUFtQixPQUFPLENBQUMsTUFBRCxDQUFQLENBQWdCLFlBRHJDO0FBRUEsVUFBTSxtQkFBbUIsR0FBRyxVQUFVLENBQUMsWUFBdkM7O0FBRUEsUUFBSSx3QkFBd0IsSUFBSSxtQkFBaEMsRUFBcUQ7QUFDbkQ7QUFDQTtBQUNBLFlBQU0sWUFBWSxHQUNoQixtQkFBbUIsQ0FBQyxZQUFwQixJQUNBLHdCQUF3QixDQUFDLFlBRjNCLENBSG1ELENBT25EOztBQUNBLE1BQUEsZ0JBQWdCLENBQUMsWUFBakIsR0FBZ0M7QUFDOUIsUUFBQSxZQUQ4QjtBQUU5QixRQUFBLFFBQVEsa0NBQ0gsd0JBQXdCLENBQUMsUUFEdEIsR0FFSCxtQkFBbUIsQ0FBQyxRQUZqQjtBQUZzQixPQUFoQztBQU9EOztBQUVELElBQUEsT0FBTyxDQUFDLE1BQUQsQ0FBUCxHQUFrQixnQkFBbEI7QUFFQSxTQUFLLGFBQUwsQ0FBbUIsT0FBbkI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSxtQkFBbUIsQ0FBQyxPQUFELEVBQVU7QUFDM0IsUUFDRSxDQUFDLE9BQU8sQ0FBQyxNQUFULElBQ0EsQ0FBQyxPQUFPLENBQUMsTUFBUixDQUFlLENBQWYsQ0FERCxJQUVBLE9BQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxDQUFmLENBQVAsS0FBNkIsUUFGN0IsSUFHQSxLQUFLLENBQUMsT0FBTixDQUFjLE9BQU8sQ0FBQyxNQUFSLENBQWUsQ0FBZixDQUFkLENBSkYsRUFLRTtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU8sTUFBTSxDQUFDLElBQVAsQ0FBWSxPQUFPLENBQUMsTUFBUixDQUFlLENBQWYsQ0FBWixDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsRUFBQSx5QkFBeUIsQ0FBQyxJQUFELEVBQU87QUFDOUIsUUFBSSxJQUFJLENBQUMsZ0JBQUwsS0FBMEIsY0FBMUIsSUFBNEMsQ0FBQyxJQUFJLENBQUMsT0FBdEQsRUFBK0Q7QUFDN0QsYUFBTyxFQUFQO0FBQ0Q7O0FBRUQsVUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFKLEVBQWpCOztBQUNBLFNBQUssTUFBTSxNQUFYLElBQXFCLElBQUksQ0FBQyxPQUExQixFQUFtQztBQUNqQyxVQUNFLE1BQU0sQ0FBQyxJQUFQLEtBQWdCLHlCQUFZLHdCQUE1QixJQUNBLEtBQUssQ0FBQyxPQUFOLENBQWMsTUFBTSxDQUFDLEtBQXJCLENBRkYsRUFHRTtBQUNBLGFBQUssTUFBTSxLQUFYLElBQW9CLE1BQU0sQ0FBQyxLQUEzQixFQUFrQztBQUNoQyxVQUFBLFFBQVEsQ0FBQyxHQUFULENBQWEsS0FBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxXQUFPLENBQUMsR0FBRyxRQUFKLENBQVA7QUFDRDs7QUF6VmtDLEMsQ0E0VnJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBLFNBQVMsbUJBQVQsQ0FBNkIsUUFBN0IsRUFBdUMsSUFBdkMsRUFBNkM7QUFDM0MsU0FBTyxRQUFRLENBQUMsTUFBVCxDQUFnQixDQUFDLEdBQUQsRUFBTSxPQUFOLHFDQUF3QixHQUF4QjtBQUE2QixLQUFDLE9BQUQsR0FBVztBQUF4QyxJQUFoQixFQUFpRSxFQUFqRSxDQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDclhEOztBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE1BQVAsbUJBQ2xCLDhCQURrQixFQUF2QjtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxNQUFQLENBQWM7QUFDcEMsR0FBQyx5QkFBWSx3QkFBYixHQUF5QyxRQUFELElBQWM7QUFDcEQsV0FBTztBQUFFLE1BQUEsSUFBSSxFQUFFLHlCQUFZLHdCQUFwQjtBQUE4QyxNQUFBLEtBQUssRUFBRTtBQUFyRCxLQUFQO0FBQ0Q7QUFIbUMsQ0FBZCxDQUF4QjtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNPLE1BQU0sdUJBQXVCLEdBQUcsQ0FBQztBQUFFLEVBQUE7QUFBRixDQUFELEtBQXVCO0FBQzVELFNBQU87QUFDTCxLQUFDLHlCQUFZLHdCQUFiLEdBQXdDO0FBQ3RDLE1BQUEsSUFBSSxFQUFFLHlCQUFZLHdCQURvQjtBQUd0QyxNQUFBLFNBQVMsRUFBRSxDQUFDLE1BQUQsRUFBUyxNQUFULEtBQW9CO0FBQzdCLGVBQU8sTUFBTyxJQUFQLElBQWdCO0FBQ3JCLGdCQUFNLE1BQU0sR0FBRyxNQUFNLE1BQU0sQ0FBQyxJQUFELENBQTNCO0FBQ0EsaUJBQU8sTUFBTSxDQUNWLE1BREksQ0FDSSxPQUFELElBQWEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxRQUFiLENBQXNCLE9BQXRCLENBRGhCLEVBRUosS0FGSSxDQUVFLENBRkYsRUFFSyxDQUZMLENBQVA7QUFHRCxTQUxEO0FBTUQsT0FWcUM7QUFZdEMsTUFBQSxTQUFTLEVBQUUsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixPQUFsQixLQUNULHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxLQUFSLEVBQWUsYUFBZjtBQWJjO0FBRG5DLEdBQVA7QUFpQkQsQ0FsQk07QUFvQlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDTyxNQUFNLDJCQUEyQixHQUFHLENBQUM7QUFDMUMsRUFBQSxjQUQwQztBQUUxQyxFQUFBO0FBRjBDLENBQUQsS0FHckM7QUFDSixTQUFPO0FBQ0wsS0FBQyxjQUFjLENBQUMsWUFBaEIsR0FBK0I7QUFDN0IsTUFBQSxTQUFTLEVBQUUsY0FBYyxDQUFDLFlBREc7QUFFN0IsTUFBQSxjQUFjLEVBQUUsQ0FBQyx5QkFBWSx3QkFBYixDQUZhO0FBSTdCLE1BQUEsT0FBTyxFQUFFLENBQUMsaUJBQUQsRUFBb0IsV0FBcEIsS0FBb0M7QUFDM0MsWUFBSSxLQUFLLENBQUMsT0FBTixDQUFjLGlCQUFpQixDQUFDLE9BQWhDLENBQUosRUFBOEM7QUFDNUMsZ0JBQU0sSUFBSSxLQUFKLENBQ0gsR0FBRSxjQUFjLENBQUMsWUFBYSx5RkFEM0IsQ0FBTjtBQUdELFNBTDBDLENBTzNDOzs7QUFDQSxZQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFqQixFQUFtQztBQUNqQyxnQkFBTSxJQUFJLEtBQUosQ0FDSCxHQUFFLGNBQWMsQ0FBQyxZQUFhLHlDQUQzQixDQUFOO0FBR0Q7O0FBRUQsZUFBTywwRUFDRixpQkFERTtBQUVMLFVBQUEsT0FBTyxFQUFFLENBQ1AsZUFBZSxDQUFDLHlCQUFZLHdCQUFiLENBQWYsQ0FDRSxXQUFXLENBQUMsZ0JBRGQsQ0FETztBQUZKLFdBQVA7QUFRRCxPQTFCNEI7QUE0QjdCLE1BQUEsb0JBQW9CLEVBQUUsTUFBTyxLQUFQLElBQWlCO0FBQ3JDLGNBQU0sUUFBUSxHQUFHLE1BQU0sY0FBYyxFQUFyQztBQUNBLGNBQU0sVUFBVSxHQUFHLGFBQWEsRUFBaEM7QUFFQSxlQUFPLFFBQVEsQ0FBQyxJQUFULENBQWMsQ0FBQyxZQUFELEVBQWUsYUFBZixLQUFpQztBQUNwRCxjQUFJLENBQUMsVUFBVSxDQUFDLFlBQUQsQ0FBZixFQUErQjtBQUM3QixrQkFBTSxJQUFJLEtBQUosQ0FBVyxrQ0FBaUMsWUFBYSxJQUF6RCxDQUFOO0FBQ0QsV0FGRCxNQUVPLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBRCxDQUFmLEVBQWdDO0FBQ3JDLGtCQUFNLElBQUksS0FBSixDQUNILGtDQUFpQyxhQUFjLElBRDVDLENBQU47QUFHRCxXQUpNLE1BSUEsSUFDTCxVQUFVLENBQUMsWUFBRCxDQUFWLENBQXlCLFlBQXpCLEtBQ0EsVUFBVSxDQUFDLGFBQUQsQ0FBVixDQUEwQixZQUZyQixFQUdMO0FBQ0EsbUJBQU8sQ0FBUDtBQUNELFdBTE0sTUFLQSxJQUFJLFVBQVUsQ0FBQyxZQUFELENBQVYsQ0FBeUIsWUFBekIsS0FBMEMsU0FBOUMsRUFBeUQ7QUFDOUQsbUJBQU8sQ0FBUDtBQUNELFdBRk0sTUFFQSxJQUFJLFVBQVUsQ0FBQyxhQUFELENBQVYsQ0FBMEIsWUFBMUIsS0FBMkMsU0FBL0MsRUFBMEQ7QUFDL0QsbUJBQU8sQ0FBQyxDQUFSO0FBQ0Q7O0FBRUQsaUJBQ0UsVUFBVSxDQUFDLGFBQUQsQ0FBVixDQUEwQixZQUExQixHQUNBLFVBQVUsQ0FBQyxZQUFELENBQVYsQ0FBeUIsWUFGM0I7QUFJRCxTQXRCTSxDQUFQO0FBdUJELE9BdkQ0QjtBQXlEN0IsTUFBQSxTQUFTLEVBQUUsQ0FBQyxVQUFELEVBQWEsT0FBYixFQUFzQixPQUF0QixLQUFrQztBQUMzQyxjQUFNO0FBQUUsVUFBQTtBQUFGLFlBQWMsVUFBcEI7O0FBQ0EsWUFDRSxDQUFDLE9BQUQsSUFDQSxPQUFPLENBQUMsTUFBUixLQUFtQixDQURuQixJQUVBLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBVyxJQUFYLEtBQW9CLHlCQUFZLHdCQUhsQyxFQUlFO0FBQ0EsZ0JBQU0sSUFBSSxLQUFKLENBQ0gsR0FBRSxjQUFjLENBQUMsWUFBYSxtRUFBa0UseUJBQVksd0JBQXlCLElBRGxJLENBQU47QUFHRDtBQUNGO0FBcEU0QjtBQUQxQixHQUFQO0FBd0VELENBNUVNO0FBOEVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQSxTQUFTLHNCQUFULENBQWdDLFFBQWhDLEVBQTBDLGFBQTFDLEVBQXlEO0FBQ3ZELE1BQUksQ0FBQyxLQUFLLENBQUMsT0FBTixDQUFjLFFBQWQsQ0FBRCxJQUE0QixRQUFRLENBQUMsTUFBVCxLQUFvQixDQUFwRCxFQUF1RDtBQUNyRCxVQUFNLElBQUksS0FBSixDQUNILEdBQUUsY0FBYyxDQUFDLFlBQWEseURBRDNCLENBQU47QUFHRDs7QUFFRCxRQUFNLFVBQVUsR0FBRyxhQUFhLEVBQWhDO0FBQ0EsRUFBQSxRQUFRLENBQUMsT0FBVCxDQUFrQixPQUFELElBQWE7QUFDNUIsUUFBSSxDQUFDLE9BQUQsSUFBWSxPQUFPLE9BQVAsS0FBbUIsUUFBbkMsRUFBNkM7QUFDM0MsWUFBTSxJQUFJLEtBQUosQ0FDSCxHQUFFLGNBQWMsQ0FBQyxZQUFhLCtEQUE4RCxPQUFRLElBRGpHLENBQU47QUFHRDs7QUFFRCxRQUFJLENBQUMsVUFBVSxDQUFDLE9BQUQsQ0FBZixFQUEwQjtBQUN4QixZQUFNLElBQUksS0FBSixDQUNILEdBQUUsY0FBYyxDQUFDLFlBQWEsMkNBQTBDLE9BQVEsSUFEN0UsQ0FBTjtBQUdEO0FBQ0YsR0FaRDtBQWFEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxDQUMvQyxpQkFEK0MsRUFFL0MsVUFGK0MsRUFHL0MsYUFIK0MsRUFJL0MsY0FKK0MsRUFLL0MsYUFMK0MsRUFNL0MsaUJBTitDLEVBTy9DLGdCQVArQyxFQVEvQyxjQVIrQyxFQVMvQyxnQkFUK0MsRUFVL0Msb0JBVitDLEVBVy9DLHNCQVgrQyxFQVkvQyxvQ0FaK0MsRUFhL0Msc0NBYitDLEVBYy9DLGFBZCtDLEVBZS9DLDRCQWYrQyxFQWdCL0Msc0JBaEIrQyxFQWlCL0MsbUJBakIrQyxFQWtCL0MsYUFsQitDLEVBbUIvQyxjQW5CK0MsRUFvQi9DLGtCQXBCK0MsRUFxQi9DLHVDQXJCK0MsRUFzQi9DLHlDQXRCK0MsRUF1Qi9DLDBCQXZCK0MsRUF3Qi9DLHlCQXhCK0MsRUF5Qi9DLDJCQXpCK0MsRUEwQi9DLGlDQTFCK0MsRUEyQi9DLG1DQTNCK0MsRUE0Qi9DLDhCQTVCK0MsRUE2Qi9DLGdDQTdCK0MsRUE4Qi9DLGFBOUIrQyxFQStCL0MsY0EvQitDLEVBZ0MvQyxZQWhDK0MsRUFpQy9DLG9CQWpDK0MsRUFrQy9DLGVBbEMrQyxFQW1DL0MsaUNBbkMrQyxFQW9DL0MscUJBcEMrQyxFQXFDL0Msd0JBckMrQyxFQXNDL0MscUJBdEMrQyxFQXVDL0MsVUF2QytDLEVBd0MvQyxtQkF4QytDLEVBeUMvQyxzQkF6QytDLEVBMEMvQyxzQkExQytDLEVBMkMvQyxzQkEzQytDLEVBNEMvQyxvQkE1QytDLEVBNkMvQyxnQkE3QytDLEVBOEMvQyxhQTlDK0MsRUErQy9DLHFCQS9DK0MsRUFnRC9DLDJCQWhEK0MsRUFpRC9DLHFCQWpEK0MsRUFrRC9DLGVBbEQrQyxFQW1EL0MsZUFuRCtDLEVBb0QvQyxhQXBEK0MsRUFxRC9DLG9CQXJEK0MsRUFzRC9DLGVBdEQrQyxFQXVEL0MsbUJBdkQrQyxFQXdEL0Msb0JBeEQrQyxFQXlEL0MsV0F6RCtDLENBQWQsQ0FBNUI7Ozs7Ozs7Ozs7Ozs7O0FDdk1QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyVEEsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGlCQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSx3QkFBQSxPQUFBLENBQUEseUJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEscUJBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQTs7QUFJQSxJQUFBLFlBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsV0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFdBQUEsT0FBQSxDQUFBLHNDQUFBLENBQUEsQ0FBQTs7QUFVQSxJQUFBLFFBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLDBDQUFBLENBQUEsQ0FBQTs7QUFJQSxJQUFBLG9CQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLCtDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsNEJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxzQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxzQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHVCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBOzs7Ozs7QUFFQSxNQUFNLE1BQU0sT0FBTyxJQUFQLGFBQVosQ0FBQTtBQUNBLE1BQU0sbUJBQW1CLENBQUEsQ0FBQSxFQUFBLGlCQUFBLFFBQUEsRUFBb0IsS0FBQSxPQUFBLEdBQVMsRUFBN0IsQ0FBekIsQ0FBQTtBQUVBLElBQUkseUJBQUosQ0FBQTs7QUFDQSxJQUFJLE9BQU8sSUFBUCxRQUFKLEVBQXlCO0VBQ3ZCLDRCQUE0QjtJQUMxQixNQUFNLFFBQUEsaUJBRG9CO0lBRTFCLFFBQVEsdUJBRmtCO0lBRzFCLFNBQVMsT0FIaUI7SUFJMUIsVUFBVSxnQkFBQTtHQUpaLENBQUE7Q0FERixNQU9PLElBQUksT0FBTyxJQUFQLGVBQUEsSUFBOEIsR0FBRyxLQUFLLE1BQTFDLEVBQWtEO0VBQ3ZELDRCQUE0QjtJQUFFLE1BQU0sUUFBQSxRQUFSO0lBQWlCLFNBQVMsUUFBQSxpQkFBQTtHQUF0RCxDQUFBO0NBREssTUFFQTtFQUNMLDRCQUE0QjtJQUFFLE1BQU0sUUFBQSxRQUFSO0lBQWlCLFNBQVMsUUFBQSxpQkFBQTtHQUF0RCxDQUFBO0NBQ0Q7O0FBRUQsTUFBTSx3QkFBcUIsYUFBQSxDQUFBO0VBQ3pCLFFBQVEsS0FBQTtDQURpQixFQUV0Qix5QkFGc0IsQ0FBM0IsQ0FBQTs7QUFLQSxNQUFNLDZCQUE2QjtFQUNqQyxNQUFNO0lBQUUsTUFBTSxTQUFBO0dBQVI7Q0FEUixDQUFBO0FBSU8sTUFBTSxpQkFBaUI7O0VBRTVCLG9CQUFvQixrQkFGUTs7RUFJNUIscUJBQXFCLG1CQUpPOztFQU01QixtQkFBbUIsaUJBTlM7O0VBUTVCLHFCQUFxQixtQkFBQTtDQVJoQixDQUFBOzs7QUFXUSxnQ0FBZ0MsT0FBQSxRQUFoQyxDQUE2QztFQUMxRCxXQUFXLENBQUMsT0FBTyxFQUFSLEVBQVk7SUFDckIsS0FBQSxFQUFBLENBRHFCOztJQUlyQixJQUFBLGNBQUEsR0FBcUIsSUFBSSxTQUFBLGdCQUFKLENBQ25CLElBQUksU0FBSixJQUFBLGFBQUEsQ0FBQSxFQUFBLEVBQXNCLHFCQUF0QixDQURtQixDQUFyQixDQUFBO0lBR0EsSUFBQSxzQkFBQSxHQUE2QixJQUFJLFNBQUEsZ0JBQUosQ0FDM0IsSUFBQSxjQUFBLFNBQUEsRUFEMkIsQ0FBN0IsQ0FBQTtJQUdBLElBQUEsYUFBQSxHQUFvQixJQUFJLFNBQUEsZ0JBQUosQ0FBb0IsU0FBcEIsQ0FBcEIsQ0FWcUI7Ozs7OztJQWdCckIsSUFBQSxlQUFBLEdBQXNCLElBQUksU0FBQSxnQkFBSixDQUNwQixJQUFJLGVBQUosSUFBQSxhQUFBLENBQUEsRUFBQSxFQUNLLDBCQURMLENBRG9CLENBQXRCLENBQUE7SUFLQSxJQUFBLE1BQUEsR0FBYSxJQUFJLFNBQUEsY0FBSixDQUFrQjtNQUM3QixVQUFVLElBQUEsY0FEbUI7TUFFN0IsdUJBQXVCLElBQUEsc0JBRk07TUFHN0IsU0FBUyxJQUFBLGFBSG9CO01BSTdCLGdCQUFnQixJQUFBLGVBQUs7S0FKVixDQUFiLENBckJxQjs7SUE2QnJCLElBQUEsVUFBQSxHQUFpQixJQUFqQixDQUFBO0lBQ0EsSUFBQSxjQUFBLEdBQXFCLElBQXJCLENBOUJxQjs7SUFpQ3JCLElBQUEsZUFBQSxHQUFzQixJQUF0QixDQUFBO0lBQ0EsSUFBQSxtQkFBQSxHQUEwQixJQUExQixDQUFBO0lBRUEsSUFBQSxHQUFBLENBQVEsY0FBYyxtQkFBdEIsRUFBMkMsSUFBQSxjQUEzQyxDQUFBLENBQUE7R0FDRDs7Ozs7Ozs7OztFQVNELGtCQUFrQixZQUFZO0lBQzVCLElBQUksQ0FBQyxTQUFELElBQWMsT0FBTyxTQUFQLEtBQXFCLFFBQXZDLEVBQWlEO01BQy9DLE1BQU0sSUFBSSxLQUFKLENBQVUsMkJBQVYsQ0FBTixDQUFBO0tBQ0Q7O0lBRUQsSUFBQSxpQkFBQSxHQUF3QixTQUF4QixDQUFBO0dBQ0Q7O0VBRUQsa0JBQWtCLGlCQUFpQjtJQUNqQyxJQUFBLG9CQUFBLEdBQTJCLGNBQTNCLENBQUE7SUFDQSxNQUFNOzs7O0tBQUEsR0FBNEIsSUFBQSxrQkFBQSxFQUFsQyxDQUFBOztJQUNBLElBQUEsbUJBQUEsQ0FBd0I7TUFBRSxJQUFGO01BQVEsTUFBUjtNQUFnQixPQUFBO0tBQXhDLENBQUEsQ0FBQTs7SUFDQSxJQUFBLGNBQUEsRUFBQSxDQUFBO0dBM0R3RDs7O0VBK0QxRCwwQkFBMEIsR0FBRztJQUMzQixNQUFNLFdBQVcsSUFBQSxlQUFqQixDQUFBO0lBQ0EsTUFBTSxlQUFlLElBQUEsbUJBQXJCLENBQUE7SUFDQSxPQUFPO01BQUUsUUFBRjtNQUFZLFlBQUE7S0FBbkIsQ0FBQTtHQUNEOzs7Ozs7O0VBTUQsY0FBYyxHQUFHO0lBQ2YsT0FBTyxJQUFJLE9BQUosQ0FBWSxxQkFBcUI7TUFDdEMsTUFBTTs7T0FBQSxHQUFlLElBQUEsMkJBQUEsRUFBckIsQ0FBQTtNQUNBLE1BQU0sV0FBVyxJQUFJLFNBQUEsUUFBSixDQUFhLFFBQWIsQ0FBakIsQ0FBQTtNQUNBLFFBQVEsVUFBUixDQUNFO1FBQUUsUUFBUSxzQkFBVjtRQUFrQyxRQUFRLENBQUMsUUFBRCxFQUFXLEtBQVgsQ0FBQTtPQUQ1QyxFQUVFLGdCQUFnQjtRQUNkLElBQUksR0FBSixFQUFTO1VBQ1AsT0FBTyxNQUFNLENBQUMsR0FBRCxDQUFiLENBQUE7U0FDRDs7UUFDRCxPQUFPLE9BQU8sQ0FBQyxLQUFELENBQWQsQ0FBQTtPQU5KLENBQUEsQ0FBQTtLQUhLLENBQVAsQ0FBQTtHQWFEOzs7Ozs7OztFQU80Qiw2QkFBQSxHQUFHO0lBQzlCLE1BQU07O0tBQUEsR0FBVyxJQUFBLGVBQUEsU0FBQSxFQUFqQixDQUFBOztJQUNBLElBQUksSUFBSSxDQUFDLElBQUQsQ0FBSixLQUFlLFNBQW5CLEVBQThCO01BQzVCLE9BQU8sSUFBSSxDQUFDLElBQUQsQ0FBWCxDQUFBO0tBQ0Q7O0lBQ0QsTUFBTSxjQUFjLE1BQU0sSUFBQSxlQUFBLEVBQTFCLENBQUE7SUFDQSxNQUFNLGtCQUNKLFdBQVcsSUFBSSxXQUFXLGNBQVgsS0FBOEIsU0FEL0MsQ0FBQTtJQUVBLElBQUEscUJBQUEsQ0FBMEIsSUFBMUIsRUFBZ0MsZUFBaEMsQ0FBQSxDQUFBO0lBQ0EsT0FBTyxlQUFQLENBQUE7R0FDRDs7RUFFRCxhQUFhLEdBQUc7O0lBRWQsSUFBSSxJQUFBLGlCQUFBLEVBQUosRUFBNkI7TUFDM0IsSUFBQSxjQUFBLEVBQUEsQ0FBQTtLQUNEO0dBQ0Y7O0VBRUQsZUFBZSxHQUFHO0lBQ2hCLE9BQU8sSUFBQSxhQUFBLFNBQUEsRUFBUCxDQUFBO0dBQ0Q7O0VBRUQsZUFBZSxVQUFVO0lBQ3ZCLElBQUEsYUFBQSxTQUFBLENBQTJCLE9BQTNCLENBQUEsQ0FBQTtHQUNEOzs7Ozs7OztFQU9ELG9CQUFvQix5QkFBeUI7SUFDM0MsSUFBQSxlQUFBLFlBQUEsQ0FBZ0M7TUFDOUIsTUFBTTtRQUNKLENBQUMsU0FBRCxHQUFhLFdBQUE7T0FEVDtLQURSLENBQUEsQ0FBQTtHQUtEOzs7Ozs7RUFLRCxtQkFBbUIsR0FBRztJQUNwQixJQUFBLGVBQUEsU0FBQSxDQUFBLGFBQUEsQ0FBQSxFQUFBLEVBQWtDLDBCQUFsQyxDQUFBLENBQUEsQ0FBQTtHQUNEOztFQUVELGdCQUFnQixHQUFHO0lBQ2pCLE9BQU8sSUFBQSxnQkFBQSxFQUFBLEtBQTJCLFNBQWxDLENBQUE7R0FDRDs7RUFFRCxhQUFhLEdBQUc7O0lBRWQsSUFBSSxDQUFDLElBQUEsVUFBTCxFQUFxQjtNQUNuQixTQUFBLFFBQUEsS0FBQSxDQUNFLG1FQURGLENBQUEsQ0FBQTs7TUFHQSxPQUFBO0tBQ0Q7O0lBRUQsTUFBTSxVQUFVLElBQUEsa0JBQUEsRUFBaEIsQ0FBQTs7SUFDQSxJQUFJLENBQUMsT0FBTCxFQUFjO01BQ1osU0FBQSxRQUFBLEtBQUEsQ0FDRSxrRUFERixDQUFBLENBQUE7O01BR0EsSUFBQSxnQkFBQSxDQUFxQixTQUFyQixDQUFBLENBSlk7O01BTVosSUFBQSxvQkFBQSxFQUFBLENBQUE7TUFDQSxPQUFBO0tBakJZOzs7SUFxQmQsTUFBTSxXQUFXLElBQUksU0FBQSxRQUFKLENBQWEsSUFBQSxVQUFiLENBQWpCLENBQUE7SUFDQSxNQUFNLGlCQUFpQixJQUFBLGdCQUFBLEVBQXZCLENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQVcsSUFBQSxrQkFBQSxFQUFqQixDQUFBOztJQUNBLE1BQU0sV0FBVyxRQUFBLHNCQUFBLFNBQUEsQ0FBK0IsSUFBL0IsQ0FBakIsQ0FBQTs7SUFFQSxJQUFJLFFBQUosRUFBYztNQUNaLElBQUEseUJBQUEsQ0FBOEIsSUFBOUIsQ0FBQSxDQUFBO0tBREYsTUFFTztNQUNMLElBQUEsS0FBQSxDQUFVLGNBQWMsb0JBQXhCLENBQUEsQ0FBQTtLQUNEOztJQUVELFFBQVEsVUFBUixDQUFtQjtNQUFFLFFBQVEsYUFBQTtLQUE3QixFQUE4Qyx5QkFBeUI7TUFDckUsTUFBTSxpQkFBaUIsSUFBQSxnQkFBQSxFQUF2QixDQUFBOztNQUNBLElBQUksY0FBYyxLQUFLLGNBQXZCLEVBQXVDO1FBQ3JDLElBQUksR0FBSixFQUFTO1VBQ1AsSUFBQSxnQkFBQSxDQUFxQixTQUFyQixDQUFBLENBRE87O1VBR1AsSUFBQSxvQkFBQSxFQUFBLENBQUE7VUFDQSxPQUFBO1NBQ0Q7O1FBRUQsSUFBQSxnQkFBQSxDQUFxQixjQUFyQixDQUFBLENBUnFDOztRQVVyQyxJQUFBLHdCQUFBLEVBQUEsQ0FBQTtPQUNEO0tBYkgsQ0FBQSxDQUFBO0dBZUQ7O0VBRUQsaUJBQWlCLEdBQUc7SUFBQSxJQUFBLHFCQUFBLENBQUE7O0lBQ2xCLE1BQU07OztLQUFBLEdBQW1DLElBQUEsa0JBQUEsRUFBekMsQ0FBQTtJQUNBLE9BQU8sQ0FBQSxDQUFBLHdCQUFBLFFBQUEsdUJBQUEsQ0FBdUIsSUFBdkIsQ0FBQSxNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLHFCQUFBLFFBQUEsS0FBeUMsYUFBaEQsQ0FBQTtHQUNEOztFQUVELFlBQVksa0JBQWtCLFNBQVMsS0FBM0IsRUFBa0MsV0FBVyxFQUE3QyxZQUEyRDtJQUNyRSxPQUFBLE9BQUEsR0FBQSxDQUNFLENBQUEsQ0FBQSxFQUFBLFNBQUEsNkJBQUEsRUFBNkIsT0FBN0IsQ0FERixFQUVHLENBQUEsa0JBQUEsRUFBb0IsT0FBUSxDQUFBLHNCQUFBLENBRi9CLENBQUEsQ0FBQTs7SUFJQSxPQUFBLE9BQUEsR0FBQSxDQUNFLENBQUEsQ0FBQSxFQUFBLFNBQUEsY0FBQSxFQUFjLFFBQVEsQ0FBQyxPQUFELEVBQVUsRUFBVixDQUF0QixDQURGLEVBRUcsQ0FBQSxrQkFBQSxFQUFvQixPQUFRLENBQUEsK0NBQUEsQ0FGL0IsQ0FBQSxDQUFBOztJQUlBLElBQUEsa0JBQUEsQ0FBdUI7TUFDckIsTUFBTSxRQUFBLGlCQURlO01BRXJCLE1BRnFCO01BR3JCLE9BSHFCO01BSXJCLE1BSnFCO01BS3JCLFFBTHFCO01BTXJCLFFBQUE7S0FORixDQUFBLENBQUE7R0FRRDs7RUFFb0IscUJBQUEsT0FBTztJQUMxQixPQUFBLE9BQUEsZUFBQSxDQUNFLElBREYsRUFFRSxRQUFBLGlCQUZGLEVBR0csQ0FBQSw2REFBQSxFQUErRCxRQUFBLGlCQUFpQixDQUFBLHFCQUFBLENBSG5GLENBQUEsQ0FBQTs7SUFLQSxPQUFBLE9BQUEsR0FBQSxDQUNFLFFBQUEsc0JBQUEsU0FBQSxDQUErQixJQUEvQixDQURGLEVBRUcsQ0FBQSw4QkFBQSxFQUFnQyxJQUFLLENBQUEsRUFBQSxDQUZ4QyxDQUFBLENBQUE7O0lBSUEsTUFBTTs7S0FBQSxHQUFjLFFBQUEsdUJBQUEsQ0FBdUIsSUFBdkIsQ0FBcEIsQ0FBQTtJQUNBLElBQUEsa0JBQUEsQ0FBdUI7TUFDckIsSUFEcUI7TUFFckIsUUFBUSxFQUZhO01BR3JCLE9BSHFCO01BSXJCLFFBQVEsS0FKYTtNQUtyQixVQUFVLEVBQUE7S0FMWixDQUFBLENBQUE7R0FPRDs7RUFFRCxlQUFlLEdBQUc7SUFDaEIsSUFBQSxrQkFBQSxDQUF1QixJQUFBLGtCQUFBLEVBQXZCLENBQUEsQ0FBQTtHQUNEOzs7Ozs7RUFLRCxpQkFBaUIsU0FBUztJQUN4QixJQUFBLHNCQUFBLFlBQUEsQ0FBdUMsSUFBQSxrQkFBQSxFQUF2QyxDQUFBLENBQUE7SUFDQSxJQUFBLGNBQUEsWUFBQSxDQUErQixNQUEvQixDQUFBLENBQUE7O0lBQ0EsSUFBQSxlQUFBLENBQW9CLE1BQXBCLENBQUEsQ0FBQTtHQUNEOztFQUVELDBCQUEwQixHQUFHO0lBQzNCLE1BQU0sU0FBUyxJQUFBLHNCQUFBLFNBQUEsRUFBZixDQUFBO0lBQ0EsSUFBQSxjQUFBLFlBQUEsQ0FBK0IsTUFBL0IsQ0FBQSxDQUFBOztJQUNBLElBQUEsZUFBQSxDQUFvQixNQUFwQixDQUFBLENBQUE7R0FDRDs7RUFFRCxpQkFBaUIsR0FBRztJQUNsQixPQUFPLElBQUEsY0FBQSxTQUFBLEVBQVAsQ0FBQTtHQUNEOztFQUVELG9CQUFvQixHQUFHO0lBQ3JCLE1BQU0sV0FBVyxJQUFBLGNBQUEsU0FBQSxFQUFqQixDQUFBO0lBQ0EsT0FBTyxRQUFRLEtBQVIsS0FBa0IsUUFBQSxpQkFBbEIsR0FBcUMsUUFBUSxPQUE3QyxHQUF1RCxRQUFRLEtBQXRFLENBQUE7R0F2UXdEOzs7OztFQThRNUIsOEJBQUEsVUFBVTtJQUN0QyxNQUFNLFNBQVUsQ0FBQSxRQUFBLEVBQVUsT0FBUSxDQUFBLGNBQUEsRUFBZ0IsSUFBQSxpQkFBc0IsQ0FBQSxDQUF4RSxDQUFBO0lBRUEsSUFBSSxpQkFBaUIsS0FBckIsQ0FBQTtJQUNBLElBQUEsS0FBQSxDQUFVLGNBQWMsbUJBQXhCLEVBQTZDLE1BQU07TUFDakQsaUJBQWlCLElBQWpCLENBQUE7S0FERixDQUFBLENBQUE7O0lBSUEsSUFBSTtNQUNGLE1BQU0sV0FBVyxNQUFNLGdCQUFnQixDQUFDLE1BQUQsRUFBUztRQUM5QyxRQUFRLE1BRHNDO1FBRTlDLE1BQU0sSUFBSSxVQUFKLENBQWU7VUFDbkIsU0FBUyxLQURVO1VBRW5CLFFBQVEsaUJBRlc7VUFHbkIsUUFBUSxFQUhXO1VBSW5CLElBQUksQ0FBQTtTQUpBLENBQUE7T0FGK0IsQ0FBdkMsQ0FBQTs7TUFVQSxJQUFJLGNBQUosRUFBb0I7UUFDbEIsT0FBQTtPQUNEOztNQUVELElBQUksUUFBUSxHQUFaLEVBQWlCO1FBQ2YsSUFBQSxLQUFBLENBQVUsY0FBYyxvQkFBeEIsQ0FBQSxDQUFBO09BREYsTUFFTztRQUNMLE1BQU0sa0JBQWtCLE1BQU0sUUFBUSxLQUFSLEVBQTlCLENBQUE7O1FBQ0EsSUFBSSxjQUFKLEVBQW9CO1VBQ2xCLE9BQUE7U0FDRDs7UUFDRCxJQUFJLGVBQWUsTUFBZixLQUEwQixRQUFBLG1CQUE5QixFQUFrRDtVQUNoRCxJQUFBLEtBQUEsQ0FBVSxjQUFjLGtCQUF4QixDQUFBLENBQUE7U0FDRDtPQUNGO0tBekJILENBMEJFLFlBQVk7TUFDWixTQUFBLFFBQUEsS0FBQSxDQUFVLENBQUEsMkNBQUEsQ0FBVixFQUF3RCxHQUF4RCxDQUFBLENBQUE7S0FDRDtHQUNGOztFQUVELGNBQWMsT0FBTzs7SUFFbkIsSUFBQSxLQUFBLENBQVUsY0FBYyxvQkFBeEIsQ0FBQSxDQUZtQjs7SUFJbkIsSUFBQSxnQkFBQSxDQUFxQixTQUFyQixDQUFBLENBSm1COztJQU1uQixJQUFBLG9CQUFBLEVBQUEsQ0FObUI7O0lBUW5CLElBQUEsbUJBQUEsQ0FBd0IsSUFBeEIsQ0FBQSxDQVJtQjs7O0lBVW5CLElBQUEsS0FBQSxDQUFVLGNBQWMsbUJBQXhCLEVBQTZDLElBQUksS0FBakQsQ0FBQSxDQUFBO0dBQ0Q7O0VBRUQsa0JBQWtCLENBQUM7Ozs7R0FBRCxFQUE0Qjs7SUFFNUMsTUFBTSxXQUFXLFFBQUEsc0JBQUEsU0FBQSxDQUErQixJQUEvQixDQUFqQixDQUFBOztJQUNBLElBQUksUUFBSixFQUFjO01BQ1osSUFBQSx5QkFBQSxDQUE4QixJQUE5QixFQUFvQyxJQUFBLGlCQUFwQyxDQUFBLENBRFk7O0tBQWQsTUFHTyxJQUFJLElBQUksS0FBSyxRQUFBLGlCQUFiLEVBQStCO01BQ3BDLElBQUEsMkJBQUEsQ0FBZ0MsTUFBaEMsRUFBd0MsT0FBeEMsQ0FBQSxDQUFBO0tBREssTUFFQTtNQUNMLE1BQU0sSUFBSSxLQUFKLENBQ0gsQ0FBQSx1REFBQSxFQUF5RCxJQUFLLENBQUEsQ0FBQSxDQUQzRCxDQUFOLENBQUE7S0FHRDtHQUNGOztFQUVELHdCQUF3QixrQkFBa0I7SUFDeEMsU0FBQSxRQUFBLEtBQUEsQ0FBUyw2Q0FBVCxFQUF3RCxJQUF4RCxDQUFBLENBQUE7O0lBQ0EsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFBLEVBQUEsbUJBQUEsUUFBQSxFQUFtQjtNQUN2QyxTQUFTLElBRDhCO01BRXZDLFNBQUE7S0FGb0IsQ0FBdEIsQ0FBQTs7SUFJQSxJQUFBLGtCQUFBLENBQXVCLGFBQXZCLENBQUEsQ0FBQTtHQUNEOztFQUVELDBCQUEwQixrQkFBa0I7SUFDMUMsU0FBQSxRQUFBLEtBQUEsQ0FBUywrQ0FBVCxFQUEwRCxNQUExRCxDQUFBLENBQUE7O0lBQ0EsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFBLEVBQUEsb0JBQUEsUUFBQSxFQUFvQjtNQUFFLE1BQUY7TUFBVSxPQUFBO0tBQTlCLENBQXRCLENBQUE7O0lBQ0EsSUFBQSxrQkFBQSxDQUF1QixhQUF2QixDQUFBLENBQUE7R0FDRDs7RUFFRCxpQkFBaUIsQ0FBQzs7O0dBQUQsRUFBc0M7SUFDckQsTUFBTSxxQkFBcUIsQ0FBQSxDQUFBLEVBQUEseUJBQUEsUUFBQSxFQUN6QixJQUFBLG9CQUR5QixDQUEzQixDQUFBO0lBR0EsTUFBTSxTQUFTLElBQUksY0FBQSxjQUFKLEVBQWYsQ0FBQTtJQUNBLE1BQU0sS0FBTixDQUFZLGtCQUFaLENBQUEsQ0FBQTtJQUNBLE1BQU0sS0FBTixDQUFZLGlCQUFaLENBQUEsQ0FBQTtJQUNBLE1BQU0sV0FBVyxDQUFBLENBQUEsRUFBQSxxQkFBQSxtQkFBQSxFQUFtQixNQUFuQixDQUFqQixDQUFBOztJQUNBLElBQUEsNEJBQUEsQ0FBaUM7TUFBRSxRQUFGO01BQVksWUFBQTtLQUE3QyxDQUFBLENBQUE7R0FDRDs7RUFFRCwyQkFBMkIsQ0FBQzs7O0dBQUQsRUFBNkI7O0lBRXRELElBQUksSUFBQSxlQUFKLEVBQXlCO01BQ3ZCLElBQUEsZUFBQSxVQUFBLENBQThCLFFBQTlCLENBQUEsQ0FBQTtLQURGLE1BRU87TUFDTCxJQUFBLGVBQUEsR0FBc0IsQ0FBQSxDQUFBLEVBQUEsa0JBQUEscUJBQUEsRUFBcUIsUUFBckIsQ0FBdEIsQ0FBQTtLQUNEOztJQUNELElBQUksSUFBQSxtQkFBSixFQUE2QjtNQUMzQixJQUFBLG1CQUFBLFVBQUEsQ0FBa0MsWUFBbEMsQ0FBQSxDQUFBO0tBREYsTUFFTztNQUNMLElBQUEsbUJBQUEsR0FBMEIsQ0FBQSxDQUFBLEVBQUEsa0JBQUEsd0JBQUEsRUFBd0IsWUFBeEIsRUFBc0M7UUFDOUQsYUFBYSxjQUFBO09BRFcsQ0FBMUIsQ0FBQTtLQVZvRDs7O0lBZXRELElBQUEsVUFBQSxHQUFpQixRQUFqQixDQUFBO0lBQ0EsSUFBQSxjQUFBLEdBQXFCLFlBQXJCLENBQUE7R0FDRDs7Q0E1WHlEOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3QxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZOQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBLFNBQVMsS0FBVCxDQUFlLElBQWYsRUFBcUI7QUFDbkIsU0FBTyxJQUFJLE9BQUosQ0FBYSxPQUFELElBQWEsVUFBVSxDQUFDLE9BQUQsRUFBVSxJQUFWLENBQW5DLENBQVA7QUFDRDs7QUFFRCxlQUFlLGdCQUFmLENBQWdDLEdBQWhDLEVBQXFDO0FBQ25DLFFBQU0sR0FBRyxHQUFHLE1BQU0sTUFBTSxDQUFDLEtBQVAsQ0FBYyw2QkFBNEIsR0FBSSxFQUE5QyxDQUFsQjtBQUNBLFFBQU0sSUFBSSxHQUFHLE1BQU0sR0FBRyxDQUFDLElBQUosRUFBbkI7QUFDQSxTQUFPLElBQUksQ0FBQyxNQUFMLEdBQWMsSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFYLENBQWQsR0FBaUMsSUFBeEM7QUFDRDs7QUFFRCxlQUFlLGNBQWYsQ0FBOEIsR0FBOUIsRUFBbUMsWUFBbkMsRUFBaUQ7QUFDL0MsUUFBTSxHQUFHLEdBQUcsTUFBTSxNQUFNLENBQUMsS0FBUCxDQUFhLHVCQUFiLEVBQXNDO0FBQ3RELElBQUEsTUFBTSxFQUFFLE1BRDhDO0FBRXRELElBQUEsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFMLENBQWU7QUFDbkIsTUFBQSxHQURtQjtBQUVuQixNQUFBLElBQUksRUFBRTtBQUZhLEtBQWY7QUFGZ0QsR0FBdEMsQ0FBbEI7QUFRQSxTQUFPLEdBQUcsQ0FBQyxJQUFKLEVBQVA7QUFDRDs7QUFFRCxNQUFNLFFBQU4sQ0FBZTtBQUNDLFNBQVAsT0FBTyxDQUFDLE9BQUQsRUFBVTtBQUN0QixTQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsV0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQjtBQUNyQixNQUFBLFVBQVUsRUFBRyxFQUFELElBQVE7QUFDbEIsUUFBQSxVQUFVLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBVjtBQUNELE9BSG9CO0FBSXJCLE1BQUEsU0FBUyxFQUFFLE9BQU8sU0FBUCxFQUFrQixNQUFsQixLQUE2QjtBQUN0QyxjQUFNO0FBQUUsVUFBQTtBQUFGLFlBQWlCLE1BQXZCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBRUEsUUFBQSxVQUFVLENBQUMsVUFBRCxFQUFhLEdBQWIsQ0FBVjtBQUVBLGNBQU0sS0FBSyxDQUFDLEVBQUQsQ0FBWDtBQUVBLGVBQU87QUFDTCxVQUFBLE9BQU8sRUFBRTtBQUNQLFlBQUEsR0FBRyxFQUFFLE1BQU8sR0FBUCxJQUFlO0FBQ2xCLG9CQUFNLEtBQUssQ0FBQyxFQUFELENBQVg7QUFDQSxvQkFBTSxHQUFHLEdBQUcsTUFBTSxnQkFBZ0IsQ0FDL0IsR0FBRSxLQUFLLE9BQVEsSUFBRyxLQUFLLFNBQVUsSUFBRyxHQUFJLEVBRFQsQ0FBbEM7QUFHQSxxQkFBTyxHQUFQO0FBQ0QsYUFQTTtBQVFQLFlBQUEsR0FBRyxFQUFFLE9BQU8sR0FBUCxFQUFZLElBQVosS0FBcUI7QUFDeEIsb0JBQU0sY0FBYyxDQUNqQixHQUFFLEtBQUssT0FBUSxJQUFHLEtBQUssU0FBVSxJQUFHLEdBQUksRUFEdkIsRUFFbEIsSUFGa0IsQ0FBcEI7QUFJQSxvQkFBTSxLQUFLLENBQUMsRUFBRCxDQUFYO0FBQ0EscUJBQU8sSUFBUDtBQUNEO0FBZk07QUFESixTQUFQO0FBbUJELE9BL0JvQjtBQWdDckIsTUFBQSxNQUFNLEVBQUUsTUFBTTtBQWhDTyxLQUFoQixDQUFQO0FBa0NEOztBQUVxQixlQUFULFNBQVMsQ0FBQyxPQUFELEVBQVU7QUFDOUIsVUFBTSxNQUFNLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBRSxHQUFFLE9BQVEsMEJBQVosQ0FBckM7QUFDQSxXQUFPLE1BQU0sR0FBRztBQUFFLE1BQUEsTUFBTSxFQUFFO0FBQUUsUUFBQSxRQUFRLEVBQUU7QUFBWjtBQUFWLEtBQUgsR0FBa0MsRUFBL0M7QUFDRDs7QUExQ1k7O0FBNkNmLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLFFBQWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBOztBQUNBOztBQUNBOztBQUtlLFNBQVMsd0JBQVQsQ0FBa0M7QUFDL0MsRUFBQSxPQUQrQztBQUUvQyxFQUFBLFdBRitDO0FBRy9DLEVBQUEsa0JBSCtDO0FBSS9DLEVBQUEscUJBSitDO0FBSy9DLEVBQUEsbUJBTCtDO0FBTS9DLEVBQUEscUJBTitDO0FBTy9DLEVBQUEscUJBUCtDO0FBUS9DLEVBQUEsc0JBUitDO0FBUy9DLEVBQUEscUJBVCtDO0FBVS9DLEVBQUEsMEJBVitDO0FBVy9DLEVBQUEsZUFYK0M7QUFZL0MsRUFBQTtBQVorQyxDQUFsQyxFQWFaO0FBQ0QsUUFBTSxrQkFBa0IsR0FBRyxvQ0FBZ0IsQ0FDekMsNkNBQXlCO0FBQ3ZCLElBQUEsV0FBVyxFQUFFLEtBRFU7QUFFdkIsSUFBQSxrQkFBa0IsRUFBRyxhQUFZLE9BQVE7QUFGbEIsR0FBekIsQ0FEeUMsRUFLekMsa0RBQXVCO0FBQ3JCLElBQUEsV0FEcUI7QUFFckIsSUFBQSxrQkFGcUI7QUFHckIsSUFBQSxxQkFIcUI7QUFJckIsSUFBQSxtQkFKcUI7QUFLckIsSUFBQSxxQkFMcUI7QUFNckIsSUFBQSxxQkFOcUI7QUFPckIsSUFBQSxzQkFQcUI7QUFRckIsSUFBQSxxQkFScUI7QUFTckIsSUFBQTtBQVRxQixHQUF2QixDQUx5QyxFQWdCekMsMkNBQTZCO0FBQUUsSUFBQTtBQUFGLEdBQTdCLENBaEJ5QyxFQWlCekMsd0NBQTBCO0FBQUUsSUFBQTtBQUFGLEdBQTFCLENBakJ5QyxDQUFoQixDQUEzQjtBQW1CQSxTQUFPLGtCQUFQO0FBQ0Q7Ozs7Ozs7Ozs7OztBQ3pDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RpRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTSxXQUFXLEdBQUcsQ0FBQyxHQUFHLGlCQUFKLEVBQW1CLEdBQUcsc0NBQXFCLFFBQTNDLENBQXBCO0FBRUEsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLE1BQVosQ0FBbUIsQ0FBQyxHQUFELEVBQU0sT0FBTixLQUFrQjtBQUN0RCxPQUFLLE1BQU0sVUFBWCxJQUF5QixPQUFPLENBQUMsV0FBakMsRUFBOEM7QUFDNUMsSUFBQSxHQUFHLENBQUMsR0FBSixDQUFRLFVBQVIsRUFBb0IsT0FBcEI7QUFDRDs7QUFDRCxTQUFPLEdBQVA7QUFDRCxDQUxrQixFQUtoQixJQUFJLEdBQUosRUFMZ0IsQ0FBbkI7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDZSxTQUFTLHNCQUFULENBQWdDLEtBQWhDLEVBQXVDO0FBQ3BELFNBQU8sZUFBZSxnQkFBZixDQUFnQyxHQUFoQyxFQUFxQyxHQUFyQyxFQUEwQyxJQUExQyxFQUFnRCxHQUFoRCxFQUFxRDtBQUMxRDtBQUNBLFFBQUksaUNBQXdCLEdBQXhCLENBQTRCLEdBQUcsQ0FBQyxNQUFoQyxDQUFKLEVBQTZDO0FBQzNDLGFBQU8sR0FBRyxDQUFDLHdCQUFVLEdBQVYsQ0FBYyxrQkFBZCxFQUFELENBQVY7QUFDRDs7QUFFRCxVQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsR0FBWCxDQUFlLEdBQUcsQ0FBQyxNQUFuQixDQUFoQjs7QUFDQSxRQUFJLE9BQUosRUFBYTtBQUNYLFlBQU07QUFBRSxRQUFBLGNBQUY7QUFBa0IsUUFBQTtBQUFsQixVQUFnQyxPQUF0Qzs7QUFDQSxVQUFJO0FBQ0Y7QUFDQSxlQUFPLE1BQU0sY0FBYyxDQUN6QixHQUR5QixFQUV6QixHQUZ5QixFQUd6QixJQUh5QixFQUl6QixHQUp5QixFQUt6Qiw2QkFBWSxLQUFaLEVBQW1CLFNBQW5CLENBTHlCLENBQTNCO0FBT0QsT0FURCxDQVNFLE9BQU8sS0FBUCxFQUFjO0FBQ2QsZUFBTyxHQUFHLENBQUMsS0FBRCxDQUFWO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQUksRUFBWDtBQUNELEdBeEJEO0FBeUJEOzs7Ozs7Ozs7Ozs7QUNuREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoSUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BBOztBQUNBOztBQVFBOztBQUNBOzs7Ozs7QUFFQSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsR0FBUixDQUFZLE9BQTNCO0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLEdBQUc7QUFBRSxFQUFBLGVBQWUsRUFBRTtBQUFuQixDQUFILEdBQWlDLEVBQWhFOztBQUNBLE1BQU0sa0JBQWtCLEdBQUcsTUFBTTtBQUMvQixTQUFPLE1BQU0sR0FBRyxDQUFDLG9DQUFvQyxFQUFyQyxDQUFILEdBQThDLEVBQTNEO0FBQ0QsQ0FGRDs7QUFJZSxTQUFTLG1CQUFULENBQTZCO0FBQUUsRUFBQSxNQUFGO0FBQVUsRUFBQTtBQUFWLENBQTdCLEVBQWtEO0FBQy9ELFFBQU0sZUFBZSxHQUFHLGlEQUFzQjtBQUFFLElBQUE7QUFBRixHQUF0QixDQUF4QjtBQUNBLFFBQU0sYUFBYSxHQUFHLGtEQUF1QixlQUF2QixDQUF0QjtBQUNBLFFBQU0sWUFBWSxHQUFHLElBQUksb0NBQUosaUNBQ2hCLGdCQURnQjtBQUVuQixJQUFBLFFBQVEsRUFBRTtBQUZTLEtBQXJCO0FBS0EsUUFBTSxpQkFBaUIsR0FBRyxvQ0FBZ0IsQ0FDeEMsR0FBRyxrQkFBa0IsRUFEbUIsRUFFeEMsdUJBQXVCLENBQUMsT0FBRCxDQUZpQixFQUd4QywyREFBZ0M7QUFBRSxJQUFBO0FBQUYsR0FBaEMsQ0FId0MsRUFJeEMsc0RBQTJCO0FBQUUsSUFBQTtBQUFGLEdBQTNCLENBSndDLEVBS3hDLDBEQUx3QyxFQU14QyxpRUFBc0M7QUFBRSxJQUFBO0FBQUYsR0FBdEMsQ0FOd0MsRUFPeEMsZUFQd0MsQ0FBaEIsQ0FBMUI7QUFVQSxTQUFPO0FBQUUsSUFBQSxpQkFBRjtBQUFxQixJQUFBO0FBQXJCLEdBQVA7QUFDRDs7QUFFRCxTQUFTLHVCQUFULENBQWlDLE9BQWpDLEVBQTBDO0FBQ3hDLFNBQU8sQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLElBQVgsRUFBaUIsR0FBakIsS0FBeUI7QUFDOUIsUUFBSSxHQUFHLENBQUMsTUFBSixLQUFlLGFBQW5CLEVBQWtDO0FBQ2hDLE1BQUEsR0FBRyxDQUFDLE1BQUosR0FBYSxPQUFiO0FBQ0EsYUFBTyxHQUFHLEVBQVY7QUFDRDs7QUFDRCxXQUFPLElBQUksRUFBWDtBQUNELEdBTkQ7QUFPRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTLG9DQUFULEdBQWdEO0FBQzlDLFNBQU8sMENBQXNCLE9BQU8sR0FBUCxFQUFZLENBQVosRUFBZSxJQUFmLEtBQXdCO0FBQ25ELFFBQUksR0FBRyxDQUFDLE1BQUosS0FBZSxpQkFBbkIsRUFBc0M7QUFDcEMsWUFBTSxJQUFJLE9BQUosQ0FBYSxPQUFELElBQWEsVUFBVSxDQUFDLE9BQUQsRUFBVSxlQUFTLENBQW5CLENBQW5DLENBQU47QUFDRDs7QUFDRCxXQUFPLElBQUksRUFBWDtBQUNELEdBTE0sQ0FBUDtBQU1EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVERDs7QUFDQTs7QUFTQTs7QUFDQTs7QUFFQTs7QUFFZSxTQUFTLGtCQUFULENBQTRCO0FBQUUsRUFBQSxPQUFGO0FBQVcsRUFBQTtBQUFYLENBQTVCLEVBQW9EO0FBQ2pFLFFBQU0sZ0JBQWdCLEdBQUcsK0JBQXVCO0FBQzlDLElBQUEsT0FEOEM7QUFFOUMsSUFBQSxTQUY4QztBQUc5QyxJQUFBLFdBQVcsRUFBRSxDQUhpQztBQUk5QyxJQUFBLE1BQU0sRUFBRTtBQUpzQyxHQUF2QixDQUF6QjtBQU1BLFFBQU0sY0FBYyxHQUFHLGtEQUF1QixnQkFBdkIsQ0FBdkI7QUFDQSxRQUFNLFlBQVksR0FBRyxJQUFJLG9DQUFKLENBQXdCO0FBQUUsSUFBQSxRQUFRLEVBQUU7QUFBWixHQUF4QixDQUFyQjtBQUVBLFFBQU0saUJBQWlCLEdBQUcsb0NBQWdCLENBQ3hDLGlDQUFpQyxDQUFDO0FBQUUsSUFBQTtBQUFGLEdBQUQsQ0FETyxFQUV4QyxzREFBMkI7QUFBRSxJQUFBO0FBQUYsR0FBM0IsQ0FGd0MsRUFHeEMsMERBSHdDLEVBSXhDLG9EQUF5QjtBQUFFLElBQUEsWUFBRjtBQUFnQixJQUFBLFFBQVEsRUFBRTtBQUExQixHQUF6QixDQUp3QyxFQUt4Qyx3REFBNkI7QUFBRSxJQUFBLFlBQUY7QUFBZ0IsSUFBQSxRQUFRLEVBQUU7QUFBMUIsR0FBN0IsQ0FMd0MsRUFNeEMsaUVBQXNDO0FBQUUsSUFBQTtBQUFGLEdBQXRDLENBTndDLEVBT3hDLGdCQVB3QyxDQUFoQixDQUExQjtBQVNBLFNBQU87QUFBRSxJQUFBLGlCQUFGO0FBQXFCLElBQUE7QUFBckIsR0FBUDtBQUNEOztBQUVELFNBQVMsaUNBQVQsQ0FBMkM7QUFBRSxFQUFBO0FBQUYsQ0FBM0MsRUFBd0Q7QUFDdEQsTUFBSSxDQUFDLGdDQUF1QixPQUF2QixDQUFMLEVBQXNDO0FBQ3BDLFVBQU0sSUFBSSxLQUFKLENBQVcseUNBQXdDLE9BQVEsR0FBM0QsQ0FBTjtBQUNEOztBQUVELFFBQU07QUFBRSxJQUFBLE9BQUY7QUFBVyxJQUFBO0FBQVgsTUFBeUIsZ0NBQXVCLE9BQXZCLENBQS9CO0FBRUEsU0FBTyw2Q0FBeUI7QUFDOUIsSUFBQSxXQUFXLEVBQUUsT0FEaUI7QUFFOUIsSUFBQSxXQUFXLEVBQUU7QUFGaUIsR0FBekIsQ0FBUDtBQUlEOzs7Ozs7Ozs7Ozs7O0FDaEREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ245QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ251QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5SUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1JBOztBQUNBOztBQUVPLFNBQVMsNEJBQVQsQ0FBc0M7QUFBRSxFQUFBO0FBQUYsQ0FBdEMsRUFBMkQ7QUFDaEUsU0FBTywwQ0FBc0IsT0FBTyxHQUFQLEVBQVksR0FBWixFQUFpQixJQUFqQixLQUEwQjtBQUNyRCxVQUFNO0FBQUUsTUFBQSxNQUFGO0FBQVUsTUFBQTtBQUFWLFFBQXFCLEdBQTNCOztBQUNBLFFBQUksTUFBTSxLQUFLLHlCQUFmLEVBQTBDO0FBQ3hDLE1BQUEsSUFBSTtBQUNKO0FBQ0Q7O0FBQ0QsVUFBTSxDQUFDLEtBQUQsRUFBUSxRQUFSLElBQW9CLE1BQTFCOztBQUNBLFFBQUksUUFBUSxLQUFLLFNBQWpCLEVBQTRCO0FBQzFCLE1BQUEsSUFBSTtBQUNKO0FBQ0Q7O0FBQ0QsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLE1BQU0sZUFBZSxDQUFDLEtBQUQsQ0FBbEM7QUFDRCxHQVpNLENBQVA7QUFhRDs7QUFFTSxTQUFTLHlCQUFULENBQW1DO0FBQUUsRUFBQTtBQUFGLENBQW5DLEVBQW9FO0FBQ3pFLFNBQU8sMENBQXNCLE9BQU8sR0FBUCxFQUFZLEdBQVosRUFBaUIsSUFBakIsS0FBMEI7QUFDckQsVUFBTTtBQUFFLE1BQUEsTUFBRjtBQUFVLE1BQUE7QUFBVixRQUFxQixHQUEzQjs7QUFDQSxRQUFJLE1BQU0sS0FBSywwQkFBZixFQUEyQztBQUN6QyxNQUFBLElBQUk7QUFDSjtBQUNEOztBQUNELFVBQU0sQ0FBQyxJQUFELElBQVMsTUFBZjtBQUNBLFVBQU0sTUFBTSxHQUFHLDJCQUEyQixDQUFDLElBQUQsQ0FBMUM7O0FBQ0EsUUFBSSxDQUFDLE1BQUwsRUFBYTtBQUNYLE1BQUEsSUFBSTtBQUNKO0FBQ0Q7O0FBQ0QsSUFBQSxHQUFHLENBQUMsTUFBSixHQUFhLG9DQUF5QixNQUF6QixDQUFiO0FBQ0QsR0FiTSxDQUFQO0FBY0Q7Ozs7Ozs7Ozs7OztBQ2xDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzc3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFFBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xKQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNLFFBQVEsR0FBRyxDQUNmLHlCQURlLEVBRWYsb0JBRmUsRUFHZix5QkFIZSxFQUlmLHlCQUplLEVBS2Ysd0JBTGUsRUFNZixxQkFOZSxFQU9mLDRCQVBlLEVBUWYsbUJBUmUsQ0FBakI7ZUFVZSxROzs7Ozs7Ozs7Ozs7O0FDbkJmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRkE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFzQkE7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeDVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3MEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZmQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBOztBQUNBOztBQUVPLE1BQU0scUJBQXFCLEdBQUksR0FBRCxJQUFTLDZCQUFvQixHQUFwQixDQUF2Qzs7OztBQUVBLFNBQVMsd0JBQVQsQ0FBa0MsTUFBbEMsRUFBMEM7QUFDL0MsUUFBTTtBQUFFLElBQUEsQ0FBRjtBQUFLLElBQUEsQ0FBTDtBQUFRLElBQUEsQ0FBUjtBQUFXLElBQUEsSUFBWDtBQUFpQixJQUFBLFNBQWpCO0FBQTRCLElBQUE7QUFBNUIsTUFBeUMsTUFBL0M7QUFDQSxRQUFNO0FBQ0osSUFBQSxFQURJO0FBRUosSUFBQSxJQUZJO0FBR0osSUFBQSxLQUhJO0FBSUosSUFBQSxHQUpJO0FBS0osSUFBQSxJQUxJO0FBTUosSUFBQSxLQU5JO0FBT0osSUFBQSxRQVBJO0FBUUosSUFBQSxVQVJJO0FBU0osSUFBQSxZQVRJO0FBVUosSUFBQTtBQVZJLE1BV0YsUUFYSjtBQWFBLFFBQU0sZUFBZSxHQUFHO0FBQ3RCLElBQUEsQ0FEc0I7QUFFdEIsSUFBQSxDQUZzQjtBQUd0QixJQUFBLENBSHNCO0FBSXRCLElBQUEsRUFKc0I7QUFLdEIsSUFBQSxHQUxzQjtBQU10QixJQUFBLElBTnNCO0FBT3RCLElBQUEsSUFQc0I7QUFRdEIsSUFBQSxLQVJzQjtBQVN0QixJQUFBLEtBQUssRUFBRSxJQUFJLElBQUksSUFUTztBQVV0QixJQUFBLEtBQUssRUFBRSxLQUFLLElBQUksS0FWTTtBQVd0QixJQUFBLFVBQVUsRUFBRSxVQUFVLElBQUksSUFYSjtBQVl0QixJQUFBLFNBQVMsRUFBRSxDQUFBLFNBQVMsU0FBVCxJQUFBLFNBQVMsV0FBVCxZQUFBLFNBQVMsQ0FBRSxTQUFYLEtBQXdCLElBWmI7QUFhdEIsSUFBQSxXQUFXLEVBQUUsQ0FBQSxTQUFTLFNBQVQsSUFBQSxTQUFTLFdBQVQsWUFBQSxTQUFTLENBQUUsV0FBWCxLQUEwQixJQWJqQjtBQWN0QixJQUFBLGdCQUFnQixFQUFFLENBQUEsU0FBUyxTQUFULElBQUEsU0FBUyxXQUFULFlBQUEsU0FBUyxDQUFFLGdCQUFYLEtBQStCO0FBZDNCLEdBQXhCOztBQWlCQSxNQUFJLFlBQVksSUFBSSxvQkFBcEIsRUFBMEM7QUFDeEMsSUFBQSxlQUFlLENBQUMsUUFBaEIsR0FBMkIsWUFBM0I7QUFDQSxJQUFBLGVBQWUsQ0FBQyxZQUFoQixHQUErQixZQUEvQjtBQUNBLElBQUEsZUFBZSxDQUFDLG9CQUFoQixHQUF1QyxvQkFBdkM7QUFDQSxJQUFBLGVBQWUsQ0FBQyxJQUFoQixHQUF1Qix3Q0FBMkIsVUFBbEQ7QUFDRCxHQUxELE1BS087QUFDTCxJQUFBLGVBQWUsQ0FBQyxRQUFoQixHQUEyQixRQUEzQjtBQUNBLElBQUEsZUFBZSxDQUFDLElBQWhCLEdBQXVCLHdDQUEyQixNQUFsRDtBQUNEOztBQUVELFNBQU8sZUFBUDtBQUNEOzs7Ozs7Ozs7Ozs7QUNoREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hMQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJiYWNrZ3JvdW5kLTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ3NhZmUtZXZlbnQtZW1pdHRlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICdAbWV0YW1hc2svb2JzLXN0b3JlJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsga2V5QnksIG1hcFZhbHVlcywgb21pdEJ5LCBwaWNrQnksIHNvcnRCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgY3JlYXRlSWQgZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyB9IGZyb20gJy4uLy4uL21ldGFtYXNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3RyYW5zYWN0aW9uLnV0aWxzJztcbmltcG9ydCB7XG4gIGdlbmVyYXRlSGlzdG9yeUVudHJ5LFxuICByZXBsYXlIaXN0b3J5LFxuICBzbmFwc2hvdEZyb21UeE1ldGEsXG59IGZyb20gJy4vbGliL3R4LXN0YXRlLWhpc3RvcnktaGVscGVycyc7XG5pbXBvcnQgeyBnZXRGaW5hbFN0YXRlcywgbm9ybWFsaXplQW5kVmFsaWRhdGVUeFBhcmFtcyB9IGZyb20gJy4vbGliL3V0aWwnO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uU3RhdHVzZXMgcmVpbXBvcnRlZCBmcm9tIHRoZSBzaGFyZWQgdHJhbnNhY3Rpb24gY29uc3RhbnRzIGZpbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXG4gKiAgJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nXG4gKiApLlRyYW5zYWN0aW9uU3RhdHVzU3RyaW5nfSBUcmFuc2FjdGlvblN0YXR1c1N0cmluZ1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbicpLlR4UGFyYW1zfSBUeFBhcmFtc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcbiAqICAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbidcbiAqICkuVHJhbnNhY3Rpb25NZXRhfSBUcmFuc2FjdGlvbk1ldGFcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyYW5zYWN0aW9uU3RhdGVcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgVHJhbnNhY3Rpb25NZXRhPn0gdHJhbnNhY3Rpb25zIC0gVHJhbnNhY3Rpb25NZXRhXG4gKiAga2V5ZWQgYnkgdGhlIHRyYW5zYWN0aW9uJ3MgaWQuXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvblN0YXRlTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHN0YXRlIG9mIGEgdHJhbnNhY3Rpb24gYW5kXG4gKiBzdG9yaW5nIHRoZSB0cmFuc2FjdGlvbi4gSXQgYWxzbyBoYXMgc29tZSBjb252ZW5pZW5jZSBtZXRob2RzIGZvciBmaW5kaW5nXG4gKiBzdWJzZXRzIG9mIHRyYW5zYWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uU3RhdGV9IFtvcHRzLmluaXRTdGF0ZT17IHRyYW5zYWN0aW9uczoge30gfV0gLSBpbml0aWFsXG4gKiAgdHJhbnNhY3Rpb25zIGxpc3Qga2V5ZWQgYnkgaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50eEhpc3RvcnlMaW1pdF0gLSBsaW1pdCBmb3IgaG93IG1hbnkgZmluaXNoZWRcbiAqICB0cmFuc2FjdGlvbnMgY2FuIGhhbmcgYXJvdW5kIGluIHN0YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmdldE5ldHdvcmsgLSByZXR1cm4gbmV0d29yayBudW1iZXJcbiAqIEBjbGFzc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2FjdGlvblN0YXRlTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHsgaW5pdFN0YXRlLCB0eEhpc3RvcnlMaW1pdCwgZ2V0TmV0d29yaywgZ2V0Q3VycmVudENoYWluSWQgfSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IHt9LFxuICAgICAgLi4uaW5pdFN0YXRlLFxuICAgIH0pO1xuICAgIHRoaXMudHhIaXN0b3J5TGltaXQgPSB0eEhpc3RvcnlMaW1pdDtcbiAgICB0aGlzLmdldE5ldHdvcmsgPSBnZXROZXR3b3JrO1xuICAgIHRoaXMuZ2V0Q3VycmVudENoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBUcmFuc2FjdGlvbk1ldGEgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgdGhlIGZpZWxkcyByZXF1aXJlZCBmb3JcbiAgICogdXNlIHRocm91Z2hvdXQgdGhlIGV4dGVuc2lvbi4gVGhlIGFyZ3VtZW50IGhlcmUgd2lsbCBvdmVycmlkZSBldmVyeXRoaW5nXG4gICAqIGluIHRoZSByZXN1bHRpbmcgdHJhbnNhY3Rpb24gbWV0YS5cbiAgICpcbiAgICogVE9ETzogRG9uJ3Qgb3ZlcndyaXRlIGV2ZXJ5dGhpbmc/XG4gICAqXG4gICAqIEBwYXJhbSB7UGFydGlhbDxUcmFuc2FjdGlvbk1ldGE+fSBvcHRzIC0gdGhlIG9iamVjdCB0byB1c2Ugd2hlblxuICAgKiAgb3ZlcndyaXRpbmcgZGVmYXVsdCBrZXlzIG9mIHRoZSBUcmFuc2FjdGlvbk1ldGFcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YX0gdGhlIGRlZmF1bHQgdHhNZXRhIG9iamVjdFxuICAgKi9cbiAgZ2VuZXJhdGVUeE1ldGEob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgbmV0SWQgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgIGlmIChuZXRJZCA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGlzIGhhdmluZyB0cm91YmxlIGNvbm5lY3RpbmcgdG8gdGhlIG5ldHdvcmsnKTtcbiAgICB9XG5cbiAgICBsZXQgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgPSBudWxsO1xuXG4gICAgLy8gSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIHRyYW5zYWN0aW9uIHN1Z2dlc3RlZCBieSBhIGRhcHAgYW5kIG5vdFxuICAgIC8vIGFuIGludGVybmFsbHkgY3JlYXRlZCBtZXRhbWFzayB0cmFuc2FjdGlvbiwgd2UgbmVlZCB0byBrZWVwIHJlY29yZCBvZlxuICAgIC8vIHRoZSBvcmlnaW5hbGx5IHN1Ym1pdHRlZCBnYXNQYXJhbXMuXG4gICAgaWYgKFxuICAgICAgb3B0cy50eFBhcmFtcyAmJlxuICAgICAgdHlwZW9mIG9wdHMub3JpZ2luID09PSAnc3RyaW5nJyAmJlxuICAgICAgb3B0cy5vcmlnaW4gIT09ICdtZXRhbWFzaydcbiAgICApIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy50eFBhcmFtcy5nYXNQcmljZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgPSB7XG4gICAgICAgICAgZ2FzUHJpY2U6IG9wdHMudHhQYXJhbXMuZ2FzUHJpY2UsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2Ygb3B0cy50eFBhcmFtcy5tYXhGZWVQZXJHYXMgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiBvcHRzLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIGRhcHBTdWdnZXN0ZWRHYXNGZWVzID0ge1xuICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBvcHRzLnR4UGFyYW1zLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgIG1heEZlZVBlckdhczogb3B0cy50eFBhcmFtcy5tYXhGZWVQZXJHYXMsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy50eFBhcmFtcy5nYXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRhcHBTdWdnZXN0ZWRHYXNGZWVzID0ge1xuICAgICAgICAgIC4uLmRhcHBTdWdnZXN0ZWRHYXNGZWVzLFxuICAgICAgICAgIGdhczogb3B0cy50eFBhcmFtcy5nYXMsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBjcmVhdGVJZCgpLFxuICAgICAgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQsXG4gICAgICBtZXRhbWFza05ldHdvcmtJZDogbmV0SWQsXG4gICAgICBjaGFpbklkLFxuICAgICAgbG9hZGluZ0RlZmF1bHRzOiB0cnVlLFxuICAgICAgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMsXG4gICAgICAuLi5vcHRzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB1bmFwcHJvdmVkIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogbmV0d29yay4gVGhpcyBpcyB0aGUgb25seSB0cmFuc2FjdGlvbiBmZXRjaGluZyBtZXRob2QgdGhhdCByZXR1cm5zIGFuXG4gICAqIG9iamVjdCwgc28gaXQgZG9lc24ndCB1c2UgZ2V0VHJhbnNhY3Rpb25zIGxpa2UgZXZlcnl0aGluZyBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgVHJhbnNhY3Rpb25NZXRhPn0gVW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMga2V5ZWRcbiAgICogIGJ5IGlkXG4gICAqL1xuICBnZXRVbmFwcHJvdmVkVHhMaXN0KCkge1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgY29uc3QgbmV0d29yayA9IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgIHJldHVybiBwaWNrQnkoXG4gICAgICB0aGlzLnN0b3JlLmdldFN0YXRlKCkudHJhbnNhY3Rpb25zLFxuICAgICAgKHRyYW5zYWN0aW9uKSA9PlxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQgJiZcbiAgICAgICAgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayh0cmFuc2FjdGlvbiwgY2hhaW5JZCwgbmV0d29yayksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGFwcHJvdmVkIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay4gSWYgYW4gYWRkcmVzcyBpc1xuICAgKiBwcm92aWRlZCwgdGhlIGxpc3Qgd2lsbCBiZSBmdXJ0aGVyIHJlZmluZWQgdG8gb25seSB0aG9zZSB0cmFuc2FjdGlvbnNcbiAgICogb3JpZ2luYXRpbmcgZnJvbSB0aGUgc3VwcGxpZWQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthZGRyZXNzXSAtIGhleCBwcmVmaXhlZCBhZGRyZXNzIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGZvci5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YVtdfSB0aGUgZmlsdGVyZWQgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGdldEFwcHJvdmVkVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICBjb25zdCBzZWFyY2hDcml0ZXJpYSA9IHsgc3RhdHVzOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5BUFBST1ZFRCB9O1xuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICBzZWFyY2hDcml0ZXJpYS5mcm9tID0gYWRkcmVzcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25zKHsgc2VhcmNoQ3JpdGVyaWEgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay4gSWYgYW4gYWRkcmVzcyBpc1xuICAgKiBwcm92aWRlZCwgdGhlIGxpc3Qgd2lsbCBiZSBmdXJ0aGVyIHJlZmluZWQgdG8gb25seSB0aG9zZSB0cmFuc2FjdGlvbnNcbiAgICogb3JpZ2luYXRpbmcgZnJvbSB0aGUgc3VwcGxpZWQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthZGRyZXNzXSAtIGhleCBwcmVmaXhlZCBhZGRyZXNzIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGZvci5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uTWV0YVtdfSB0aGUgZmlsdGVyZWQgbGlzdCBvZiB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGdldFBlbmRpbmdUcmFuc2FjdGlvbnMoYWRkcmVzcykge1xuICAgIGNvbnN0IHNlYXJjaENyaXRlcmlhID0geyBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCB9O1xuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICBzZWFyY2hDcml0ZXJpYS5mcm9tID0gYWRkcmVzcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb25zKHsgc2VhcmNoQ3JpdGVyaWEgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjb25maXJtZWQgdHJhbnNhY3Rpb25zIGZvciB0aGUgY3VycmVudCBuZXR3b3JrLiBJZiBhbiBhZGRyZXNzIGlzXG4gICAqIHByb3ZpZGVkLCB0aGUgbGlzdCB3aWxsIGJlIGZ1cnRoZXIgcmVmaW5lZCB0byBvbmx5IHRob3NlIHRyYW5zYWN0aW9uc1xuICAgKiBvcmlnaW5hdGluZyBmcm9tIHRoZSBzdXBwbGllZCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FkZHJlc3NdIC0gaGV4IHByZWZpeGVkIGFkZHJlc3MgdG8gZmluZCB0cmFuc2FjdGlvbnMgZm9yLlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25NZXRhW119IHRoZSBmaWx0ZXJlZCBsaXN0IG9mIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICBjb25zdCBzZWFyY2hDcml0ZXJpYSA9IHsgc3RhdHVzOiBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQgfTtcbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgc2VhcmNoQ3JpdGVyaWEuZnJvbSA9IGFkZHJlc3M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9ucyh7IHNlYXJjaENyaXRlcmlhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHR4TWV0YSB0byB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgaW4gdGhlIHN0b3JlLlxuICAgKiBpZiB0aGUgbGlzdCBpcyBvdmVyIHR4SGlzdG9yeUxpbWl0IGl0IHdpbGwgcmVtb3ZlIGEgdHJhbnNhY3Rpb24gdGhhdFxuICAgKiBpcyBpbiBpdHMgZmluYWwgc3RhdGUuXG4gICAqIGl0IHdpbGwgYWxzbyBhZGQgdGhlIGtleSBgaGlzdG9yeWAgdG8gdGhlIHR4TWV0YSB3aXRoIHRoZSBzbmFwIHNob3Qgb2ZcbiAgICogdGhlIG9yaWdpbmFsIG9iamVjdFxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uTWV0YX0gdHhNZXRhIC0gVGhlIFRyYW5zYWN0aW9uTWV0YSBvYmplY3QgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25NZXRhfSBUaGUgc2FtZSBUcmFuc2FjdGlvbk1ldGEsIGJ1dCB3aXRoIHZhbGlkYXRlZFxuICAgKiAgdHhQYXJhbXMgYW5kIHRyYW5zYWN0aW9uIGhpc3RvcnkuXG4gICAqL1xuICBhZGRUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgICAvLyBub3JtYWxpemUgYW5kIHZhbGlkYXRlIHR4UGFyYW1zIGlmIHByZXNlbnRcbiAgICBpZiAodHhNZXRhLnR4UGFyYW1zKSB7XG4gICAgICB0eE1ldGEudHhQYXJhbXMgPSBub3JtYWxpemVBbmRWYWxpZGF0ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcywgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMub25jZShgJHt0eE1ldGEuaWR9OnNpZ25lZGAsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3R4TWV0YS5pZH06cmVqZWN0ZWRgKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uY2UoYCR7dHhNZXRhLmlkfTpyZWplY3RlZGAsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3R4TWV0YS5pZH06c2lnbmVkYCk7XG4gICAgfSk7XG4gICAgLy8gaW5pdGlhbGl6ZSBoaXN0b3J5XG4gICAgdHhNZXRhLmhpc3RvcnkgPSBbXTtcbiAgICAvLyBjYXB0dXJlIGluaXRpYWwgc25hcHNob3Qgb2YgdHhNZXRhIGZvciBoaXN0b3J5XG4gICAgY29uc3Qgc25hcHNob3QgPSBzbmFwc2hvdEZyb21UeE1ldGEodHhNZXRhKTtcbiAgICB0eE1ldGEuaGlzdG9yeS5wdXNoKHNuYXBzaG90KTtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICAgIGZpbHRlclRvQ3VycmVudE5ldHdvcms6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgdHhIaXN0b3J5TGltaXQgfSA9IHRoaXM7XG5cbiAgICAvLyBjaGVja3MgaWYgdGhlIGxlbmd0aCBvZiB0aGUgdHggaGlzdG9yeSBpcyBsb25nZXIgdGhlbiBkZXNpcmVkIHBlcnNpc3RlbmNlXG4gICAgLy8gbGltaXQgYW5kIHRoZW4gaWYgaXQgaXMgcmVtb3ZlcyB0aGUgb2xkZXN0IGNvbmZpcm1lZCBvciByZWplY3RlZCB0eC5cbiAgICAvLyBQZW5kaW5nIG9yIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIHdpbGwgbm90IGJlIHJlbW92ZWQgYnkgdGhpc1xuICAgIC8vIG9wZXJhdGlvbi4gRm9yIHNhZmV0eSBvZiBwcmVzZW50aW5nIGEgZnVsbHkgZnVuY3Rpb25hbCB0cmFuc2FjdGlvbiBVSVxuICAgIC8vIHJlcHJlc2VudGF0aW9uLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJyZWFrIGFwYXJ0IHRyYW5zYWN0aW9ucyB3aXRoIHRoZVxuICAgIC8vIHNhbWUgbm9uY2UsIHBlciBuZXR3b3JrLiBOb3QgYWNjb3VudGluZyBmb3IgdHJhbnNhY3Rpb25zIG9mIHRoZSBzYW1lXG4gICAgLy8gbm9uY2UgYW5kIG5ldHdvcmsgY29tYm8gY2FuIHJlc3VsdCBpbiBjb25mdXNpbmcgb3IgYnJva2VuIGV4cGVyaWVuY2VzXG4gICAgLy8gaW4gdGhlIFVJLlxuICAgIC8vXG4gICAgLy8gVE9ETzogd2UgYXJlIGFscmVhZHkgbGltaXRpbmcgd2hhdCB3ZSBzZW5kIHRvIHRoZSBVSSwgYW5kIGluIHRoZSBmdXR1cmVcbiAgICAvLyB3ZSB3aWxsIHNlbmQgVUkgb25seSBjb2xsZWN0ZWQgZ3JvdXBzIG9mIHRyYW5zYWN0aW9ucyAqcGVyIHBhZ2UqIHNvIGF0XG4gICAgLy8gc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB0aGlzIHBlcnNpc3RlbmNlIGxpbWl0IGNhbiBiZSBhZGp1c3RlZC4gV2hlblxuICAgIC8vIHdlIGRvIHRoYXQgSSB0aGluayB3ZSBzaG91bGQgZmlndXJlIG91dCBhIGJldHRlciBzdG9yYWdlIHNvbHV0aW9uIGZvclxuICAgIC8vIHRyYW5zYWN0aW9uIGhpc3RvcnkgZW50cmllcy5cbiAgICBjb25zdCBub25jZU5ldHdvcmtTZXQgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdHhzVG9EZWxldGUgPSB0cmFuc2FjdGlvbnNcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maWx0ZXIoKHR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4LnR4UGFyYW1zO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIG1ldGFtYXNrTmV0d29ya0lkLCBzdGF0dXMgfSA9IHR4O1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtub25jZX0tJHtjaGFpbklkID8/IG1ldGFtYXNrTmV0d29ya0lkfWA7XG4gICAgICAgIGlmIChub25jZU5ldHdvcmtTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgbm9uY2VOZXR3b3JrU2V0LnNpemUgPCB0eEhpc3RvcnlMaW1pdCAtIDEgfHxcbiAgICAgICAgICBnZXRGaW5hbFN0YXRlcygpLmluY2x1ZGVzKHN0YXR1cykgPT09IGZhbHNlXG4gICAgICAgICkge1xuICAgICAgICAgIG5vbmNlTmV0d29ya1NldC5hZGQoa2V5KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICAgLm1hcCgodHgpID0+IHR4LmlkKTtcblxuICAgIHRoaXMuX2RlbGV0ZVRyYW5zYWN0aW9ucyh0eHNUb0RlbGV0ZSk7XG4gICAgdGhpcy5fYWRkVHJhbnNhY3Rpb25zVG9TdGF0ZShbdHhNZXRhXSk7XG4gICAgcmV0dXJuIHR4TWV0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHhJZFxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25NZXRhfSB0aGUgdHhNZXRhIHdobyBtYXRjaGVzIHRoZSBnaXZlbiBpZCBpZiBub25lIGZvdW5kXG4gICAqIGZvciB0aGUgbmV0d29yayByZXR1cm5zIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb24odHhJZCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uc1t0eElkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGVzIHRoZSB0eE1ldGEgaW4gdGhlIGxpc3QgYW5kIGFkZHMgYSBoaXN0b3J5IGVudHJ5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSB0aGUgdHhNZXRhIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25vdGVdIC0gYSBub3RlIGFib3V0IHRoZSB1cGRhdGUgZm9yIGhpc3RvcnlcbiAgICovXG4gIHVwZGF0ZVRyYW5zYWN0aW9uKHR4TWV0YSwgbm90ZSkge1xuICAgIC8vIG5vcm1hbGl6ZSBhbmQgdmFsaWRhdGUgdHhQYXJhbXMgaWYgcHJlc2VudFxuICAgIGlmICh0eE1ldGEudHhQYXJhbXMpIHtcbiAgICAgIHR4TWV0YS50eFBhcmFtcyA9IG5vcm1hbGl6ZUFuZFZhbGlkYXRlVHhQYXJhbXModHhNZXRhLnR4UGFyYW1zLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHR4TWV0YSBzbmFwc2hvdCBmb3IgaGlzdG9yeVxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHNuYXBzaG90RnJvbVR4TWV0YSh0eE1ldGEpO1xuICAgIC8vIHJlY292ZXIgcHJldmlvdXMgdHggc3RhdGUgb2JqXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHJlcGxheUhpc3RvcnkodHhNZXRhLmhpc3RvcnkpO1xuICAgIC8vIGdlbmVyYXRlIGhpc3RvcnkgZW50cnkgYW5kIGFkZCB0byBoaXN0b3J5XG4gICAgY29uc3QgZW50cnkgPSBnZW5lcmF0ZUhpc3RvcnlFbnRyeShwcmV2aW91c1N0YXRlLCBjdXJyZW50U3RhdGUsIG5vdGUpO1xuICAgIGlmIChlbnRyeS5sZW5ndGgpIHtcbiAgICAgIHR4TWV0YS5oaXN0b3J5LnB1c2goZW50cnkpO1xuICAgIH1cblxuICAgIC8vIGNvbW1pdCB0eE1ldGEgdG8gc3RhdGVcbiAgICBjb25zdCB0eElkID0gdHhNZXRhLmlkO1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiB7XG4gICAgICAgIC4uLnRoaXMuc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2FjdGlvbnMsXG4gICAgICAgIFt0eElkXTogdHhNZXRhLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hDcml0ZXJpYSBjYW4gc2VhcmNoIGluIGFueSBrZXkgaW4gVHhQYXJhbXMgb3IgdGhlIGJhc2VcbiAgICogVHJhbnNhY3Rpb25NZXRhLiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhbnkga2V5IG9uIGVpdGhlciBvZiB0aG9zZSB0d29cbiAgICogdHlwZXMuXG4gICAqIEB0eXBlZGVmIHtUeFBhcmFtc1trZXlvZiBUeFBhcmFtc10gfCBUcmFuc2FjdGlvbk1ldGFba2V5b2YgVHJhbnNhY3Rpb25NZXRhXX0gU2VhcmNoYWJsZUtleXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFByZWRpY2F0ZXMgY2FuIGVpdGhlciBiZSBzdHJpY3QgdmFsdWVzLCB3aGljaCBpcyBzaG9ydGhhbmQgZm9yIHVzaW5nXG4gICAqIHN0cmljdCBlcXVhbGl0eSwgb3IgYSBtZXRob2QgdGhhdCByZWNlaXZlcyBoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGtleVxuICAgKiBhbmQgcmV0dXJucyBhIGJvb2xlYW4uXG4gICAqIEB0eXBlZGVmIHsodjogdW5rbm93bikgPT4gYm9vbGVhbiB8IHVua25vd259IEZpbHRlclByZWRpY2F0ZVxuICAgKi9cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBmcm9tIHN0YXRlLiBCeSBkZWZhdWx0IHRoaXMgd2lsbCByZXR1cm5cbiAgICogdGhlIGZ1bGwgbGlzdCBvZiBUcmFuc2FjdGlvbnMgZm9yIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hhaW4vbmV0d29yay5cbiAgICogQWRkaXRpb25hbCBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCB0byBjaGFuZ2Ugd2hhdCBpcyBpbmNsdWRlZCBpbiB0aGUgZmluYWxcbiAgICogbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHRvIGNoYW5nZSBmaWx0ZXIgYmVoYXZpb3JcbiAgICogQHBhcmFtIHtSZWNvcmQ8U2VhcmNoYWJsZUtleXMsIEZpbHRlclByZWRpY2F0ZT59IFtvcHRzLnNlYXJjaENyaXRlcmlhXSAtXG4gICAqICBhbiBvYmplY3Qgd2l0aCBrZXlzIHRoYXQgbWF0Y2gga2V5cyBpbiBUcmFuc2FjdGlvbk1ldGEgb3IgVHhQYXJhbXMsIGFuZFxuICAgKiAgdmFsdWVzIHRoYXQgYXJlIHByZWRpY2F0ZXMuIFByZWRpY2F0ZXMgY2FuIGVpdGhlciBiZSBzdHJpY3QgdmFsdWVzLFxuICAgKiAgd2hpY2ggaXMgc2hvcnRoYW5kIGZvciB1c2luZyBzdHJpY3QgZXF1YWxpdHksIG9yIGEgbWV0aG9kIHRoYXQgcmVjZWl2ZXNcbiAgICogIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGtleSBhbmQgcmV0dXJucyBhIGJvb2xlYW4uIFRoZSB0cmFuc2FjdGlvblxuICAgKiAgbGlzdCB3aWxsIGJlIGZpbHRlcmVkIHRvIG9ubHkgdGhvc2UgaXRlbXMgdGhhdCB0aGUgcHJlZGljYXRlIHJldHVybnNcbiAgICogIHRydXRoeSBmb3IuICoqSElOVCoqOiBgZXJyOiB1bmRlZmluZWRgIGlzIGxpa2UgbG9va2luZyBmb3IgYSB0eCB3aXRoIG5vXG4gICAqICBlcnIuIHNvIHlvdSBjYW4gYWxzbyBzZWFyY2ggdHhzIHRoYXQgZG9uJ3QgaGF2ZSBzb21ldGhpbmcgYXMgd2VsbCBieVxuICAgKiAgc2V0dGluZyB0aGUgdmFsdWUgYXMgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uTWV0YVtdfSBbb3B0cy5pbml0aWFsTGlzdF0gLSBJZiBwcm92aWRlZCB0aGUgZmlsdGVyaW5nXG4gICAqICB3aWxsIG9jY3VyIG9uIHRoZSBwcm92aWRlZCBsaXN0LiBCeSBkZWZhdWx0IHRoaXMgd2lsbCBiZSB0aGUgZnVsbCBsaXN0XG4gICAqICBmcm9tIHN0YXRlIHNvcnRlZCBieSB0aW1lIEFTQy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5maWx0ZXJUb0N1cnJlbnROZXR3b3JrPXRydWVdIC0gRmlsdGVyIHRyYW5zYWN0aW9uXG4gICAqICBsaXN0IHRvIG9ubHkgdGhvc2UgdGhhdCBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBjaGFpbiBvciBuZXR3b3JrLlxuICAgKiAgRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxpbWl0XSAtIGxpbWl0IHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHJldHVybmVkXG4gICAqICB0byBOIHVuaXF1ZSBub25jZXMuXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbk1ldGFbXX0gVGhlIFRyYW5zYWN0aW9uTWV0YSBvYmplY3RzIHRoYXQgYWxsIHByb3ZpZGVkXG4gICAqICBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHkgZm9yLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25zKHtcbiAgICBzZWFyY2hDcml0ZXJpYSA9IHt9LFxuICAgIGluaXRpYWxMaXN0LFxuICAgIGZpbHRlclRvQ3VycmVudE5ldHdvcmsgPSB0cnVlLFxuICAgIGxpbWl0LFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAvLyBzZWFyY2hDcml0ZXJpYSBpcyBhbiBvYmplY3QgdGhhdCBtaWdodCBoYXZlIHZhbHVlcyB0aGF0IGFyZW4ndCBwcmVkaWNhdGVcbiAgICAvLyBtZXRob2RzLiBXaGVuIHByb3ZpZGluZyBhbnkgb3RoZXIgdmFsdWUgdHlwZSAoc3RyaW5nLCBudW1iZXIsIGV0YyksIHdlXG4gICAgLy8gY29uc2lkZXIgdGhpcyBzaG9ydGhhbmQgZm9yIFwiY2hlY2sgdGhlIHZhbHVlIGF0IGtleSBmb3Igc3RyaWN0IGVxdWFsaXR5XG4gICAgLy8gd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWVcIi4gVG8gY29uZm9ybSB0aGlzIG9iamVjdCB0byBiZSBvbmx5IG1ldGhvZHMsIHdlXG4gICAgLy8gbWFwVmFsdWVzIChsb2Rhc2gpIHN1Y2ggdGhhdCBldmVyeSB2YWx1ZSBvbiB0aGUgb2JqZWN0IGlzIGEgbWV0aG9kIHRoYXRcbiAgICAvLyByZXR1cm5zIGEgYm9vbGVhbi5cbiAgICBjb25zdCBwcmVkaWNhdGVNZXRob2RzID0gbWFwVmFsdWVzKHNlYXJjaENyaXRlcmlhLCAocHJlZGljYXRlKSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIHByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHByZWRpY2F0ZVxuICAgICAgICA6ICh2KSA9PiB2ID09PSBwcmVkaWNhdGU7XG4gICAgfSk7XG5cbiAgICAvLyBJZiBhbiBpbml0aWFsIGxpc3QgaXMgcHJvdmlkZWQgd2UgbmVlZCB0byBjaGFuZ2UgaXQgYmFjayBpbnRvIGFuIG9iamVjdFxuICAgIC8vIGZpcnN0LCBzbyB0aGF0IGl0IG1hdGNoZXMgdGhlIHNoYXBlIG9mIG91ciBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHRoZVxuICAgIC8vIGxvZGFzaCBrZXlCeSBtZXRob2QuIFRoaXMgaXMgdGhlIGVkZ2UgY2FzZSBmb3IgdGhpcyBtZXRob2QsIHR5cGljYWxseVxuICAgIC8vIGluaXRpYWxMaXN0IHdpbGwgYmUgdW5kZWZpbmVkLlxuICAgIGNvbnN0IHRyYW5zYWN0aW9uc1RvRmlsdGVyID0gaW5pdGlhbExpc3RcbiAgICAgID8ga2V5QnkoaW5pdGlhbExpc3QsICdpZCcpXG4gICAgICA6IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2FjdGlvbnM7XG5cbiAgICAvLyBDb21iaW5lIHNvcnRCeSBhbmQgcGlja0J5IHRvIHRyYW5zZm9ybSBvdXIgc3RhdGUgb2JqZWN0IGludG8gYW4gYXJyYXkgb2ZcbiAgICAvLyBtYXRjaGluZyB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgc29ydGVkIGJ5IHRpbWUuXG4gICAgY29uc3QgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSBzb3J0QnkoXG4gICAgICBwaWNrQnkodHJhbnNhY3Rpb25zVG9GaWx0ZXIsICh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAvLyBkZWZhdWx0IG1hdGNoZXNDcml0ZXJpYSB0byB0aGUgdmFsdWUgb2YgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29ya1xuICAgICAgICAvLyB3aGVuIGZpbHRlclRvQ3VycmVudE5ldHdvcmsgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGZpbHRlclRvQ3VycmVudE5ldHdvcmsgJiZcbiAgICAgICAgICB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrKHRyYW5zYWN0aW9uLCBjaGFpbklkLCBuZXR3b3JrKSA9PT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgcHJlZGljYXRlTWV0aG9kcyBrZXlzIHRvIGNoZWNrIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAvLyBtYXRjaGVzIHRoZSBzZWFyY2hDcml0ZXJpYVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByZWRpY2F0ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJlZGljYXRlTWV0aG9kcykpIHtcbiAgICAgICAgICAvLyBXZSByZXR1cm4gZmFsc2UgZWFybHkgYXMgc29vbiBhcyB3ZSBrbm93IHRoYXQgb25lIG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICAvLyBzZWFyY2ggY3JpdGVyaWEgZG8gbm90IG1hdGNoIHRoZSB0cmFuc2FjdGlvbi4gVGhpcyBwcmV2ZW50c1xuICAgICAgICAgIC8vIG5lZWRsZXNzbHkgY2hlY2tpbmcgYWxsIGNyaXRlcmlhIHdoZW4gd2UgYWxyZWFkeSBrbm93IHRoZSBjcml0ZXJpYVxuICAgICAgICAgIC8vIGFyZSBub3QgZnVsbHkgc2F0aXNmaWVkLiBXZSBjaGVjayBib3RoIHR4UGFyYW1zIGFuZCB0aGUgYmFzZVxuICAgICAgICAgIC8vIG9iamVjdCBhcyBwcmVkaWNhdGUga2V5cyBjYW4gYmUgZWl0aGVyLlxuICAgICAgICAgIGlmIChrZXkgaW4gdHJhbnNhY3Rpb24udHhQYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUodHJhbnNhY3Rpb24udHhQYXJhbXNba2V5XSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZSh0cmFuc2FjdGlvbltrZXldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pLFxuICAgICAgJ3RpbWUnLFxuICAgICk7XG4gICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gaGF2ZSBhbGwgdHJhbnNhY3Rpb25zIG9mIGEgZ2l2ZW4gbm9uY2UgaW4gb3JkZXIgdG8gZGlzcGxheVxuICAgICAgLy8gbmVjZXNzYXJ5IGRldGFpbHMgaW4gdGhlIFVJLiBXZSB1c2UgdGhlIHNpemUgb2YgdGhpcyBzZXQgdG8gZGV0ZXJtaW5lXG4gICAgICAvLyB3aGV0aGVyIHdlIGhhdmUgcmVhY2hlZCB0aGUgbGltaXQgcHJvdmlkZWQsIHRodXMgZW5zdXJpbmcgdGhhdCBhbGxcbiAgICAgIC8vIHRyYW5zYWN0aW9ucyBvZiBub25jZXMgd2UgaW5jbHVkZSB3aWxsIGJlIHNlbnQgdG8gdGhlIFVJLlxuICAgICAgY29uc3Qgbm9uY2VzID0gbmV3IFNldCgpO1xuICAgICAgY29uc3QgdHhzID0gW107XG4gICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdHJhbnNhY3Rpb24gbGlzdCB3ZSBmaWx0ZXIgZnJvbSBpcyBzb3J0ZWQgYnkgdGltZSBBU0MuXG4gICAgICAvLyBUbyBlbnN1cmUgdGhhdCBmaWx0ZXJlZCByZXN1bHRzIHByZWZlcnMgdGhlIG5ld2VzdCB0cmFuc2FjdGlvbnMgd2VcbiAgICAgIC8vIGl0ZXJhdGUgZnJvbSByaWdodCB0byBsZWZ0LCBpbnNlcnRpbmcgdHJhbnNhY3Rpb25zIGludG8gZnJvbnQgb2YgYSBuZXdcbiAgICAgIC8vIGFycmF5LiBUaGUgb3JpZ2luYWwgb3JkZXIgaXMgcHJlc2VydmVkLCBidXQgd2UgZW5zdXJlIHRoYXQgbmV3ZXN0IHR4c1xuICAgICAgLy8gYXJlIHByZWZlcnJlZC5cbiAgICAgIGZvciAobGV0IGkgPSBmaWx0ZXJlZFRyYW5zYWN0aW9ucy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICBjb25zdCB0eE1ldGEgPSBmaWx0ZXJlZFRyYW5zYWN0aW9uc1tpXTtcbiAgICAgICAgY29uc3QgeyBub25jZSB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgICAgICBpZiAoIW5vbmNlcy5oYXMobm9uY2UpKSB7XG4gICAgICAgICAgaWYgKG5vbmNlcy5zaXplIDwgbGltaXQpIHtcbiAgICAgICAgICAgIG5vbmNlcy5hZGQobm9uY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCB0cmFuc2FjdGlvbiBpbnRvIHRoZSBiZWdpbm5pbmcgb2Ygb3VyIGFycmF5IHRvIGVuc3VyZSB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgb3JkZXIgaXMgcHJlc2VydmVkLlxuICAgICAgICB0eHMudW5zaGlmdCh0eE1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkVHJhbnNhY3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0dXMgb2YgdGhlIFRyYW5zYWN0aW9uTWV0YSB3aXRoIHByb3ZpZGVkIGlkIHRvICdyZWplY3RlZCcuXG4gICAqIEFmdGVyIHNldHRpbmcgdGhlIHN0YXR1cywgdGhlIFRyYW5zYWN0aW9uTWV0YSBpcyBkZWxldGVkIGZyb20gc3RhdGUuXG4gICAqXG4gICAqIFRPRE86IFNob3VsZCB3ZSBzaG93IGhpc3RvcmljYWxseSByZWplY3RlZCB0cmFuc2FjdGlvbnMgc29tZXdoZXJlIGluIHRoZVxuICAgKiBVST8gU2VlbXMgbGlrZSBpdCBjb3VsZCBiZSB2YWx1YWJsZSBmb3IgaW5mb3JtYXRpb24gcHVycG9zZXMuIE9mIGNvdXJzZVxuICAgKiBvbmx5IGFmdGVyIGxpbWl0IGlzc3VlcyBhcmUgcmVkdWNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c1JlamVjdGVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCk7XG4gICAgdGhpcy5fZGVsZXRlVHJhbnNhY3Rpb24odHhJZCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb25NZXRhIHdpdGggcHJvdmlkZWQgaWQgdG8gJ3VuYXBwcm92ZWQnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHRhcmdldCBUcmFuc2FjdGlvbk1ldGEncyBJZFxuICAgKi9cbiAgc2V0VHhTdGF0dXNVbmFwcHJvdmVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3RhdHVzIG9mIHRoZSBUcmFuc2FjdGlvbk1ldGEgd2l0aCBwcm92aWRlZCBpZCB0byAnYXBwcm92ZWQnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHRhcmdldCBUcmFuc2FjdGlvbk1ldGEncyBJZFxuICAgKi9cbiAgc2V0VHhTdGF0dXNBcHByb3ZlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0dXMgb2YgdGhlIFRyYW5zYWN0aW9uTWV0YSB3aXRoIHByb3ZpZGVkIGlkIHRvICdzaWduZWQnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHRhcmdldCBUcmFuc2FjdGlvbk1ldGEncyBJZFxuICAgKi9cbiAgc2V0VHhTdGF0dXNTaWduZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNJR05FRCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb25NZXRhIHdpdGggcHJvdmlkZWQgaWQgdG8gJ3N1Ym1pdHRlZCdcbiAgICogYW5kIHNldHMgdGhlICdzdWJtaXR0ZWRUaW1lJyBwcm9wZXJ0eSB3aXRoIHRoZSBjdXJyZW50IFVuaXggZXBvY2ggdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqL1xuICBzZXRUeFN0YXR1c1N1Ym1pdHRlZCh0eElkKSB7XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICB0eE1ldGEuc3VibWl0dGVkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhLCAndHhTdGF0ZU1hbmFnZXIgLSBhZGQgc3VibWl0dGVkIHRpbWUgc3RhbXAnKTtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0dXMgb2YgdGhlIFRyYW5zYWN0aW9uTWV0YSB3aXRoIHByb3ZpZGVkIGlkIHRvICdjb25maXJtZWQnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHRhcmdldCBUcmFuc2FjdGlvbk1ldGEncyBJZFxuICAgKi9cbiAgc2V0VHhTdGF0dXNDb25maXJtZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkNPTkZJUk1FRCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb25NZXRhIHdpdGggcHJvdmlkZWQgaWQgdG8gJ2Ryb3BwZWQnXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0eElkIC0gdGhlIHRhcmdldCBUcmFuc2FjdGlvbk1ldGEncyBJZFxuICAgKi9cbiAgc2V0VHhTdGF0dXNEcm9wcGVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUUkFOU0FDVElPTl9TVEFUVVNFUy5EUk9QUEVEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3RhdHVzIG9mIHRoZSBUcmFuc2FjdGlvbk1ldGEgd2l0aCBwcm92aWRlZCBpZCB0byAnZmFpbGVkJyBhbmQgcHV0XG4gICAqIHRoZSBlcnJvciBvbiB0aGUgVHJhbnNhY3Rpb25NZXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgdGFyZ2V0IFRyYW5zYWN0aW9uTWV0YSdzIElkXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIGVycm9yIG9iamVjdFxuICAgKi9cbiAgc2V0VHhTdGF0dXNGYWlsZWQodHhJZCwgZXJyKSB7XG4gICAgY29uc3QgZXJyb3IgPSBlcnIgfHwgbmV3IEVycm9yKCdJbnRlcm5hbCBtZXRhbWFzayBmYWlsdXJlJyk7XG5cbiAgICBjb25zdCB0eE1ldGEgPSB0aGlzLmdldFRyYW5zYWN0aW9uKHR4SWQpO1xuICAgIHR4TWV0YS5lcnIgPSB7XG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlPy50b1N0cmluZygpIHx8IGVycm9yLnRvU3RyaW5nKCksXG4gICAgICBycGM6IGVycm9yLnZhbHVlLFxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgIH07XG4gICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbihcbiAgICAgIHR4TWV0YSxcbiAgICAgICd0cmFuc2FjdGlvbnM6dHgtc3RhdGUtbWFuYWdlciNmYWlsIC0gYWRkIGVycm9yJyxcbiAgICApO1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkZBSUxFRCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdHJhbnNhY3Rpb25zIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcyBvbiB0aGUgY3VycmVudCBuZXR3b3JrLFxuICAgKiBwcmVmZXJyaW5nIGNoYWluSWQgZm9yIGNvbXBhcmlzb24gb3ZlciBuZXR3b3JrSWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gaGV4IHN0cmluZyBvZiB0aGUgZnJvbSBhZGRyZXNzIG9uIHRoZSB0eFBhcmFtc1xuICAgKiAgdG8gcmVtb3ZlXG4gICAqL1xuICB3aXBlVHJhbnNhY3Rpb25zKGFkZHJlc3MpIHtcbiAgICAvLyBuZXR3b3JrIG9ubHkgdHhcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuXG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IG9taXRCeShcbiAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICAodHJhbnNhY3Rpb24pID0+XG4gICAgICAgICAgdHJhbnNhY3Rpb24udHhQYXJhbXMuZnJvbSA9PT0gYWRkcmVzcyAmJlxuICAgICAgICAgIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHJhbnNhY3Rpb24sIGNoYWluSWQsIG5ldHdvcmspLFxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIG91dCB0aGUgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgZnJvbSBzdGF0ZVxuICAgKi9cbiAgY2xlYXJVbmFwcHJvdmVkVHhzKCkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zOiBvbWl0QnkoXG4gICAgICAgIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2FjdGlvbnMsXG4gICAgICAgICh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVELFxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vXG4gIC8vICAgICAgICAgICBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICAvKipcbiAgICogVXBkYXRlcyBhIHRyYW5zYWN0aW9uJ3Mgc3RhdHVzIGluIHN0YXRlLCBhbmQgdGhlbiBlbWl0cyBldmVudHMgdGhhdCBhcmVcbiAgICogc3Vic2NyaWJlZCB0byBlbHNld2hlcmUuIFNlZSBiZWxvdyBmb3IgYmVzdCBndWVzc2VzIG9uIHdoZXJlIGFuZCBob3cgdGhlc2VcbiAgICogZXZlbnRzIGFyZSByZWNlaXZlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR4SWQgLSB0aGUgVHJhbnNhY3Rpb25NZXRhIElkXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25TdGF0dXNTdHJpbmd9IHN0YXR1cyAtIHRoZSBzdGF0dXMgdG8gc2V0IG9uIHRoZVxuICAgKiAgVHJhbnNhY3Rpb25NZXRhXG4gICAqIEBlbWl0cyB0eE1ldGEuaWQ6dHhNZXRhLnN0YXR1cyAtIGV2ZXJ5IHRpbWUgYSB0cmFuc2FjdGlvbidzIHN0YXR1cyBjaGFuZ2VzXG4gICAqICB3ZSBlbWl0IHRoZSBjaGFuZ2UgcGFzc2luZyBhbG9uZyB0aGUgaWQuIFRoaXMgZG9lcyBub3QgYXBwZWFyIHRvIGJlIHVzZWRcbiAgICogIG91dHNpZGUgb2YgdGhpcyBmaWxlLCB3aGljaCBvbmx5IGxpc3RlbnMgdG8gdGhpcyB0byB1bnN1YnNjcmliZSBsaXN0ZW5lcnNcbiAgICogIG9mIDpyZWplY3RlZCBhbmQgOnNpZ25lZCBzdGF0dXNlcyB3aGVuIHRoZSBpbnZlcnNlIHN0YXR1cyBjaGFuZ2VzLiBMaWtlbHlcbiAgICogIHNhZmUgdG8gZHJvcC5cbiAgICogQGVtaXRzIHR4OnN0YXR1cy11cGRhdGUgLSBldmVyeSB0aW1lIGEgdHJhbnNhY3Rpb24ncyBzdGF0dXMgY2hhbmdlcyB3ZVxuICAgKiAgZW1pdCB0aGlzIGV2ZW50IGFuZCBwYXNzIHR4SWQgYW5kIHN0YXR1cy4gVGhpcyBldmVudCBpcyBzdWJzY3JpYmVkIHRvIGluXG4gICAqICB0aGUgVHJhbnNhY3Rpb25Db250cm9sbGVyIGFuZCByZS1icm9hZGNhc3QgYnkgdGhlIFRyYW5zYWN0aW9uQ29udHJvbGxlci5cbiAgICogIEl0IGlzIHVzZWQgaW50ZXJuYWxseSB3aXRoaW4gdGhlIFRyYW5zYWN0aW9uQ29udHJvbGxlciB0byB0cnkgYW5kIHVwZGF0ZVxuICAgKiAgcGVuZGluZyB0cmFuc2FjdGlvbnMgb24gZWFjaCBuZXcgYmxvY2sgKGZyb20gYmxvY2tUcmFja2VyKS4gSXQncyBhbHNvXG4gICAqICBzdWJzY3JpYmVkIHRvIGluIG1ldGFtYXNrLWNvbnRyb2xsZXIgdG8gZGlzcGxheSBhIGJyb3dzZXIgbm90aWZpY2F0aW9uIG9uXG4gICAqICBjb25maXJtZWQgb3IgZmFpbGVkIHRyYW5zYWN0aW9ucy5cbiAgICogQGVtaXRzIHR4TWV0YS5pZDpmaW5pc2hlZCAtIFdoZW4gYSB0cmFuc2FjdGlvbiBtb3ZlcyB0byBhIGZpbmlzaGVkIHN0YXRlXG4gICAqICB0aGlzIGV2ZW50IGlzIGVtaXR0ZWQsIHdoaWNoIGlzIHVzZWQgaW4gdGhlIFRyYW5zYWN0aW9uQ29udHJvbGxlciB0byBwYXNzXG4gICAqICBhbG9uZyBkZXRhaWxzIG9mIHRoZSB0cmFuc2FjdGlvbiB0byB0aGUgZGFwcCB0aGF0IHN1Z2dlc3RlZCB0aGVtLiBUaGlzXG4gICAqICBwYXR0ZXJuIGlzIHJlcGxpY2F0ZWQgYWNyb3NzIGFsbCBvZiB0aGUgbWVzc2FnZSBtYW5hZ2VycyBhbmQgY2FuIGxpa2VseVxuICAgKiAgYmUgc3VwcGxlbWVudGVkIG9yIHJlcGxhY2VkIGJ5IHRoZSBBcHByb3ZhbENvbnRyb2xsZXIuXG4gICAqIEBlbWl0cyB1cGRhdGVCYWRnZSAtIFdoZW4gdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgY2hhbmdlcyBpbiBzdGF0ZSxcbiAgICogIHRoZSBiYWRnZSBpbiB0aGUgYnJvd3NlciBleHRlbnNpb24gYmFyIHNob3VsZCBiZSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlXG4gICAqICBudW1iZXIgb2YgcGVuZGluZyB0cmFuc2FjdGlvbnMuIFRoaXMgcGFydGljdWxhciBlbWl0IGRvZXNuJ3QgYXBwZWFyIHRvXG4gICAqICBidWJibGUgdXAgYW55d2hlcmUgdGhhdCBpcyBhY3R1YWxseSB1c2VkLiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgZW1pdHNcbiAgICogIHRoaXMgKmFueXRpbWUgdGhlIHN0YXRlIGNoYW5nZXMqLCBzbyB0aGlzIGlzIHByb2JhYmx5IHN1cGVyZmx1b3VzLlxuICAgKi9cbiAgX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIHN0YXR1cykge1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG5cbiAgICBpZiAoIXR4TWV0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHR4TWV0YS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgIHR4TWV0YSxcbiAgICAgICAgYHR4U3RhdGVNYW5hZ2VyOiBzZXR0aW5nIHN0YXR1cyB0byAke3N0YXR1c31gLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChgJHt0eE1ldGEuaWR9OiR7c3RhdHVzfWAsIHR4SWQpO1xuICAgICAgdGhpcy5lbWl0KGB0eDpzdGF0dXMtdXBkYXRlYCwgdHhJZCwgc3RhdHVzKTtcbiAgICAgIGlmIChcbiAgICAgICAgW1xuICAgICAgICAgIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCxcbiAgICAgICAgICBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCxcbiAgICAgICAgICBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQsXG4gICAgICAgIF0uaW5jbHVkZXMoc3RhdHVzKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW1pdChgJHt0eE1ldGEuaWR9OmZpbmlzaGVkYCwgdHhNZXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBtb3JlIHRyYW5zYWN0aW9ucyBpbnRvIHN0YXRlLiBUaGlzIGlzIG5vdCBpbnRlbmRlZCBmb3JcbiAgICogZXh0ZXJuYWwgdXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uTWV0YVtdfSB0cmFuc2FjdGlvbnMgLSB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgdG8gc2F2ZVxuICAgKi9cbiAgX2FkZFRyYW5zYWN0aW9uc1RvU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5yZWR1Y2UoKHJlc3VsdCwgbmV3VHgpID0+IHtcbiAgICAgICAgcmVzdWx0W25ld1R4LmlkXSA9IG5ld1R4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnRyYW5zYWN0aW9ucyksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlcyBvbmUgdHJhbnNhY3Rpb24gZnJvbSBzdGF0ZS4gVGhpcyBpcyBub3QgaW50ZW5kZWQgZm9yIGV4dGVybmFsIHVzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFRyYW5zYWN0aW9uSWQgLSB0aGUgdHJhbnNhY3Rpb24gdG8gZGVsZXRlXG4gICAqL1xuICBfZGVsZXRlVHJhbnNhY3Rpb24odGFyZ2V0VHJhbnNhY3Rpb25JZCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgZGVsZXRlIHRyYW5zYWN0aW9uc1t0YXJnZXRUcmFuc2FjdGlvbklkXTtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmVzIG11bHRpcGxlIHRyYW5zYWN0aW9uIGZyb20gc3RhdGUuIFRoaXMgaXMgbm90IGludGVuZGVkIGZvciBleHRlcm5hbCB1c2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHRhcmdldFRyYW5zYWN0aW9uSWRzIC0gdGhlIHRyYW5zYWN0aW9ucyB0byBkZWxldGVcbiAgICovXG4gIF9kZWxldGVUcmFuc2FjdGlvbnModGFyZ2V0VHJhbnNhY3Rpb25JZHMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHRhcmdldFRyYW5zYWN0aW9uSWRzLmZvckVhY2goKHRyYW5zYWN0aW9uSWQpID0+IHtcbiAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZF07XG4gICAgfSk7XG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnc2FmZS1ldmVudC1lbWl0dGVyJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aGpzLXF1ZXJ5JztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbi8qKlxuXG4gIEV2ZW50IGVtaXR0ZXIgdXRpbGl0eSBjbGFzcyBmb3IgdHJhY2tpbmcgdGhlIHRyYW5zYWN0aW9ucyBhcyB0aGV5PGJyPlxuICBnbyBmcm9tIGEgcGVuZGluZyBzdGF0ZSB0byBhIGNvbmZpcm1lZCAobWluZWQgaW4gYSBibG9jaykgc3RhdGU8YnI+XG48YnI+XG4gIEFzIHdlbGwgYXMgY29udGludWVzIGJyb2FkY2FzdCB3aGlsZSBpbiB0aGUgcGVuZGluZyBzdGF0ZVxuPGJyPlxuQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIG5vbiBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCBjb25zaXN0cyBvZjpcbiAgICBAcGFyYW0ge09iamVjdH0gY29uZmlnLnByb3ZpZGVyIC0gQSBuZXR3b3JrIHByb3ZpZGVyLlxuICAgIEBwYXJhbSB7T2JqZWN0fSBjb25maWcubm9uY2VUcmFja2VyIC0gc2VlIG5vbmNlIHRyYWNrZXJcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyAtIGEgZnVuY3Rpb24gZm9yIGdldHRpbmcgYW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLFxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5wdWJsaXNoVHJhbnNhY3Rpb24gLSBhIGFzeW5jIGZ1bmN0aW9uIGZvciBwdWJsaXNoaW5nIHJhdyB0cmFuc2FjdGlvbnMsXG5cbkBjbGFzc1xuKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVuZGluZ1RyYW5zYWN0aW9uVHJhY2tlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBXZSB3YWl0IHRoaXMgbWFueSBibG9ja3MgYmVmb3JlIGVtaXR0aW5nIGEgJ3R4OmRyb3BwZWQnIGV2ZW50XG4gICAqXG4gICAqIFRoaXMgaXMgYmVjYXVzZSB3ZSBjb3VsZCBiZSB0YWxraW5nIHRvIGEgbm9kZSB0aGF0IGlzIG91dCBvZiBzeW5jLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgRFJPUFBFRF9CVUZGRVJfQ09VTlQgPSAzO1xuXG4gIC8qKlxuICAgKiBBIG1hcCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMgdG8gdGhlIG51bWJlciBvZiBibG9ja3Mgd2UndmUgc2VlblxuICAgKiBzaW5jZSBmaXJzdCBjb25zaWRlcmluZyBpdCBkcm9wcGVkXG4gICAqXG4gICAqIEB0eXBlIHtNYXA8U3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgZHJvcHBlZEJsb2Nrc0J1ZmZlckJ5SGFzaCA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucXVlcnkgPSBjb25maWcucXVlcnkgfHwgbmV3IEV0aFF1ZXJ5KGNvbmZpZy5wcm92aWRlcik7XG4gICAgdGhpcy5ub25jZVRyYWNrZXIgPSBjb25maWcubm9uY2VUcmFja2VyO1xuICAgIHRoaXMuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyA9IGNvbmZpZy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zO1xuICAgIHRoaXMuZ2V0Q29tcGxldGVkVHJhbnNhY3Rpb25zID0gY29uZmlnLmdldENvbXBsZXRlZFRyYW5zYWN0aW9ucztcbiAgICB0aGlzLnB1Ymxpc2hUcmFuc2FjdGlvbiA9IGNvbmZpZy5wdWJsaXNoVHJhbnNhY3Rpb247XG4gICAgdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24gPSBjb25maWcuYXBwcm92ZVRyYW5zYWN0aW9uO1xuICAgIHRoaXMuY29uZmlybVRyYW5zYWN0aW9uID0gY29uZmlnLmNvbmZpcm1UcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgIGNoZWNrcyB0aGUgbmV0d29yayBmb3Igc2lnbmVkIHR4cyBhbmQgcmVsZWFzZXMgdGhlIG5vbmNlIGdsb2JhbCBsb2NrIGlmIGl0IGlzXG4gICovXG4gIGFzeW5jIHVwZGF0ZVBlbmRpbmdUeHMoKSB7XG4gICAgLy8gaW4gb3JkZXIgdG8ga2VlcCB0aGUgbm9uY2VUcmFja2VyIGFjY3VyYXRlIHdlIGJsb2NrIGl0IHdoaWxlIHVwZGF0aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zXG4gICAgY29uc3Qgbm9uY2VHbG9iYWxMb2NrID0gYXdhaXQgdGhpcy5ub25jZVRyYWNrZXIuZ2V0R2xvYmFsTG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwZW5kaW5nVHhzID0gdGhpcy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgcGVuZGluZ1R4cy5tYXAoKHR4TWV0YSkgPT4gdGhpcy5fY2hlY2tQZW5kaW5nVHgodHhNZXRhKSksXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmVycm9yKFxuICAgICAgICAnUGVuZGluZ1RyYW5zYWN0aW9uVHJhY2tlciAtIEVycm9yIHVwZGF0aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zJyxcbiAgICAgICk7XG4gICAgICBsb2cuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgbm9uY2VHbG9iYWxMb2NrLnJlbGVhc2VMb2NrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdWJtaXRzIGVhY2ggcGVuZGluZyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tOdW1iZXIgLSB0aGUgbGF0ZXN0IGJsb2NrIG51bWJlciBpbiBoZXhcbiAgICogQGVtaXRzIHR4Ondhcm5pbmdcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyByZXN1Ym1pdFBlbmRpbmdUeHMoYmxvY2tOdW1iZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCk7XG4gICAgaWYgKCFwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR4TWV0YSBvZiBwZW5kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZXN1Ym1pdFR4KHR4TWV0YSwgYmxvY2tOdW1iZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgZXJyLnZhbHVlPy5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpIHx8IGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGlzS25vd25UeCA9XG4gICAgICAgICAgLy8gZ2V0aFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygncmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWQnKSB8fFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygna25vd24gdHJhbnNhY3Rpb24nKSB8fFxuICAgICAgICAgIC8vIHBhcml0eVxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnZ2FzIHByaWNlIHRvbyBsb3cgdG8gcmVwbGFjZScpIHx8XG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFxuICAgICAgICAgICAgJ3RyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZCcsXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgIC8vIG90aGVyXG4gICAgICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdnYXRld2F5IHRpbWVvdXQnKSB8fFxuICAgICAgICAgIGVycm9yTWVzc2FnZS5pbmNsdWRlcygnbm9uY2UgdG9vIGxvdycpO1xuICAgICAgICAvLyBpZ25vcmUgcmVzdWJtaXQgd2FybmluZ3MsIHJldHVybiBlYXJseVxuICAgICAgICBpZiAoaXNLbm93blR4KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuY291bnRlcmVkIHJlYWwgZXJyb3IgLSB0cmFuc2l0aW9uIHRvIGVycm9yIHN0YXRlXG4gICAgICAgIHR4TWV0YS53YXJuaW5nID0ge1xuICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgbWVzc2FnZTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGVuIHJlc3VibWl0dGluZyB0aGlzIHRyYW5zYWN0aW9uLicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdCgndHg6d2FybmluZycsIHR4TWV0YSwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVzdWJtaXQgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgKlxuICAgKiBXaWxsIG9ubHkgYXR0ZW1wdCB0byByZXRyeSB0aGUgZ2l2ZW4gdHggZXZlcnkge0Bjb2RlIDIqKih0eE1ldGEucmV0cnlDb3VudCl9IGJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0cmFuc2FjdGlvbiBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0ZXN0QmxvY2tOdW1iZXIgLSB0aGUgbGF0ZXN0IGJsb2NrIG51bWJlciBpbiBoZXhcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nfHVuZGVmaW5lZD59IHRoZSB0eCBoYXNoIGlmIHJldHJpZWRcbiAgICogQGVtaXRzIHR4OmJsb2NrLXVwZGF0ZVxuICAgKiBAZW1pdHMgdHg6cmV0cnlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9yZXN1Ym1pdFR4KHR4TWV0YSwgbGF0ZXN0QmxvY2tOdW1iZXIpIHtcbiAgICBpZiAoIXR4TWV0YS5maXJzdFJldHJ5QmxvY2tOdW1iZXIpIHtcbiAgICAgIHRoaXMuZW1pdCgndHg6YmxvY2stdXBkYXRlJywgdHhNZXRhLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RSZXRyeUJsb2NrTnVtYmVyID1cbiAgICAgIHR4TWV0YS5maXJzdFJldHJ5QmxvY2tOdW1iZXIgfHwgbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgY29uc3QgdHhCbG9ja0Rpc3RhbmNlID1cbiAgICAgIE51bWJlci5wYXJzZUludChsYXRlc3RCbG9ja051bWJlciwgMTYpIC1cbiAgICAgIE51bWJlci5wYXJzZUludChmaXJzdFJldHJ5QmxvY2tOdW1iZXIsIDE2KTtcblxuICAgIGNvbnN0IHJldHJ5Q291bnQgPSB0eE1ldGEucmV0cnlDb3VudCB8fCAwO1xuXG4gICAgLy8gRXhwb25lbnRpYWwgYmFja29mZiB0byBsaW1pdCByZXRyaWVzIGF0IHB1Ymxpc2hpbmcgKGNhcHBlZCBhdCB+MTUgbWludXRlcyBiZXR3ZWVuIHJldHJpZXMpXG4gICAgaWYgKHR4QmxvY2tEaXN0YW5jZSA8IE1hdGgubWluKDUwLCBNYXRoLnBvdygyLCByZXRyeUNvdW50KSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gT25seSBhdXRvLXN1Ym1pdCBhbHJlYWR5LXNpZ25lZCB0eHM6XG4gICAgaWYgKCEoJ3Jhd1R4JyBpbiB0eE1ldGEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24odHhNZXRhLmlkKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJhd1R4IH0gPSB0eE1ldGE7XG4gICAgY29uc3QgdHhIYXNoID0gYXdhaXQgdGhpcy5wdWJsaXNoVHJhbnNhY3Rpb24ocmF3VHgpO1xuXG4gICAgLy8gSW5jcmVtZW50IHN1Y2Nlc3NmdWwgdHJpZXM6XG4gICAgdGhpcy5lbWl0KCd0eDpyZXRyeScsIHR4TWV0YSk7XG4gICAgcmV0dXJuIHR4SGFzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSB0aGUgbmV0d29yayB0byBzZWUgaWYgdGhlIGdpdmVuIHtAY29kZSB0eE1ldGF9IGhhcyBiZWVuIGluY2x1ZGVkIGluIGEgYmxvY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0cmFuc2FjdGlvbiBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICogQGVtaXRzIHR4OmNvbmZpcm1lZFxuICAgKiBAZW1pdHMgdHg6ZHJvcHBlZFxuICAgKiBAZW1pdHMgdHg6ZmFpbGVkXG4gICAqIEBlbWl0cyB0eDp3YXJuaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGFzeW5jIF9jaGVja1BlbmRpbmdUeCh0eE1ldGEpIHtcbiAgICBjb25zdCB0eEhhc2ggPSB0eE1ldGEuaGFzaDtcbiAgICBjb25zdCB0eElkID0gdHhNZXRhLmlkO1xuXG4gICAgLy8gT25seSBjaGVjayBzdWJtaXR0ZWQgdHhzXG4gICAgaWYgKHR4TWV0YS5zdGF0dXMgIT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dHJhIGNoZWNrIGluIGNhc2UgdGhlcmUgd2FzIGFuIHVuY2F1Z2h0IGVycm9yIGR1cmluZyB0aGVcbiAgICAvLyBzaWduYXR1cmUgYW5kIHN1Ym1pc3Npb24gcHJvY2Vzc1xuICAgIGlmICghdHhIYXNoKSB7XG4gICAgICBjb25zdCBub1R4SGFzaEVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ1dlIGhhZCBhbiBlcnJvciB3aGlsZSBzdWJtaXR0aW5nIHRoaXMgdHJhbnNhY3Rpb24sIHBsZWFzZSB0cnkgYWdhaW4uJyxcbiAgICAgICk7XG4gICAgICBub1R4SGFzaEVyci5uYW1lID0gJ05vVHhIYXNoRXJyb3InO1xuICAgICAgdGhpcy5lbWl0KCd0eDpmYWlsZWQnLCB0eElkLCBub1R4SGFzaEVycik7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgdGhpcy5fY2hlY2tJZk5vbmNlSXNUYWtlbih0eE1ldGEpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3R4OmRyb3BwZWQnLCB0eElkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25SZWNlaXB0ID0gYXdhaXQgdGhpcy5xdWVyeS5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgIGlmICh0cmFuc2FjdGlvblJlY2VpcHQ/LmJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBiYXNlRmVlUGVyR2FzLFxuICAgICAgICAgIHRpbWVzdGFtcDogYmxvY2tUaW1lc3RhbXAsXG4gICAgICAgIH0gPSBhd2FpdCB0aGlzLnF1ZXJ5LmdldEJsb2NrQnlIYXNoKFxuICAgICAgICAgIHRyYW5zYWN0aW9uUmVjZWlwdD8uYmxvY2tIYXNoLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAndHg6Y29uZmlybWVkJyxcbiAgICAgICAgICB0eElkLFxuICAgICAgICAgIHRyYW5zYWN0aW9uUmVjZWlwdCxcbiAgICAgICAgICBiYXNlRmVlUGVyR2FzLFxuICAgICAgICAgIGJsb2NrVGltZXN0YW1wLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0eE1ldGEud2FybmluZyA9IHtcbiAgICAgICAgZXJyb3I6IGVyci5tZXNzYWdlLFxuICAgICAgICBtZXNzYWdlOiAnVGhlcmUgd2FzIGEgcHJvYmxlbSBsb2FkaW5nIHRoaXMgdHJhbnNhY3Rpb24uJyxcbiAgICAgIH07XG4gICAgICB0aGlzLmVtaXQoJ3R4Ondhcm5pbmcnLCB0eE1ldGEsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IHRoaXMuX2NoZWNrSWZUeFdhc0Ryb3BwZWQodHhNZXRhKSkge1xuICAgICAgdGhpcy5lbWl0KCd0eDpkcm9wcGVkJywgdHhJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBub25jZSBpbiB0aGUgZ2l2ZW4ge0Bjb2RlIHR4TWV0YX0gaXMgYmVoaW5kIHRoZSBuZXR3b3JrIG5vbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSB0aGUgdHJhbnNhY3Rpb24gbWV0YWRhdGFcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfY2hlY2tJZlR4V2FzRHJvcHBlZCh0eE1ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBoYXNoOiB0eEhhc2gsXG4gICAgICB0eFBhcmFtczogeyBub25jZSwgZnJvbSB9LFxuICAgIH0gPSB0eE1ldGE7XG4gICAgY29uc3QgbmV0d29ya05leHROb25jZSA9IGF3YWl0IHRoaXMucXVlcnkuZ2V0VHJhbnNhY3Rpb25Db3VudChmcm9tKTtcblxuICAgIGlmIChwYXJzZUludChub25jZSwgMTYpID49IG5ldHdvcmtOZXh0Tm9uY2UudG9OdW1iZXIoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kcm9wcGVkQmxvY2tzQnVmZmVyQnlIYXNoLmhhcyh0eEhhc2gpKSB7XG4gICAgICB0aGlzLmRyb3BwZWRCbG9ja3NCdWZmZXJCeUhhc2guc2V0KHR4SGFzaCwgMCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEJsb2NrQnVmZmVyID0gdGhpcy5kcm9wcGVkQmxvY2tzQnVmZmVyQnlIYXNoLmdldCh0eEhhc2gpO1xuXG4gICAgaWYgKGN1cnJlbnRCbG9ja0J1ZmZlciA8IHRoaXMuRFJPUFBFRF9CVUZGRVJfQ09VTlQpIHtcbiAgICAgIHRoaXMuZHJvcHBlZEJsb2Nrc0J1ZmZlckJ5SGFzaC5zZXQodHhIYXNoLCBjdXJyZW50QmxvY2tCdWZmZXIgKyAxKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRyb3BwZWRCbG9ja3NCdWZmZXJCeUhhc2guZGVsZXRlKHR4SGFzaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIG5vbmNlIGluIHRoZSBnaXZlbiB7QGNvZGUgdHhNZXRhfSBpcyBjb3JyZWN0IGFnYWluc3QgdGhlIGxvY2FsIHNldCBvZiB0cmFuc2FjdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IHR4TWV0YSAtIHRoZSB0cmFuc2FjdGlvbiBtZXRhZGF0YVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9jaGVja0lmTm9uY2VJc1Rha2VuKHR4TWV0YSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSB0eE1ldGEudHhQYXJhbXMuZnJvbTtcbiAgICBjb25zdCBjb21wbGV0ZWQgPSB0aGlzLmdldENvbXBsZXRlZFRyYW5zYWN0aW9ucyhhZGRyZXNzKTtcbiAgICByZXR1cm4gY29tcGxldGVkLnNvbWUoXG4gICAgICAvLyBUaGlzIGlzIGNhbGxlZCB3aGlsZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW4tZmxpZ2h0LCBzbyBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZVxuICAgICAgLy8gbGlzdCBvZiBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zIG5vdyBpbmNsdWRlcyB0aGUgdHJhbnNhY3Rpb24gd2Ugd2VyZSBsb29raW5nIGF0XG4gICAgICAvLyBhbmQgaWYgdGhhdCBpcyB0aGUgY2FzZSwgZG9uJ3QgY29uc2lkZXIgdGhlIHRyYW5zYWN0aW9uIHRvIGhhdmUgdGFrZW4gaXRzIG93biBub25jZVxuICAgICAgKG90aGVyKSA9PlxuICAgICAgICAhKG90aGVyLmlkID09PSB0eE1ldGEuaWQpICYmXG4gICAgICAgIG90aGVyLnR4UGFyYW1zLm5vbmNlID09PSB0eE1ldGEudHhQYXJhbXMubm9uY2UsXG4gICAgKTtcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IFdBTExFVF9QUkVGSVggPSAnd2FsbGV0Xyc7XG5cbmV4cG9ydCBjb25zdCBOT1RJRklDQVRJT05fTkFNRVMgPSB7XG4gIGFjY291bnRzQ2hhbmdlZDogJ21ldGFtYXNrX2FjY291bnRzQ2hhbmdlZCcsXG4gIHVubG9ja1N0YXRlQ2hhbmdlZDogJ21ldGFtYXNrX3VubG9ja1N0YXRlQ2hhbmdlZCcsXG4gIGNoYWluQ2hhbmdlZDogJ21ldGFtYXNrX2NoYWluQ2hhbmdlZCcsXG59O1xuXG5leHBvcnQgY29uc3QgTE9HX0lHTk9SRV9NRVRIT0RTID0gW1xuICAnd2FsbGV0X3JlZ2lzdGVyT25ib2FyZGluZycsXG4gICd3YWxsZXRfd2F0Y2hBc3NldCcsXG5dO1xuXG5leHBvcnQgY29uc3QgTE9HX01FVEhPRF9UWVBFUyA9IHtcbiAgcmVzdHJpY3RlZDogJ3Jlc3RyaWN0ZWQnLFxuICBpbnRlcm5hbDogJ2ludGVybmFsJyxcbn07XG5cbi8qKlxuICogVGhlIHBlcm1pc3Npb24gYWN0aXZpdHkgbG9nIHNpemUgbGltaXQuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0dfTElNSVQgPSAxMDA7XG4iLCJpbXBvcnQge1xuICBDYXZlYXRUeXBlcyxcbiAgUmVzdHJpY3RlZE1ldGhvZHMsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvcGVybWlzc2lvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVybWlzc2lvbkJhY2tncm91bmRBcGlNZXRob2RzKHBlcm1pc3Npb25Db250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgYWRkUGVybWl0dGVkQWNjb3VudDogKG9yaWdpbiwgYWNjb3VudCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBwZXJtaXNzaW9uQ29udHJvbGxlci5nZXRDYXZlYXQoXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgUmVzdHJpY3RlZE1ldGhvZHMuZXRoX2FjY291bnRzLFxuICAgICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMsXG4gICAgICApO1xuXG4gICAgICBpZiAoZXhpc3RpbmcudmFsdWUuaW5jbHVkZXMoYWNjb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBldGhfYWNjb3VudHMgcGVybWlzc2lvbiBmb3Igb3JpZ2luIFwiJHtvcmlnaW59XCIgYWxyZWFkeSBwZXJtaXRzIGFjY291bnQgXCIke2FjY291bnR9XCIuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlQ2F2ZWF0KFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcbiAgICAgICAgQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuICAgICAgICBbLi4uZXhpc3RpbmcudmFsdWUsIGFjY291bnRdLFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlUGVybWl0dGVkQWNjb3VudDogKG9yaWdpbiwgYWNjb3VudCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBwZXJtaXNzaW9uQ29udHJvbGxlci5nZXRDYXZlYXQoXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgUmVzdHJpY3RlZE1ldGhvZHMuZXRoX2FjY291bnRzLFxuICAgICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMsXG4gICAgICApO1xuXG4gICAgICBpZiAoIWV4aXN0aW5nLnZhbHVlLmluY2x1ZGVzKGFjY291bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgZXRoX2FjY291bnRzIHBlcm1pc3Npb24gZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGFscmVhZHkgZG9lcyBub3QgcGVybWl0IGFjY291bnQgXCIke2FjY291bnR9XCIuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVtYWluaW5nQWNjb3VudHMgPSBleGlzdGluZy52YWx1ZS5maWx0ZXIoXG4gICAgICAgIChleGlzdGluZ0FjY291bnQpID0+IGV4aXN0aW5nQWNjb3VudCAhPT0gYWNjb3VudCxcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZW1haW5pbmdBY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIucmV2b2tlUGVybWlzc2lvbihcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgUmVzdHJpY3RlZE1ldGhvZHMuZXRoX2FjY291bnRzLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlQ2F2ZWF0KFxuICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXG4gICAgICAgICAgQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuICAgICAgICAgIHJlbWFpbmluZ0FjY291bnRzLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uV2l0aElkOiBhc3luYyAob3JpZ2luKSA9PiB7XG4gICAgICBjb25zdCBbLCB7IGlkIH1dID0gYXdhaXQgcGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zKFxuICAgICAgICB7IG9yaWdpbiB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXRoX2FjY291bnRzOiB7fSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgQ2F2ZWF0VHlwZXMgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3Blcm1pc3Npb25zJztcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgc2VsZWN0b3JzIGZvciBQZXJtaXNzaW9uQ29udHJvbGxlciBzZWxlY3RvciBldmVudFxuICogc3Vic2NyaXB0aW9ucywgdXNlZCB0byBkZXRlY3Qgd2hlbmV2ZXIgYSBzdWJqZWN0J3MgYWNjb3VudHMgY2hhbmdlIHNvIHRoYXRcbiAqIHdlIGNhbiBub3RpZnkgdGhlIHN1YmplY3QgdmlhIHRoZSBgYWNjb3VudHNDaGFuZ2VkYCBwcm92aWRlciBldmVudC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+fSBzdGF0ZSAtIFRoZVxuICogUGVybWlzc2lvbkNvbnRyb2xsZXIgc3RhdGUuXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IFRoZSBQZXJtaXNzaW9uQ29udHJvbGxlciBzdWJqZWN0cy5cbiAqL1xuY29uc3QgZ2V0U3ViamVjdHMgPSAoc3RhdGUpID0+IHN0YXRlLnN1YmplY3RzO1xuXG4vKipcbiAqIEdldCB0aGUgcGVybWl0dGVkIGFjY291bnRzIGZvciBlYWNoIHN1YmplY3QsIGtleWVkIGJ5IG9yaWdpbi5cbiAqIFRoZSB2YWx1ZXMgb2YgdGhlIHJldHVybmVkIG1hcCBhcmUgaW1tdXRhYmxlIHZhbHVlcyBmcm9tIHRoZVxuICogUGVybWlzc2lvbkNvbnRyb2xsZXIgc3RhdGUuXG4gKlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZ1tdPn0gVGhlIGN1cnJlbnQgb3JpZ2luOmFjY291bnRzW10gbWFwLlxuICovXG5leHBvcnQgY29uc3QgZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbiA9IGNyZWF0ZVNlbGVjdG9yKFxuICBnZXRTdWJqZWN0cyxcbiAgKHN1YmplY3RzKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3ViamVjdHMpLnJlZHVjZSgob3JpZ2luVG9BY2NvdW50c01hcCwgc3ViamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2F2ZWF0ID0gc3ViamVjdC5wZXJtaXNzaW9ucz8uZXRoX2FjY291bnRzPy5jYXZlYXRzLmZpbmQoXG4gICAgICAgICh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuICAgICAgKTtcblxuICAgICAgaWYgKGNhdmVhdCkge1xuICAgICAgICBvcmlnaW5Ub0FjY291bnRzTWFwLnNldChzdWJqZWN0Lm9yaWdpbiwgY2F2ZWF0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5Ub0FjY291bnRzTWFwO1xuICAgIH0sIG5ldyBNYXAoKSk7XG4gIH0sXG4pO1xuXG4vKipcbiAqIEdpdmVuIHRoZSBjdXJyZW50IGFuZCBwcmV2aW91cyBleHBvc2VkIGFjY291bnRzIGZvciBlYWNoIFBlcm1pc3Npb25Db250cm9sbGVyXG4gKiBzdWJqZWN0LCByZXR1cm5zIGEgbmV3IG1hcCBjb250YWluaW5nIGFsbCBhY2NvdW50cyB0aGF0IGhhdmUgY2hhbmdlZC5cbiAqIFRoZSB2YWx1ZXMgb2YgZWFjaCBtYXAgbXVzdCBiZSBpbW11dGFibGUgdmFsdWVzIGRpcmVjdGx5IGZyb20gdGhlXG4gKiBQZXJtaXNzaW9uQ29udHJvbGxlciBzdGF0ZSwgb3IgYW4gZW1wdHkgYXJyYXkgaW5zdGFudGlhdGVkIGluIHRoaXNcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgc3RyaW5nW10+fSBuZXdBY2NvdW50c01hcCAtIFRoZSBuZXcgb3JpZ2luOmFjY291bnRzW10gbWFwLlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmdbXT59IFtwcmV2aW91c0FjY291bnRzTWFwXSAtIFRoZSBwcmV2aW91cyBvcmlnaW46YWNjb3VudHNbXSBtYXAuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nW10+fSBUaGUgb3JpZ2luOmFjY291bnRzW10gbWFwIG9mIGNoYW5nZWQgYWNjb3VudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDaGFuZ2VkQWNjb3VudHMgPSAobmV3QWNjb3VudHNNYXAsIHByZXZpb3VzQWNjb3VudHNNYXApID0+IHtcbiAgaWYgKHByZXZpb3VzQWNjb3VudHNNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXdBY2NvdW50c01hcDtcbiAgfVxuXG4gIGNvbnN0IGNoYW5nZWRBY2NvdW50cyA9IG5ldyBNYXAoKTtcbiAgaWYgKG5ld0FjY291bnRzTWFwID09PSBwcmV2aW91c0FjY291bnRzTWFwKSB7XG4gICAgcmV0dXJuIGNoYW5nZWRBY2NvdW50cztcbiAgfVxuXG4gIGNvbnN0IG5ld09yaWdpbnMgPSBuZXcgU2V0KFsuLi5uZXdBY2NvdW50c01hcC5rZXlzKCldKTtcblxuICBmb3IgKGNvbnN0IG9yaWdpbiBvZiBwcmV2aW91c0FjY291bnRzTWFwLmtleXMoKSkge1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gbmV3QWNjb3VudHNNYXAuZ2V0KG9yaWdpbikgPz8gW107XG5cbiAgICAvLyBUaGUgdmFsdWVzIG9mIHRoZXNlIG1hcHMgYXJlIHJlZmVyZW5jZXMgdG8gaW1tdXRhYmxlIHZhbHVlcywgd2hpY2ggaXMgd2h5XG4gICAgLy8gYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgaXMgZW5vdWdoIGZvciBkaWZmaW5nLiBUaGUgdmFsdWVzIGFyZSBlaXRoZXIgZnJvbVxuICAgIC8vIFBlcm1pc3Npb25Db250cm9sbGVyIHN0YXRlLCBvciBhbiBlbXB0eSBhcnJheSBpbml0aWFsaXplZCBpbiB0aGUgcHJldmlvdXNcbiAgICAvLyBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uIGBuZXdBY2NvdW50c01hcGAgd2lsbCBuZXZlciBjb250YWluIGFueSBlbXB0eVxuICAgIC8vIGFycmF5cy5cbiAgICBpZiAocHJldmlvdXNBY2NvdW50c01hcC5nZXQob3JpZ2luKSAhPT0gbmV3QWNjb3VudHMpIHtcbiAgICAgIGNoYW5nZWRBY2NvdW50cy5zZXQob3JpZ2luLCBuZXdBY2NvdW50cyk7XG4gICAgfVxuXG4gICAgbmV3T3JpZ2lucy5kZWxldGUob3JpZ2luKTtcbiAgfVxuXG4gIC8vIEJ5IG5vdywgbmV3T3JpZ2lucyBpcyBlaXRoZXIgZW1wdHkgb3IgY29udGFpbnMgc29tZSBudW1iZXIgb2YgcHJldmlvdXNseVxuICAvLyB1bmVuY291bnRlcmVkIG9yaWdpbnMsIGFuZCBhbGwgb2YgdGhlaXIgYWNjb3VudHMgaGF2ZSBcImNoYW5nZWRcIi5cbiAgZm9yIChjb25zdCBvcmlnaW4gb2YgbmV3T3JpZ2lucy5rZXlzKCkpIHtcbiAgICBjaGFuZ2VkQWNjb3VudHMuc2V0KG9yaWdpbiwgbmV3QWNjb3VudHNNYXAuZ2V0KG9yaWdpbikpO1xuICB9XG4gIHJldHVybiBjaGFuZ2VkQWNjb3VudHM7XG59O1xuIiwiaW1wb3J0IHsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiB9IGZyb20gJ0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzJztcbmltcG9ydCB7IENhdmVhdFR5cGVzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucyc7XG5cbi8qKlxuICogRmFjdG9yaWVzIHRoYXQgY29uc3RydWN0IGNhdmVhdCBtdXRhdG9yIGZ1bmN0aW9ucyB0aGF0IGFyZSBwYXNzZWQgdG9cbiAqIFBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQuXG4gKi9cbmV4cG9ydCBjb25zdCBDYXZlYXRNdXRhdG9yRmFjdG9yaWVzID0ge1xuICBbQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzXToge1xuICAgIHJlbW92ZUFjY291bnQsXG4gIH0sXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRhcmdldCBhY2NvdW50IGZyb20gdGhlIHZhbHVlIGFycmF5cyBvZiBhbGxcbiAqIGByZXN0cmljdFJldHVybmVkQWNjb3VudHNgIGNhdmVhdHMuIE5vLW9wcyBpZiB0aGUgdGFyZ2V0IGFjY291bnQgaXMgbm90IGluXG4gKiB0aGUgYXJyYXksIGFuZCByZXZva2VzIHRoZSBwYXJlbnQgcGVybWlzc2lvbiBpZiBpdCdzIHRoZSBvbmx5IGFjY291bnQgaW5cbiAqIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0QWNjb3VudCAtIFRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIHJlbW92ZSBmcm9tXG4gKiBhbGwgYWNjb3VudHMgcGVybWlzc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGlzdGluZ0FjY291bnRzIC0gVGhlIGFjY291bnQgYWRkcmVzcyBhcnJheSBmcm9tIHRoZVxuICogYWNjb3VudCBwZXJtaXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQWNjb3VudCh0YXJnZXRBY2NvdW50LCBleGlzdGluZ0FjY291bnRzKSB7XG4gIGNvbnN0IG5ld0FjY291bnRzID0gZXhpc3RpbmdBY2NvdW50cy5maWx0ZXIoXG4gICAgKGFkZHJlc3MpID0+IGFkZHJlc3MgIT09IHRhcmdldEFjY291bnQsXG4gICk7XG5cbiAgaWYgKG5ld0FjY291bnRzLmxlbmd0aCA9PT0gZXhpc3RpbmdBY2NvdW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4geyBvcGVyYXRpb246IENhdmVhdE11dGF0b3JPcGVyYXRpb24ubm9vcCB9O1xuICB9IGVsc2UgaWYgKG5ld0FjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0aW9uOiBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnVwZGF0ZVZhbHVlLFxuICAgICAgdmFsdWU6IG5ld0FjY291bnRzLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgb3BlcmF0aW9uOiBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLnJldm9rZVBlcm1pc3Npb24gfTtcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdmYXN0LXNhZmUtc3RyaW5naWZ5JztcbmltcG9ydCB7IENhdmVhdFR5cGVzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucyc7XG5pbXBvcnQge1xuICBMT0dfSUdOT1JFX01FVEhPRFMsXG4gIExPR19MSU1JVCxcbiAgTE9HX01FVEhPRF9UWVBFUyxcbiAgV0FMTEVUX1BSRUZJWCxcbn0gZnJvbSAnLi9lbnVtcyc7XG5cbi8qKlxuICogQ29udHJvbGxlciB3aXRoIG1pZGRsZXdhcmUgZm9yIGxvZ2dpbmcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byByZXN0cmljdGVkXG4gKiBhbmQgcGVybWlzc2lvbnMtcmVsYXRlZCBtZXRob2RzLlxuICovXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHt7IHJlc3RyaWN0ZWRNZXRob2RzOiBTZXQ8c3RyaW5nPiwgaW5pdFN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB9fSBvcHRpb25zIC0gT3B0aW9ucyBiYWcuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IHJlc3RyaWN0ZWRNZXRob2RzLCBpbml0U3RhdGUgfSkge1xuICAgIHRoaXMucmVzdHJpY3RlZE1ldGhvZHMgPSByZXN0cmljdGVkTWV0aG9kcztcbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZSh7XG4gICAgICBwZXJtaXNzaW9uSGlzdG9yeToge30sXG4gICAgICBwZXJtaXNzaW9uQWN0aXZpdHlMb2c6IFtdLFxuICAgICAgLi4uaW5pdFN0YXRlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzdHJpY3RlZCBtZXRob2QgYWN0aXZpdHkgbG9nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gVGhlIGFjdGl2aXR5IGxvZy5cbiAgICovXG4gIGdldEFjdGl2aXR5TG9nKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKCkucGVybWlzc2lvbkFjdGl2aXR5TG9nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcmVzdHJpY3RlZCBtZXRob2QgYWN0aXZpdHkgbG9nLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGxvZ3MgLSBUaGUgbmV3IGFjdGl2aXR5IGxvZyBhcnJheS5cbiAgICovXG4gIHVwZGF0ZUFjdGl2aXR5TG9nKGxvZ3MpIHtcbiAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgcGVybWlzc2lvbkFjdGl2aXR5TG9nOiBsb2dzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVybWlzc2lvbiBoaXN0b3J5IGxvZy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBlcm1pc3Npb25zIGhpc3RvcnkgbG9nLlxuICAgKi9cbiAgZ2V0SGlzdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLnBlcm1pc3Npb25IaXN0b3J5O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGVybWlzc2lvbiBoaXN0b3J5IGxvZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhpc3RvcnkgLSBUaGUgbmV3IHBlcm1pc3Npb25zIGhpc3RvcnkgbG9nIG9iamVjdC5cbiAgICovXG4gIHVwZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyBwZXJtaXNzaW9uSGlzdG9yeTogaGlzdG9yeSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBleHBvc2VkIGFjY291bnQgaGlzdG9yeSBmb3IgdGhlIGdpdmVuIG9yaWdpbi5cbiAgICogU2V0cyB0aGUgJ2xhc3Qgc2VlbicgdGltZSB0byBEYXRlLm5vdygpIGZvciB0aGUgZ2l2ZW4gYWNjb3VudHMuXG4gICAqIERvZXMgKipub3QqKiB1cGRhdGUgdGhlICdsYXN0QXBwcm92ZWQnIHRpbWUgZm9yIHRoZSBwZXJtaXNzaW9uIGl0c2VsZi5cbiAgICogUmV0dXJucyBpZiB0aGUgYWNjb3VudHMgYXJyYXkgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoYXQgdGhlIGFjY291bnRzIGFyZSBleHBvc2VkIHRvLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFjY291bnRzIC0gVGhlIGFjY291bnRzLlxuICAgKi9cbiAgdXBkYXRlQWNjb3VudHNIaXN0b3J5KG9yaWdpbiwgYWNjb3VudHMpIHtcbiAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudFRvVGltZU1hcCA9IGdldEFjY291bnRUb1RpbWVNYXAoYWNjb3VudHMsIERhdGUubm93KCkpO1xuXG4gICAgdGhpcy5jb21taXROZXdIaXN0b3J5KG9yaWdpbiwge1xuICAgICAgZXRoX2FjY291bnRzOiB7XG4gICAgICAgIGFjY291bnRzOiBhY2NvdW50VG9UaW1lTWFwLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwZXJtaXNzaW9ucyBsb2cgbWlkZGxld2FyZS4gUmVjb3JkcyBwZXJtaXNzaW9ucyBhY3Rpdml0eSBhbmQgaGlzdG9yeTpcbiAgICpcbiAgICogQWN0aXZpdHk6IHJlcXVlc3RzIGFuZCByZXNwb25zZXMgZm9yIHJlc3RyaWN0ZWQgYW5kIG1vc3Qgd2FsbGV0XyBtZXRob2RzLlxuICAgKlxuICAgKiBIaXN0b3J5OiBmb3IgZWFjaCBvcmlnaW4sIHRoZSBsYXN0IHRpbWUgYSBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBpbmNsdWRpbmdcbiAgICogd2hpY2ggYWNjb3VudHMgd2VyZSBleHBvc2VkLCBpZiBhbnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtKc29uUnBjRW5naW5lTWlkZGxld2FyZX0gVGhlIHBlcm1pc3Npb25zIGxvZyBtaWRkbGV3YXJlLlxuICAgKi9cbiAgY3JlYXRlTWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgICBsZXQgYWN0aXZpdHlFbnRyeSwgcmVxdWVzdGVkTWV0aG9kcztcbiAgICAgIGNvbnN0IHsgb3JpZ2luLCBtZXRob2QgfSA9IHJlcTtcbiAgICAgIGNvbnN0IGlzSW50ZXJuYWwgPSBtZXRob2Quc3RhcnRzV2l0aChXQUxMRVRfUFJFRklYKTtcblxuICAgICAgLy8gd2Ugb25seSBsb2cgY2VydGFpbiBtZXRob2RzXG4gICAgICBpZiAoXG4gICAgICAgICFMT0dfSUdOT1JFX01FVEhPRFMuaW5jbHVkZXMobWV0aG9kKSAmJlxuICAgICAgICAoaXNJbnRlcm5hbCB8fCB0aGlzLnJlc3RyaWN0ZWRNZXRob2RzLmhhcyhtZXRob2QpKVxuICAgICAgKSB7XG4gICAgICAgIGFjdGl2aXR5RW50cnkgPSB0aGlzLmxvZ1JlcXVlc3QocmVxLCBpc0ludGVybmFsKTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSBgJHtXQUxMRVRfUFJFRklYfXJlcXVlc3RQZXJtaXNzaW9uc2ApIHtcbiAgICAgICAgICAvLyBnZXQgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcyBmcm9tIHRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMgc29cbiAgICAgICAgICAvLyB0aGF0IHdlIGNhbiByZWNvcmQgcGVybWlzc2lvbnMgaGlzdG9yeVxuICAgICAgICAgIHJlcXVlc3RlZE1ldGhvZHMgPSB0aGlzLmdldFJlcXVlc3RlZE1ldGhvZHMocmVxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdldGhfcmVxdWVzdEFjY291bnRzJykge1xuICAgICAgICAvLyBldGhfcmVxdWVzdEFjY291bnRzIGlzIGEgc3BlY2lhbCBjYXNlOyB3ZSBuZWVkIHRvIGV4dHJhY3QgdGhlIGFjY291bnRzXG4gICAgICAgIC8vIGZyb20gaXRcbiAgICAgICAgYWN0aXZpdHlFbnRyeSA9IHRoaXMubG9nUmVxdWVzdChyZXEsIGlzSW50ZXJuYWwpO1xuICAgICAgICByZXF1ZXN0ZWRNZXRob2RzID0gWydldGhfYWNjb3VudHMnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vLW9wXG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxsIG5leHQgd2l0aCBhIHJldHVybiBoYW5kbGVyIGZvciBjYXB0dXJpbmcgdGhlIHJlc3BvbnNlXG4gICAgICBuZXh0KChjYikgPT4ge1xuICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5sb2dSZXNwb25zZShhY3Rpdml0eUVudHJ5LCByZXMsIHRpbWUpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRNZXRob2RzICYmICFyZXMuZXJyb3IgJiYgcmVzLnJlc3VsdCkge1xuICAgICAgICAgIC8vIGFueSBwZXJtaXNzaW9ucyBvciBhY2NvdW50cyBjaGFuZ2VzIHdpbGwgYmUgcmVjb3JkZWQgb24gdGhlIHJlc3BvbnNlLFxuICAgICAgICAgIC8vIHNvIHdlIG9ubHkgbG9nIHBlcm1pc3Npb25zIGhpc3RvcnkgaGVyZVxuICAgICAgICAgIHRoaXMubG9nUGVybWlzc2lvbnNIaXN0b3J5KFxuICAgICAgICAgICAgcmVxdWVzdGVkTWV0aG9kcyxcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHJlcy5yZXN1bHQsXG4gICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgbWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBjb21taXRzIGFuIGFjdGl2aXR5IGxvZyBlbnRyeSwgd2l0aG91dCByZXNwb25zZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0ludGVybmFsIC0gV2hldGhlciB0aGUgcmVxdWVzdCBpcyBpbnRlcm5hbC5cbiAgICovXG4gIGxvZ1JlcXVlc3QocmVxdWVzdCwgaXNJbnRlcm5hbCkge1xuICAgIGNvbnN0IGFjdGl2aXR5RW50cnkgPSB7XG4gICAgICBpZDogcmVxdWVzdC5pZCxcbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICBtZXRob2RUeXBlOiBpc0ludGVybmFsXG4gICAgICAgID8gTE9HX01FVEhPRF9UWVBFUy5pbnRlcm5hbFxuICAgICAgICA6IExPR19NRVRIT0RfVFlQRVMucmVzdHJpY3RlZCxcbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICByZXF1ZXN0OiBzdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMiksXG4gICAgICByZXF1ZXN0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgIHJlc3BvbnNlOiBudWxsLFxuICAgICAgcmVzcG9uc2VUaW1lOiBudWxsLFxuICAgICAgc3VjY2VzczogbnVsbCxcbiAgICB9O1xuICAgIHRoaXMuY29tbWl0TmV3QWN0aXZpdHkoYWN0aXZpdHlFbnRyeSk7XG4gICAgcmV0dXJuIGFjdGl2aXR5RW50cnk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyByZXNwb25zZSBkYXRhIHRvIGFuIGV4aXN0aW5nIGFjdGl2aXR5IGxvZyBlbnRyeS5cbiAgICogRW50cnkgYXNzdW1lZCBhbHJlYWR5IGNvbW1pdHRlZCAoaS5lLiwgaW4gdGhlIGxvZykuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIFRoZSBlbnRyeSB0byBhZGQgYSByZXNwb25zZSB0by5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBPdXRwdXQgZnJvbSBEYXRlLm5vdygpXG4gICAqL1xuICBsb2dSZXNwb25zZShlbnRyeSwgcmVzcG9uc2UsIHRpbWUpIHtcbiAgICBpZiAoIWVudHJ5IHx8ICFyZXNwb25zZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVudHJ5LnJlc3BvbnNlID0gc3RyaW5naWZ5KHJlc3BvbnNlLCBudWxsLCAyKTtcbiAgICBlbnRyeS5yZXNwb25zZVRpbWUgPSB0aW1lO1xuICAgIGVudHJ5LnN1Y2Nlc3MgPSAhcmVzcG9uc2UuZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQ29tbWl0IGEgbmV3IGVudHJ5IHRvIHRoZSBhY3Rpdml0eSBsb2cuXG4gICAqIFJlbW92ZXMgdGhlIG9sZGVzdCBlbnRyeSBmcm9tIHRoZSBsb2cgaWYgaXQgZXhjZWVkcyB0aGUgbG9nIGxpbWl0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50cnkgLSBUaGUgYWN0aXZpdHkgbG9nIGVudHJ5LlxuICAgKi9cbiAgY29tbWl0TmV3QWN0aXZpdHkoZW50cnkpIHtcbiAgICBjb25zdCBsb2dzID0gdGhpcy5nZXRBY3Rpdml0eUxvZygpO1xuXG4gICAgLy8gYWRkIG5ldyBlbnRyeSB0byBlbmQgb2YgbG9nXG4gICAgbG9ncy5wdXNoKGVudHJ5KTtcblxuICAgIC8vIHJlbW92ZSBvbGRlc3QgbG9nIGlmIGV4Y2VlZGluZyBzaXplIGxpbWl0XG4gICAgaWYgKGxvZ3MubGVuZ3RoID4gTE9HX0xJTUlUKSB7XG4gICAgICBsb2dzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBY3Rpdml0eUxvZyhsb2dzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IHBlcm1pc3Npb25zIGhpc3RvcnkgbG9nIGVudHJpZXMsIGlmIGFueSwgYW5kIGNvbW1pdCB0aGVtLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHJlcXVlc3RlZE1ldGhvZHMgLSBUaGUgbWV0aG9kIG5hbWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHBlcm1pc3Npb25zIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7QXJyYXk8SU9jYXBMZENhcGFiaWxpdHl9IHJlc3VsdCAtIFRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0IHJlc3BvbnNlLnJlc3VsdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWUgLSBUaGUgdGltZSBvZiB0aGUgcmVxdWVzdCwgaS5lLiBEYXRlLm5vdygpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRXRoUmVxdWVzdEFjY291bnRzIC0gV2hldGhlciB0aGUgcGVybWlzc2lvbnMgcmVxdWVzdCB3YXMgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLlxuICAgKi9cbiAgbG9nUGVybWlzc2lvbnNIaXN0b3J5KFxuICAgIHJlcXVlc3RlZE1ldGhvZHMsXG4gICAgb3JpZ2luLFxuICAgIHJlc3VsdCxcbiAgICB0aW1lLFxuICAgIGlzRXRoUmVxdWVzdEFjY291bnRzLFxuICApIHtcbiAgICBsZXQgYWNjb3VudHMsIG5ld0VudHJpZXM7XG5cbiAgICBpZiAoaXNFdGhSZXF1ZXN0QWNjb3VudHMpIHtcbiAgICAgIGFjY291bnRzID0gcmVzdWx0O1xuICAgICAgY29uc3QgYWNjb3VudFRvVGltZU1hcCA9IGdldEFjY291bnRUb1RpbWVNYXAoYWNjb3VudHMsIHRpbWUpO1xuXG4gICAgICBuZXdFbnRyaWVzID0ge1xuICAgICAgICBldGhfYWNjb3VudHM6IHtcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFRvVGltZU1hcCxcbiAgICAgICAgICBsYXN0QXBwcm92ZWQ6IHRpbWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmRzIG5ldyBcImxhc3RBcHByb3ZlZFwiIHRpbWVzIGZvciB0aGUgZ3JhbnRlZCBwZXJtaXNzaW9ucywgaWYgYW55LlxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgZXRoX2FjY291bnRzLCBpbiBvcmRlciB0byByZWNvcmQgdGhlIHRpbWUgdGhlXG4gICAgICAvLyBhY2NvdW50cyB3ZXJlIGxhc3Qgc2VlbiBvciBhcHByb3ZlZCBieSB0aGUgb3JpZ2luLlxuICAgICAgbmV3RW50cmllcyA9IHJlc3VsdFxuICAgICAgICAubWFwKChwZXJtKSA9PiB7XG4gICAgICAgICAgaWYgKHBlcm0ucGFyZW50Q2FwYWJpbGl0eSA9PT0gJ2V0aF9hY2NvdW50cycpIHtcbiAgICAgICAgICAgIGFjY291bnRzID0gdGhpcy5nZXRBY2NvdW50c0Zyb21QZXJtaXNzaW9uKHBlcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwZXJtLnBhcmVudENhcGFiaWxpdHk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgbWV0aG9kKSA9PiB7XG4gICAgICAgICAgLy8gYWxsIGFwcHJvdmVkIHBlcm1pc3Npb25zIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlLFxuICAgICAgICAgIC8vIG5vdCBqdXN0IHRoZSBuZXdseSByZXF1ZXN0ZWQgb25lc1xuICAgICAgICAgIGlmIChyZXF1ZXN0ZWRNZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdldGhfYWNjb3VudHMnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjY291bnRUb1RpbWVNYXAgPSBnZXRBY2NvdW50VG9UaW1lTWFwKGFjY291bnRzLCB0aW1lKTtcblxuICAgICAgICAgICAgICBhY2NbbWV0aG9kXSA9IHtcbiAgICAgICAgICAgICAgICBsYXN0QXBwcm92ZWQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgYWNjb3VudHM6IGFjY291bnRUb1RpbWVNYXAsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY2NbbWV0aG9kXSA9IHsgbGFzdEFwcHJvdmVkOiB0aW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhuZXdFbnRyaWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbW1pdE5ld0hpc3Rvcnkob3JpZ2luLCBuZXdFbnRyaWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tbWl0IG5ldyBlbnRyaWVzIHRvIHRoZSBwZXJtaXNzaW9ucyBoaXN0b3J5IGxvZy5cbiAgICogTWVyZ2VzIHRoZSBoaXN0b3J5IGZvciB0aGUgZ2l2ZW4gb3JpZ2luLCBvdmVyd3JpdGluZyBleGlzdGluZyBlbnRyaWVzXG4gICAqIHdpdGggdGhlIHNhbWUga2V5IChwZXJtaXNzaW9uIG5hbWUpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIHJlcXVlc3Rpbmcgb3JpZ2luLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RW50cmllcyAtIFRoZSBuZXcgZW50cmllcyB0byBjb21taXQuXG4gICAqL1xuICBjb21taXROZXdIaXN0b3J5KG9yaWdpbiwgbmV3RW50cmllcykge1xuICAgIC8vIGEgc2ltcGxlIG1lcmdlIHVwZGF0ZXMgbW9zdCBwZXJtaXNzaW9uc1xuICAgIGNvbnN0IGhpc3RvcnkgPSB0aGlzLmdldEhpc3RvcnkoKTtcbiAgICBjb25zdCBuZXdPcmlnaW5IaXN0b3J5ID0ge1xuICAgICAgLi4uaGlzdG9yeVtvcmlnaW5dLFxuICAgICAgLi4ubmV3RW50cmllcyxcbiAgICB9O1xuXG4gICAgLy8gZXRoX2FjY291bnRzIHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmcsIGJlY2F1c2Ugb2YgaW5mb3JtYXRpb25cbiAgICAvLyB3ZSBzdG9yZSBhYm91dCB0aGUgYWNjb3VudHNcbiAgICBjb25zdCBleGlzdGluZ0V0aEFjY291bnRzRW50cnkgPVxuICAgICAgaGlzdG9yeVtvcmlnaW5dICYmIGhpc3Rvcnlbb3JpZ2luXS5ldGhfYWNjb3VudHM7XG4gICAgY29uc3QgbmV3RXRoQWNjb3VudHNFbnRyeSA9IG5ld0VudHJpZXMuZXRoX2FjY291bnRzO1xuXG4gICAgaWYgKGV4aXN0aW5nRXRoQWNjb3VudHNFbnRyeSAmJiBuZXdFdGhBY2NvdW50c0VudHJ5KSB7XG4gICAgICAvLyB3ZSBtYXkgaW50ZW5kIHRvIHVwZGF0ZSBqdXN0IHRoZSBhY2NvdW50cywgbm90IHRoZSBwZXJtaXNzaW9uXG4gICAgICAvLyBpdHNlbGZcbiAgICAgIGNvbnN0IGxhc3RBcHByb3ZlZCA9XG4gICAgICAgIG5ld0V0aEFjY291bnRzRW50cnkubGFzdEFwcHJvdmVkIHx8XG4gICAgICAgIGV4aXN0aW5nRXRoQWNjb3VudHNFbnRyeS5sYXN0QXBwcm92ZWQ7XG5cbiAgICAgIC8vIG1lcmdlIG9sZCBhbmQgbmV3IGV0aF9hY2NvdW50cyBoaXN0b3J5IGVudHJpZXNcbiAgICAgIG5ld09yaWdpbkhpc3RvcnkuZXRoX2FjY291bnRzID0ge1xuICAgICAgICBsYXN0QXBwcm92ZWQsXG4gICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgLi4uZXhpc3RpbmdFdGhBY2NvdW50c0VudHJ5LmFjY291bnRzLFxuICAgICAgICAgIC4uLm5ld0V0aEFjY291bnRzRW50cnkuYWNjb3VudHMsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGhpc3Rvcnlbb3JpZ2luXSA9IG5ld09yaWdpbkhpc3Rvcnk7XG5cbiAgICB0aGlzLnVwZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCByZXF1ZXN0ZWQgbWV0aG9kcyBmcm9tIGEgcGVybWlzc2lvbnMgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBUaGUgbmFtZXMgb2YgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy5cbiAgICovXG4gIGdldFJlcXVlc3RlZE1ldGhvZHMocmVxdWVzdCkge1xuICAgIGlmIChcbiAgICAgICFyZXF1ZXN0LnBhcmFtcyB8fFxuICAgICAgIXJlcXVlc3QucGFyYW1zWzBdIHx8XG4gICAgICB0eXBlb2YgcmVxdWVzdC5wYXJhbXNbMF0gIT09ICdvYmplY3QnIHx8XG4gICAgICBBcnJheS5pc0FycmF5KHJlcXVlc3QucGFyYW1zWzBdKVxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXF1ZXN0LnBhcmFtc1swXSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJtaXR0ZWQgYWNjb3VudHMgZnJvbSBhbiBldGhfYWNjb3VudHMgcGVybWlzc2lvbnMgb2JqZWN0LlxuICAgKiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIHRoZSBwZXJtaXNzaW9uIGlzIG5vdCBldGhfYWNjb3VudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwZXJtIC0gVGhlIHBlcm1pc3Npb25zIG9iamVjdC5cbiAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59IFRoZSBwZXJtaXR0ZWQgYWNjb3VudHMuXG4gICAqL1xuICBnZXRBY2NvdW50c0Zyb21QZXJtaXNzaW9uKHBlcm0pIHtcbiAgICBpZiAocGVybS5wYXJlbnRDYXBhYmlsaXR5ICE9PSAnZXRoX2FjY291bnRzJyB8fCAhcGVybS5jYXZlYXRzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBjYXZlYXQgb2YgcGVybS5jYXZlYXRzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhdmVhdC50eXBlID09PSBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShjYXZlYXQudmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBjYXZlYXQudmFsdWUpIHtcbiAgICAgICAgICBhY2NvdW50cy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4uYWNjb3VudHNdO1xuICB9XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbnNcblxuLyoqXG4gKiBHZXQgYSBtYXAgZnJvbSBhY2NvdW50IGFkZHJlc3NlcyB0byB0aGUgZ2l2ZW4gdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFjY291bnRzIC0gQW4gYXJyYXkgb2YgYWRkcmVzc2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBBIHRpbWUsIGUuZy4gRGF0ZS5ub3coKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgc3RyaW5nOm51bWJlciBtYXAgb2YgYWRkcmVzc2VzIHRvIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIGdldEFjY291bnRUb1RpbWVNYXAoYWNjb3VudHMsIHRpbWUpIHtcbiAgcmV0dXJuIGFjY291bnRzLnJlZHVjZSgoYWNjLCBhY2NvdW50KSA9PiAoeyAuLi5hY2MsIFthY2NvdW50XTogdGltZSB9KSwge30pO1xufVxuIiwiaW1wb3J0IHsgY29uc3RydWN0UGVybWlzc2lvbiB9IGZyb20gJ0BtZXRhbWFzay9zbmFwLWNvbnRyb2xsZXJzJztcbmltcG9ydCB7XG4gIENhdmVhdFR5cGVzLFxuICBSZXN0cmljdGVkTWV0aG9kcyxcbn0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucyc7XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBzcGVjaWZpY2F0aW9ucyBvZiB0aGUgcGVybWlzc2lvbnMgYW5kIGNhdmVhdHNcbiAqIHRoYXQgYXJlIHJlY29nbml6ZWQgYnkgb3VyIHBlcm1pc3Npb24gc3lzdGVtLiBTZWUgdGhlIFBlcm1pc3Npb25Db250cm9sbGVyXG4gKiBSRUFETUUgaW4gQG1ldGFtYXNrL3NuYXAtY29udHJvbGxlcnMgZm9yIGRldGFpbHMuXG4gKi9cblxuLyoqXG4gKiBUaGUgXCJrZXlzXCIgb2YgYWxsIG9mIHBlcm1pc3Npb25zIHJlY29nbml6ZWQgYnkgdGhlIFBlcm1pc3Npb25Db250cm9sbGVyLlxuICogUGVybWlzc2lvbiBrZXlzIGFuZCBuYW1lcyBoYXZlIGRpc3RpbmN0IG1lYW5pbmdzIGluIHRoZSBwZXJtaXNzaW9uIHN5c3RlbS5cbiAqL1xuY29uc3QgUGVybWlzc2lvbktleXMgPSBPYmplY3QuZnJlZXplKHtcbiAgLi4uUmVzdHJpY3RlZE1ldGhvZHMsXG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9ucyBmb3IgYWxsIGNhdmVhdCB0eXBlcyByZWNvZ25pemVkIGJ5IHRoZVxuICogUGVybWlzc2lvbkNvbnRyb2xsZXIuXG4gKi9cbmNvbnN0IENhdmVhdEZhY3RvcmllcyA9IE9iamVjdC5mcmVlemUoe1xuICBbQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzXTogKGFjY291bnRzKSA9PiB7XG4gICAgcmV0dXJuIHsgdHlwZTogQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLCB2YWx1ZTogYWNjb3VudHMgfTtcbiAgfSxcbn0pO1xuXG4vKipcbiAqIEEgUHJlZmVyZW5jZXNDb250cm9sbGVyIGlkZW50aXR5IG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJZGVudGl0eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgaWRlbnRpdHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBpZGVudGl0eS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGFzdFNlbGVjdGVkXSAtIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGlkZW50aXR5IHdhc1xuICogbGFzdCBzZWxlY3RlZCBpbiB0aGUgVUkuXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBzcGVjaWZpY2F0aW9ucyBmb3IgYWxsIGNhdmVhdHMgdGhhdCB3aWxsIGJlIHJlY29nbml6ZWQgYnkgdGhlXG4gKiBQZXJtaXNzaW9uQ29udHJvbGxlci5cbiAqXG4gKiBAcGFyYW0ge3tcbiAqICAgZ2V0SWRlbnRpdGllczogKCkgPT4gUmVjb3JkPHN0cmluZywgSWRlbnRpdHk+LFxuICogfX0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICovXG5leHBvcnQgY29uc3QgZ2V0Q2F2ZWF0U3BlY2lmaWNhdGlvbnMgPSAoeyBnZXRJZGVudGl0aWVzIH0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBbQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzXToge1xuICAgICAgdHlwZTogQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzLFxuXG4gICAgICBkZWNvcmF0b3I6IChtZXRob2QsIGNhdmVhdCkgPT4ge1xuICAgICAgICByZXR1cm4gYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtZXRob2QoYXJncyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgLmZpbHRlcigoYWNjb3VudCkgPT4gY2F2ZWF0LnZhbHVlLmluY2x1ZGVzKGFjY291bnQpKVxuICAgICAgICAgICAgLnNsaWNlKDAsIDEpO1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgdmFsaWRhdG9yOiAoY2F2ZWF0LCBfb3JpZ2luLCBfdGFyZ2V0KSA9PlxuICAgICAgICB2YWxpZGF0ZUNhdmVhdEFjY291bnRzKGNhdmVhdC52YWx1ZSwgZ2V0SWRlbnRpdGllcyksXG4gICAgfSxcbiAgfTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgc3BlY2lmaWNhdGlvbnMgZm9yIGFsbCBwZXJtaXNzaW9ucyB0aGF0IHdpbGwgYmUgcmVjb2duaXplZCBieSB0aGVcbiAqIFBlcm1pc3Npb25Db250cm9sbGVyLlxuICpcbiAqIEBwYXJhbSB7e1xuICogICBnZXRBbGxBY2NvdW50czogKCkgPT4gUHJvbWlzZTxzdHJpbmdbXT4sXG4gKiAgIGdldElkZW50aXRpZXM6ICgpID0+IFJlY29yZDxzdHJpbmcsIElkZW50aXR5PixcbiAqIH19IG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAqIEBwYXJhbSBvcHRpb25zLmdldEFsbEFjY291bnRzIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYWxsIEV0aGVyZXVtIGFjY291bnRzXG4gKiBpbiB0aGUgY3VycmVudCBNZXRhTWFzayBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvcHRpb25zLmdldElkZW50aXRpZXMgLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAqIGBQcmVmZXJlbmNlc0NvbnRyb2xsZXJgIGlkZW50aXR5IG9iamVjdHMgZm9yIGFsbCBFdGhlcmV1bSBhY2NvdW50cyBpbiB0aGVcbiAqIGN1cnJlbnQgTWV0YU1hc2sgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMgPSAoe1xuICBnZXRBbGxBY2NvdW50cyxcbiAgZ2V0SWRlbnRpdGllcyxcbn0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBbUGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzXToge1xuICAgICAgdGFyZ2V0S2V5OiBQZXJtaXNzaW9uS2V5cy5ldGhfYWNjb3VudHMsXG4gICAgICBhbGxvd2VkQ2F2ZWF0czogW0NhdmVhdFR5cGVzLnJlc3RyaWN0UmV0dXJuZWRBY2NvdW50c10sXG5cbiAgICAgIGZhY3Rvcnk6IChwZXJtaXNzaW9uT3B0aW9ucywgcmVxdWVzdERhdGEpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGVybWlzc2lvbk9wdGlvbnMuY2F2ZWF0cykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJHtQZXJtaXNzaW9uS2V5cy5ldGhfYWNjb3VudHN9IGVycm9yOiBSZWNlaXZlZCB1bmV4cGVjdGVkIGNhdmVhdHMuIEFueSBwZXJtaXR0ZWQgY2F2ZWF0cyB3aWxsIGJlIGFkZGVkIGF1dG9tYXRpY2FsbHkuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyB2YWx1ZSB3aWxsIGJlIGZ1cnRoZXIgdmFsaWRhdGVkIGFzIHBhcnQgb2YgdGhlIGNhdmVhdC5cbiAgICAgICAgaWYgKCFyZXF1ZXN0RGF0YS5hcHByb3ZlZEFjY291bnRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCR7UGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzfSBlcnJvcjogTm8gYXBwcm92ZWQgYWNjb3VudHMgc3BlY2lmaWVkLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RQZXJtaXNzaW9uKHtcbiAgICAgICAgICAuLi5wZXJtaXNzaW9uT3B0aW9ucyxcbiAgICAgICAgICBjYXZlYXRzOiBbXG4gICAgICAgICAgICBDYXZlYXRGYWN0b3JpZXNbQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzXShcbiAgICAgICAgICAgICAgcmVxdWVzdERhdGEuYXBwcm92ZWRBY2NvdW50cyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBtZXRob2RJbXBsZW1lbnRhdGlvbjogYXN5bmMgKF9hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWxsQWNjb3VudHMoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpdGllcyA9IGdldElkZW50aXRpZXMoKTtcblxuICAgICAgICByZXR1cm4gYWNjb3VudHMuc29ydCgoZmlyc3RBZGRyZXNzLCBzZWNvbmRBZGRyZXNzKSA9PiB7XG4gICAgICAgICAgaWYgKCFpZGVudGl0aWVzW2ZpcnN0QWRkcmVzc10pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBpZGVudGl0eSBmb3IgYWRkcmVzczogXCIke2ZpcnN0QWRkcmVzc31cIi5gKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpZGVudGl0aWVzW3NlY29uZEFkZHJlc3NdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBNaXNzaW5nIGlkZW50aXR5IGZvciBhZGRyZXNzOiBcIiR7c2Vjb25kQWRkcmVzc31cIi5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgaWRlbnRpdGllc1tmaXJzdEFkZHJlc3NdLmxhc3RTZWxlY3RlZCA9PT1cbiAgICAgICAgICAgIGlkZW50aXRpZXNbc2Vjb25kQWRkcmVzc10ubGFzdFNlbGVjdGVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlkZW50aXRpZXNbZmlyc3RBZGRyZXNzXS5sYXN0U2VsZWN0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChpZGVudGl0aWVzW3NlY29uZEFkZHJlc3NdLmxhc3RTZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlkZW50aXRpZXNbc2Vjb25kQWRkcmVzc10ubGFzdFNlbGVjdGVkIC1cbiAgICAgICAgICAgIGlkZW50aXRpZXNbZmlyc3RBZGRyZXNzXS5sYXN0U2VsZWN0ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIHZhbGlkYXRvcjogKHBlcm1pc3Npb24sIF9vcmlnaW4sIF90YXJnZXQpID0+IHtcbiAgICAgICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNhdmVhdHMgfHxcbiAgICAgICAgICBjYXZlYXRzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICAgIGNhdmVhdHNbMF0udHlwZSAhPT0gQ2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke1Blcm1pc3Npb25LZXlzLmV0aF9hY2NvdW50c30gZXJyb3I6IEludmFsaWQgY2F2ZWF0cy4gVGhlcmUgbXVzdCBiZSBhIHNpbmdsZSBjYXZlYXQgb2YgdHlwZSBcIiR7Q2F2ZWF0VHlwZXMucmVzdHJpY3RSZXR1cm5lZEFjY291bnRzfVwiLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICB9O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGFjY291bnRzIGFzc29jaWF0ZWQgd2l0aCBhIGNhdmVhdC4gSW4gZXNzZW5jZSwgZW5zdXJlcyB0aGF0XG4gKiB0aGUgYWNjb3VudHMgdmFsdWUgaXMgYW4gYXJyYXkgb2Ygbm9uLWVtcHR5IHN0cmluZ3MsIGFuZCB0aGF0IGVhY2ggc3RyaW5nXG4gKiBjb3JyZXNwb25kcyB0byBhIFByZWZlcmVuY2VzQ29udHJvbGxlciBpZGVudGl0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2NvdW50cyAtIFRoZSBhY2NvdW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhdmVhdC5cbiAqIEBwYXJhbSB7KCkgPT4gUmVjb3JkPHN0cmluZywgSWRlbnRpdHk+fSBnZXRJZGVudGl0aWVzIC0gR2V0cyBhbGxcbiAqIFByZWZlcmVuY2VzQ29udHJvbGxlciBpZGVudGl0aWVzLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNhdmVhdEFjY291bnRzKGFjY291bnRzLCBnZXRJZGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhY2NvdW50cykgfHwgYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7UGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzfSBlcnJvcjogRXhwZWN0ZWQgbm9uLWVtcHR5IGFycmF5IG9mIEV0aGVyZXVtIGFkZHJlc3Nlcy5gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBpZGVudGl0aWVzID0gZ2V0SWRlbnRpdGllcygpO1xuICBhY2NvdW50cy5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XG4gICAgaWYgKCFhZGRyZXNzIHx8IHR5cGVvZiBhZGRyZXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtQZXJtaXNzaW9uS2V5cy5ldGhfYWNjb3VudHN9IGVycm9yOiBFeHBlY3RlZCBhbiBhcnJheSBvZiBFdGhlcmV1bSBhZGRyZXNzZXMuIFJlY2VpdmVkOiBcIiR7YWRkcmVzc31cIi5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlkZW50aXRpZXNbYWRkcmVzc10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7UGVybWlzc2lvbktleXMuZXRoX2FjY291bnRzfSBlcnJvcjogUmVjZWl2ZWQgdW5yZWNvZ25pemVkIGFkZHJlc3M6IFwiJHthZGRyZXNzfVwiLmAsXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQWxsIHVucmVzdHJpY3RlZCBtZXRob2RzIHJlY29nbml6ZWQgYnkgdGhlIFBlcm1pc3Npb25Db250cm9sbGVyLlxuICogVW5yZXN0cmljdGVkIG1ldGhvZHMgYXJlIGlnbm9yZWQgYnkgdGhlIHBlcm1pc3Npb24gc3lzdGVtLCBidXQgZXZlcnlcbiAqIEpTT04tUlBDIHJlcXVlc3Qgc2VlbiBieSB0aGUgcGVybWlzc2lvbiBzeXN0ZW0gbXVzdCBjb3JyZXNwb25kIHRvIGFcbiAqIHJlc3RyaWN0ZWQgb3IgdW5yZXN0cmljdGVkIG1ldGhvZCwgb3IgdGhlIHJlcXVlc3Qgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFcbiAqIFwibWV0aG9kIG5vdCBmb3VuZFwiIGVycm9yLlxuICovXG5leHBvcnQgY29uc3QgdW5yZXN0cmljdGVkTWV0aG9kcyA9IE9iamVjdC5mcmVlemUoW1xuICAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgJ2V0aF9jYWxsJyxcbiAgJ2V0aF9jaGFpbklkJyxcbiAgJ2V0aF9jb2luYmFzZScsXG4gICdldGhfZGVjcnlwdCcsXG4gICdldGhfZXN0aW1hdGVHYXMnLFxuICAnZXRoX2ZlZUhpc3RvcnknLFxuICAnZXRoX2dhc1ByaWNlJyxcbiAgJ2V0aF9nZXRCYWxhbmNlJyxcbiAgJ2V0aF9nZXRCbG9ja0J5SGFzaCcsXG4gICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJyxcbiAgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcicsXG4gICdldGhfZ2V0Q29kZScsXG4gICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXG4gICdldGhfZ2V0RmlsdGVyQ2hhbmdlcycsXG4gICdldGhfZ2V0RmlsdGVyTG9ncycsXG4gICdldGhfZ2V0TG9ncycsXG4gICdldGhfZ2V0UHJvb2YnLFxuICAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JyxcbiAgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCcsXG4gICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnLFxuICAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsXG4gICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JyxcbiAgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCcsXG4gICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoJyxcbiAgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlcicsXG4gICdldGhfZ2V0V29yaycsXG4gICdldGhfaGFzaHJhdGUnLFxuICAnZXRoX21pbmluZycsXG4gICdldGhfbmV3QmxvY2tGaWx0ZXInLFxuICAnZXRoX25ld0ZpbHRlcicsXG4gICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJyxcbiAgJ2V0aF9wcm90b2NvbFZlcnNpb24nLFxuICAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgJ2V0aF9zaWduJyxcbiAgJ2V0aF9zaWduVHlwZWREYXRhJyxcbiAgJ2V0aF9zaWduVHlwZWREYXRhX3YxJyxcbiAgJ2V0aF9zaWduVHlwZWREYXRhX3YzJyxcbiAgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JyxcbiAgJ2V0aF9zdWJtaXRIYXNocmF0ZScsXG4gICdldGhfc3VibWl0V29yaycsXG4gICdldGhfc3luY2luZycsXG4gICdldGhfdW5pbnN0YWxsRmlsdGVyJyxcbiAgJ21ldGFtYXNrX2dldFByb3ZpZGVyU3RhdGUnLFxuICAnbWV0YW1hc2tfd2F0Y2hBc3NldCcsXG4gICduZXRfbGlzdGVuaW5nJyxcbiAgJ25ldF9wZWVyQ291bnQnLFxuICAnbmV0X3ZlcnNpb24nLFxuICAncGVyc29uYWxfZWNSZWNvdmVyJyxcbiAgJ3BlcnNvbmFsX3NpZ24nLFxuICAnd2FsbGV0X3dhdGNoQXNzZXQnLFxuICAnd2ViM19jbGllbnRWZXJzaW9uJyxcbiAgJ3dlYjNfc2hhMycsXG5dKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgcmVtb3ZlU2xhc2ggPSByZXF1aXJlKCdyZW1vdmUtdHJhaWxpbmctc2xhc2gnKVxuY29uc3QgbG9vc2VseVZhbGlkYXRlID0gcmVxdWlyZSgnQHNlZ21lbnQvbG9vc2VseS12YWxpZGF0ZS1ldmVudCcpXG5jb25zdCBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJylcbmNvbnN0IGF4aW9zUmV0cnkgPSByZXF1aXJlKCdheGlvcy1yZXRyeScpXG5jb25zdCBtcyA9IHJlcXVpcmUoJ21zJylcbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0JylcbmNvbnN0IG1kNSA9IHJlcXVpcmUoJ21kNScpXG5jb25zdCB2ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5jb25zdCBpc1N0cmluZyA9IHJlcXVpcmUoJ2xvZGFzaC5pc3N0cmluZycpXG5cbmNvbnN0IHNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGUgfHwgcHJvY2Vzcy5uZXh0VGljay5iaW5kKHByb2Nlc3MpXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY2xhc3MgQW5hbHl0aWNzIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgYEFuYWx5dGljc2Agd2l0aCB5b3VyIFNlZ21lbnQgcHJvamVjdCdzIGB3cml0ZUtleWAgYW5kIGFuXG4gICAqIG9wdGlvbmFsIGRpY3Rpb25hcnkgb2YgYG9wdGlvbnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gd3JpdGVLZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpXG4gICAqICAgQHByb3BlcnR5IHtOdW1iZXJ9IGZsdXNoQXQgKGRlZmF1bHQ6IDIwKVxuICAgKiAgIEBwcm9wZXJ0eSB7TnVtYmVyfSBmbHVzaEludGVydmFsIChkZWZhdWx0OiAxMDAwMClcbiAgICogICBAcHJvcGVydHkge1N0cmluZ30gaG9zdCAoZGVmYXVsdDogJ2h0dHBzOi8vYXBpLnNlZ21lbnQuaW8nKVxuICAgKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlIChkZWZhdWx0OiB0cnVlKVxuICAgKi9cblxuICBjb25zdHJ1Y3RvciAod3JpdGVLZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgYXNzZXJ0KHdyaXRlS2V5LCAnWW91IG11c3QgcGFzcyB5b3VyIFNlZ21lbnQgcHJvamVjdFxcJ3Mgd3JpdGUga2V5LicpXG5cbiAgICB0aGlzLnF1ZXVlID0gW11cbiAgICB0aGlzLndyaXRlS2V5ID0gd3JpdGVLZXlcbiAgICB0aGlzLmhvc3QgPSByZW1vdmVTbGFzaChvcHRpb25zLmhvc3QgfHwgJ2h0dHBzOi8vYXBpLnNlZ21lbnQuaW8nKVxuICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCBmYWxzZVxuICAgIHRoaXMuZmx1c2hBdCA9IE1hdGgubWF4KG9wdGlvbnMuZmx1c2hBdCwgMSkgfHwgMjBcbiAgICB0aGlzLmZsdXNoSW50ZXJ2YWwgPSBvcHRpb25zLmZsdXNoSW50ZXJ2YWwgfHwgMTAwMDBcbiAgICB0aGlzLmZsdXNoZWQgPSBmYWxzZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZW5hYmxlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdHlwZW9mIG9wdGlvbnMuZW5hYmxlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuYWJsZSA6IHRydWVcbiAgICB9KVxuICAgIHRoaXMuYXhpb3NDbGllbnQgPSBheGlvcy5jcmVhdGUoKVxuICAgIGF4aW9zUmV0cnkodGhpcy5heGlvc0NsaWVudCwge1xuICAgICAgcmV0cmllczogb3B0aW9ucy5yZXRyeUNvdW50IHx8IDMsXG4gICAgICByZXRyeUNvbmRpdGlvbjogdGhpcy5faXNFcnJvclJldHJ5YWJsZSxcbiAgICAgIHJldHJ5RGVsYXk6IGF4aW9zUmV0cnkuZXhwb25lbnRpYWxEZWxheVxuICAgIH0pXG4gIH1cblxuICBfdmFsaWRhdGUgKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgbG9vc2VseVZhbGlkYXRlKG1lc3NhZ2UsIHR5cGUpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubWVzc2FnZSA9PT0gJ1lvdXIgbWVzc2FnZSBtdXN0IGJlIDwgMzJrYi4nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdZb3VyIG1lc3NhZ2UgbXVzdCBiZSA8IDMya2IuIFRoaXMgaXMgY3VycmVudGx5IHN1cmZhY2VkIGFzIGEgd2FybmluZyB0byBhbGxvdyBjbGllbnRzIHRvIHVwZGF0ZS4gVmVyc2lvbnMgcmVsZWFzZWQgYWZ0ZXIgQXVndXN0IDEsIDIwMTggd2lsbCB0aHJvdyBhbiBlcnJvciBpbnN0ZWFkLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZSBiZWZvcmUgdGhlbi4nLCBtZXNzYWdlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhbiBpZGVudGlmeSBgbWVzc2FnZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHtBbmFseXRpY3N9XG4gICAqL1xuXG4gIGlkZW50aWZ5IChtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3ZhbGlkYXRlKG1lc3NhZ2UsICdpZGVudGlmeScpXG4gICAgdGhpcy5lbnF1ZXVlKCdpZGVudGlmeScsIG1lc3NhZ2UsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGdyb3VwIGBtZXNzYWdlYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm4ge0FuYWx5dGljc31cbiAgICovXG5cbiAgZ3JvdXAgKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fdmFsaWRhdGUobWVzc2FnZSwgJ2dyb3VwJylcbiAgICB0aGlzLmVucXVldWUoJ2dyb3VwJywgbWVzc2FnZSwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhY2sgYG1lc3NhZ2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIChvcHRpb25hbClcbiAgICogQHJldHVybiB7QW5hbHl0aWNzfVxuICAgKi9cblxuICB0cmFjayAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXNzYWdlLCAndHJhY2snKVxuICAgIHRoaXMuZW5xdWV1ZSgndHJhY2snLCBtZXNzYWdlLCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwYWdlIGBtZXNzYWdlYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAob3B0aW9uYWwpXG4gICAqIEByZXR1cm4ge0FuYWx5dGljc31cbiAgICovXG5cbiAgcGFnZSAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXNzYWdlLCAncGFnZScpXG4gICAgdGhpcy5lbnF1ZXVlKCdwYWdlJywgbWVzc2FnZSwgY2FsbGJhY2spXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2NyZWVuIGBtZXNzYWdlYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHtBbmFseXRpY3N9XG4gICAqL1xuXG4gIHNjcmVlbiAobWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl92YWxpZGF0ZShtZXNzYWdlLCAnc2NyZWVuJylcbiAgICB0aGlzLmVucXVldWUoJ3NjcmVlbicsIG1lc3NhZ2UsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhbiBhbGlhcyBgbWVzc2FnZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJuIHtBbmFseXRpY3N9XG4gICAqL1xuXG4gIGFsaWFzIChtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3ZhbGlkYXRlKG1lc3NhZ2UsICdhbGlhcycpXG4gICAgdGhpcy5lbnF1ZXVlKCdhbGlhcycsIG1lc3NhZ2UsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgYG1lc3NhZ2VgIG9mIHR5cGUgYHR5cGVgIHRvIHRoZSBxdWV1ZSBhbmRcbiAgICogY2hlY2sgd2hldGhlciBpdCBzaG91bGQgYmUgZmx1c2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAob3B0aW9uYWwpXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBlbnF1ZXVlICh0eXBlLCBtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcFxuXG4gICAgaWYgKCF0aGlzLmVuYWJsZSkge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjaylcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZSlcbiAgICBtZXNzYWdlLnR5cGUgPSB0eXBlXG4gICAgbWVzc2FnZS5jb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsaWJyYXJ5OiB7XG4gICAgICAgIG5hbWU6ICdhbmFseXRpY3Mtbm9kZScsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICB9LCBtZXNzYWdlLmNvbnRleHQpXG5cbiAgICBtZXNzYWdlLl9tZXRhZGF0YSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbm9kZVZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMubm9kZVxuICAgIH0sIG1lc3NhZ2UuX21ldGFkYXRhKVxuXG4gICAgaWYgKCFtZXNzYWdlLnRpbWVzdGFtcCkge1xuICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpXG4gICAgfVxuXG4gICAgaWYgKCFtZXNzYWdlLm1lc3NhZ2VJZCkge1xuICAgICAgLy8gV2UgbWQ1IHRoZSBtZXNzYWFnZSB0byBhZGQgbW9yZSByYW5kb21uZXNzLiBUaGlzIGlzIHByaW1hcmlseSBtZWFudFxuICAgICAgLy8gZm9yIHVzZSBpbiB0aGUgYnJvd3NlciB3aGVyZSB0aGUgdXVpZCBwYWNrYWdlIGZhbGxzIGJhY2sgdG8gTWF0aC5yYW5kb20oKVxuICAgICAgLy8gd2hpY2ggaXMgbm90IGEgZ3JlYXQgc291cmNlIG9mIHJhbmRvbW5lc3MuXG4gICAgICAvLyBCb3Jyb3dlZCBmcm9tIGFuYWx5dGljcy5qcyAoaHR0cHM6Ly9naXRodWIuY29tL3NlZ21lbnQtaW50ZWdyYXRpb25zL2FuYWx5dGljcy5qcy1pbnRlZ3JhdGlvbi1zZWdtZW50aW8vYmxvYi9hMjBkMmEyZDIyMmFlYjNhYjJhOGM3ZTcyMjgwZjFkZjI2MTg0NDBlL2xpYi9pbmRleC5qcyNMMjU1LUwyNTYpLlxuICAgICAgbWVzc2FnZS5tZXNzYWdlSWQgPSBgbm9kZS0ke21kNShKU09OLnN0cmluZ2lmeShtZXNzYWdlKSl9LSR7dXVpZCgpfWBcbiAgICB9XG5cbiAgICAvLyBIaXN0b3JpY2FsbHkgdGhpcyBsaWJyYXJ5IGhhcyBhY2NlcHRlZCBzdHJpbmdzIGFuZCBudW1iZXJzIGFzIElEcy5cbiAgICAvLyBIb3dldmVyLCBvdXIgc3BlYyBvbmx5IGFsbG93cyBzdHJpbmdzLiBUbyBhdm9pZCBicmVha2luZyBjb21wYXRpYmlsaXR5LFxuICAgIC8vIHdlJ2xsIGNvZXJjZSB0aGVzZSB0byBzdHJpbmdzIGlmIHRoZXkgYXJlbid0IGFscmVhZHkuXG4gICAgaWYgKG1lc3NhZ2UuYW5vbnltb3VzSWQgJiYgIWlzU3RyaW5nKG1lc3NhZ2UuYW5vbnltb3VzSWQpKSB7XG4gICAgICBtZXNzYWdlLmFub255bW91c0lkID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZS5hbm9ueW1vdXNJZClcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UudXNlcklkICYmICFpc1N0cmluZyhtZXNzYWdlLnVzZXJJZCkpIHtcbiAgICAgIG1lc3NhZ2UudXNlcklkID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZS51c2VySWQpXG4gICAgfVxuXG4gICAgdGhpcy5xdWV1ZS5wdXNoKHsgbWVzc2FnZSwgY2FsbGJhY2sgfSlcblxuICAgIGlmICghdGhpcy5mbHVzaGVkKSB7XG4gICAgICB0aGlzLmZsdXNoZWQgPSB0cnVlXG4gICAgICB0aGlzLmZsdXNoKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+PSB0aGlzLmZsdXNoQXQpIHtcbiAgICAgIHRoaXMuZmx1c2goKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsdXNoSW50ZXJ2YWwgJiYgIXRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuZmx1c2guYmluZCh0aGlzKSwgdGhpcy5mbHVzaEludGVydmFsKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgY3VycmVudCBxdWV1ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIChvcHRpb25hbClcbiAgICogQHJldHVybiB7QW5hbHl0aWNzfVxuICAgKi9cblxuICBmbHVzaCAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3BcblxuICAgIGlmICghdGhpcy5lbmFibGUpIHtcbiAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICAgICAgdGhpcy50aW1lciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5xdWV1ZS5zcGxpY2UoMCwgdGhpcy5mbHVzaEF0KVxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uY2FsbGJhY2spXG4gICAgY29uc3QgbWVzc2FnZXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLm1lc3NhZ2UpXG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgYmF0Y2g6IG1lc3NhZ2VzLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgc2VudEF0OiBuZXcgRGF0ZSgpXG4gICAgfVxuXG4gICAgY29uc3QgZG9uZSA9IGVyciA9PiB7XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhlcnIpKVxuICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKVxuICAgIH1cblxuICAgIC8vIERvbid0IHNldCB0aGUgdXNlciBhZ2VudCBpZiB3ZSdyZSBub3Qgb24gYSBicm93c2VyLiBUaGUgbGF0ZXN0IHNwZWMgYWxsb3dzXG4gICAgLy8gdGhlIFVzZXItQWdlbnQgaGVhZGVyIChzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Rlcm1pbm9sb2d5LWhlYWRlcnNcbiAgICAvLyBhbmQgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3NldFJlcXVlc3RIZWFkZXIpLFxuICAgIC8vIGJ1dCBicm93c2VycyBzdWNoIGFzIENocm9tZSBhbmQgU2FmYXJpIGhhdmUgbm90IGNhdWdodCB1cC5cbiAgICBjb25zdCBoZWFkZXJzID0ge31cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGhlYWRlcnNbJ3VzZXItYWdlbnQnXSA9IGBhbmFseXRpY3Mtbm9kZS8ke3ZlcnNpb259YFxuICAgIH1cblxuICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiBgJHt0aGlzLmhvc3R9L3YxL2JhdGNoYCxcbiAgICAgIGF1dGg6IHtcbiAgICAgICAgdXNlcm5hbWU6IHRoaXMud3JpdGVLZXlcbiAgICAgIH0sXG4gICAgICBkYXRhLFxuICAgICAgaGVhZGVyc1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHJlcS50aW1lb3V0ID0gdHlwZW9mIHRoaXMudGltZW91dCA9PT0gJ3N0cmluZycgPyBtcyh0aGlzLnRpbWVvdXQpIDogdGhpcy50aW1lb3V0XG4gICAgfVxuXG4gICAgdGhpcy5heGlvc0NsaWVudChyZXEpXG4gICAgICAudGhlbigoKSA9PiBkb25lKCkpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKGVyci5yZXNwb25zZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVyci5yZXNwb25zZS5zdGF0dXNUZXh0KVxuICAgICAgICAgIHJldHVybiBkb25lKGVycm9yKVxuICAgICAgICB9XG5cbiAgICAgICAgZG9uZShlcnIpXG4gICAgICB9KVxuICB9XG5cbiAgX2lzRXJyb3JSZXRyeWFibGUgKGVycm9yKSB7XG4gICAgLy8gUmV0cnkgTmV0d29yayBFcnJvcnMuXG4gICAgaWYgKGF4aW9zUmV0cnkuaXNOZXR3b3JrRXJyb3IoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgIC8vIENhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHJldHJpZWRcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIFJldHJ5IFNlcnZlciBFcnJvcnMgKDV4eCkuXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDw9IDU5OSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBSZXRyeSBpZiByYXRlIGxpbWl0ZWQuXG4gICAgaWYgKGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQW5hbHl0aWNzXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIFdhbGxldCA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgc2NyeXB0c3kgPSByZXF1aXJlKCdzY3J5cHRzeScpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG52YXIgYWVzanMgPSByZXF1aXJlKCdhZXMtanMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkNpcGhlckJ1ZmZlcihjaXBoZXIsIGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUoZGF0YSksIGNpcGhlci5maW5hbCgpXSk7XG59XG5cbnZhciBUaGlyZHBhcnR5ID0ge307XG5cbi8qXG4gKiBvcHRzOlxuICogLSBkaWdlc3QgLSBkaWdlc3QgYWxnb3JpdGhtLCBkZWZhdWx0cyB0byBtZDVcbiAqIC0gY291bnQgLSBoYXNoIGl0ZXJhdGlvbnNcbiAqIC0ga2V5c2l6ZSAtIGRlc2lyZWQga2V5IHNpemVcbiAqIC0gaXZzaXplIC0gZGVzaXJlZCBJViBzaXplXG4gKlxuICogQWxnb3JpdGhtIGZvcm0gaHR0cHM6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9tYW5tYXN0ZXIvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcbiAqXG4gKiBGSVhNRTogbm90IG9wdGltaXNlZCBhdCBhbGxcbiAqL1xuZnVuY3Rpb24gZXZwX2tkZihkYXRhLCBzYWx0LCBvcHRzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgLy8gQSBzaW5nbGUgRVZQIGl0ZXJhdGlvbiwgcmV0dXJucyBgRF9pYCwgd2hlcmUgYmxvY2sgZXF1bGFzIHRvIGBEXyhpLTEpYFxuICBmdW5jdGlvbiBpdGVyKGJsb2NrKSB7XG4gICAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChvcHRzLmRpZ2VzdCB8fCAnbWQ1Jyk7XG4gICAgaGFzaC51cGRhdGUoYmxvY2spO1xuICAgIGhhc2gudXBkYXRlKGRhdGEpO1xuICAgIGhhc2gudXBkYXRlKHNhbHQpO1xuICAgIGJsb2NrID0gaGFzaC5kaWdlc3QoKTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgKG9wdHMuY291bnQgfHwgMSk7IGkrKykge1xuICAgICAgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKG9wdHMuZGlnZXN0IHx8ICdtZDUnKTtcbiAgICAgIGhhc2gudXBkYXRlKGJsb2NrKTtcbiAgICAgIGJsb2NrID0gaGFzaC5kaWdlc3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICB2YXIga2V5c2l6ZSA9IG9wdHMua2V5c2l6ZSB8fCAxNjtcbiAgdmFyIGl2c2l6ZSA9IG9wdHMuaXZzaXplIHx8IDE2O1xuXG4gIHZhciByZXQgPSBbXTtcblxuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChCdWZmZXIuY29uY2F0KHJldCkubGVuZ3RoIDwga2V5c2l6ZSArIGl2c2l6ZSkge1xuICAgIHJldFtpXSA9IGl0ZXIoaSA9PT0gMCA/IEJ1ZmZlci5hbGxvYygwKSA6IHJldFtpIC0gMV0pO1xuICAgIGkrKztcbiAgfVxuXG4gIHZhciB0bXAgPSBCdWZmZXIuY29uY2F0KHJldCk7XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IHRtcC5zbGljZSgwLCBrZXlzaXplKSxcbiAgICBpdjogdG1wLnNsaWNlKGtleXNpemUsIGtleXNpemUgKyBpdnNpemUpXG4gIH07XG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjUyODgzMTEvY3J5cHRvanMtYWVzLXBhdHRlcm4tYWx3YXlzLWVuZHMtd2l0aFxuZnVuY3Rpb24gZGVjb2RlQ3J5cHRvanNTYWx0KGlucHV0KSB7XG4gIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oaW5wdXQsICdiYXNlNjQnKTtcbiAgaWYgKGNpcGhlcnRleHQuc2xpY2UoMCwgOCkudG9TdHJpbmcoKSA9PT0gJ1NhbHRlZF9fJykge1xuICAgIHJldHVybiB7XG4gICAgICBzYWx0OiBjaXBoZXJ0ZXh0LnNsaWNlKDgsIDE2KSxcbiAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQuc2xpY2UoMTYpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFxuICAgIH07XG4gIH1cbn1cblxuLypcbiAqIFRoaXMgd2FsbGV0IGZvcm1hdCBpcyBjcmVhdGVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9TaWxlbnRDaWNlcm8vZXRoZXJldW1qcy1hY2NvdW50c1xuICogYW5kIHVzZWQgb24gaHR0cHM6Ly93d3cubXlldGhlcndhbGxldC5jb20vXG4gKi9cblRoaXJkcGFydHkuZnJvbUV0aGVyV2FsbGV0ID0gZnVuY3Rpb24gKGlucHV0LCBwYXNzd29yZCkge1xuICB2YXIganNvbiA9ICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnID8gaW5wdXQgOiBKU09OLnBhcnNlKGlucHV0KTtcblxuICB2YXIgcHJpdktleTtcbiAgaWYgKCFqc29uLmxvY2tlZCkge1xuICAgIGlmIChqc29uLnByaXZhdGUubGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5IGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHByaXZLZXkgPSBCdWZmZXIuZnJvbShqc29uLnByaXZhdGUsICdoZXgnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgNykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDcgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIC8vIHRoZSBcImVuY3J5cHRlZFwiIHZlcnNpb24gaGFzIHRoZSBsb3cgNCBieXRlc1xuICAgIC8vIG9mIHRoZSBoYXNoIG9mIHRoZSBhZGRyZXNzIGFwcGVuZGVkXG4gICAgdmFyIGNpcGhlciA9IGpzb24uZW5jcnlwdGVkID8ganNvbi5wcml2YXRlLnNsaWNlKDAsIDEyOCkgOiBqc29uLnByaXZhdGU7XG5cbiAgICAvLyBkZWNvZGUgb3BlbnNzbCBjaXBoZXJ0ZXh0ICsgc2FsdCBlbmNvZGluZ1xuICAgIGNpcGhlciA9IGRlY29kZUNyeXB0b2pzU2FsdChjaXBoZXIpO1xuXG4gICAgaWYgKCFjaXBoZXIuc2FsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBFdGhlcldhbGxldCBrZXkgZm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgLy8gZGVyaXZlIGtleS9pdiB1c2luZyBPcGVuU1NMIEVWUCBhcyBpbXBsZW1lbnRlZCBpbiBDcnlwdG9KU1xuICAgIHZhciBldnAgPSBldnBfa2RmKEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgY2lwaGVyLnNhbHQsIHsga2V5c2l6ZTogMzIsIGl2c2l6ZTogMTYgfSk7XG5cbiAgICB2YXIgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1jYmMnLCBldnAua2V5LCBldnAuaXYpO1xuICAgIHByaXZLZXkgPSBydW5DaXBoZXJCdWZmZXIoZGVjaXBoZXIsIEJ1ZmZlci5mcm9tKGNpcGhlci5jaXBoZXJ0ZXh0KSk7XG5cbiAgICAvLyBOT1RFOiB5ZXMsIHRoZXkndmUgcnVuIGl0IHRocm91Z2ggVVRGOFxuICAgIHByaXZLZXkgPSBCdWZmZXIuZnJvbSh1dGY4LmRlY29kZShwcml2S2V5LnRvU3RyaW5nKCkpLCAnaGV4Jyk7XG4gIH1cblxuICB2YXIgd2FsbGV0ID0gbmV3IFdhbGxldChwcml2S2V5KTtcblxuICBpZiAod2FsbGV0LmdldEFkZHJlc3NTdHJpbmcoKSAhPT0ganNvbi5hZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5IG9yIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHJldHVybiB3YWxsZXQ7XG59O1xuXG5UaGlyZHBhcnR5LmZyb21FdGhlckNhbXAgPSBmdW5jdGlvbiAocGFzc3BocmFzZSkge1xuICByZXR1cm4gbmV3IFdhbGxldChldGhVdGlsLmtlY2NhazI1NihCdWZmZXIuZnJvbShwYXNzcGhyYXNlKSkpO1xufTtcblxuVGhpcmRwYXJ0eS5mcm9tS3J5cHRvS2l0ID0gZnVuY3Rpb24gKGVudHJvcHksIHBhc3N3b3JkKSB7XG4gIGZ1bmN0aW9uIGtyeXB0b0tpdEJyb2tlblNjcnlwdFNlZWQoYnVmKSB7XG4gICAgLy8ganMtc2NyeXB0IGNhbGxzIGBCdWZmZXIuZnJvbShTdHJpbmcoc2FsdCksICd1dGY4JylgIG9uIHRoZSBzZWVkIGV2ZW4gdGhvdWdoIGl0IGlzIGEgYnVmZmVyXG4gICAgLy9cbiAgICAvLyBUaGUgYGJ1ZmZlcmBgIGltcGxlbWVudGF0aW9uIHVzZWQgZG9lcyB0aGUgYmVsb3cgdHJhbnNmb3JtYXRpb24gKGRvZXNuJ3QgbWF0Y2hlcyB0aGUgY3VycmVudCB2ZXJzaW9uKTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY3YzYxMTgxYjkzOGIxN2QxMGRiZmMwYTU0NWY3MTNiOGJkNTlkZTgvaW5kZXguanNcblxuICAgIGZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCk7IC8vIFVURiA4IGludmFsaWQgY2hhclxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXMgPSAnJztcbiAgICB2YXIgdG1wID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApKTtcbiAgfVxuXG4gIGlmIChlbnRyb3B5WzBdID09PSAnIycpIHtcbiAgICBlbnRyb3B5ID0gZW50cm9weS5zbGljZSgxKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gZW50cm9weVswXTtcbiAgZW50cm9weSA9IGVudHJvcHkuc2xpY2UoMSk7XG5cbiAgdmFyIHByaXZLZXk7XG4gIGlmICh0eXBlID09PSAnZCcpIHtcbiAgICBwcml2S2V5ID0gZXRoVXRpbC5zaGEyNTYoQnVmZmVyLmZyb20oZW50cm9weSkpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdxJykge1xuICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGVuY3J5cHRlZFNlZWQgPSBldGhVdGlsLnNoYTI1NihCdWZmZXIuZnJvbShlbnRyb3B5LnNsaWNlKDAsIDMwKSkpO1xuICAgIHZhciBjaGVja3N1bSA9IGVudHJvcHkuc2xpY2UoMzAsIDQ2KTtcblxuICAgIHZhciBzYWx0ID0ga3J5cHRvS2l0QnJva2VuU2NyeXB0U2VlZChlbmNyeXB0ZWRTZWVkKTtcbiAgICB2YXIgYWVzS2V5ID0gc2NyeXB0c3koQnVmZmVyLmZyb20ocGFzc3dvcmQsICd1dGY4JyksIHNhbHQsIDE2Mzg0LCA4LCAxLCAzMik7XG5cbiAgICAvKiBGSVhNRTogdHJ5IHRvIHVzZSBgY3J5cHRvYCBpbnN0ZWFkIG9mIGBhZXNqc2BcbiAgICAgLy8gTk9URTogRUNCIGRvZXNuJ3QgdXNlIHRoZSBJViwgc28gaXQgY2FuIGJlIGFueXRoaW5nXG4gICAgdmFyIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJhZXMtMjU2LWVjYlwiLCBhZXNLZXksIEJ1ZmZlci5mcm9tKDApKVxuICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIGNsZWFyIGFidXNlLCBidXQgc2VlbXMgdG8gbWF0Y2ggaG93IEVDQiBpbiBhZXNqcyB3b3Jrc1xuICAgIHByaXZLZXkgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWRTZWVkKS5zbGljZSgwLCAxNiksXG4gICAgICBkZWNpcGhlci51cGRhdGUoZW5jcnlwdGVkU2VlZCkuc2xpY2UoMCwgMTYpLFxuICAgIF0pXG4gICAgKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbiAgICB2YXIgZGVjaXBoZXIgPSBuZXcgYWVzanMuTW9kZU9mT3BlcmF0aW9uLmVjYihhZXNLZXkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbmV3LWNhcCAqL1xuICAgIC8qIGRlY3J5cHQgcmV0dXJucyBhbiBVaW50OEFycmF5LCBwZXJoYXBzIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0byBjb25jYXRlbmF0ZSAqL1xuICAgIHByaXZLZXkgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShkZWNpcGhlci5kZWNyeXB0KGVuY3J5cHRlZFNlZWQuc2xpY2UoMCwgMTYpKSksIEJ1ZmZlci5mcm9tKGRlY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkU2VlZC5zbGljZSgxNiwgMzIpKSldKTtcblxuICAgIGlmIChjaGVja3N1bS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoY2hlY2tzdW0gIT09IGV0aFV0aWwuc2hhMjU2KGV0aFV0aWwuc2hhMjU2KHByaXZLZXkpKS5zbGljZSgwLCA4KS50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBpbnB1dCAtIHBvc3NpYmx5IGludmFsaWQgcGFzc3BocmFzZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgZW50cm9weSB0eXBlJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFdhbGxldChwcml2S2V5KTtcbn07XG5cblRoaXJkcGFydHkuZnJvbVF1b3J1bVdhbGxldCA9IGZ1bmN0aW9uIChwYXNzcGhyYXNlLCB1c2VyaWQpIHtcbiAgYXNzZXJ0KHBhc3NwaHJhc2UubGVuZ3RoID49IDEwKTtcbiAgYXNzZXJ0KHVzZXJpZC5sZW5ndGggPj0gMTApO1xuXG4gIHZhciBzZWVkID0gcGFzc3BocmFzZSArIHVzZXJpZDtcbiAgc2VlZCA9IGNyeXB0by5wYmtkZjJTeW5jKHNlZWQsIHNlZWQsIDIwMDAsIDMyLCAnc2hhMjU2Jyk7XG5cbiAgcmV0dXJuIG5ldyBXYWxsZXQoc2VlZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRoaXJkcGFydHk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xudmFyIHNjcnlwdHN5ID0gcmVxdWlyZSgnc2NyeXB0c3knKTtcbnZhciB1dWlkdjQgPSByZXF1aXJlKCd1dWlkL3Y0Jyk7XG52YXIgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5DaXBoZXJCdWZmZXIoY2lwaGVyLCBkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtjaXBoZXIudXBkYXRlKGRhdGEpLCBjaXBoZXIuZmluYWwoKV0pO1xufVxuXG52YXIgV2FsbGV0ID0gZnVuY3Rpb24gV2FsbGV0KHByaXYsIHB1Yikge1xuICBpZiAocHJpdiAmJiBwdWIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdXBwbHkgYm90aCBhIHByaXZhdGUgYW5kIGEgcHVibGljIGtleSB0byB0aGUgY29uc3RydWN0b3InKTtcbiAgfVxuXG4gIGlmIChwcml2ICYmICFldGhVdGlsLmlzVmFsaWRQcml2YXRlKHByaXYpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBjdXJ2ZSByZXF1aXJlbWVudHMgKGllLiBpdCBpcyBpbnZhbGlkKScpO1xuICB9XG5cbiAgaWYgKHB1YiAmJiAhZXRoVXRpbC5pc1ZhbGlkUHVibGljKHB1YikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHVibGljIGtleScpO1xuICB9XG5cbiAgdGhpcy5fcHJpdktleSA9IHByaXY7XG4gIHRoaXMuX3B1YktleSA9IHB1Yjtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYWxsZXQucHJvdG90eXBlLCAncHJpdktleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgYXNzZXJ0KHRoaXMuX3ByaXZLZXksICdUaGlzIGlzIGEgcHVibGljIGtleSBvbmx5IHdhbGxldCcpO1xuICAgIHJldHVybiB0aGlzLl9wcml2S2V5O1xuICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsICdwdWJLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICghdGhpcy5fcHViS2V5KSB7XG4gICAgICB0aGlzLl9wdWJLZXkgPSBldGhVdGlsLnByaXZhdGVUb1B1YmxpYyh0aGlzLnByaXZLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHViS2V5O1xuICB9XG59KTtcblxuV2FsbGV0LmdlbmVyYXRlID0gZnVuY3Rpb24gKGljYXBEaXJlY3QpIHtcbiAgaWYgKGljYXBEaXJlY3QpIHtcbiAgICB2YXIgbWF4ID0gbmV3IGV0aFV0aWwuQk4oJzA4OGY5MjRlZWNlZWRhN2ZlOTJlMWY1YjBmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwcml2S2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgaWYgKG5ldyBldGhVdGlsLkJOKGV0aFV0aWwucHJpdmF0ZVRvQWRkcmVzcyhwcml2S2V5KSkubHRlKG1heCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQocHJpdktleSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHJhbmRvbUJ5dGVzKDMyKSk7XG4gIH1cbn07XG5cbldhbGxldC5nZW5lcmF0ZVZhbml0eUFkZHJlc3MgPSBmdW5jdGlvbiAocGF0dGVybikge1xuICBpZiAoKHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXR0ZXJuKSkgIT09ICdvYmplY3QnKSB7XG4gICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gIH1cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwcml2S2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgIHZhciBhZGRyZXNzID0gZXRoVXRpbC5wcml2YXRlVG9BZGRyZXNzKHByaXZLZXkpO1xuXG4gICAgaWYgKHBhdHRlcm4udGVzdChhZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSkpIHtcbiAgICAgIHJldHVybiBuZXcgV2FsbGV0KHByaXZLZXkpO1xuICAgIH1cbiAgfVxufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcml2S2V5O1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRQcml2YXRlS2V5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmdldFByaXZhdGVLZXkoKSk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHViS2V5O1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRQdWJsaWNLZXlTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuZ2V0UHVibGljS2V5KCkpO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3ModGhpcy5wdWJLZXkpO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRBZGRyZXNzU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmdldEFkZHJlc3MoKSk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldENoZWNrc3VtQWRkcmVzc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3ModGhpcy5nZXRBZGRyZXNzU3RyaW5nKCkpO1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb25cbldhbGxldC5wcm90b3R5cGUudG9WMyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0cykge1xuICBhc3NlcnQodGhpcy5fcHJpdktleSwgJ1RoaXMgaXMgYSBwdWJsaWMga2V5IG9ubHkgd2FsbGV0Jyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBzYWx0ID0gb3B0cy5zYWx0IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgdmFyIGl2ID0gb3B0cy5pdiB8fCByYW5kb21CeXRlcygxNik7XG5cbiAgdmFyIGRlcml2ZWRLZXk7XG4gIHZhciBrZGYgPSBvcHRzLmtkZiB8fCAnc2NyeXB0JztcbiAgdmFyIGtkZnBhcmFtcyA9IHtcbiAgICBka2xlbjogb3B0cy5ka2xlbiB8fCAzMixcbiAgICBzYWx0OiBzYWx0LnRvU3RyaW5nKCdoZXgnKVxuICB9O1xuXG4gIGlmIChrZGYgPT09ICdwYmtkZjInKSB7XG4gICAga2RmcGFyYW1zLmMgPSBvcHRzLmMgfHwgMjYyMTQ0O1xuICAgIGtkZnBhcmFtcy5wcmYgPSAnaG1hYy1zaGEyNTYnO1xuICAgIGRlcml2ZWRLZXkgPSBjcnlwdG8ucGJrZGYyU3luYyhCdWZmZXIuZnJvbShwYXNzd29yZCksIHNhbHQsIGtkZnBhcmFtcy5jLCBrZGZwYXJhbXMuZGtsZW4sICdzaGEyNTYnKTtcbiAgfSBlbHNlIGlmIChrZGYgPT09ICdzY3J5cHQnKSB7XG4gICAgLy8gRklYTUU6IHN1cHBvcnQgcHJvZ3Jlc3MgcmVwb3J0aW5nIGNhbGxiYWNrXG4gICAga2RmcGFyYW1zLm4gPSBvcHRzLm4gfHwgMjYyMTQ0O1xuICAgIGtkZnBhcmFtcy5yID0gb3B0cy5yIHx8IDg7XG4gICAga2RmcGFyYW1zLnAgPSBvcHRzLnAgfHwgMTtcbiAgICBkZXJpdmVkS2V5ID0gc2NyeXB0c3koQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBzYWx0LCBrZGZwYXJhbXMubiwga2RmcGFyYW1zLnIsIGtkZnBhcmFtcy5wLCBrZGZwYXJhbXMuZGtsZW4pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2RmJyk7XG4gIH1cblxuICB2YXIgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KG9wdHMuY2lwaGVyIHx8ICdhZXMtMTI4LWN0cicsIGRlcml2ZWRLZXkuc2xpY2UoMCwgMTYpLCBpdik7XG4gIGlmICghY2lwaGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjaXBoZXInKTtcbiAgfVxuXG4gIHZhciBjaXBoZXJ0ZXh0ID0gcnVuQ2lwaGVyQnVmZmVyKGNpcGhlciwgdGhpcy5wcml2S2V5KTtcblxuICB2YXIgbWFjID0gZXRoVXRpbC5rZWNjYWsyNTYoQnVmZmVyLmNvbmNhdChbZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpLCBCdWZmZXIuZnJvbShjaXBoZXJ0ZXh0LCAnaGV4JyldKSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAzLFxuICAgIGlkOiB1dWlkdjQoeyByYW5kb206IG9wdHMudXVpZCB8fCByYW5kb21CeXRlcygxNikgfSksXG4gICAgYWRkcmVzczogdGhpcy5nZXRBZGRyZXNzKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgIGNyeXB0bzoge1xuICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dC50b1N0cmluZygnaGV4JyksXG4gICAgICBjaXBoZXJwYXJhbXM6IHtcbiAgICAgICAgaXY6IGl2LnRvU3RyaW5nKCdoZXgnKVxuICAgICAgfSxcbiAgICAgIGNpcGhlcjogb3B0cy5jaXBoZXIgfHwgJ2Flcy0xMjgtY3RyJyxcbiAgICAgIGtkZjoga2RmLFxuICAgICAga2RmcGFyYW1zOiBrZGZwYXJhbXMsXG4gICAgICBtYWM6IG1hYy50b1N0cmluZygnaGV4JylcbiAgICB9XG4gIH07XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldFYzRmlsZW5hbWUgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gIC8qXG4gICAqIFdlIHdhbnQgYSB0aW1lc3RhbXAgbGlrZSAyMDE2LTAzLTE1VDE3LTExLTMzLjAwNzU5ODI4OFouIERhdGUgZm9ybWF0dGluZ1xuICAgKiBpcyBhIHBhaW4gaW4gSmF2YXNjcmlwdCwgZXZlcmJvZHkga25vd3MgdGhhdC4gV2UgY291bGQgdXNlIG1vbWVudC5qcyxcbiAgICogYnV0IGRlY2lkZSB0byBkbyBpdCBtYW51YWxseSBpbiBvcmRlciB0byBzYXZlIHNwYWNlLlxuICAgKlxuICAgKiB0b0pTT04oKSByZXR1cm5zIGEgcHJldHR5IGNsb3NlIHZlcnNpb24sIHNvIGxldCdzIHVzZSBpdC4gSXQgaXMgbm90IFVUQyB0aG91Z2gsXG4gICAqIGJ1dCBkb2VzIGl0IHJlYWxseSBtYXR0ZXI/XG4gICAqXG4gICAqIEFsdGVybmF0aXZlIG1hbnVhbCB3YXkgd2l0aCBwYWRkaW5nIGFuZCBEYXRlIGZpZWxkczogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzI0NDI4OC80OTY0ODE5XG4gICAqXG4gICAqL1xuICB2YXIgdHMgPSB0aW1lc3RhbXAgPyBuZXcgRGF0ZSh0aW1lc3RhbXApIDogbmV3IERhdGUoKTtcblxuICByZXR1cm4gWydVVEMtLScsIHRzLnRvSlNPTigpLnJlcGxhY2UoLzovZywgJy0nKSwgJy0tJywgdGhpcy5nZXRBZGRyZXNzKCkudG9TdHJpbmcoJ2hleCcpXS5qb2luKCcnKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUudG9WM1N0cmluZyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0cykge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b1YzKHBhc3N3b3JkLCBvcHRzKSk7XG59O1xuXG5XYWxsZXQuZnJvbVB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWIsIG5vblN0cmljdCkge1xuICBpZiAobm9uU3RyaWN0KSB7XG4gICAgcHViID0gZXRoVXRpbC5pbXBvcnRQdWJsaWMocHViKTtcbiAgfVxuICByZXR1cm4gbmV3IFdhbGxldChudWxsLCBwdWIpO1xufTtcblxuV2FsbGV0LmZyb21FeHRlbmRlZFB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWIpIHtcbiAgYXNzZXJ0KHB1Yi5zbGljZSgwLCA0KSA9PT0gJ3hwdWInLCAnTm90IGFuIGV4dGVuZGVkIHB1YmxpYyBrZXknKTtcbiAgcHViID0gYnM1OGNoZWNrLmRlY29kZShwdWIpLnNsaWNlKDQ1KTtcbiAgLy8gQ29udmVydCB0byBhbiBFdGhlcmV1bSBwdWJsaWMga2V5XG4gIHJldHVybiBXYWxsZXQuZnJvbVB1YmxpY0tleShwdWIsIHRydWUpO1xufTtcblxuV2FsbGV0LmZyb21Qcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXYpIHtcbiAgcmV0dXJuIG5ldyBXYWxsZXQocHJpdik7XG59O1xuXG5XYWxsZXQuZnJvbUV4dGVuZGVkUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2KSB7XG4gIGFzc2VydChwcml2LnNsaWNlKDAsIDQpID09PSAneHBydicsICdOb3QgYW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXknKTtcbiAgdmFyIHRtcCA9IGJzNThjaGVjay5kZWNvZGUocHJpdik7XG4gIGFzc2VydCh0bXBbNDVdID09PSAwLCAnSW52YWxpZCBleHRlbmRlZCBwcml2YXRlIGtleScpO1xuICByZXR1cm4gV2FsbGV0LmZyb21Qcml2YXRlS2V5KHRtcC5zbGljZSg0NikpO1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL3dpa2kvUGFzc3BocmFzZS1wcm90ZWN0ZWQta2V5LXN0b3JlLXNwZWNcbldhbGxldC5mcm9tVjEgPSBmdW5jdGlvbiAoaW5wdXQsIHBhc3N3b3JkKSB7XG4gIGFzc2VydCh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKTtcbiAgdmFyIGpzb24gPSAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCkpID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShpbnB1dCk7XG5cbiAgaWYgKGpzb24uVmVyc2lvbiAhPT0gJzEnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBWMSB3YWxsZXQnKTtcbiAgfVxuXG4gIGlmIChqc29uLkNyeXB0by5LZXlIZWFkZXIuS2RmICE9PSAnc2NyeXB0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gc2NoZW1lJyk7XG4gIH1cblxuICB2YXIga2RmcGFyYW1zID0ganNvbi5DcnlwdG8uS2V5SGVhZGVyLktkZlBhcmFtcztcbiAgdmFyIGRlcml2ZWRLZXkgPSBzY3J5cHRzeShCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGpzb24uQ3J5cHRvLlNhbHQsICdoZXgnKSwga2RmcGFyYW1zLk4sIGtkZnBhcmFtcy5SLCBrZGZwYXJhbXMuUCwga2RmcGFyYW1zLkRrTGVuKTtcblxuICB2YXIgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGpzb24uQ3J5cHRvLkNpcGhlclRleHQsICdoZXgnKTtcblxuICB2YXIgbWFjID0gZXRoVXRpbC5rZWNjYWsyNTYoQnVmZmVyLmNvbmNhdChbZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpO1xuXG4gIGlmIChtYWMudG9TdHJpbmcoJ2hleCcpICE9PSBqc29uLkNyeXB0by5NQUMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBkZXJpdmF0aW9uIGZhaWxlZCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgfVxuXG4gIHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMTI4LWNiYycsIGV0aFV0aWwua2VjY2FrMjU2KGRlcml2ZWRLZXkuc2xpY2UoMCwgMTYpKS5zbGljZSgwLCAxNiksIEJ1ZmZlci5mcm9tKGpzb24uQ3J5cHRvLklWLCAnaGV4JykpO1xuICB2YXIgc2VlZCA9IHJ1bkNpcGhlckJ1ZmZlcihkZWNpcGhlciwgY2lwaGVydGV4dCk7XG5cbiAgcmV0dXJuIG5ldyBXYWxsZXQoc2VlZCk7XG59O1xuXG5XYWxsZXQuZnJvbVYzID0gZnVuY3Rpb24gKGlucHV0LCBwYXNzd29yZCwgbm9uU3RyaWN0KSB7XG4gIGFzc2VydCh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKTtcbiAgdmFyIGpzb24gPSAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCkpID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShub25TdHJpY3QgPyBpbnB1dC50b0xvd2VyQ2FzZSgpIDogaW5wdXQpO1xuXG4gIGlmIChqc29uLnZlcnNpb24gIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIFYzIHdhbGxldCcpO1xuICB9XG5cbiAgdmFyIGRlcml2ZWRLZXk7XG4gIHZhciBrZGZwYXJhbXM7XG4gIGlmIChqc29uLmNyeXB0by5rZGYgPT09ICdzY3J5cHQnKSB7XG4gICAga2RmcGFyYW1zID0ganNvbi5jcnlwdG8ua2RmcGFyYW1zO1xuXG4gICAgLy8gRklYTUU6IHN1cHBvcnQgcHJvZ3Jlc3MgcmVwb3J0aW5nIGNhbGxiYWNrXG4gICAgZGVyaXZlZEtleSA9IHNjcnlwdHN5KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oa2RmcGFyYW1zLnNhbHQsICdoZXgnKSwga2RmcGFyYW1zLm4sIGtkZnBhcmFtcy5yLCBrZGZwYXJhbXMucCwga2RmcGFyYW1zLmRrbGVuKTtcbiAgfSBlbHNlIGlmIChqc29uLmNyeXB0by5rZGYgPT09ICdwYmtkZjInKSB7XG4gICAga2RmcGFyYW1zID0ganNvbi5jcnlwdG8ua2RmcGFyYW1zO1xuXG4gICAgaWYgKGtkZnBhcmFtcy5wcmYgIT09ICdobWFjLXNoYTI1NicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVycyB0byBQQktERjInKTtcbiAgICB9XG5cbiAgICBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShrZGZwYXJhbXMuc2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMuYywga2RmcGFyYW1zLmRrbGVuLCAnc2hhMjU2Jyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBzY2hlbWUnKTtcbiAgfVxuXG4gIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oanNvbi5jcnlwdG8uY2lwaGVydGV4dCwgJ2hleCcpO1xuXG4gIHZhciBtYWMgPSBldGhVdGlsLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtkZXJpdmVkS2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSk7XG4gIGlmIChtYWMudG9TdHJpbmcoJ2hleCcpICE9PSBqc29uLmNyeXB0by5tYWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBkZXJpdmF0aW9uIGZhaWxlZCAtIHBvc3NpYmx5IHdyb25nIHBhc3NwaHJhc2UnKTtcbiAgfVxuXG4gIHZhciBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGpzb24uY3J5cHRvLmNpcGhlciwgZGVyaXZlZEtleS5zbGljZSgwLCAxNiksIEJ1ZmZlci5mcm9tKGpzb24uY3J5cHRvLmNpcGhlcnBhcmFtcy5pdiwgJ2hleCcpKTtcbiAgdmFyIHNlZWQgPSBydW5DaXBoZXJCdWZmZXIoZGVjaXBoZXIsIGNpcGhlcnRleHQpO1xuXG4gIHJldHVybiBuZXcgV2FsbGV0KHNlZWQpO1xufTtcblxuLypcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9weWV0aHNhbGV0b29sL2Jsb2IvbWFzdGVyL3B5ZXRoc2FsZXRvb2wucHlcbiAqIEpTT04gZmllbGRzOiBlbmNzZWVkLCBldGhhZGRyLCBidGNhZGRyLCBlbWFpbFxuICovXG5XYWxsZXQuZnJvbUV0aFNhbGUgPSBmdW5jdGlvbiAoaW5wdXQsIHBhc3N3b3JkKSB7XG4gIGFzc2VydCh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKTtcbiAgdmFyIGpzb24gPSAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbnB1dCkpID09PSAnb2JqZWN0JyA/IGlucHV0IDogSlNPTi5wYXJzZShpbnB1dCk7XG5cbiAgdmFyIGVuY3NlZWQgPSBCdWZmZXIuZnJvbShqc29uLmVuY3NlZWQsICdoZXgnKTtcblxuICAvLyBrZXkgZGVyaXZhdGlvblxuICB2YXIgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBwYXNzd29yZCwgMjAwMCwgMzIsICdzaGEyNTYnKS5zbGljZSgwLCAxNik7XG5cbiAgLy8gc2VlZCBkZWNvZGluZyAoSVYgaXMgZmlyc3QgMTYgYnl0ZXMpXG4gIC8vIE5PVEU6IGNyeXB0byAoZGVyaXZlZCBmcm9tIG9wZW5zc2wpIHdoZW4gdXNlZCB3aXRoIGFlcy0qLWNiYyB3aWxsIGhhbmRsZSBQS0NTIzcgcGFkZGluZyBpbnRlcm5hbGx5XG4gIC8vICAgICAgIHNlZSBhbHNvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNjE0NzcwLzQ5NjQ4MTlcbiAgdmFyIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0xMjgtY2JjJywgZGVyaXZlZEtleSwgZW5jc2VlZC5zbGljZSgwLCAxNikpO1xuICB2YXIgc2VlZCA9IHJ1bkNpcGhlckJ1ZmZlcihkZWNpcGhlciwgZW5jc2VlZC5zbGljZSgxNikpO1xuXG4gIHZhciB3YWxsZXQgPSBuZXcgV2FsbGV0KGV0aFV0aWwua2VjY2FrMjU2KHNlZWQpKTtcbiAgaWYgKHdhbGxldC5nZXRBZGRyZXNzKCkudG9TdHJpbmcoJ2hleCcpICE9PSBqc29uLmV0aGFkZHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZWQga2V5IG1pc21hdGNoIC0gcG9zc2libHkgd3JvbmcgcGFzc3BocmFzZScpO1xuICB9XG4gIHJldHVybiB3YWxsZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdhbGxldDsiLCJpbXBvcnQgeyBzdHJpY3QgYXMgYXNzZXJ0IH0gZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IENvbXBvc2VkU3RvcmUsIE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgSnNvblJwY0VuZ2luZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBwcm92aWRlckZyb21FbmdpbmUgfSBmcm9tICdldGgtanNvbi1ycGMtbWlkZGxld2FyZSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7XG4gIGNyZWF0ZVN3YXBwYWJsZVByb3h5LFxuICBjcmVhdGVFdmVudEVtaXR0ZXJQcm94eSxcbn0gZnJvbSAnc3dhcHBhYmxlLW9iai1wcm94eSc7XG5pbXBvcnQgRXRoUXVlcnkgZnJvbSAnZXRoLXF1ZXJ5JztcbmltcG9ydCB7XG4gIFJJTktFQlksXG4gIE1BSU5ORVQsXG4gIElORlVSQV9QUk9WSURFUl9UWVBFUyxcbiAgTkVUV09SS19UWVBFX1JQQyxcbiAgTkVUV09SS19UWVBFX1RPX0lEX01BUCxcbiAgTUFJTk5FVF9DSEFJTl9JRCxcbiAgUklOS0VCWV9DSEFJTl9JRCxcbiAgSU5GVVJBX0JMT0NLRURfS0VZLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCB7XG4gIGlzUHJlZml4ZWRGb3JtYXR0ZWRIZXhTdHJpbmcsXG4gIGlzU2FmZUNoYWluSWQsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL25ldHdvcmsudXRpbHMnO1xuaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvZmV0Y2gtd2l0aC10aW1lb3V0JztcbmltcG9ydCBjcmVhdGVNZXRhbWFza01pZGRsZXdhcmUgZnJvbSAnLi9jcmVhdGVNZXRhbWFza01pZGRsZXdhcmUnO1xuaW1wb3J0IGNyZWF0ZUluZnVyYUNsaWVudCBmcm9tICcuL2NyZWF0ZUluZnVyYUNsaWVudCc7XG5pbXBvcnQgY3JlYXRlSnNvblJwY0NsaWVudCBmcm9tICcuL2NyZWF0ZUpzb25ScGNDbGllbnQnO1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudi5NRVRBTUFTS19FTlY7XG5jb25zdCBmZXRjaFdpdGhUaW1lb3V0ID0gZ2V0RmV0Y2hXaXRoVGltZW91dChTRUNPTkQgKiAzMCk7XG5cbmxldCBkZWZhdWx0UHJvdmlkZXJDb25maWdPcHRzO1xuaWYgKHByb2Nlc3MuZW52LklOX1RFU1QpIHtcbiAgZGVmYXVsdFByb3ZpZGVyQ29uZmlnT3B0cyA9IHtcbiAgICB0eXBlOiBORVRXT1JLX1RZUEVfUlBDLFxuICAgIHJwY1VybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODU0NScsXG4gICAgY2hhaW5JZDogJzB4NTM5JyxcbiAgICBuaWNrbmFtZTogJ0xvY2FsaG9zdCA4NTQ1JyxcbiAgfTtcbn0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTUVUQU1BU0tfREVCVUcgfHwgZW52ID09PSAndGVzdCcpIHtcbiAgZGVmYXVsdFByb3ZpZGVyQ29uZmlnT3B0cyA9IHsgdHlwZTogUklOS0VCWSwgY2hhaW5JZDogUklOS0VCWV9DSEFJTl9JRCB9O1xufSBlbHNlIHtcbiAgZGVmYXVsdFByb3ZpZGVyQ29uZmlnT3B0cyA9IHsgdHlwZTogTUFJTk5FVCwgY2hhaW5JZDogTUFJTk5FVF9DSEFJTl9JRCB9O1xufVxuXG5jb25zdCBkZWZhdWx0UHJvdmlkZXJDb25maWcgPSB7XG4gIHRpY2tlcjogJ0VUSCcsXG4gIC4uLmRlZmF1bHRQcm92aWRlckNvbmZpZ09wdHMsXG59O1xuXG5jb25zdCBkZWZhdWx0TmV0d29ya0RldGFpbHNTdGF0ZSA9IHtcbiAgRUlQUzogeyAxNTU5OiB1bmRlZmluZWQgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBORVRXT1JLX0VWRU5UUyA9IHtcbiAgLy8gRmlyZWQgYWZ0ZXIgdGhlIGFjdGl2ZWx5IHNlbGVjdGVkIG5ldHdvcmsgaXMgY2hhbmdlZFxuICBORVRXT1JLX0RJRF9DSEFOR0U6ICduZXR3b3JrRGlkQ2hhbmdlJyxcbiAgLy8gRmlyZWQgd2hlbiB0aGUgYWN0aXZlbHkgc2VsZWN0ZWQgbmV0d29yayAqd2lsbCogY2hhbmdlXG4gIE5FVFdPUktfV0lMTF9DSEFOR0U6ICduZXR3b3JrV2lsbENoYW5nZScsXG4gIC8vIEZpcmVkIHdoZW4gSW5mdXJhIHJldHVybnMgYW4gZXJyb3IgaW5kaWNhdGluZyBubyBzdXBwb3J0XG4gIElORlVSQV9JU19CTE9DS0VEOiAnaW5mdXJhSXNCbG9ja2VkJyxcbiAgLy8gRmlyZWQgd2hlbiBub3QgdXNpbmcgYW4gSW5mdXJhIG5ldHdvcmsgb3Igd2hlbiBJbmZ1cmEgcmV0dXJucyBubyBlcnJvciwgaW5kaWNhdGluZyBzdXBwb3J0XG4gIElORlVSQV9JU19VTkJMT0NLRUQ6ICdpbmZ1cmFJc1VuYmxvY2tlZCcsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXR3b3JrQ29udHJvbGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBjcmVhdGUgc3RvcmVzXG4gICAgdGhpcy5wcm92aWRlclN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZShcbiAgICAgIG9wdHMucHJvdmlkZXIgfHwgeyAuLi5kZWZhdWx0UHJvdmlkZXJDb25maWcgfSxcbiAgICApO1xuICAgIHRoaXMucHJldmlvdXNQcm92aWRlclN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZShcbiAgICAgIHRoaXMucHJvdmlkZXJTdG9yZS5nZXRTdGF0ZSgpLFxuICAgICk7XG4gICAgdGhpcy5uZXR3b3JrU3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKCdsb2FkaW5nJyk7XG4gICAgLy8gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGEgZmV3IGRldGFpbHMgYWJvdXQgdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgIC8vIElkZWFsbHkgd2UnZCBtZXJnZSB0aGlzLm5ldHdvcmtTdG9yZSB3aXRoIHRoaXMgbmV3IHN0b3JlLCBidXQgZG9pbmcgc29cbiAgICAvLyB3aWxsIHJlcXVpcmUgYSBkZWNlbnQgc2l6ZWQgcmVmYWN0b3Igb2YgaG93IHdlJ3JlIGFjY2Vzc2luZyBuZXR3b3JrXG4gICAgLy8gc3RhdGUuIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgZGV0ZWN0aW5nIEVJUCAxNTU5IHN1cHBvcnQgYnV0XG4gICAgLy8gY2FuIGJlIGV4dGVuZGVkIHRvIHRyYWNrIG90aGVyIG5ldHdvcmsgZGV0YWlscy5cbiAgICB0aGlzLm5ldHdvcmtEZXRhaWxzID0gbmV3IE9ic2VydmFibGVTdG9yZShcbiAgICAgIG9wdHMubmV0d29ya0RldGFpbHMgfHwge1xuICAgICAgICAuLi5kZWZhdWx0TmV0d29ya0RldGFpbHNTdGF0ZSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IENvbXBvc2VkU3RvcmUoe1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJTdG9yZSxcbiAgICAgIHByZXZpb3VzUHJvdmlkZXJTdG9yZTogdGhpcy5wcmV2aW91c1Byb3ZpZGVyU3RvcmUsXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmtTdG9yZSxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiB0aGlzLm5ldHdvcmtEZXRhaWxzLFxuICAgIH0pO1xuXG4gICAgLy8gcHJvdmlkZXIgYW5kIGJsb2NrIHRyYWNrZXJcbiAgICB0aGlzLl9wcm92aWRlciA9IG51bGw7XG4gICAgdGhpcy5fYmxvY2tUcmFja2VyID0gbnVsbDtcblxuICAgIC8vIHByb3ZpZGVyIGFuZCBibG9jayB0cmFja2VyIHByb3hpZXMgLSBiZWNhdXNlIHRoZSBuZXR3b3JrIGNoYW5nZXNcbiAgICB0aGlzLl9wcm92aWRlclByb3h5ID0gbnVsbDtcbiAgICB0aGlzLl9ibG9ja1RyYWNrZXJQcm94eSA9IG51bGw7XG5cbiAgICB0aGlzLm9uKE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSwgdGhpcy5sb29rdXBOZXR3b3JrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBJbmZ1cmEgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkIC0gVGhlIEluZnVyYSBwcm9qZWN0IElEXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgcHJvamVjdCBJRCBpcyBub3QgYSB2YWxpZCBzdHJpbmdcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHNldEluZnVyYVByb2plY3RJZChwcm9qZWN0SWQpIHtcbiAgICBpZiAoIXByb2plY3RJZCB8fCB0eXBlb2YgcHJvamVjdElkICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEluZnVyYSBwcm9qZWN0IElEJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mdXJhUHJvamVjdElkID0gcHJvamVjdElkO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVByb3ZpZGVyKHByb3ZpZGVyUGFyYW1zKSB7XG4gICAgdGhpcy5fYmFzZVByb3ZpZGVyUGFyYW1zID0gcHJvdmlkZXJQYXJhbXM7XG4gICAgY29uc3QgeyB0eXBlLCBycGNVcmwsIGNoYWluSWQgfSA9IHRoaXMuZ2V0UHJvdmlkZXJDb25maWcoKTtcbiAgICB0aGlzLl9jb25maWd1cmVQcm92aWRlcih7IHR5cGUsIHJwY1VybCwgY2hhaW5JZCB9KTtcbiAgICB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgcHJveGllcyBzbyB0aGUgcmVmZXJlbmNlcyB3aWxsIGFsd2F5cyBiZSBnb29kXG4gIGdldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5fcHJvdmlkZXJQcm94eTtcbiAgICBjb25zdCBibG9ja1RyYWNrZXIgPSB0aGlzLl9ibG9ja1RyYWNrZXJQcm94eTtcbiAgICByZXR1cm4geyBwcm92aWRlciwgYmxvY2tUcmFja2VyIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIHJldHVybiB0aGUgbGF0ZXN0IGJsb2NrIGZvciB0aGUgY3VycmVudCBuZXR3b3JrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEJsb2NrIGhlYWRlclxuICAgKi9cbiAgZ2V0TGF0ZXN0QmxvY2soKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHRoaXMuZ2V0UHJvdmlkZXJBbmRCbG9ja1RyYWNrZXIoKTtcbiAgICAgIGNvbnN0IGV0aFF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KHByb3ZpZGVyKTtcbiAgICAgIGV0aFF1ZXJ5LnNlbmRBc3luYyhcbiAgICAgICAgeyBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsIHBhcmFtczogWydsYXRlc3QnLCBmYWxzZV0gfSxcbiAgICAgICAgKGVyciwgYmxvY2spID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKGJsb2NrKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBibG9jayBoZWFkZXIgY29udGFpbnMgZmllbGRzIHRoYXQgaW5kaWNhdGUgRUlQIDE1NTlcbiAgICogc3VwcG9ydCAoYmFzZUZlZVBlckdhcykuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIGlmIGN1cnJlbnQgbmV0d29yayBzdXBwb3J0cyBFSVAgMTU1OVxuICAgKi9cbiAgYXN5bmMgZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgY29uc3QgeyBFSVBTIH0gPSB0aGlzLm5ldHdvcmtEZXRhaWxzLmdldFN0YXRlKCk7XG4gICAgaWYgKEVJUFNbMTU1OV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEVJUFNbMTU1OV07XG4gICAgfVxuICAgIGNvbnN0IGxhdGVzdEJsb2NrID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9jaygpO1xuICAgIGNvbnN0IHN1cHBvcnRzRUlQMTU1OSA9XG4gICAgICBsYXRlc3RCbG9jayAmJiBsYXRlc3RCbG9jay5iYXNlRmVlUGVyR2FzICE9PSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZXROZXR3b3JrRUlQU3VwcG9ydCgxNTU5LCBzdXBwb3J0c0VJUDE1NTkpO1xuICAgIHJldHVybiBzdXBwb3J0c0VJUDE1NTk7XG4gIH1cblxuICB2ZXJpZnlOZXR3b3JrKCkge1xuICAgIC8vIENoZWNrIG5ldHdvcmsgd2hlbiByZXN0b3JpbmcgY29ubmVjdGl2aXR5OlxuICAgIGlmICh0aGlzLmlzTmV0d29ya0xvYWRpbmcoKSkge1xuICAgICAgdGhpcy5sb29rdXBOZXR3b3JrKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TmV0d29ya1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLm5ldHdvcmtTdG9yZS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgc2V0TmV0d29ya1N0YXRlKG5ldHdvcmspIHtcbiAgICB0aGlzLm5ldHdvcmtTdG9yZS5wdXRTdGF0ZShuZXR3b3JrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgRUlQIHN1cHBvcnQgaW5kaWNhdGlvbiBpbiB0aGUgbmV0d29ya0RldGFpbHMgc3RvcmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IEVJUE51bWJlciAtIFRoZSBudW1iZXIgb2YgdGhlIEVJUCB0byBtYXJrIHN1cHBvcnQgZm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdXBwb3J0ZWQgLSBUcnVlIGlmIHRoZSBFSVAgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBzZXROZXR3b3JrRUlQU3VwcG9ydChFSVBOdW1iZXIsIGlzU3VwcG9ydGVkKSB7XG4gICAgdGhpcy5uZXR3b3JrRGV0YWlscy51cGRhdGVTdGF0ZSh7XG4gICAgICBFSVBTOiB7XG4gICAgICAgIFtFSVBOdW1iZXJdOiBpc1N1cHBvcnRlZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgRUlQIHN1cHBvcnQgdG8gZGVmYXVsdCAobm8gc3VwcG9ydClcbiAgICovXG4gIGNsZWFyTmV0d29ya0RldGFpbHMoKSB7XG4gICAgdGhpcy5uZXR3b3JrRGV0YWlscy5wdXRTdGF0ZSh7IC4uLmRlZmF1bHROZXR3b3JrRGV0YWlsc1N0YXRlIH0pO1xuICB9XG5cbiAgaXNOZXR3b3JrTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROZXR3b3JrU3RhdGUoKSA9PT0gJ2xvYWRpbmcnO1xuICB9XG5cbiAgbG9va3VwTmV0d29yaygpIHtcbiAgICAvLyBQcmV2ZW50IGZpcmluZyB3aGVuIHByb3ZpZGVyIGlzIG5vdCBkZWZpbmVkLlxuICAgIGlmICghdGhpcy5fcHJvdmlkZXIpIHtcbiAgICAgIGxvZy53YXJuKFxuICAgICAgICAnTmV0d29ya0NvbnRyb2xsZXIgLSBsb29rdXBOZXR3b3JrIGFib3J0ZWQgZHVlIHRvIG1pc3NpbmcgcHJvdmlkZXInLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFpbklkID0gdGhpcy5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgbG9nLndhcm4oXG4gICAgICAgICdOZXR3b3JrQ29udHJvbGxlciAtIGxvb2t1cE5ldHdvcmsgYWJvcnRlZCBkdWUgdG8gbWlzc2luZyBjaGFpbklkJyxcbiAgICAgICk7XG4gICAgICB0aGlzLnNldE5ldHdvcmtTdGF0ZSgnbG9hZGluZycpO1xuICAgICAgLy8ga2VlcCBuZXR3b3JrIGRldGFpbHMgaW4gc3luYyB3aXRoIG5ldHdvcmsgc3RhdGVcbiAgICAgIHRoaXMuY2xlYXJOZXR3b3JrRGV0YWlscygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFBpbmcgdGhlIFJQQyBlbmRwb2ludCBzbyB3ZSBjYW4gY29uZmlybSB0aGF0IGl0IHdvcmtzXG4gICAgY29uc3QgZXRoUXVlcnkgPSBuZXcgRXRoUXVlcnkodGhpcy5fcHJvdmlkZXIpO1xuICAgIGNvbnN0IGluaXRpYWxOZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHRoaXMuZ2V0UHJvdmlkZXJDb25maWcoKTtcbiAgICBjb25zdCBpc0luZnVyYSA9IElORlVSQV9QUk9WSURFUl9UWVBFUy5pbmNsdWRlcyh0eXBlKTtcblxuICAgIGlmIChpc0luZnVyYSkge1xuICAgICAgdGhpcy5fY2hlY2tJbmZ1cmFBdmFpbGFiaWxpdHkodHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdChORVRXT1JLX0VWRU5UUy5JTkZVUkFfSVNfVU5CTE9DS0VEKTtcbiAgICB9XG5cbiAgICBldGhRdWVyeS5zZW5kQXN5bmMoeyBtZXRob2Q6ICduZXRfdmVyc2lvbicgfSwgKGVyciwgbmV0d29ya1ZlcnNpb24pID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgIGlmIChpbml0aWFsTmV0d29yayA9PT0gY3VycmVudE5ldHdvcmspIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuc2V0TmV0d29ya1N0YXRlKCdsb2FkaW5nJyk7XG4gICAgICAgICAgLy8ga2VlcCBuZXR3b3JrIGRldGFpbHMgaW4gc3luYyB3aXRoIG5ldHdvcmsgc3RhdGVcbiAgICAgICAgICB0aGlzLmNsZWFyTmV0d29ya0RldGFpbHMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE5ldHdvcmtTdGF0ZShuZXR3b3JrVmVyc2lvbik7XG4gICAgICAgIC8vIGxvb2sgdXAgRUlQLTE1NTkgc3VwcG9ydFxuICAgICAgICB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRDdXJyZW50Q2hhaW5JZCgpIHtcbiAgICBjb25zdCB7IHR5cGUsIGNoYWluSWQ6IGNvbmZpZ0NoYWluSWQgfSA9IHRoaXMuZ2V0UHJvdmlkZXJDb25maWcoKTtcbiAgICByZXR1cm4gTkVUV09SS19UWVBFX1RPX0lEX01BUFt0eXBlXT8uY2hhaW5JZCB8fCBjb25maWdDaGFpbklkO1xuICB9XG5cbiAgc2V0UnBjVGFyZ2V0KHJwY1VybCwgY2hhaW5JZCwgdGlja2VyID0gJ0VUSCcsIG5pY2tuYW1lID0gJycsIHJwY1ByZWZzKSB7XG4gICAgYXNzZXJ0Lm9rKFxuICAgICAgaXNQcmVmaXhlZEZvcm1hdHRlZEhleFN0cmluZyhjaGFpbklkKSxcbiAgICAgIGBJbnZhbGlkIGNoYWluIElEIFwiJHtjaGFpbklkfVwiOiBpbnZhbGlkIGhleCBzdHJpbmcuYCxcbiAgICApO1xuICAgIGFzc2VydC5vayhcbiAgICAgIGlzU2FmZUNoYWluSWQocGFyc2VJbnQoY2hhaW5JZCwgMTYpKSxcbiAgICAgIGBJbnZhbGlkIGNoYWluIElEIFwiJHtjaGFpbklkfVwiOiBudW1lcmljYWwgdmFsdWUgZ3JlYXRlciB0aGFuIG1heCBzYWZlIHZhbHVlLmAsXG4gICAgKTtcbiAgICB0aGlzLnNldFByb3ZpZGVyQ29uZmlnKHtcbiAgICAgIHR5cGU6IE5FVFdPUktfVFlQRV9SUEMsXG4gICAgICBycGNVcmwsXG4gICAgICBjaGFpbklkLFxuICAgICAgdGlja2VyLFxuICAgICAgbmlja25hbWUsXG4gICAgICBycGNQcmVmcyxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNldFByb3ZpZGVyVHlwZSh0eXBlKSB7XG4gICAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKFxuICAgICAgdHlwZSxcbiAgICAgIE5FVFdPUktfVFlQRV9SUEMsXG4gICAgICBgTmV0d29ya0NvbnRyb2xsZXIgLSBjYW5ub3QgY2FsbCBcInNldFByb3ZpZGVyVHlwZVwiIHdpdGggdHlwZSBcIiR7TkVUV09SS19UWVBFX1JQQ31cIi4gVXNlIFwic2V0UnBjVGFyZ2V0XCJgLFxuICAgICk7XG4gICAgYXNzZXJ0Lm9rKFxuICAgICAgSU5GVVJBX1BST1ZJREVSX1RZUEVTLmluY2x1ZGVzKHR5cGUpLFxuICAgICAgYFVua25vd24gSW5mdXJhIHByb3ZpZGVyIHR5cGUgXCIke3R5cGV9XCIuYCxcbiAgICApO1xuICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gTkVUV09SS19UWVBFX1RPX0lEX01BUFt0eXBlXTtcbiAgICB0aGlzLnNldFByb3ZpZGVyQ29uZmlnKHtcbiAgICAgIHR5cGUsXG4gICAgICBycGNVcmw6ICcnLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHRpY2tlcjogJ0VUSCcsXG4gICAgICBuaWNrbmFtZTogJycsXG4gICAgfSk7XG4gIH1cblxuICByZXNldENvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRQcm92aWRlckNvbmZpZyh0aGlzLmdldFByb3ZpZGVyQ29uZmlnKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb3ZpZGVyIGNvbmZpZyBhbmQgc3dpdGNoZXMgdGhlIG5ldHdvcmsuXG4gICAqL1xuICBzZXRQcm92aWRlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLnByZXZpb3VzUHJvdmlkZXJTdG9yZS51cGRhdGVTdGF0ZSh0aGlzLmdldFByb3ZpZGVyQ29uZmlnKCkpO1xuICAgIHRoaXMucHJvdmlkZXJTdG9yZS51cGRhdGVTdGF0ZShjb25maWcpO1xuICAgIHRoaXMuX3N3aXRjaE5ldHdvcmsoY29uZmlnKTtcbiAgfVxuXG4gIHJvbGxiYWNrVG9QcmV2aW91c1Byb3ZpZGVyKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucHJldmlvdXNQcm92aWRlclN0b3JlLmdldFN0YXRlKCk7XG4gICAgdGhpcy5wcm92aWRlclN0b3JlLnVwZGF0ZVN0YXRlKGNvbmZpZyk7XG4gICAgdGhpcy5fc3dpdGNoTmV0d29yayhjb25maWcpO1xuICB9XG5cbiAgZ2V0UHJvdmlkZXJDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJTdG9yZS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgZ2V0TmV0d29ya0lkZW50aWZpZXIoKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyU3RvcmUuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gcHJvdmlkZXIudHlwZSA9PT0gTkVUV09SS19UWVBFX1JQQyA/IHByb3ZpZGVyLnJwY1VybCA6IHByb3ZpZGVyLnR5cGU7XG4gIH1cblxuICAvL1xuICAvLyBQcml2YXRlXG4gIC8vXG5cbiAgYXN5bmMgX2NoZWNrSW5mdXJhQXZhaWxhYmlsaXR5KG5ldHdvcmspIHtcbiAgICBjb25zdCBycGNVcmwgPSBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pby92My8ke3RoaXMuX2luZnVyYVByb2plY3RJZH1gO1xuXG4gICAgbGV0IG5ldHdvcmtDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5vbmNlKE5FVFdPUktfRVZFTlRTLk5FVFdPUktfRElEX0NIQU5HRSwgKCkgPT4ge1xuICAgICAgbmV0d29ya0NoYW5nZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChycGNVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBtZXRob2Q6ICdldGhfYmxvY2tOdW1iZXInLFxuICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXR3b3JrQ2hhbmdlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICB0aGlzLmVtaXQoTkVUV09SS19FVkVOVFMuSU5GVVJBX0lTX1VOQkxPQ0tFRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChuZXR3b3JrQ2hhbmdlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yID09PSBJTkZVUkFfQkxPQ0tFRF9LRVkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoTkVUV09SS19FVkVOVFMuSU5GVVJBX0lTX0JMT0NLRUQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihgTWV0YU1hc2sgLSBJbmZ1cmEgYXZhaWxhYmlsaXR5IGNoZWNrIGZhaWxlZGAsIGVycik7XG4gICAgfVxuICB9XG5cbiAgX3N3aXRjaE5ldHdvcmsob3B0cykge1xuICAgIC8vIEluZGljYXRlIHRvIHN1YnNjcmliZXJzIHRoYXQgbmV0d29yayBpcyBhYm91dCB0byBjaGFuZ2VcbiAgICB0aGlzLmVtaXQoTkVUV09SS19FVkVOVFMuTkVUV09SS19XSUxMX0NIQU5HRSk7XG4gICAgLy8gU2V0IGxvYWRpbmcgc3RhdGVcbiAgICB0aGlzLnNldE5ldHdvcmtTdGF0ZSgnbG9hZGluZycpO1xuICAgIC8vIFJlc2V0IG5ldHdvcmsgZGV0YWlsc1xuICAgIHRoaXMuY2xlYXJOZXR3b3JrRGV0YWlscygpO1xuICAgIC8vIENvbmZpZ3VyZSB0aGUgcHJvdmlkZXIgYXBwcm9wcmlhdGVseVxuICAgIHRoaXMuX2NvbmZpZ3VyZVByb3ZpZGVyKG9wdHMpO1xuICAgIC8vIE5vdGlmeSBzdWJzY3JpYmVycyB0aGF0IG5ldHdvcmsgaGFzIGNoYW5nZWRcbiAgICB0aGlzLmVtaXQoTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLCBvcHRzLnR5cGUpO1xuICB9XG5cbiAgX2NvbmZpZ3VyZVByb3ZpZGVyKHsgdHlwZSwgcnBjVXJsLCBjaGFpbklkIH0pIHtcbiAgICAvLyBpbmZ1cmEgdHlwZS1iYXNlZCBlbmRwb2ludHNcbiAgICBjb25zdCBpc0luZnVyYSA9IElORlVSQV9QUk9WSURFUl9UWVBFUy5pbmNsdWRlcyh0eXBlKTtcbiAgICBpZiAoaXNJbmZ1cmEpIHtcbiAgICAgIHRoaXMuX2NvbmZpZ3VyZUluZnVyYVByb3ZpZGVyKHR5cGUsIHRoaXMuX2luZnVyYVByb2plY3RJZCk7XG4gICAgICAvLyB1cmwtYmFzZWQgcnBjIGVuZHBvaW50c1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTkVUV09SS19UWVBFX1JQQykge1xuICAgICAgdGhpcy5fY29uZmlndXJlU3RhbmRhcmRQcm92aWRlcihycGNVcmwsIGNoYWluSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOZXR3b3JrQ29udHJvbGxlciAtIF9jb25maWd1cmVQcm92aWRlciAtIHVua25vd24gdHlwZSBcIiR7dHlwZX1cImAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9jb25maWd1cmVJbmZ1cmFQcm92aWRlcih0eXBlLCBwcm9qZWN0SWQpIHtcbiAgICBsb2cuaW5mbygnTmV0d29ya0NvbnRyb2xsZXIgLSBjb25maWd1cmVJbmZ1cmFQcm92aWRlcicsIHR5cGUpO1xuICAgIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBjcmVhdGVJbmZ1cmFDbGllbnQoe1xuICAgICAgbmV0d29yazogdHlwZSxcbiAgICAgIHByb2plY3RJZCxcbiAgICB9KTtcbiAgICB0aGlzLl9zZXROZXR3b3JrQ2xpZW50KG5ldHdvcmtDbGllbnQpO1xuICB9XG5cbiAgX2NvbmZpZ3VyZVN0YW5kYXJkUHJvdmlkZXIocnBjVXJsLCBjaGFpbklkKSB7XG4gICAgbG9nLmluZm8oJ05ldHdvcmtDb250cm9sbGVyIC0gY29uZmlndXJlU3RhbmRhcmRQcm92aWRlcicsIHJwY1VybCk7XG4gICAgY29uc3QgbmV0d29ya0NsaWVudCA9IGNyZWF0ZUpzb25ScGNDbGllbnQoeyBycGNVcmwsIGNoYWluSWQgfSk7XG4gICAgdGhpcy5fc2V0TmV0d29ya0NsaWVudChuZXR3b3JrQ2xpZW50KTtcbiAgfVxuXG4gIF9zZXROZXR3b3JrQ2xpZW50KHsgbmV0d29ya01pZGRsZXdhcmUsIGJsb2NrVHJhY2tlciB9KSB7XG4gICAgY29uc3QgbWV0YW1hc2tNaWRkbGV3YXJlID0gY3JlYXRlTWV0YW1hc2tNaWRkbGV3YXJlKFxuICAgICAgdGhpcy5fYmFzZVByb3ZpZGVyUGFyYW1zLFxuICAgICk7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IEpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaChtZXRhbWFza01pZGRsZXdhcmUpO1xuICAgIGVuZ2luZS5wdXNoKG5ldHdvcmtNaWRkbGV3YXJlKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuX3NldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciB9KTtcbiAgfVxuXG4gIF9zZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcih7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIgfSkge1xuICAgIC8vIHVwZGF0ZSBvciBpbml0aWFsaXplIHByb3hpZXNcbiAgICBpZiAodGhpcy5fcHJvdmlkZXJQcm94eSkge1xuICAgICAgdGhpcy5fcHJvdmlkZXJQcm94eS5zZXRUYXJnZXQocHJvdmlkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm92aWRlclByb3h5ID0gY3JlYXRlU3dhcHBhYmxlUHJveHkocHJvdmlkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYmxvY2tUcmFja2VyUHJveHkpIHtcbiAgICAgIHRoaXMuX2Jsb2NrVHJhY2tlclByb3h5LnNldFRhcmdldChibG9ja1RyYWNrZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ibG9ja1RyYWNrZXJQcm94eSA9IGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5KGJsb2NrVHJhY2tlciwge1xuICAgICAgICBldmVudEZpbHRlcjogJ3NraXBJbnRlcm5hbCcsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc2V0IG5ldyBwcm92aWRlciBhbmQgYmxvY2tUcmFja2VyXG4gICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICB0aGlzLl9ibG9ja1RyYWNrZXIgPSBibG9ja1RyYWNrZXI7XG4gIH1cbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbnZhciBjcyA9IHJlcXVpcmUoJ2NvaW5zdHJpbmcnKVxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpXG5cbnZhciBNQVNURVJfU0VDUkVUID0gQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcsICd1dGY4JylcbnZhciBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwXG52YXIgTEVOID0gNzhcblxuLy8gQml0Y29pbiBoYXJkY29kZWQgYnkgZGVmYXVsdCwgY2FuIHVzZSBwYWNrYWdlIGBjb2luaW5mb2AgZm9yIG90aGVyc1xudmFyIEJJVENPSU5fVkVSU0lPTlMgPSB7cHJpdmF0ZTogMHgwNDg4QURFNCwgcHVibGljOiAweDA0ODhCMjFFfVxuXG5mdW5jdGlvbiBIREtleSAodmVyc2lvbnMpIHtcbiAgdGhpcy52ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdGhpcy5kZXB0aCA9IDBcbiAgdGhpcy5pbmRleCA9IDBcbiAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgdGhpcy5fcHVibGljS2V5ID0gbnVsbFxuICB0aGlzLmNoYWluQ29kZSA9IG51bGxcbiAgdGhpcy5fZmluZ2VycHJpbnQgPSAwXG4gIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdmaW5nZXJwcmludCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9maW5nZXJwcmludCB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnaWRlbnRpZmllcicsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZGVudGlmaWVyIH0gfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJLZXlIYXNoJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaWRlbnRpZmllciB9IH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwcml2YXRlS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydC5lcXVhbCh2YWx1ZS5sZW5ndGgsIDMyLCAnUHJpdmF0ZSBrZXkgbXVzdCBiZSAzMiBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHByaXZhdGUga2V5JylcblxuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSB2YWx1ZVxuICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUodmFsdWUsIHRydWUpXG4gICAgdGhpcy5faWRlbnRpZmllciA9IGhhc2gxNjAodGhpcy5wdWJsaWNLZXkpXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSB0aGlzLl9pZGVudGlmaWVyLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHVibGljS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCA9PT0gMzMgfHwgdmFsdWUubGVuZ3RoID09PSA2NSwgJ1B1YmxpYyBrZXkgbXVzdCBiZSAzMyBvciA2NSBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHZhbHVlKSA9PT0gdHJ1ZSwgJ0ludmFsaWQgcHVibGljIGtleScpXG5cbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydCh2YWx1ZSwgdHJ1ZSkgLy8gZm9yY2UgY29tcHJlc3NlZCBwb2ludFxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gbnVsbFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHJpdmF0ZUV4dGVuZGVkS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcHJpdmF0ZUtleSkgcmV0dXJuIGNzLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wcml2YXRlLCBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MoMSwgMCksIHRoaXMucHJpdmF0ZUtleV0pKSlcbiAgICBlbHNlIHJldHVybiBudWxsXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJsaWNFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNzLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHVibGljS2V5KSlcbiAgfVxufSlcblxuSERLZXkucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmIChwYXRoID09PSAnbScgfHwgcGF0aCA9PT0gJ00nIHx8IHBhdGggPT09IFwibSdcIiB8fCBwYXRoID09PSBcIk0nXCIpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSBwYXRoLnNwbGl0KCcvJylcbiAgdmFyIGhka2V5ID0gdGhpc1xuICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgYXNzZXJ0KGMsICdtJywgJ0ludmFsaWQgcGF0aCcpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaGFyZGVuZWQgPSAoYy5sZW5ndGggPiAxKSAmJiAoY1tjLmxlbmd0aCAtIDFdID09PSBcIidcIilcbiAgICB2YXIgY2hpbGRJbmRleCA9IHBhcnNlSW50KGMsIDEwKSAvLyAmIChIQVJERU5FRF9PRkZTRVQgLSAxKVxuICAgIGFzc2VydChjaGlsZEluZGV4IDwgSEFSREVORURfT0ZGU0VULCAnSW52YWxpZCBpbmRleCcpXG4gICAgaWYgKGhhcmRlbmVkKSBjaGlsZEluZGV4ICs9IEhBUkRFTkVEX09GRlNFVFxuXG4gICAgaGRrZXkgPSBoZGtleS5kZXJpdmVDaGlsZChjaGlsZEluZGV4KVxuICB9KVxuXG4gIHJldHVybiBoZGtleVxufVxuXG5IREtleS5wcm90b3R5cGUuZGVyaXZlQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdmFyIGlzSGFyZGVuZWQgPSBpbmRleCA+PSBIQVJERU5FRF9PRkZTRVRcbiAgdmFyIGluZGV4QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIGluZGV4QnVmZmVyLndyaXRlVUludDMyQkUoaW5kZXgsIDApXG5cbiAgdmFyIGRhdGFcblxuICBpZiAoaXNIYXJkZW5lZCkgeyAvLyBIYXJkZW5lZCBjaGlsZFxuICAgIGFzc2VydCh0aGlzLnByaXZhdGVLZXksICdDb3VsZCBub3QgZGVyaXZlIGhhcmRlbmVkIGNoaWxkIGtleScpXG5cbiAgICB2YXIgcGsgPSB0aGlzLnByaXZhdGVLZXlcbiAgICB2YXIgemIgPSBCdWZmZXIuYWxsb2MoMSwgMClcbiAgICBwayA9IEJ1ZmZlci5jb25jYXQoW3piLCBwa10pXG5cbiAgICAvLyBkYXRhID0gMHgwMCB8fCBzZXIyNTYoa3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3BrLCBpbmRleEJ1ZmZlcl0pXG4gIH0gZWxzZSB7IC8vIE5vcm1hbCBjaGlsZFxuICAgIC8vIGRhdGEgPSBzZXJQKHBvaW50KGtwYXIpKSB8fCBzZXIzMihpbmRleClcbiAgICAvLyAgICAgID0gc2VyUChLcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbdGhpcy5wdWJsaWNLZXksIGluZGV4QnVmZmVyXSlcbiAgfVxuXG4gIHZhciBJID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIHRoaXMuY2hhaW5Db2RlKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgdmFyIElMID0gSS5zbGljZSgwLCAzMilcbiAgdmFyIElSID0gSS5zbGljZSgzMilcblxuICB2YXIgaGQgPSBuZXcgSERLZXkodGhpcy52ZXJzaW9ucylcblxuICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuICAgIC8vIGtpID0gcGFyc2UyNTYoSUwpICsga3BhciAobW9kIG4pXG4gICAgdHJ5IHtcbiAgICAgIGhkLnByaXZhdGVLZXkgPSBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHRoaXMucHJpdmF0ZUtleSwgSUwpXG4gICAgICAvLyB0aHJvdyBpZiBJTCA+PSBuIHx8IChwcml2YXRlS2V5ICsgSUwpID09PSAwXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuIG9yIGtpID09IDAsIG9uZSBzaG91bGQgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKVxuICAgIH1cbiAgLy8gUHVibGljIHBhcmVudCBrZXkgLT4gcHVibGljIGNoaWxkIGtleVxuICB9IGVsc2Uge1xuICAgIC8vIEtpID0gcG9pbnQocGFyc2UyNTYoSUwpKSArIEtwYXJcbiAgICAvLyAgICA9IEcqSUwgKyBLcGFyXG4gICAgdHJ5IHtcbiAgICAgIGhkLnB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZCh0aGlzLnB1YmxpY0tleSwgSUwsIHRydWUpXG4gICAgICAvLyB0aHJvdyBpZiBJTCA+PSBuIHx8IChnKipJTCArIHB1YmxpY0tleSkgaXMgaW5maW5pdHlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEluIGNhc2UgcGFyc2UyNTYoSUwpID49IG4gb3IgS2kgaXMgdGhlIHBvaW50IGF0IGluZmluaXR5LCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSwgaXNIYXJkZW5lZClcbiAgICB9XG4gIH1cblxuICBoZC5jaGFpbkNvZGUgPSBJUlxuICBoZC5kZXB0aCA9IHRoaXMuZGVwdGggKyAxXG4gIGhkLnBhcmVudEZpbmdlcnByaW50ID0gdGhpcy5maW5nZXJwcmludC8vIC5yZWFkVUludDMyQkUoMClcbiAgaGQuaW5kZXggPSBpbmRleFxuXG4gIHJldHVybiBoZFxufVxuXG5IREtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIChoYXNoKSB7XG4gIHJldHVybiBzZWNwMjU2azEuc2lnbihoYXNoLCB0aGlzLnByaXZhdGVLZXkpLnNpZ25hdHVyZVxufVxuXG5IREtleS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGhhc2gsIHNpZ25hdHVyZSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnZlcmlmeShoYXNoLCBzaWduYXR1cmUsIHRoaXMucHVibGljS2V5KVxufVxuXG5IREtleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICB4cHViOiB0aGlzLnB1YmxpY0V4dGVuZGVkS2V5XG4gIH1cbn1cblxuSERLZXkuZnJvbU1hc3RlclNlZWQgPSBmdW5jdGlvbiAoc2VlZEJ1ZmZlciwgdmVyc2lvbnMpIHtcbiAgdmFyIEkgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgTUFTVEVSX1NFQ1JFVCkudXBkYXRlKHNlZWRCdWZmZXIpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIGhka2V5ID0gbmV3IEhES2V5KHZlcnNpb25zKVxuICBoZGtleS5jaGFpbkNvZGUgPSBJUlxuICBoZGtleS5wcml2YXRlS2V5ID0gSUxcblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUV4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKGJhc2U1OGtleSwgdmVyc2lvbnMpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdmFyIGhka2V5ID0gbmV3IEhES2V5KHZlcnNpb25zKVxuXG4gIHZhciBrZXlCdWZmZXIgPSBjcy5kZWNvZGUoYmFzZTU4a2V5KVxuXG4gIHZhciB2ZXJzaW9uID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHJpdmF0ZSB8fCB2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlIG9yIHB1YmxpYycpXG5cbiAgaGRrZXkuZGVwdGggPSBrZXlCdWZmZXIucmVhZFVJbnQ4KDQpXG4gIGhka2V5LnBhcmVudEZpbmdlcnByaW50ID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSg1KVxuICBoZGtleS5pbmRleCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoOSlcbiAgaGRrZXkuY2hhaW5Db2RlID0ga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSlcblxuICB2YXIga2V5ID0ga2V5QnVmZmVyLnNsaWNlKDQ1KVxuICBpZiAoa2V5LnJlYWRVSW50OCgwKSA9PT0gMCkgeyAvLyBwcml2YXRlXG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHByaXZhdGUnKVxuICAgIGhka2V5LnByaXZhdGVLZXkgPSBrZXkuc2xpY2UoMSkgLy8gY3V0IG9mZiBmaXJzdCAweDAgYnl0ZVxuICB9IGVsc2Uge1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHB1YmxpYycpXG4gICAgaGRrZXkucHVibGljS2V5ID0ga2V5XG4gIH1cblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUpTT04gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBIREtleS5mcm9tRXh0ZW5kZWRLZXkob2JqLnhwcml2KVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGhka2V5LCB2ZXJzaW9uLCBrZXkpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKExFTilcblxuICBidWZmZXIud3JpdGVVSW50MzJCRSh2ZXJzaW9uLCAwKVxuICBidWZmZXIud3JpdGVVSW50OChoZGtleS5kZXB0aCwgNClcblxuICB2YXIgZmluZ2VycHJpbnQgPSBoZGtleS5kZXB0aCA/IGhka2V5LnBhcmVudEZpbmdlcnByaW50IDogMHgwMDAwMDAwMFxuICBidWZmZXIud3JpdGVVSW50MzJCRShmaW5nZXJwcmludCwgNSlcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoaGRrZXkuaW5kZXgsIDkpXG5cbiAgaGRrZXkuY2hhaW5Db2RlLmNvcHkoYnVmZmVyLCAxMylcbiAga2V5LmNvcHkoYnVmZmVyLCA0NSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGhhc2gxNjAgKGJ1Zikge1xuICB2YXIgc2hhID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKHNoYSkuZGlnZXN0KClcbn1cblxuSERLZXkuSEFSREVORURfT0ZGU0VUID0gSEFSREVORURfT0ZGU0VUXG5tb2R1bGUuZXhwb3J0cyA9IEhES2V5XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX2V4cG9ydE5hbWVzID0ge307XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbk9iamVjdC5rZXlzKF9jb25zdGFudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jb25zdGFudHNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfY29uc3RhbnRzW2tleV07XG59KTtcblxudmFyIF9ub2RlID0gcmVxdWlyZShcIi4vZW52L25vZGVcIik7XG5cbnZhciBfdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcblxuT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdHlwZXNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHlwZXNba2V5XTtcbn0pO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgVHJlem9yQ29ubmVjdCA9IHtcbiAgbWFuaWZlc3Q6IF9ub2RlLm1hbmlmZXN0LFxuICBpbml0OiBfbm9kZS5pbml0LFxuICBnZXRTZXR0aW5nczogX25vZGUuZ2V0U2V0dGluZ3MsXG4gIG9uOiBmdW5jdGlvbiBvbih0eXBlLCBmbikge1xuICAgIF9ub2RlLmV2ZW50RW1pdHRlci5vbih0eXBlLCBmbik7XG4gIH0sXG4gIG9mZjogZnVuY3Rpb24gb2ZmKHR5cGUsIGZuKSB7XG4gICAgX25vZGUuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGZuKTtcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgX25vZGUuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LFxuICB1aVJlc3BvbnNlOiBfbm9kZS51aVJlc3BvbnNlLFxuICAvLyBtZXRob2RzXG4gIGJsb2NrY2hhaW5HZXRBY2NvdW50QmFsYW5jZUhpc3Rvcnk6IGZ1bmN0aW9uIGJsb2NrY2hhaW5HZXRBY2NvdW50QmFsYW5jZUhpc3RvcnkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5HZXRBY2NvdW50QmFsYW5jZUhpc3RvcnknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5HZXRDdXJyZW50RmlhdFJhdGVzOiBmdW5jdGlvbiBibG9ja2NoYWluR2V0Q3VycmVudEZpYXRSYXRlcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkdldEN1cnJlbnRGaWF0UmF0ZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5HZXRGaWF0UmF0ZXNGb3JUaW1lc3RhbXBzOiBmdW5jdGlvbiBibG9ja2NoYWluR2V0RmlhdFJhdGVzRm9yVGltZXN0YW1wcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkdldEZpYXRSYXRlc0ZvclRpbWVzdGFtcHMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5EaXNjb25uZWN0OiBmdW5jdGlvbiBibG9ja2NoYWluRGlzY29ubmVjdChwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkRpc2Nvbm5lY3QnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5Fc3RpbWF0ZUZlZTogZnVuY3Rpb24gYmxvY2tjaGFpbkVzdGltYXRlRmVlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluRXN0aW1hdGVGZWUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5HZXRUcmFuc2FjdGlvbnM6IGZ1bmN0aW9uIGJsb2NrY2hhaW5HZXRUcmFuc2FjdGlvbnMocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5HZXRUcmFuc2FjdGlvbnMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5TZXRDdXN0b21CYWNrZW5kOiBmdW5jdGlvbiBibG9ja2NoYWluU2V0Q3VzdG9tQmFja2VuZChwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpblNldEN1c3RvbUJhY2tlbmQnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5TdWJzY3JpYmU6IGZ1bmN0aW9uIGJsb2NrY2hhaW5TdWJzY3JpYmUocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5TdWJzY3JpYmUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5TdWJzY3JpYmVGaWF0UmF0ZXM6IGZ1bmN0aW9uIGJsb2NrY2hhaW5TdWJzY3JpYmVGaWF0UmF0ZXMocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5TdWJzY3JpYmVGaWF0UmF0ZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5VbnN1YnNjcmliZTogZnVuY3Rpb24gYmxvY2tjaGFpblVuc3Vic2NyaWJlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluVW5zdWJzY3JpYmUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJsb2NrY2hhaW5VbnN1YnNjcmliZUZpYXRSYXRlczogZnVuY3Rpb24gYmxvY2tjaGFpblVuc3Vic2NyaWJlRmlhdFJhdGVzKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluVW5zdWJzY3JpYmVGaWF0UmF0ZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGN1c3RvbU1lc3NhZ2U6IGZ1bmN0aW9uIGN1c3RvbU1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jdXN0b21NZXNzYWdlKShwYXJhbXMpO1xuICB9LFxuICByZXF1ZXN0TG9naW46IGZ1bmN0aW9uIHJlcXVlc3RMb2dpbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLnJlcXVlc3RMb2dpbikocGFyYW1zKTtcbiAgfSxcbiAgY2FyZGFub0dldEFkZHJlc3M6IGZ1bmN0aW9uIGNhcmRhbm9HZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjYXJkYW5vR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgY2FyZGFub0dldE5hdGl2ZVNjcmlwdEhhc2g6IGZ1bmN0aW9uIGNhcmRhbm9HZXROYXRpdmVTY3JpcHRIYXNoKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjYXJkYW5vR2V0TmF0aXZlU2NyaXB0SGFzaCdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2FyZGFub0dldFB1YmxpY0tleTogZnVuY3Rpb24gY2FyZGFub0dldFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2FyZGFub0dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2FyZGFub1NpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gY2FyZGFub1NpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2FyZGFub1NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2lwaGVyS2V5VmFsdWU6IGZ1bmN0aW9uIGNpcGhlcktleVZhbHVlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjaXBoZXJLZXlWYWx1ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY29tcG9zZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiBjb21wb3NlVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2NvbXBvc2VUcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZGVidWdMaW5rRGVjaXNpb246IGZ1bmN0aW9uIGRlYnVnTGlua0RlY2lzaW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdkZWJ1Z0xpbmtEZWNpc2lvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZGVidWdMaW5rR2V0U3RhdGU6IGZ1bmN0aW9uIGRlYnVnTGlua0dldFN0YXRlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdkZWJ1Z0xpbmtHZXRTdGF0ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1HZXRBZGRyZXNzOiBmdW5jdGlvbiBldGhlcmV1bUdldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2V0aGVyZXVtR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgZXRoZXJldW1HZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIGV0aGVyZXVtR2V0UHVibGljS2V5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bUdldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1TaWduTWVzc2FnZTogZnVuY3Rpb24gZXRoZXJldW1TaWduTWVzc2FnZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZXRoZXJldW1TaWduTWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1TaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIGV0aGVyZXVtU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZXRoZXJldW1WZXJpZnlNZXNzYWdlOiBmdW5jdGlvbiBldGhlcmV1bVZlcmlmeU1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2V0aGVyZXVtVmVyaWZ5TWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0QWNjb3VudEluZm86IGZ1bmN0aW9uIGdldEFjY291bnRJbmZvKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRBY2NvdW50SW5mbydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0QWRkcmVzczogZnVuY3Rpb24gZ2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZ2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgZ2V0RGV2aWNlU3RhdGU6IGZ1bmN0aW9uIGdldERldmljZVN0YXRlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXREZXZpY2VTdGF0ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0RmVhdHVyZXM6IGZ1bmN0aW9uIGdldEZlYXR1cmVzKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRGZWF0dXJlcydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0UHVibGljS2V5OiBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgbGlza0dldEFkZHJlc3M6IGZ1bmN0aW9uIGxpc2tHZXRBZGRyZXNzKCkge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoe1xuICAgICAgbWV0aG9kOiAnbGlza0RlcHJlY2F0ZWQnXG4gICAgfSk7XG4gIH0sXG4gIGxpc2tHZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIGxpc2tHZXRQdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbGlza1NpZ25NZXNzYWdlOiBmdW5jdGlvbiBsaXNrU2lnbk1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbGlza1NpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gbGlza1NpZ25UcmFuc2FjdGlvbigpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKHtcbiAgICAgIG1ldGhvZDogJ2xpc2tEZXByZWNhdGVkJ1xuICAgIH0pO1xuICB9LFxuICBsaXNrVmVyaWZ5TWVzc2FnZTogZnVuY3Rpb24gbGlza1ZlcmlmeU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbmVtR2V0QWRkcmVzczogZnVuY3Rpb24gbmVtR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnbmVtR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgbmVtU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBuZW1TaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ25lbVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcHVzaFRyYW5zYWN0aW9uOiBmdW5jdGlvbiBwdXNoVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3B1c2hUcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmlwcGxlR2V0QWRkcmVzczogZnVuY3Rpb24gcmlwcGxlR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAncmlwcGxlR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgcmlwcGxlU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiByaXBwbGVTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3JpcHBsZVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgc2lnbk1lc3NhZ2U6IGZ1bmN0aW9uIHNpZ25NZXNzYWdlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdzaWduTWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgc2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgc3RlbGxhckdldEFkZHJlc3M6IGZ1bmN0aW9uIHN0ZWxsYXJHZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdzdGVsbGFyR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgc3RlbGxhclNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gc3RlbGxhclNpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnc3RlbGxhclNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgdGV6b3NHZXRBZGRyZXNzOiBmdW5jdGlvbiB0ZXpvc0dldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3Rlem9zR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgdGV6b3NHZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIHRlem9zR2V0UHVibGljS2V5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICd0ZXpvc0dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgdGV6b3NTaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIHRlem9zU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICd0ZXpvc1NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZW9zR2V0UHVibGljS2V5OiBmdW5jdGlvbiBlb3NHZXRQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Vvc0dldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZW9zU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBlb3NTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Vvc1NpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYmluYW5jZUdldEFkZHJlc3M6IGZ1bmN0aW9uIGJpbmFuY2VHZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdiaW5hbmNlR2V0QWRkcmVzcydcbiAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgdXNlRXZlbnRMaXN0ZW5lcjogdXNlRXZlbnRMaXN0ZW5lclxuICAgIH0pKTtcbiAgfSxcbiAgYmluYW5jZUdldFB1YmxpY0tleTogZnVuY3Rpb24gYmluYW5jZUdldFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmluYW5jZUdldFB1YmxpY0tleSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYmluYW5jZVNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gYmluYW5jZVNpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmluYW5jZVNpZ25UcmFuc2FjdGlvbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgdmVyaWZ5TWVzc2FnZTogZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAndmVyaWZ5TWVzc2FnZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmVzZXREZXZpY2U6IGZ1bmN0aW9uIHJlc2V0RGV2aWNlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdyZXNldERldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgd2lwZURldmljZTogZnVuY3Rpb24gd2lwZURldmljZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnd2lwZURldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYXBwbHlGbGFnczogZnVuY3Rpb24gYXBwbHlGbGFncyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYXBwbHlGbGFncydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYXBwbHlTZXR0aW5nczogZnVuY3Rpb24gYXBwbHlTZXR0aW5ncyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYXBwbHlTZXR0aW5ncydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgYmFja3VwRGV2aWNlOiBmdW5jdGlvbiBiYWNrdXBEZXZpY2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2JhY2t1cERldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgY2hhbmdlUGluOiBmdW5jdGlvbiBjaGFuZ2VQaW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2NoYW5nZVBpbidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZmlybXdhcmVVcGRhdGU6IGZ1bmN0aW9uIGZpcm13YXJlVXBkYXRlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdmaXJtd2FyZVVwZGF0ZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmVjb3ZlcnlEZXZpY2U6IGZ1bmN0aW9uIHJlY292ZXJ5RGV2aWNlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdyZWNvdmVyeURldmljZSdcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZ2V0Q29pbkluZm86IGZ1bmN0aW9uIGdldENvaW5JbmZvKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRDb2luSW5mbydcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgcmVib290VG9Cb290bG9hZGVyOiBmdW5jdGlvbiByZWJvb3RUb0Jvb3Rsb2FkZXIocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3JlYm9vdFRvQm9vdGxvYWRlcidcbiAgICB9LCBwYXJhbXMpKTtcbiAgfSxcbiAgZGlzcG9zZTogX25vZGUuZGlzcG9zZSxcbiAgY2FuY2VsOiBfbm9kZS5jYW5jZWwsXG4gIHJlbmRlcldlYlVTQkJ1dHRvbjogX25vZGUucmVuZGVyV2ViVVNCQnV0dG9uLFxuICBkaXNhYmxlV2ViVVNCOiBfbm9kZS5kaXNhYmxlV2ViVVNCXG59O1xudmFyIF9kZWZhdWx0ID0gVHJlem9yQ29ubmVjdDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxudmFyIGNzID0gcmVxdWlyZSgnY29pbnN0cmluZycpXG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnc2VjcDI1NmsxJylcblxudmFyIE1BU1RFUl9TRUNSRVQgPSBCdWZmZXIuZnJvbSgnQml0Y29pbiBzZWVkJywgJ3V0ZjgnKVxudmFyIEhBUkRFTkVEX09GRlNFVCA9IDB4ODAwMDAwMDBcbnZhciBMRU4gPSA3OFxuXG4vLyBCaXRjb2luIGhhcmRjb2RlZCBieSBkZWZhdWx0LCBjYW4gdXNlIHBhY2thZ2UgYGNvaW5pbmZvYCBmb3Igb3RoZXJzXG52YXIgQklUQ09JTl9WRVJTSU9OUyA9IHtwcml2YXRlOiAweDA0ODhBREU0LCBwdWJsaWM6IDB4MDQ4OEIyMUV9XG5cbmZ1bmN0aW9uIEhES2V5ICh2ZXJzaW9ucykge1xuICB0aGlzLnZlcnNpb25zID0gdmVyc2lvbnMgfHwgQklUQ09JTl9WRVJTSU9OU1xuICB0aGlzLmRlcHRoID0gMFxuICB0aGlzLmluZGV4ID0gMFxuICB0aGlzLl9wcml2YXRlS2V5ID0gbnVsbFxuICB0aGlzLl9wdWJsaWNLZXkgPSBudWxsXG4gIHRoaXMuY2hhaW5Db2RlID0gbnVsbFxuICB0aGlzLl9maW5nZXJwcmludCA9IDBcbiAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IDBcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ2ZpbmdlcnByaW50JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ZpbmdlcnByaW50IH0gfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdpZGVudGlmaWVyJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkZW50aWZpZXIgfSB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YktleUhhc2gnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pZGVudGlmaWVyIH0gfSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3ByaXZhdGVLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlS2V5XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNzZXJ0LmVxdWFsKHZhbHVlLmxlbmd0aCwgMzIsICdQcml2YXRlIGtleSBtdXN0IGJlIDMyIGJ5dGVzLicpXG4gICAgYXNzZXJ0KHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHZhbHVlKSA9PT0gdHJ1ZSwgJ0ludmFsaWQgcHJpdmF0ZSBrZXknKVxuXG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IHZhbHVlXG4gICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZSh2YWx1ZSwgdHJ1ZSlcbiAgICB0aGlzLl9pZGVudGlmaWVyID0gaGFzaDE2MCh0aGlzLnB1YmxpY0tleSlcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IHRoaXMuX2lkZW50aWZpZXIuc2xpY2UoMCwgNCkucmVhZFVJbnQzMkJFKDApXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJsaWNLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXlcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSAzMyB8fCB2YWx1ZS5sZW5ndGggPT09IDY1LCAnUHVibGljIGtleSBtdXN0IGJlIDMzIG9yIDY1IGJ5dGVzLicpXG4gICAgYXNzZXJ0KHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkodmFsdWUpID09PSB0cnVlLCAnSW52YWxpZCBwdWJsaWMga2V5JylcblxuICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHZhbHVlLCB0cnVlKSAvLyBmb3JjZSBjb21wcmVzc2VkIHBvaW50XG4gICAgdGhpcy5faWRlbnRpZmllciA9IGhhc2gxNjAodGhpcy5wdWJsaWNLZXkpXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSB0aGlzLl9pZGVudGlmaWVyLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKVxuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBudWxsXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwcml2YXRlRXh0ZW5kZWRLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wcml2YXRlS2V5KSByZXR1cm4gY3MuZW5jb2RlKHNlcmlhbGl6ZSh0aGlzLCB0aGlzLnZlcnNpb25zLnByaXZhdGUsIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5hbGxvYygxLCAwKSwgdGhpcy5wcml2YXRlS2V5XSkpKVxuICAgIGVsc2UgcmV0dXJuIG51bGxcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YmxpY0V4dGVuZGVkS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3MuZW5jb2RlKHNlcmlhbGl6ZSh0aGlzLCB0aGlzLnZlcnNpb25zLnB1YmxpYywgdGhpcy5wdWJsaWNLZXkpKVxuICB9XG59KVxuXG5IREtleS5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHBhdGggPT09ICdtJyB8fCBwYXRoID09PSAnTScgfHwgcGF0aCA9PT0gXCJtJ1wiIHx8IHBhdGggPT09IFwiTSdcIikge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgZW50cmllcyA9IHBhdGguc3BsaXQoJy8nKVxuICB2YXIgaGRrZXkgPSB0aGlzXG4gIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBhc3NlcnQoYywgJ20nLCAnSW52YWxpZCBwYXRoJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBoYXJkZW5lZCA9IChjLmxlbmd0aCA+IDEpICYmIChjW2MubGVuZ3RoIC0gMV0gPT09IFwiJ1wiKVxuICAgIHZhciBjaGlsZEluZGV4ID0gcGFyc2VJbnQoYywgMTApIC8vICYgKEhBUkRFTkVEX09GRlNFVCAtIDEpXG4gICAgYXNzZXJ0KGNoaWxkSW5kZXggPCBIQVJERU5FRF9PRkZTRVQsICdJbnZhbGlkIGluZGV4JylcbiAgICBpZiAoaGFyZGVuZWQpIGNoaWxkSW5kZXggKz0gSEFSREVORURfT0ZGU0VUXG5cbiAgICBoZGtleSA9IGhka2V5LmRlcml2ZUNoaWxkKGNoaWxkSW5kZXgpXG4gIH0pXG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LnByb3RvdHlwZS5kZXJpdmVDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgaXNIYXJkZW5lZCA9IGluZGV4ID49IEhBUkRFTkVEX09GRlNFVFxuICB2YXIgaW5kZXhCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgaW5kZXhCdWZmZXIud3JpdGVVSW50MzJCRShpbmRleCwgMClcblxuICB2YXIgZGF0YVxuXG4gIGlmIChpc0hhcmRlbmVkKSB7IC8vIEhhcmRlbmVkIGNoaWxkXG4gICAgYXNzZXJ0KHRoaXMucHJpdmF0ZUtleSwgJ0NvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5JylcblxuICAgIHZhciBwayA9IHRoaXMucHJpdmF0ZUtleVxuICAgIHZhciB6YiA9IEJ1ZmZlci5hbGxvYygxLCAwKVxuICAgIHBrID0gQnVmZmVyLmNvbmNhdChbemIsIHBrXSlcblxuICAgIC8vIGRhdGEgPSAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbcGssIGluZGV4QnVmZmVyXSlcbiAgfSBlbHNlIHsgLy8gTm9ybWFsIGNoaWxkXG4gICAgLy8gZGF0YSA9IHNlclAocG9pbnQoa3BhcikpIHx8IHNlcjMyKGluZGV4KVxuICAgIC8vICAgICAgPSBzZXJQKEtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnB1YmxpY0tleSwgaW5kZXhCdWZmZXJdKVxuICB9XG5cbiAgdmFyIEkgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgdGhpcy5jaGFpbkNvZGUpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB2YXIgSUwgPSBJLnNsaWNlKDAsIDMyKVxuICB2YXIgSVIgPSBJLnNsaWNlKDMyKVxuXG4gIHZhciBoZCA9IG5ldyBIREtleSh0aGlzLnZlcnNpb25zKVxuXG4gIC8vIFByaXZhdGUgcGFyZW50IGtleSAtPiBwcml2YXRlIGNoaWxkIGtleVxuICBpZiAodGhpcy5wcml2YXRlS2V5KSB7XG4gICAgLy8ga2kgPSBwYXJzZTI1NihJTCkgKyBrcGFyIChtb2QgbilcbiAgICB0cnkge1xuICAgICAgaGQucHJpdmF0ZUtleSA9IHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQodGhpcy5wcml2YXRlS2V5LCBJTClcbiAgICAgIC8vIHRocm93IGlmIElMID49IG4gfHwgKHByaXZhdGVLZXkgKyBJTCkgPT09IDBcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEluIGNhc2UgcGFyc2UyNTYoSUwpID49IG4gb3Iga2kgPT0gMCwgb25lIHNob3VsZCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpXG4gICAgfVxuICAvLyBQdWJsaWMgcGFyZW50IGtleSAtPiBwdWJsaWMgY2hpbGQga2V5XG4gIH0gZWxzZSB7XG4gICAgLy8gS2kgPSBwb2ludChwYXJzZTI1NihJTCkpICsgS3BhclxuICAgIC8vICAgID0gRypJTCArIEtwYXJcbiAgICB0cnkge1xuICAgICAgaGQucHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKHRoaXMucHVibGljS2V5LCBJTCwgdHJ1ZSlcbiAgICAgIC8vIHRocm93IGlmIElMID49IG4gfHwgKGcqKklMICsgcHVibGljS2V5KSBpcyBpbmZpbml0eVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiBvciBLaSBpcyB0aGUgcG9pbnQgYXQgaW5maW5pdHksIG9uZSBzaG91bGQgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxLCBpc0hhcmRlbmVkKVxuICAgIH1cbiAgfVxuXG4gIGhkLmNoYWluQ29kZSA9IElSXG4gIGhkLmRlcHRoID0gdGhpcy5kZXB0aCArIDFcbiAgaGQucGFyZW50RmluZ2VycHJpbnQgPSB0aGlzLmZpbmdlcnByaW50Ly8gLnJlYWRVSW50MzJCRSgwKVxuICBoZC5pbmRleCA9IGluZGV4XG5cbiAgcmV0dXJuIGhkXG59XG5cbkhES2V5LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKGhhc2gpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5zaWduKGhhc2gsIHRoaXMucHJpdmF0ZUtleSkuc2lnbmF0dXJlXG59XG5cbkhES2V5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoaGFzaCwgc2lnbmF0dXJlKSB7XG4gIHJldHVybiBzZWNwMjU2azEudmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSwgdGhpcy5wdWJsaWNLZXkpXG59XG5cbkhES2V5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgeHByaXY6IHRoaXMucHJpdmF0ZUV4dGVuZGVkS2V5LFxuICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXlcbiAgfVxufVxuXG5IREtleS5mcm9tTWFzdGVyU2VlZCA9IGZ1bmN0aW9uIChzZWVkQnVmZmVyLCB2ZXJzaW9ucykge1xuICB2YXIgSSA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCBNQVNURVJfU0VDUkVUKS51cGRhdGUoc2VlZEJ1ZmZlcikuZGlnZXN0KClcbiAgdmFyIElMID0gSS5zbGljZSgwLCAzMilcbiAgdmFyIElSID0gSS5zbGljZSgzMilcblxuICB2YXIgaGRrZXkgPSBuZXcgSERLZXkodmVyc2lvbnMpXG4gIGhka2V5LmNoYWluQ29kZSA9IElSXG4gIGhka2V5LnByaXZhdGVLZXkgPSBJTFxuXG4gIHJldHVybiBoZGtleVxufVxuXG5IREtleS5mcm9tRXh0ZW5kZWRLZXkgPSBmdW5jdGlvbiAoYmFzZTU4a2V5LCB2ZXJzaW9ucykge1xuICAvLyA9PiB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gIHZlcnNpb25zID0gdmVyc2lvbnMgfHwgQklUQ09JTl9WRVJTSU9OU1xuICB2YXIgaGRrZXkgPSBuZXcgSERLZXkodmVyc2lvbnMpXG5cbiAgdmFyIGtleUJ1ZmZlciA9IGNzLmRlY29kZShiYXNlNThrZXkpXG5cbiAgdmFyIHZlcnNpb24gPSBrZXlCdWZmZXIucmVhZFVJbnQzMkJFKDApXG4gIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wcml2YXRlIHx8IHZlcnNpb24gPT09IHZlcnNpb25zLnB1YmxpYywgJ1ZlcnNpb24gbWlzbWF0Y2g6IGRvZXMgbm90IG1hdGNoIHByaXZhdGUgb3IgcHVibGljJylcblxuICBoZGtleS5kZXB0aCA9IGtleUJ1ZmZlci5yZWFkVUludDgoNClcbiAgaGRrZXkucGFyZW50RmluZ2VycHJpbnQgPSBrZXlCdWZmZXIucmVhZFVJbnQzMkJFKDUpXG4gIGhka2V5LmluZGV4ID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSg5KVxuICBoZGtleS5jaGFpbkNvZGUgPSBrZXlCdWZmZXIuc2xpY2UoMTMsIDQ1KVxuXG4gIHZhciBrZXkgPSBrZXlCdWZmZXIuc2xpY2UoNDUpXG4gIGlmIChrZXkucmVhZFVJbnQ4KDApID09PSAwKSB7IC8vIHByaXZhdGVcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHJpdmF0ZSwgJ1ZlcnNpb24gbWlzbWF0Y2g6IHZlcnNpb24gZG9lcyBub3QgbWF0Y2ggcHJpdmF0ZScpXG4gICAgaGRrZXkucHJpdmF0ZUtleSA9IGtleS5zbGljZSgxKSAvLyBjdXQgb2ZmIGZpcnN0IDB4MCBieXRlXG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnB1YmxpYywgJ1ZlcnNpb24gbWlzbWF0Y2g6IHZlcnNpb24gZG9lcyBub3QgbWF0Y2ggcHVibGljJylcbiAgICBoZGtleS5wdWJsaWNLZXkgPSBrZXlcbiAgfVxuXG4gIHJldHVybiBoZGtleVxufVxuXG5IREtleS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIEhES2V5LmZyb21FeHRlbmRlZEtleShvYmoueHByaXYpXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoaGRrZXksIHZlcnNpb24sIGtleSkge1xuICAvLyA9PiB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoTEVOKVxuXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZlcnNpb24sIDApXG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGhka2V5LmRlcHRoLCA0KVxuXG4gIHZhciBmaW5nZXJwcmludCA9IGhka2V5LmRlcHRoID8gaGRrZXkucGFyZW50RmluZ2VycHJpbnQgOiAweDAwMDAwMDAwXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGZpbmdlcnByaW50LCA1KVxuICBidWZmZXIud3JpdGVVSW50MzJCRShoZGtleS5pbmRleCwgOSlcblxuICBoZGtleS5jaGFpbkNvZGUuY29weShidWZmZXIsIDEzKVxuICBrZXkuY29weShidWZmZXIsIDQ1KVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gaGFzaDE2MCAoYnVmKSB7XG4gIHZhciBzaGEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGJ1ZikuZGlnZXN0KClcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoc2hhKS5kaWdlc3QoKVxufVxuXG5IREtleS5IQVJERU5FRF9PRkZTRVQgPSBIQVJERU5FRF9PRkZTRVRcbm1vZHVsZS5leHBvcnRzID0gSERLZXlcbiIsImNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBldGhBYmkgPSByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpXG5jb25zdCBuYWNsID0gcmVxdWlyZSgndHdlZXRuYWNsJylcbm5hY2wudXRpbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbC11dGlsJylcblxuY29uc3QgVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZXM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBuYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICB0eXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ3R5cGUnXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBwcmltYXJ5VHlwZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgIG1lc3NhZ2U6IHsgdHlwZTogJ29iamVjdCcgfSxcbiAgfSxcbiAgcmVxdWlyZWQ6IFsndHlwZXMnLCAncHJpbWFyeVR5cGUnLCAnZG9tYWluJywgJ21lc3NhZ2UnXSxcbn1cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBmb3Igc2lnbmluZyB0eXBlZCBkYXRhXG4gKi9cbmNvbnN0IFR5cGVkRGF0YVV0aWxzID0ge1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGFuIG9iamVjdCBieSBlbmNvZGluZyBhbmQgY29uY2F0ZW5hdGluZyBlYWNoIG9mIGl0cyBtZW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBlbmNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0XG4gICAqL1xuICBlbmNvZGVEYXRhIChwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVuY29kZWRUeXBlcyA9IFsnYnl0ZXMzMiddXG4gICAgY29uc3QgZW5jb2RlZFZhbHVlcyA9IFt0aGlzLmhhc2hUeXBlKHByaW1hcnlUeXBlLCB0eXBlcyldXG5cbiAgICBpZiAodXNlVjQpIHtcbiAgICAgIGNvbnN0IGVuY29kZUZpZWxkID0gKG5hbWUsIHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgOlxuICAgICAgICAgICAgZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKHR5cGUsIHZhbHVlLCB0eXBlcywgdXNlVjQpKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBmaWVsZCAke25hbWV9IG9mIHR5cGUgJHt0eXBlfWApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIgLSBwcmV2ZW50cyBldGhVdGlsIGZyb20gaW50ZXJwcmV0aW5nIHN0cmluZ3MgbGlrZSAnMHhhYmNkJyBhcyBoZXhcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgZXRoVXRpbC5rZWNjYWsodmFsdWUpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUubGFzdEluZGV4T2YoJ10nKSA9PT0gdHlwZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKVxuICAgICAgICAgIGNvbnN0IHR5cGVWYWx1ZVBhaXJzID0gdmFsdWUubWFwKChpdGVtKSA9PiBlbmNvZGVGaWVsZChuYW1lLCBwYXJzZWRUeXBlLCBpdGVtKSlcbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgZXRoVXRpbC5rZWNjYWsoZXRoQWJpLnJhd0VuY29kZShcbiAgICAgICAgICAgIHR5cGVWYWx1ZVBhaXJzLm1hcCgoW190eXBlXSkgPT4gX3R5cGUpLFxuICAgICAgICAgICAgdHlwZVZhbHVlUGFpcnMubWFwKChbLCBfdmFsdWVdKSA9PiBfdmFsdWUpLFxuICAgICAgICAgICkpXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0pXG4gICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpXG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtmaWVsZC5uYW1lXVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCgnYnl0ZXMzMicpXG4gICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh2YWx1ZSlcbiAgICAgICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVzW2ZpZWxkLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKGZpZWxkLnR5cGUsIHZhbHVlLCB0eXBlcywgdXNlVjQpKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZS5sYXN0SW5kZXhPZignXScpID09PSBmaWVsZC50eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIGN1cnJlbnRseSB1bmltcGxlbWVudGVkIGluIGVuY29kZURhdGEnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmNvZGVkVHlwZXMucHVzaChmaWVsZC50eXBlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldGhBYmkucmF3RW5jb2RlKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcylcbiAgfSxcblxuICAvKipcbiAgICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVyc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gZW5jb2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgZW5jb2RlVHlwZSAocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgbGV0IGRlcHMgPSB0aGlzLmZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcykuZmlsdGVyKChkZXApID0+IGRlcCAhPT0gcHJpbWFyeVR5cGUpXG4gICAgZGVwcyA9IFtwcmltYXJ5VHlwZV0uY29uY2F0KGRlcHMuc29ydCgpKVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBkZXBzKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVzW3R5cGVdXG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdHlwZSBkZWZpbml0aW9uIHNwZWNpZmllZDogJHt0eXBlfWApXG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXS5tYXAoKHsgbmFtZSwgdHlwZTogX3R5cGUgfSkgPT4gYCR7X3R5cGV9ICR7bmFtZX1gKS5qb2luKCcsJyl9KWBcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdHlwZXMgd2l0aGluIGEgdHlwZSBkZWZpbnRpb24gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdHMgLSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gU2V0IG9mIGFsbCB0eXBlcyBmb3VuZCBpbiB0aGUgdHlwZSBkZWZpbml0aW9uXG4gICAqL1xuICBmaW5kVHlwZURlcGVuZGVuY2llcyAocHJpbWFyeVR5cGUsIHR5cGVzLCByZXN1bHRzID0gW10pIHtcbiAgICBjb25zdCBbZmlyc3RXb3JkXSA9IHByaW1hcnlUeXBlLm1hdGNoKC9eXFx3Ki91KVxuICAgIHByaW1hcnlUeXBlID0gZmlyc3RXb3JkXG4gICAgaWYgKHJlc3VsdHMuaW5jbHVkZXMocHJpbWFyeVR5cGUpIHx8IHR5cGVzW3ByaW1hcnlUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1xuICAgIH1cbiAgICByZXN1bHRzLnB1c2gocHJpbWFyeVR5cGUpXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHRoaXMuZmluZFR5cGVEZXBlbmRlbmNpZXMoZmllbGQudHlwZSwgdHlwZXMsIHJlc3VsdHMpKSB7XG4gICAgICAgICFyZXN1bHRzLmluY2x1ZGVzKGRlcCkgJiYgcmVzdWx0cy5wdXNoKGRlcClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSxcblxuICAvKipcbiAgICogSGFzaGVzIGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBPYmplY3QgdG8gaGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gSGFzaCBvZiBhbiBvYmplY3RcbiAgICovXG4gIGhhc2hTdHJ1Y3QgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGV0aFV0aWwua2VjY2FrKHRoaXMuZW5jb2RlRGF0YShwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHVzZVY0KSlcbiAgfSxcblxuICAvKipcbiAgICogSGFzaGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVR5cGUgLSBSb290IHR5cGUgdG8gaGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gSGFzaCBvZiBhbiBvYmplY3RcbiAgICovXG4gIGhhc2hUeXBlIChwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgcHJvcGVydGllcyBmcm9tIGEgbWVzc2FnZSBvYmplY3QgdGhhdCBhcmUgbm90IGRlZmluZWQgcGVyIEVJUC03MTJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB0eXBlZCBtZXNzYWdlIG9iamVjdFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0IHdpdGggb25seSBhbGxvd2VkIGZpZWxkc1xuICAgKi9cbiAgc2FuaXRpemVEYXRhIChkYXRhKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoVFlQRURfTUVTU0FHRV9TQ0hFTUEucHJvcGVydGllcykpIHtcbiAgICAgIGRhdGFba2V5XSAmJiAoc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldKVxuICAgIH1cbiAgICBpZiAoc2FuaXRpemVkRGF0YS50eXBlcykge1xuICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IHsgRUlQNzEyRG9tYWluOiBbXSwgLi4uc2FuaXRpemVkRGF0YS50eXBlcyB9XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWREYXRhXG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpZ25zIGEgdHlwZWQgbWVzc2FnZSBhcyBwZXIgRUlQLTcxMiBhbmQgcmV0dXJucyBpdHMga2VjY2FrIGhhc2hcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkRGF0YSAtIFR5cGVzIG1lc3NhZ2UgZGF0YSB0byBzaWduXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0ga2VjY2FrIGhhc2ggb2YgdGhlIHJlc3VsdGluZyBzaWduZWQgbWVzc2FnZVxuICAgKi9cbiAgc2lnbiAodHlwZWREYXRhLCB1c2VWNCA9IHRydWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gdGhpcy5zYW5pdGl6ZURhdGEodHlwZWREYXRhKVxuICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXVxuICAgIHBhcnRzLnB1c2godGhpcy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBzYW5pdGl6ZWREYXRhLmRvbWFpbiwgc2FuaXRpemVkRGF0YS50eXBlcywgdXNlVjQpKVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlICE9PSAnRUlQNzEyRG9tYWluJykge1xuICAgICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3Qoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgfVxuICAgIHJldHVybiBldGhVdGlsLmtlY2NhayhCdWZmZXIuY29uY2F0KHBhcnRzKSlcbiAgfSxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRZUEVEX01FU1NBR0VfU0NIRU1BLFxuICBUeXBlZERhdGFVdGlscyxcblxuICBjb25jYXRTaWcgKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpXG4gICAgY29uc3Qgc1NpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChzKVxuICAgIGNvbnN0IHZTaWcgPSBldGhVdGlsLmJ1ZmZlclRvSW50KHYpXG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3QgdlN0ciA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZXRoVXRpbC5pbnRUb0hleCh2U2lnKSlcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIG5vcm1hbGl6ZSAoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGV0aFV0aWwudG9CdWZmZXIoaW5wdXQpXG4gICAgICBpbnB1dCA9IGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmZmVyKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbXNnID0gJ2V0aC1zaWctdXRpbC5ub3JtYWxpemUoKSByZXF1aXJlcyBoZXggc3RyaW5nIG9yIGludGVnZXIgaW5wdXQuJ1xuICAgICAgbXNnICs9IGAgcmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9OiAke2lucHV0fWBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpXG4gIH0sXG5cbiAgcGVyc29uYWxTaWduIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICBjb25zdCBzZXJpYWxpemVkID0gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgICByZXR1cm4gc2VyaWFsaXplZFxuICB9LFxuXG4gIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gICAgcmV0dXJuIHNlbmRlckhleFxuICB9LFxuXG4gIGV4dHJhY3RQdWJsaWNLZXkgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihtc2dQYXJhbXMpXG4gICAgcmV0dXJuIGAweCR7cHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKX1gXG4gIH0sXG5cbiAgdHlwZWRTaWduYXR1cmVIYXNoICh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChoYXNoQnVmZmVyKVxuICB9LFxuXG4gIHNpZ25UeXBlZERhdGFMZWdhY3kgKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmVMZWdhY3kgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3QgcHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBtc2dQYXJhbXMuc2lnKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gIH0sXG5cbiAgZW5jcnlwdCAocmVjZWl2ZXJQdWJsaWNLZXksIG1zZ1BhcmFtcywgdmVyc2lvbikge1xuXG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgbXNnUGFyYW1zLmRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGV0ZWN0IHNlY3JldCBtZXNzYWdlLCBtZXNzYWdlIHBhcmFtcyBzaG91bGQgYmUgb2YgdGhlIGZvcm0ge2RhdGE6IFwic2VjcmV0IG1lc3NhZ2VcIn0gJylcbiAgICAgICAgfVxuICAgICAgICAvLyBnZW5lcmF0ZSBlcGhlbWVyYWwga2V5cGFpclxuICAgICAgICBjb25zdCBlcGhlbWVyYWxLZXlQYWlyID0gbmFjbC5ib3gua2V5UGFpcigpXG5cbiAgICAgICAgLy8gYXNzZW1ibGUgZW5jcnlwdGlvbiBwYXJhbWV0ZXJzIC0gZnJvbSBzdHJpbmcgdG8gVUludDhcbiAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwdWJLZXlVSW50OEFycmF5ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChyZWNlaXZlclB1YmxpY0tleSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgcHVibGljIGtleScpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtc2dQYXJhbXNVSW50OEFycmF5ID0gbmFjbC51dGlsLmRlY29kZVVURjgobXNnUGFyYW1zLmRhdGEpXG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbC5yYW5kb21CeXRlcyhuYWNsLmJveC5ub25jZUxlbmd0aClcblxuICAgICAgICAvLyBlbmNyeXB0XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveChtc2dQYXJhbXNVSW50OEFycmF5LCBub25jZSwgcHViS2V5VUludDhBcnJheSwgZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpXG5cbiAgICAgICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICB2ZXJzaW9uOiAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1JyxcbiAgICAgICAgICBub25jZTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoZXBoZW1lcmFsS2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgIGNpcGhlcnRleHQ6IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoZW5jcnlwdGVkTWVzc2FnZSksXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVuY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgfVxuICB9LFxuXG4gIGVuY3J5cHRTYWZlbHkgKHJlY2VpdmVyUHVibGljS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24pIHtcblxuICAgIGNvbnN0IERFRkFVTFRfUEFERElOR19MRU5HVEggPSAoMiAqKiAxMSlcbiAgICBjb25zdCBOQUNMX0VYVFJBX0JZVEVTID0gMTZcblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gbXNnUGFyYW1zXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IGVtcHR5IG1zZy5kYXRhJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEudG9KU09OKSB7XG4gICAgICAvLyByZW1vdmUgdG9KU09OIGF0dGFjayB2ZWN0b3JcbiAgICAgIC8vIFRPRE8sIGNoZWNrIGFsbCBwb3NzaWJsZSBjaGlsZHJlblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCB3aXRoIHRvSlNPTiBwcm9wZXJ0eS4gIFBsZWFzZSByZW1vdmUgdG9KU09OIHByb3BlcnR5JylcbiAgICB9XG5cbiAgICAvLyBhZGQgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYWRkaW5nOiAnJyxcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpLCAndXRmLTgnKVxuICAgIGNvbnN0IG1vZFZhbCA9IChkYXRhTGVuZ3RoICUgREVGQVVMVF9QQURESU5HX0xFTkdUSClcbiAgICBsZXQgcGFkTGVuZ3RoID0gMFxuICAgIC8vIE9ubHkgcGFkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChtb2RWYWwgPiAwKSB7XG4gICAgICBwYWRMZW5ndGggPSAoREVGQVVMVF9QQURESU5HX0xFTkdUSCAtIG1vZFZhbCkgLSBOQUNMX0VYVFJBX0JZVEVTIC8vIG5hY2wgZXh0cmEgYnl0ZXNcbiAgICB9XG4gICAgZGF0YVdpdGhQYWRkaW5nLnBhZGRpbmcgPSAnMCcucmVwZWF0KHBhZExlbmd0aClcblxuICAgIGNvbnN0IHBhZGRlZE1zZ1BhcmFtcyA9IHsgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKSB9XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdChyZWNlaXZlclB1YmxpY0tleSwgcGFkZGVkTXNnUGFyYW1zLCB2ZXJzaW9uKVxuICB9LFxuXG4gIGRlY3J5cHQgKGVuY3J5cHRlZERhdGEsIHJlY2VpdmVyUHJpdmF0ZUtleSkge1xuXG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgLy8gc3RyaW5nIHRvIGJ1ZmZlciB0byBVSW50OEFycmF5XG4gICAgICAgIGNvbnN0IHJlY2lldmVyUHJpdmF0ZUtleVVpbnQ4QXJyYXkgPSBuYWNsX2RlY29kZUhleChyZWNlaXZlclByaXZhdGVLZXkpXG4gICAgICAgIGNvbnN0IHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5XG5cbiAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLm5vbmNlKVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmNpcGhlcnRleHQpXG4gICAgICAgIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gbmFjbC51dGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmVwaGVtUHVibGljS2V5KVxuXG4gICAgICAgIC8vIGRlY3J5cHRcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNpZXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KVxuXG4gICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgbGV0IG91dHB1dFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dHB1dCA9IG5hY2wudXRpbC5lbmNvZGVVVEY4KGRlY3J5cHRlZE1lc3NhZ2UpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbiBmYWlsZWQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKVxuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQuJylcbiAgICB9XG4gIH0sXG5cbiAgZGVjcnlwdFNhZmVseSAoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0gSlNPTi5wYXJzZSh0aGlzLmRlY3J5cHQoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSlcbiAgICByZXR1cm4gZGF0YVdpdGhQYWRkaW5nLmRhdGFcbiAgfSxcblxuXG4gIGdldEVuY3J5cHRpb25QdWJsaWNLZXkgKHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHByaXZhdGVLZXkpXG4gICAgY29uc3QgZW5jcnlwdGlvblB1YmxpY0tleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShwcml2YXRlS2V5VWludDhBcnJheSkucHVibGljS2V5XG4gICAgcmV0dXJuIG5hY2wudXRpbC5lbmNvZGVCYXNlNjQoZW5jcnlwdGlvblB1YmxpY0tleSlcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBIGdlbmVyaWMgZW50cnkgcG9pbnQgZm9yIGFsbCB0eXBlZCBkYXRhIG1ldGhvZHMgdG8gYmUgcGFzc2VkLCBpbmNsdWRlcyBhIHZlcnNpb24gcGFyYW1ldGVyLlxuICAgKi9cbiAgc2lnblR5cGVkTWVzc2FnZSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zLCB2ZXJzaW9uID0gJ1Y0Jykge1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgY2FzZSAnVjEnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhTGVnYWN5KHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICAgIGNhc2UgJ1YzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnblR5cGVkRGF0YShwcml2YXRlS2V5LCBtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhX3Y0KHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICB9XG4gIH0sXG5cbiAgcmVjb3ZlclR5cGVkTWVzc2FnZSAobXNnUGFyYW1zLCB2ZXJzaW9uID0gJ1Y0Jykge1xuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgY2FzZSAnVjEnOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmVMZWdhY3kobXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmUobXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjQnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlclR5cGVkU2lnbmF0dXJlX3Y0KG1zZ1BhcmFtcylcbiAgICB9XG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKVxuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgodGhpcy5jb25jYXRTaWcoc2lnLnYsIHNpZy5yLCBzaWcucykpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YV92NCAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmUgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBUeXBlZERhdGFVdGlscy5zaWduKG1zZ1BhcmFtcy5kYXRhLCBmYWxzZSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQgKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBUeXBlZERhdGFVdGlscy5zaWduKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZSwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9LFxuXG59XG5cbi8qKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIEFycmF5IG9mIGRhdGEgYWxvbmcgd2l0aCB0eXBlcywgYXMgcGVyIEVJUDcxMi5cbiAqIEByZXR1cm5zIEJ1ZmZlclxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2ggKHR5cGVkRGF0YSkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpXG4gIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fCAhdHlwZWREYXRhLmxlbmd0aCkge1xuICAgIHRocm93IGVycm9yXG4gIH1cblxuICBjb25zdCBkYXRhID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnR5cGUgPT09ICdieXRlcycgPyBldGhVdGlsLnRvQnVmZmVyKGUudmFsdWUpIDogZS52YWx1ZVxuICB9KVxuICBjb25zdCB0eXBlcyA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlXG4gIH0pXG4gIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUubmFtZSkge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIGAke2UudHlwZX0gJHtlLm5hbWV9YFxuICB9KVxuXG4gIHJldHVybiBldGhBYmkuc29saWRpdHlTSEEzKFxuICAgIFsnYnl0ZXMzMicsICdieXRlczMyJ10sXG4gICAgW1xuICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyhuZXcgQXJyYXkodHlwZWREYXRhLmxlbmd0aCkuZmlsbCgnc3RyaW5nJyksIHNjaGVtYSksXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKHR5cGVzLCBkYXRhKSxcbiAgICBdLFxuICApXG59XG5cbmZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkgKGhhc2gsIHNpZykge1xuICBjb25zdCBzaWduYXR1cmUgPSBldGhVdGlsLnRvQnVmZmVyKHNpZylcbiAgY29uc3Qgc2lnUGFyYW1zID0gZXRoVXRpbC5mcm9tUnBjU2lnKHNpZ25hdHVyZSlcbiAgcmV0dXJuIGV0aFV0aWwuZWNyZWNvdmVyKGhhc2gsIHNpZ1BhcmFtcy52LCBzaWdQYXJhbXMuciwgc2lnUGFyYW1zLnMpXG59XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvciAobXNnUGFyYW1zKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICBjb25zdCBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gIHJldHVybiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG59XG5cblxuZnVuY3Rpb24gcGFkV2l0aFplcm9lcyAobnVtYmVyLCBsZW5ndGgpIHtcbiAgbGV0IG15U3RyaW5nID0gYCR7bnVtYmVyfWBcbiAgd2hpbGUgKG15U3RyaW5nLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIG15U3RyaW5nID0gYDAke215U3RyaW5nfWBcbiAgfVxuICByZXR1cm4gbXlTdHJpbmdcbn1cblxuLy8gY29udmVydHMgaGV4IHN0cmluZ3MgdG8gdGhlIFVpbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbFxuZnVuY3Rpb24gbmFjbF9kZWNvZGVIZXggKG1zZ0hleCkge1xuICBjb25zdCBtc2dCYXNlNjQgPSAoQnVmZmVyLmZyb20obXNnSGV4LCAnaGV4JykpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICByZXR1cm4gbmFjbC51dGlsLmRlY29kZUJhc2U2NChtc2dCYXNlNjQpXG59XG5cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHByb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICAgICAgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBwcm92aWRlciByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgcHJvdmlkZXJSZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHByb3ZpZGVyQXNNaWRkbGV3YXJlO1xuZnVuY3Rpb24gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gKHJlcSwgcmVzLCBfbmV4dCwgZW5kKSA9PiB7XG4gICAgICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgICAgICBwcm92aWRlci5zZW5kKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSBwcm92aWRlciByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgcHJvdmlkZXJSZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5ldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZSA9IGV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJBc01pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ1xcdTAwM2NuaWxcXHUwMDNlJ107XG4vL1xuLy8gQ2FjaGUgU3RyYXRlZ2llc1xuLy9cbmNsYXNzIEJsb2NrQ2FjaGVTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQoX3BheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl07XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FjaGUgaWYgbmVjZXNhcnlcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtibG9ja051bWJlcl0gPSBuZXdDYWNoZTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tDYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIGxvb2t1cCBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKShwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIgPyBibG9ja0NhY2hlW2lkZW50aWZpZXJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBzZXQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlc3VsdCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gY2FjaGVkIHRoaXMgcmVzdWx0XG4gICAgICAgIGNvbnN0IGNhbkNhY2hlUmVzdWx0ID0gdGhpcy5jYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWNhbkNhY2hlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQpKHBheWxvYWQsIHRydWUpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gPSByZXN1bHQ7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIC8vIGNoZWNrIHJlcXVlc3QgbWV0aG9kXG4gICAgICAgIGlmICghKDAsIGNhY2hlXzEuY2FuQ2FjaGUpKHBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYmxvY2tUYWdcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSAoMCwgY2FjaGVfMS5ibG9ja1RhZ0ZvclBheWxvYWQpKHBheWxvYWQpO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCkge1xuICAgICAgICAvLyBuZXZlciBjYWNoZSBlbXB0eSB2YWx1ZXMgKGUuZy4gdW5kZWZpbmVkKVxuICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgJiZcbiAgICAgICAgICAgIFsnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJywgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnXS5pbmNsdWRlcyhwYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0IHx8XG4gICAgICAgICAgICAgICAgIXJlc3VsdC5ibG9ja0hhc2ggfHxcbiAgICAgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID09PVxuICAgICAgICAgICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICAgIGNsZWFyQmVmb3JlKG9sZEJsb2NrSGV4KSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KG9sZEJsb2NrSGV4LCAxNik7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jYWNoZSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigobnVtKSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgICAgICAgIC5mb3JFYWNoKChudW0pID0+IGRlbGV0ZSB0aGlzLmNhY2hlW251bV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIFBvbGxpbmdCbG9ja1RyYWNrZXIgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgICBjb25zdCBibG9ja0NhY2hlID0gbmV3IEJsb2NrQ2FjaGVTdHJhdGVneSgpO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSB7XG4gICAgICAgIHBlcm1hOiBibG9ja0NhY2hlLFxuICAgICAgICBibG9jazogYmxvY2tDYWNoZSxcbiAgICAgICAgZm9yazogYmxvY2tDYWNoZSxcbiAgICB9O1xuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgICAgICBjb25zdCB0eXBlID0gKDAsIGNhY2hlXzEuY2FjaGVUeXBlRm9yUGF5bG9hZCkocmVxKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBzdHJhdGVnaWVzW3R5cGVdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHN0cmF0ZWd5IGluIHBsYWNlLCBwYXNzIGl0IGRvd24gdGhlIGNoYWluLlxuICAgICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdHJhdGVneSBjYW4ndCBjYWNoZSB0aGlzIHJlcXVlc3QsIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmxvY2sgcmVmZXJlbmNlIChudW1iZXIgb3Iga2V5d29yZClcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gKDAsIGNhY2hlXzEuYmxvY2tUYWdGb3JQYXlsb2FkKShyZXEpO1xuICAgICAgICBpZiAoIWJsb2NrVGFnKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBleGFjdCBibG9jayBudW1iZXJcbiAgICAgICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdlYXJsaWVzdCcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMganVzdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGggXCJsYXRlc3RcIlxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSAnMHgwMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2tUYWcgPT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICAvLyBmZXRjaCBsYXRlc3QgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGNhY2hlIGJlZm9yZSBsYXRlc3QgYmxvY2tcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUuY2xlYXJCZWZvcmUobGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBoZXggbnVtYmVyXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgICAgIGNvbnN0IGNhY2hlUmVzdWx0ID0gYXdhaXQgc3RyYXRlZ3kuZ2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICAgICAgICAvLyBpdCdzIHNhZmUgdG8gY2FzdCByZXMucmVzdWx0IGFzIEJsb2NrLCBkdWUgdG8gcnVudGltZSB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgLy8gcGVyZm9ybWVkIHdoZW4gc3RyYXRlZ3kuc2V0IGlzIGNhbGxlZFxuICAgICAgICAgICAgYXdhaXQgc3RyYXRlZ3kuc2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGZ1dHVyZUJsb2NrUmVmUmVxdWVzdHMgPSBbXG4gICAgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuXTtcbi8vIGluc3BlY3QgaWYgcmVzcG9uc2UgY29udGFpbnMgYSBibG9jayByZWYgaGlnaGVyIHRoYW4gb3VyIGxhdGVzdCBibG9ja1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSkge1xuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWZ1dHVyZUJsb2NrUmVmUmVxdWVzdHMuaW5jbHVkZXMocmVxLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgLy8gYWJvcnQgaWYgbm8gcmVzdWx0IG9yIG5vIGJsb2NrIG51bWJlclxuICAgICAgICBpZiAoISgoX2EgPSByZXMucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmxvY2tOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzLnJlc3VsdC5ibG9ja051bWJlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGlmIG51bWJlciBpcyBoaWdoZXIsIHN1Z2dlc3QgYmxvY2stdHJhY2tlciBjaGVjayBmb3IgYSBuZXcgYmxvY2tcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KHJlcy5yZXN1bHQuYmxvY2tOdW1iZXIsIDE2KTtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiBJZiBnZXRDdXJyZW50QmxvY2sgcmV0dXJucyBudWxsLCBjdXJyZW50QmxvY2tOdW1iZXIgd2lsbCBiZSBOYU4sIHdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tUcmFja2VyLmdldEN1cnJlbnRCbG9jaygpLCAxNik7XG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiBjdXJyZW50QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stdHJhY2tlci1pbnNwZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuZnVuY3Rpb24gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSB7XG4gICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0cyA9IHt9O1xuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgY2FjaGVJZCwgaWYgY2FjaGVhYmxlXG4gICAgICAgIGNvbnN0IGNhY2hlSWQgPSAoMCwgY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKShyZXEpO1xuICAgICAgICAvLyBpZiBub3QgY2FjaGVhYmxlLCBza2lwXG4gICAgICAgIGlmICghY2FjaGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgbGV0IGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgIC8vIGlmIGZvdW5kLCB3YWl0IGZvciB0aGUgYWN0aXZlIHJlcXVlc3QgdG8gYmUgaGFuZGxlZFxuICAgICAgICBpZiAoYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAvLyBzZXR1cCB0aGUgcmVzcG9uc2UgbGlzdGVuZXIgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gaXQgd2lsbCBoYW5kbGUgY29weWluZyB0aGUgcmVzdWx0IGFuZCByZXF1ZXN0IGZpZWxkc1xuICAgICAgICAgICAgYXdhaXQgY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyIGFycmF5IGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IFtdO1xuICAgICAgICBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdID0gYWN0aXZlUmVxdWVzdEhhbmRsZXJzO1xuICAgICAgICAvLyBhbGxvdyByZXF1ZXN0IHRvIGJlIGhhbmRsZWQgbm9ybWFsbHlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgLy8gY2xlYXIgaW5mbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgZGVsZXRlIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgIC8vIHNjaGVkdWxlIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyB0byBiZSBoYW5kbGVkXG4gICAgICAgIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcHJvbWlzZSB9ID0gZGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5wdXNoKChoYW5kbGVkUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBhcHBlbmQgYSBjb3B5IG9mIHRoZSByZXN1bHQgYW5kIGVycm9yIHRvIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgcmVzLnJlc3VsdCA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKGhhbmRsZWRSZXMucmVzdWx0KTtcbiAgICAgICAgICAgIHJlcy5lcnJvciA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKGhhbmRsZWRSZXMuZXJyb3IpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgLy8gdXNlIHNldFRpbWVvdXQgc28gd2UgY2FuIHJlc29sdmUgb3VyIG9yaWdpbmFsIHJlcXVlc3QgZmlyc3RcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXRjaCBlcnJvciBzbyBhbGwgcmVxdWVzdHMgYXJlIGhhbmRsZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlO1xuZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHJlc29sdmUsIHByb21pc2UgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmxpZ2h0LWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBleHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL2dsb2JhbC1yZXF1aXJlLEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbmNvbnN0IGZldGNoID0gZ2xvYmFsLmZldGNoIHx8IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcbmNvbnN0IGJ0b2EgPSBnbG9iYWwuYnRvYSB8fCByZXF1aXJlKCdidG9hJyk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvZ2xvYmFsLXJlcXVpcmUsQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ2ZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5JyxcbiAgICAvLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcbiAgICAnRmFpbGVkIHRvIGZldGNoJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVGZXRjaE1pZGRsZXdhcmUoeyBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9ID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIG9yaWdpbkh0dHBIZWFkZXJLZXksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xuICAgICAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXG4gICAgICAgICAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Qm9keSA9IGF3YWl0IGZldGNoUmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hCb2R5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlLXRocm93IGVycm9yIGlmIG5vdCByZXRyaWFibGVcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlO1xuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgICAgIGNhc2UgNDE4OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBkYXRhOiBib2R5LmVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgcmV0dXJuIGJvZHkucmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHsgcmVxLCBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1VybCk7XG4gICAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCk7XG4gICAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gICAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICAgIH07XG4gICAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gICAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjtcbiAgICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkLFxuICAgIH07XG4gICAgLy8gZW5jb2RlZCBhdXRoIGRldGFpbHMgYXMgaGVhZGVyIChub3QgYWxsb3dlZCBpbiBmZXRjaCB1cmwpXG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSAmJiBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXV0aFN0cmluZyA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgY29uc3QgZW5jb2RlZEF1dGggPSBidG9hKGF1dGhTdHJpbmcpO1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHtlbmNvZGVkQXV0aH1gO1xuICAgIH1cbiAgICAvLyBvcHRpb25hbDogYWRkIHJlcXVlc3Qgb3JpZ2luIGFzIGhlYWRlclxuICAgIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzW29yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4geyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxO1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgcmVzdWx0ICs9IHBhcnNlZFVybC5wcm90b2NvbDtcbiAgICByZXN1bHQgKz0gYC8vJHtwYXJzZWRVcmwuaG9zdG5hbWV9YDtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IGA6JHtwYXJzZWRVcmwucG9ydH1gO1xuICAgIH1cbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5zZWFyY2h9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBtc2cgfSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdmlkZXJGcm9tTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHByb3ZpZGVyRnJvbUVuZ2luZV8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tRW5naW5lXCIpO1xuZnVuY3Rpb24gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShtaWRkbGV3YXJlKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IGpzb25fcnBjX2VuZ2luZV8xLkpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaChtaWRkbGV3YXJlKTtcbiAgICBjb25zdCBwcm92aWRlciA9ICgwLCBwcm92aWRlckZyb21FbmdpbmVfMS5wcm92aWRlckZyb21FbmdpbmUpKGVuZ2luZSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZXhwb3J0cy5wcm92aWRlckZyb21NaWRkbGV3YXJlID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyRnJvbU1pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuLy9cbi8vIFJldHJ5T25FbXB0eU1pZGRsZXdhcmUgd2lsbCByZXRyeSBhbnkgcmVxdWVzdCB3aXRoIGFuIGVtcHR5IHJlc3BvbnNlIHRoYXQgaGFzXG4vLyBhIG51bWJlcmVkIGJsb2NrIHJlZmVyZW5jZSBhdCBvciBsb3dlciB0aGFuIHRoZSBibG9ja1RyYWNrZXIncyBsYXRlc3QgYmxvY2suXG4vLyBJdHMgdXNlZnVsIGZvciBkZWFsaW5nIHdpdGggbG9hZC1iYWxhbmNlZCBldGhlcmV1bSBKU09OIFJQQ1xuLy8gbm9kZXMgdGhhdCBhcmUgbm90IGFsd2F5cyBpbiBzeW5jIHdpdGggZWFjaCBvdGhlci5cbi8vXG4vLyBlbXB0eSB2YWx1ZXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkXG4vLyBgPG5pbD5gIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8xNjkyNVxuY29uc3QgZW1wdHlWYWx1ZXMgPSBbXG4gICAgdW5kZWZpbmVkLFxuICAgIG51bGwsXG4gICAgJ1xcdTAwM2NuaWxcXHUwMDNlJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcInByb3ZpZGVyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gKDAsIGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KShyZXEpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgZXhhY3QgYmxvY2sgcmVmZXJlbmNlc1xuICAgICAgICBsZXQgYmxvY2tSZWYgPSAoX2EgPSByZXEucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYmxvY2tSZWZJbmRleF07XG4gICAgICAgIC8vIG9taXR0ZWQgYmxvY2tSZWYgaW1wbGllcyBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibG9ja1JlZiA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm9uLW51bWJlciBibG9jayByZWZlcmVuY2VcbiAgICAgICAgaWYgKFsnbGF0ZXN0JywgJ3BlbmRpbmcnXS5pbmNsdWRlcyhibG9ja1JlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBibG9jayByZWZlcm5jZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgY29uc3QgYmxvY2tSZWZOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tSZWYuc2xpY2UoMiksIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihibG9ja1JlZk51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlckhleCA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChsYXRlc3RCbG9ja051bWJlckhleC5zbGljZSgyKSwgMTYpO1xuICAgICAgICAvLyBza2lwIGlmIHJlcXVlc3QgYmxvY2sgbnVtYmVyIGlzIGhpZ2hlciB0aGFuIGN1cnJlbnRcbiAgICAgICAgaWYgKGJsb2NrUmVmTnVtYmVyID4gbGF0ZXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gKDAsIGNsb25lXzEuZGVmYXVsdCkocmVxKTtcbiAgICAgICAgLy8gYXR0ZW1wdCBjaGlsZCByZXF1ZXN0IHVudGlsIG5vbi1lbXB0eSByZXNwb25zZSBpcyByZWNlaXZlZFxuICAgICAgICBjb25zdCBjaGlsZFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoMTAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRSZXNwb25zZSA9IGF3YWl0ICgwLCBwaWZ5XzEuZGVmYXVsdCkocHJvdmlkZXIuc2VuZEFzeW5jKS5jYWxsKHByb3ZpZGVyLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlc3VsdFxuICAgICAgICAgICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKGF0dGVtcHRSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBlbXB0eSByZXNwb25zZSBcIiR7SlNPTi5zdHJpbmdpZnkoYXR0ZW1wdFJlc3BvbnNlKX1cIiBmb3IgcmVxdWVzdCBcIiR7SlNPTi5zdHJpbmdpZnkoY2hpbGRSZXF1ZXN0KX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHRSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvcHkgY2hpbGQgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICByZXMucmVzdWx0ID0gY2hpbGRSZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzcG9uc2UuZXJyb3I7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUgPSBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlO1xuYXN5bmMgZnVuY3Rpb24gcmV0cnkobWF4UmV0cmllcywgYXN5bmNGbikge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXhSZXRyaWVzOyBpbmRleCsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXN5bmNGbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gcmV0cmllcyBleGhhdXN0ZWQnKTtcbn1cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5T25FbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcInByb3ZpZGVyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZk1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSAoMCwgY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgpKHJlcSk7XG4gICAgICAgIC8vIHNraXAgaWYgbWV0aG9kIGRvZXMgbm90IGluY2x1ZGUgYmxvY2tSZWZcbiAgICAgICAgaWYgKGJsb2NrUmVmSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vdCBcImxhdGVzdFwiXG4gICAgICAgIGxldCBibG9ja1JlZiA9IChfYSA9IHJlcS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtibG9ja1JlZkluZGV4XTtcbiAgICAgICAgLy8gb21pdHRlZCBibG9ja1JlZiBpbXBsaWVzIFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsb2NrUmVmID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrUmVmICE9PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIC8vIGNyZWF0ZSBjaGlsZCByZXF1ZXN0IHdpdGggc3BlY2lmaWMgYmxvY2stcmVmXG4gICAgICAgIGNvbnN0IGNoaWxkUmVxdWVzdCA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKHJlcSk7XG4gICAgICAgIGlmIChjaGlsZFJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgICAgICBjaGlsZFJlcXVlc3QucGFyYW1zW2Jsb2NrUmVmSW5kZXhdID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBjaGlsZCByZXF1ZXN0XG4gICAgICAgIGNvbnN0IGNoaWxkUmVzID0gYXdhaXQgKDAsIHBpZnlfMS5kZWZhdWx0KShwcm92aWRlci5zZW5kQXN5bmMpLmNhbGwocHJvdmlkZXIsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgIC8vIGNvcHkgY2hpbGQgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICByZXMucmVzdWx0ID0gY2hpbGRSZXMucmVzdWx0O1xuICAgICAgICByZXMuZXJyb3IgPSBjaGlsZFJlcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stcmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCgpO1xuICAgIC8vIGhhbmRsZSBib3RoIHJwYyBzZW5kIG1ldGhvZHNcbiAgICBwcm92aWRlci5zZW5kQXN5bmMgPSBlbmdpbmUuaGFuZGxlLmJpbmQoZW5naW5lKTtcbiAgICBwcm92aWRlci5zZW5kID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xuICAgICAgICB9XG4gICAgICAgIGVuZ2luZS5oYW5kbGUocmVxLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgICBpZiAoZW5naW5lLm9uKSB7XG4gICAgICAgIGVuZ2luZS5vbignbm90aWZpY2F0aW9uJywgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoJ2RhdGEnLCBudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gcHJvdmlkZXJGcm9tRW5naW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJGcm9tRW5naW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIF9yZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gKDAsIGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KShyZXEpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgXCJsYXRlc3RcIlxuICAgICAgICBsZXQgYmxvY2tSZWYgPSAoX2EgPSByZXEucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYmxvY2tSZWZJbmRleF07XG4gICAgICAgIC8vIG9taXR0ZWQgYmxvY2tSZWYgaW1wbGllcyBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibG9ja1JlZiA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1JlZiAhPT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV3cml0ZSBibG9ja1JlZiB0byBibG9jay10cmFja2VyJ3MgYmxvY2sgbnVtYmVyXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGlmIChyZXEucGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgICAgICAgcmVxLnBhcmFtc1tibG9ja1JlZkluZGV4XSA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stcmVmLXJld3JpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlV2FsbGV0TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHNpZ1V0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aC1zaWctdXRpbFwiKSk7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2FsbGV0TWlkZGxld2FyZSh7IGdldEFjY291bnRzLCBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UsIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LCBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UsIHByb2Nlc3NUcmFuc2FjdGlvbiwgcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbiwgcHJvY2Vzc1R5cGVkTWVzc2FnZSwgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzLCBwcm9jZXNzVHlwZWRNZXNzYWdlVjQsIH0pIHtcbiAgICBpZiAoIWdldEFjY291bnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0cy5nZXRBY2NvdW50cyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSkoe1xuICAgICAgICAvLyBhY2NvdW50IGxvb2t1cHNcbiAgICAgICAgZXRoX2FjY291bnRzOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShsb29rdXBBY2NvdW50cyksXG4gICAgICAgIGV0aF9jb2luYmFzZTogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkobG9va3VwRGVmYXVsdEFjY291bnQpLFxuICAgICAgICAvLyB0eCBzaWduYXR1cmVzXG4gICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHNlbmRUcmFuc2FjdGlvbiksXG4gICAgICAgIGV0aF9zaWduVHJhbnNhY3Rpb246ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHNpZ25UcmFuc2FjdGlvbiksXG4gICAgICAgIC8vIG1lc3NhZ2Ugc2lnbmF0dXJlc1xuICAgICAgICBldGhfc2lnbjogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoZXRoU2lnbiksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShzaWduVHlwZWREYXRhKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjM6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHNpZ25UeXBlZERhdGFWMyksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShzaWduVHlwZWREYXRhVjQpLFxuICAgICAgICBwZXJzb25hbF9zaWduOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShwZXJzb25hbFNpZ24pLFxuICAgICAgICBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleTogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoZW5jcnlwdGlvblB1YmxpY0tleSksXG4gICAgICAgIGV0aF9kZWNyeXB0OiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShkZWNyeXB0TWVzc2FnZSksXG4gICAgICAgIHBlcnNvbmFsX2VjUmVjb3ZlcjogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkocGVyc29uYWxSZWNvdmVyKSxcbiAgICB9KTtcbiAgICAvL1xuICAgIC8vIGFjY291bnQgbG9va3Vwc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9va3VwQWNjb3VudHMocmVxLCByZXMpIHtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvb2t1cERlZmF1bHRBY2NvdW50KHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGFjY291bnRzWzBdIHx8IG51bGw7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gdHJhbnNhY3Rpb24gc2lnbmF0dXJlc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFRyYW5zYWN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSByZXEucGFyYW1zWzBdIHx8IHt9O1xuICAgICAgICB0eFBhcmFtcy5mcm9tID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIodHhQYXJhbXMuZnJvbSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0gcmVxLnBhcmFtc1swXSB8fCB7fTtcbiAgICAgICAgdHhQYXJhbXMuZnJvbSA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHR4UGFyYW1zLmZyb20sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzU2lnblRyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIG1lc3NhZ2Ugc2lnbmF0dXJlc1xuICAgIC8vXG4gICAgYXN5bmMgZnVuY3Rpb24gZXRoU2lnbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NFdGhTaWduTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0V0aFNpZ25NZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMV0sIHJlcSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjEnO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YVYzKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZVYzKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1YzJztcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzKG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2lnblR5cGVkRGF0YVY0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZVY0KSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1Y0JztcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0KG1zZ1BhcmFtcywgcmVxLCB2ZXJzaW9uKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGVyc29uYWxTaWduKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb2Nlc3Mgbm9ybWFsbHlcbiAgICAgICAgY29uc3QgZmlyc3RQYXJhbSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IHNlY29uZFBhcmFtID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgLy8gbm9uLXN0YW5kYXJkIFwiZXh0cmFQYXJhbXNcIiB0byBiZSBhcHBlbmRlZCB0byBvdXIgXCJtc2dQYXJhbXNcIiBvYmpcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICAvLyBXZSBpbml0aWFsbHkgaW5jb3JyZWN0bHkgb3JkZXJlZCB0aGVzZSBwYXJhbWV0ZXJzLlxuICAgICAgICAvLyBUbyBncmFjZWZ1bGx5IHJlc3BlY3QgdXNlcnMgd2hvIGFkb3B0ZWQgdGhpcyBBUEkgZWFybHksXG4gICAgICAgIC8vIHdlIGFyZSBjdXJyZW50bHkgZ3JhY2VmdWxseSByZWNvdmVyaW5nIGZyb20gdGhlIHdyb25nIHBhcmFtIG9yZGVyXG4gICAgICAgIC8vIHdoZW4gaXQgaXMgY2xlYXJseSBpZGVudGlmaWFibGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgd2hlbiB0aGUgZmlyc3QgcGFyYW0gaXMgZGVmaW5pdGVseSBhbiBhZGRyZXNzLFxuICAgICAgICAvLyBhbmQgdGhlIHNlY29uZCBwYXJhbSBpcyBkZWZpbml0ZWx5IG5vdCwgYnV0IGlzIGhleC5cbiAgICAgICAgbGV0IGFkZHJlc3MsIG1lc3NhZ2U7XG4gICAgICAgIGlmIChyZXNlbWJsZXNBZGRyZXNzKGZpcnN0UGFyYW0pICYmICFyZXNlbWJsZXNBZGRyZXNzKHNlY29uZFBhcmFtKSkge1xuICAgICAgICAgICAgbGV0IHdhcm5pbmcgPSBgVGhlIGV0aF9wZXJzb25hbFNpZ24gbWV0aG9kIHJlcXVpcmVzIHBhcmFtcyBvcmRlcmVkIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBbbWVzc2FnZSwgYWRkcmVzc10uIFRoaXMgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbmNvcnJlY3RseSwgYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYGFuZCBoYXMgYmVlbiBjb3JyZWN0ZWQgYXV0b21hdGljYWxseS4gYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYFBsZWFzZSBzd2l0Y2ggdGhpcyBwYXJhbSBvcmRlciBmb3Igc21vb3RoIGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuYDtcbiAgICAgICAgICAgIHJlcy53YXJuaW5nID0gd2FybmluZztcbiAgICAgICAgICAgIGFkZHJlc3MgPSBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHNlY29uZFBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGZpcnN0UGFyYW07XG4gICAgICAgICAgICBhZGRyZXNzID0gc2Vjb25kUGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKGFkZHJlc3MsIHJlcSk7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzXG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzUGVyc29uYWxNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcGVyc29uYWxSZWNvdmVyKHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IHNpZzogc2lnbmF0dXJlLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUobXNnUGFyYW1zKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IHNpZ25lckFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRpb25QdWJsaWNLZXkocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXkoYWRkcmVzcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdE1lc3NhZ2UocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRGVjcnlwdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMV0sIHJlcSk7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogY2lwaGVydGV4dCB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gdXRpbGl0eVxuICAgIC8vXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBrZXlob2xkZXIgYWRkcmVzcywgYW5kIHJldHVybnMgYSBub3JtYWxpemVkIChpLmUuIGxvd2VyY2FzZSlcbiAgICAgKiBjb3B5IG9mIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbm9ybWFsaXplZCBhZGRyZXNzLCBpZiB2YWxpZC4gT3RoZXJ3aXNlLCB0aHJvd3NcbiAgICAgKiBhbiBlcnJvclxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKGFkZHJlc3MsIHJlcSkge1xuICAgICAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnICYmIGFkZHJlc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gZW5zdXJlIGFkZHJlc3MgaXMgaW5jbHVkZWQgaW4gcHJvdmlkZWQgYWNjb3VudHNcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBY2NvdW50cyA9IGFjY291bnRzLm1hcCgoX2FkZHJlc3MpID0+IF9hZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZEFjY291bnRzLmluY2x1ZGVzKG5vcm1hbGl6ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXJhbWV0ZXJzOiBtdXN0IHByb3ZpZGUgYW4gRXRoZXJldW0gYWRkcmVzcy5gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlO1xuZnVuY3Rpb24gcmVzZW1ibGVzQWRkcmVzcyhzdHIpIHtcbiAgICAvLyBoZXggcHJlZml4IDIgKyAyMCBieXRlc1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAyICsgMjAgKiAyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMVxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIwIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCkge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLSA+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTApIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiIsImNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vc3JjL2NsaWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xpZW50LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1NuYXBDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFNlcnZpY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1dlYldvcmtlckV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGVybWlzc2lvblJwY01ldGhvZHMgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2F2ZWF0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QZXJtaXNzaW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QZXJtaXNzaW9uQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuLy8gVE9ETzogTW92ZSB0aGVzZSB0byB0aGUgYXBwcm9wcmlhdGUgcGFja2FnZVxuZXhwb3J0cy5wZXJtaXNzaW9uUnBjTWV0aG9kcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9ycGMtbWV0aG9kc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmFzZUV0aEtleXJpbmcgPSByZXF1aXJlKCdAa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgb2JzU3RvcmUgPSByZXF1aXJlKCdAbWV0YW1hc2svb2JzLXN0b3JlJyk7XG52YXIgYmNVclJlZ2lzdHJ5RXRoID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciB0eCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG52YXIgcmxwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JscCcpKTtcblxuY2xhc3MgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHN5bmM6IHtcbiAgICAgICAgICAgIHJlYWRpbmc6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXknLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9IREtleSA9IGJjVXJSZWdpc3RyeUV0aC5DcnlwdG9IREtleS5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCAnaGV4JykpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoY3J5cHRvSERLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbigna2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnQnLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9BY2NvdW50ID0gYmNVclJlZ2lzdHJ5RXRoLkNyeXB0b0FjY291bnQuZnJvbUNCT1IoQnVmZmVyLmZyb20oY2JvciwgJ2hleCcpKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKGNyeXB0b0FjY291bnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbigna2V5c3RvbmUtc3luY19jYW5jZWwnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignS2V5c3RvbmVFcnJvciNzeW5jX2NhbmNlbC4gU3luYyBwcm9jZXNzIGNhbmNlbGVkLCBwbGVhc2UgcmV0cnknKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvSERLZXkgPSBjYm9yID0+IHtcbiAgICAgIHRoaXMuZW1pdCgna2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5JywgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudCA9IGNib3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudCcsIGNib3IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbFN5bmMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2tleXN0b25lLXN5bmNfY2FuY2VsJyk7XG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdFNpZ25hdHVyZSA9IChzaWduUmVxdWVzdCwgcmVxdWVzdFRpdGxlLCByZXF1ZXN0RGVzY3JpcHRpb24pID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVyID0gc2lnblJlcXVlc3QudG9VUigpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWRCdWZmZXIgPSBzaWduUmVxdWVzdC5nZXRSZXF1ZXN0SWQoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC5zdHJpbmdpZnkocmVxdWVzdElkQnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc2lnblBheWxvYWQgPSB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHVyLnR5cGUsXG4gICAgICAgICAgICBjYm9yOiB1ci5jYm9yLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHJlcXVlc3RUaXRsZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogcmVxdWVzdERlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHNpZ25QYXlsb2FkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKGAke3JlcXVlc3RJZH0tc2lnbmVkYCwgY2JvciA9PiB7XG4gICAgICAgICAgY29uc3QgZXRoU2lnbmF0dXJlID0gYmNVclJlZ2lzdHJ5RXRoLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCAnaGV4JykpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoZXRoU2lnbmF0dXJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jZShgJHtyZXF1ZXN0SWR9LWNhbmNlbGVkYCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjVHhfY2FuY2VsZWQuIFNpZ25pbmcgY2FuY2VsZWQsIHBsZWFzZSByZXRyeScpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRTaWduYXR1cmUgPSAocmVxdWVzdElkLCBjYm9yKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoYCR7cmVxdWVzdElkfS1zaWduZWRgLCBjYm9yKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc2lnblBheWxvYWQgPSB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O1xuXG4gICAgICBpZiAoc2lnblBheWxvYWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICB9ID0gc2lnblBheWxvYWQ7XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHNpZ246IHt9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoYCR7cmVxdWVzdElkfS1jYW5jZWxlZGApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0U3RhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgc3luYzoge1xuICAgICAgICAgIHJlYWRpbmc6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ246IHt9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlci5pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbVN0b3JlID0gbmV3IG9ic1N0b3JlLk9ic2VydmFibGVTdG9yZSh7XG4gICAgICBzeW5jOiB7XG4gICAgICAgIHJlYWRpbmc6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2lnbjoge30sXG4gICAgICBfdmVyc2lvbjogMVxuICAgIH0pO1xuICAgIE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlci5pbnN0YW5jZSA9IHRoaXM7XG4gIH1cblxufVxuXG5jbGFzcyBNZXRhTWFza0tleXJpbmcgZXh0ZW5kcyBiYXNlRXRoS2V5cmluZy5CYXNlS2V5cmluZyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb24gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldE1lbVN0b3JlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5tZW1TdG9yZTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVBY2NvdW50ID0gYWRkcmVzcyA9PiB7XG4gICAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKGEgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuZmlsdGVyKGEgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgIH07XG5cbiAgICB0aGlzLmZvcmdldERldmljZSA9ICgpID0+IHtcbiAgICAgIC8vY29tbW9uIHByb3BzXG4gICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgdGhpcy5wZXJQYWdlID0gNTtcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgICAgdGhpcy5uYW1lID0gJ1FSIEhhcmR3YXJlJztcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy9oZCBwcm9wcztcblxuICAgICAgdGhpcy54ZnAgPSAnJztcbiAgICAgIHRoaXMueHB1YiA9ICcnO1xuICAgICAgdGhpcy5oZFBhdGggPSAnJztcbiAgICAgIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgICAgdGhpcy5oZGsgPSB1bmRlZmluZWQ7IC8vcHVia2V5IHByb3BzO1xuXG4gICAgICB0aGlzLnBhdGhzID0ge307XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvSERLZXkgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvSERLZXk7XG4gICAgdGhpcy5zdWJtaXRDcnlwdG9BY2NvdW50ID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0FjY291bnQ7XG4gICAgdGhpcy5zdWJtaXRTaWduYXR1cmUgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0U2lnbmF0dXJlO1xuICAgIHRoaXMuY2FuY2VsU3luYyA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxTeW5jO1xuICAgIHRoaXMuY2FuY2VsU2lnblJlcXVlc3QgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsUmVxdWVzdFNpZ25hdHVyZTtcblxuICAgIGlmIChNZXRhTWFza0tleXJpbmcuaW5zdGFuY2UpIHtcbiAgICAgIE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZS5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgICAgIHJldHVybiBNZXRhTWFza0tleXJpbmcuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlID0gdGhpcztcbiAgfVxuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eCQxKSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eCQxLnR5cGUgPT09IDAgPyBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHJhbnNhY3Rpb24gOiBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHlwZWRUcmFuc2FjdGlvbjtcbiAgICBsZXQgbWVzc2FnZVRvU2lnbjtcblxuICAgIGlmICh0eCQxLnR5cGUgPT09IDApIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSBybHAuZW5jb2RlKHR4JDEuZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlVG9TaWduID0gdHgkMS5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3QgY2hhaW5JZCA9IHR4JDEuY29tbW9uLmNoYWluSWQoKTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnY0KCk7XG4gICAgY29uc3QgZXRoU2lnblJlcXVlc3QgPSBiY1VyUmVnaXN0cnlFdGguRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChtZXNzYWdlVG9TaWduLCBkYXRhVHlwZSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCBjaGFpbklkKTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsICdTY2FuIHdpdGggeW91ciBLZXlzdG9uZScsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eCQxLnRvSlNPTigpO1xuICAgIHR4SnNvbi52ID0gdjtcbiAgICB0eEpzb24ucyA9IHM7XG4gICAgdHhKc29uLnIgPSByO1xuICAgIHR4SnNvbi50eXBlID0gdHgkMS50eXBlO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHguVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhKc29uLCB7XG4gICAgICBjb21tb246IHR4JDEuY29tbW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbn1cbk1ldGFNYXNrS2V5cmluZy50eXBlID0gYmFzZUV0aEtleXJpbmcuQmFzZUtleXJpbmcudHlwZTtcblxuZXhwb3J0cy5NZXRhTWFza0tleXJpbmcgPSBNZXRhTWFza0tleXJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZSx0PXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nXCIpLHM9cmVxdWlyZShcImV2ZW50c1wiKSxuPXJlcXVpcmUoXCJAbWV0YW1hc2svb2JzLXN0b3JlXCIpLGk9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aFwiKSxyPXJlcXVpcmUoXCJ1dWlkXCIpLGM9cmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpLG89KGU9cmVxdWlyZShcInJscFwiKSkmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmU7Y2xhc3MgYSBleHRlbmRzIHMuRXZlbnRFbWl0dGVye2NvbnN0cnVjdG9yKCl7aWYoc3VwZXIoKSx0aGlzLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudD0oKT0+bmV3IFByb21pc2UoKGUsdCk9Pnt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzeW5jOntyZWFkaW5nOiEwfX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0hES2V5LmZyb21DQk9SKEJ1ZmZlci5mcm9tKHQsXCJoZXhcIikpO3RoaXMucmVzZXRTdGF0ZSgpLGUocyl9KSx0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0FjY291bnQuZnJvbUNCT1IoQnVmZmVyLmZyb20odCxcImhleFwiKSk7dGhpcy5yZXNldFN0YXRlKCksZShzKX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiLCgpPT57dGhpcy5yZXNldFN0YXRlKCksdChuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI3N5bmNfY2FuY2VsLiBTeW5jIHByb2Nlc3MgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSl9KX0pLHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLGUpfSx0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQ9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsZSl9LHRoaXMuY2FuY2VsU3luYz0oKT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpfSx0aGlzLnJlcXVlc3RTaWduYXR1cmU9KGUsdCxzKT0+bmV3IFByb21pc2UoKG4sYyk9Pntjb25zdCBvPWUudG9VUigpLGE9ZS5nZXRSZXF1ZXN0SWQoKSxoPXIuc3RyaW5naWZ5KGEpLHU9e3JlcXVlc3RJZDpoLHBheWxvYWQ6e3R5cGU6by50eXBlLGNib3I6by5jYm9yLnRvU3RyaW5nKFwiaGV4XCIpfSx0aXRsZTp0LGRlc2NyaXB0aW9uOnN9O3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e3JlcXVlc3Q6dX19KSx0aGlzLm9uY2UoaCtcIi1zaWduZWRcIixlPT57Y29uc3QgdD1pLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShlLFwiaGV4XCIpKTt0aGlzLnJlc2V0U3RhdGUoKSxuKHQpfSksdGhpcy5vbmNlKGgrXCItY2FuY2VsZWRcIiwoKT0+e3RoaXMucmVzZXRTdGF0ZSgpLGMobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNUeF9jYW5jZWxlZC4gU2lnbmluZyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKX0pfSksdGhpcy5zdWJtaXRTaWduYXR1cmU9KGUsdCk9Pnt0aGlzLmVtaXQoZStcIi1zaWduZWRcIix0KX0sdGhpcy5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlPSgpPT57Y29uc3QgZT10aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O2lmKGUpe2NvbnN0e3JlcXVlc3RJZDp0fT1lO3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e319KSx0aGlzLmVtaXQodCtcIi1jYW5jZWxlZFwiKX19LHRoaXMucmVzZXRTdGF0ZT0oKT0+e3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3N5bmM6e3JlYWRpbmc6ITF9LHNpZ246e319KX0sYS5pbnN0YW5jZSlyZXR1cm4gYS5pbnN0YW5jZTt0aGlzLm1lbVN0b3JlPW5ldyBuLk9ic2VydmFibGVTdG9yZSh7c3luYzp7cmVhZGluZzohMX0sc2lnbjp7fSxfdmVyc2lvbjoxfSksYS5pbnN0YW5jZT10aGlzfX1jbGFzcyBoIGV4dGVuZHMgdC5CYXNlS2V5cmluZ3tjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmdldEludGVyYWN0aW9uPSgpPT5uZXcgYSx0aGlzLmdldE1lbVN0b3JlPSgpPT50aGlzLmdldEludGVyYWN0aW9uKCkubWVtU3RvcmUsdGhpcy5yZW1vdmVBY2NvdW50PWU9PntpZighdGhpcy5hY2NvdW50cy5tYXAoZT0+ZS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhlLnRvTG93ZXJDYXNlKCkpKXRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2V9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTt0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuZmlsdGVyKHQ9PnQudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSl9LHRoaXMuZm9yZ2V0RGV2aWNlPSgpPT57dGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy5uYW1lPVwiUVIgSGFyZHdhcmVcIix0aGlzLmluaXRpYWxpemVkPSExLHRoaXMueGZwPVwiXCIsdGhpcy54cHViPVwiXCIsdGhpcy5oZFBhdGg9XCJcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5oZGs9dm9pZCAwLHRoaXMucGF0aHM9e319LHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9dGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0hES2V5LHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudD10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudCx0aGlzLnN1Ym1pdFNpZ25hdHVyZT10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0U2lnbmF0dXJlLHRoaXMuY2FuY2VsU3luYz10aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsU3luYyx0aGlzLmNhbmNlbFNpZ25SZXF1ZXN0PXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlLGguaW5zdGFuY2UpcmV0dXJuIGguaW5zdGFuY2UuZGVzZXJpYWxpemUoZSksaC5pbnN0YW5jZTtoLmluc3RhbmNlPXRoaXN9YXN5bmMgc2lnblRyYW5zYWN0aW9uKGUsdCl7Y29uc3Qgcz0wPT09dC50eXBlP2kuRGF0YVR5cGUudHJhbnNhY3Rpb246aS5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO2xldCBuO249MD09PXQudHlwZT9vLmVuY29kZSh0LmdldE1lc3NhZ2VUb1NpZ24oITEpKTp0LmdldE1lc3NhZ2VUb1NpZ24oITEpO2NvbnN0IGE9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLGg9dC5jb21tb24uY2hhaW5JZCgpLHU9ci52NCgpLHk9aS5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG4scyxhLHRoaXMueGZwLHUsaCkse3I6ZyxzOm0sdjpkfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUodSx5LFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJykscD10LnRvSlNPTigpO3JldHVybiBwLnY9ZCxwLnM9bSxwLnI9ZyxwLnR5cGU9dC50eXBlLGMuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEocCx7Y29tbW9uOnQuY29tbW9ufSl9fWgudHlwZT10LkJhc2VLZXlyaW5nLnR5cGUsZXhwb3J0cy5NZXRhTWFza0tleXJpbmc9aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcy5tYXBcbiIsImZ1bmN0aW9uIGRlbGF5KHRpbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZEZyb21Nb2NrM0JveChrZXkpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93LmZldGNoKGBodHRwOi8vbG9jYWxob3N0Ojg4ODk/a2V5PSR7a2V5fWApO1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgcmV0dXJuIHRleHQubGVuZ3RoID8gSlNPTi5wYXJzZSh0ZXh0KSA6IG51bGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhdmVUb01vY2szQm94KGtleSwgbmV3RGF0YUF0S2V5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHdpbmRvdy5mZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4ODg5Jywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGtleSxcbiAgICAgIGRhdGE6IG5ld0RhdGFBdEtleSxcbiAgICB9KSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcy50ZXh0KCk7XG59XG5cbmNsYXNzIE1vY2szQm94IHtcbiAgc3RhdGljIG9wZW5Cb3goYWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBvblN5bmNEb25lOiAoY2IpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMjAwKTtcbiAgICAgIH0sXG4gICAgICBvcGVuU3BhY2U6IGFzeW5jIChzcGFjZU5hbWUsIGNvbmZpZykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uU3luY0RvbmUgfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5zcGFjZU5hbWUgPSBzcGFjZU5hbWU7XG5cbiAgICAgICAgc2V0VGltZW91dChvblN5bmNEb25lLCAxNTApO1xuXG4gICAgICAgIGF3YWl0IGRlbGF5KDUwKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByaXZhdGU6IHtcbiAgICAgICAgICAgIGdldDogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICBhd2FpdCBkZWxheSg1MCk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGxvYWRGcm9tTW9jazNCb3goXG4gICAgICAgICAgICAgICAgYCR7dGhpcy5hZGRyZXNzfS0ke3RoaXMuc3BhY2VOYW1lfS0ke2tleX1gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogYXN5bmMgKGtleSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBhd2FpdCBzYXZlVG9Nb2NrM0JveChcbiAgICAgICAgICAgICAgICBgJHt0aGlzLmFkZHJlc3N9LSR7dGhpcy5zcGFjZU5hbWV9LSR7a2V5fWAsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoNTApO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsb2dvdXQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRDb25maWcoYWRkcmVzcykge1xuICAgIGNvbnN0IGJhY2t1cCA9IGF3YWl0IGxvYWRGcm9tTW9jazNCb3goYCR7YWRkcmVzc30tbWV0YW1hc2stbWV0YW1hc2tCYWNrdXBgKTtcbiAgICByZXR1cm4gYmFja3VwID8geyBzcGFjZXM6IHsgbWV0YW1hc2s6IHt9IH0gfSA6IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9jazNCb3g7XG4iLCJpbXBvcnQgeyBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUsIG1lcmdlTWlkZGxld2FyZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQgeyBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlIH0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUGVuZGluZ05vbmNlTWlkZGxld2FyZSxcbiAgY3JlYXRlUGVuZGluZ1R4TWlkZGxld2FyZSxcbn0gZnJvbSAnLi9taWRkbGV3YXJlL3BlbmRpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVNZXRhbWFza01pZGRsZXdhcmUoe1xuICB2ZXJzaW9uLFxuICBnZXRBY2NvdW50cyxcbiAgcHJvY2Vzc1RyYW5zYWN0aW9uLFxuICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsXG4gIHByb2Nlc3NUeXBlZE1lc3NhZ2UsXG4gIHByb2Nlc3NUeXBlZE1lc3NhZ2VWMyxcbiAgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LFxuICBwcm9jZXNzUGVyc29uYWxNZXNzYWdlLFxuICBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UsXG4gIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LFxuICBnZXRQZW5kaW5nTm9uY2UsXG4gIGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaCxcbn0pIHtcbiAgY29uc3QgbWV0YW1hc2tNaWRkbGV3YXJlID0gbWVyZ2VNaWRkbGV3YXJlKFtcbiAgICBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgICAgZXRoX3N5bmNpbmc6IGZhbHNlLFxuICAgICAgd2ViM19jbGllbnRWZXJzaW9uOiBgTWV0YU1hc2svdiR7dmVyc2lvbn1gLFxuICAgIH0pLFxuICAgIGNyZWF0ZVdhbGxldE1pZGRsZXdhcmUoe1xuICAgICAgZ2V0QWNjb3VudHMsXG4gICAgICBwcm9jZXNzVHJhbnNhY3Rpb24sXG4gICAgICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlLFxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzLFxuICAgICAgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LFxuICAgICAgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSxcbiAgICAgIHByb2Nlc3NEZWNyeXB0TWVzc2FnZSxcbiAgICAgIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LFxuICAgIH0pLFxuICAgIGNyZWF0ZVBlbmRpbmdOb25jZU1pZGRsZXdhcmUoeyBnZXRQZW5kaW5nTm9uY2UgfSksXG4gICAgY3JlYXRlUGVuZGluZ1R4TWlkZGxld2FyZSh7IGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaCB9KSxcbiAgXSk7XG4gIHJldHVybiBtZXRhbWFza01pZGRsZXdhcmU7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIikpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBsb2NhbHN0b3JhZ2UgPSByZXF1aXJlKCdzdG9yZScpO1xuXG52YXIgSVBGUyA9IHJlcXVpcmUoJ2lwZnMnKTtcblxudmFyIE9yYml0REIgPSByZXF1aXJlKCdvcmJpdC1kYicpO1xuXG52YXIgUHVic3ViID0gcmVxdWlyZSgnb3JiaXQtZGItcHVic3ViJyk7IC8vIGNvbnN0IE9yYml0REJDYWNoZVByb3h5ID0gcmVxdWlyZSgnb3JiaXQtZGItY2FjaGUtcG9zdG1zZy1wcm94eScpLkNsaWVudFxuLy8gY29uc3QgeyBjcmVhdGVQcm94eUNsaWVudCB9ID0gcmVxdWlyZSgnaXBmcy1wb3N0bXNnLXByb3h5JylcblxuXG52YXIgQWNjZXNzQ29udHJvbGxlcnMgPSByZXF1aXJlKCdvcmJpdC1kYi1hY2Nlc3MtY29udHJvbGxlcnMnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnM2JveC1vcmJpdGRiLXBsdWdpbnMnKSxcbiAgICBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIgPSBfcmVxdWlyZS5MZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXIsXG4gICAgVGhyZWFkQWNjZXNzQ29udHJvbGxlciA9IF9yZXF1aXJlLlRocmVhZEFjY2Vzc0NvbnRyb2xsZXIsXG4gICAgTW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlciA9IF9yZXF1aXJlLk1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXI7XG5cbkFjY2Vzc0NvbnRyb2xsZXJzLmFkZEFjY2Vzc0NvbnRyb2xsZXIoe1xuICBBY2Nlc3NDb250cm9sbGVyOiBMZWdhY3lJUEZTM0JveEFjY2Vzc0NvbnRyb2xsZXJcbn0pO1xuQWNjZXNzQ29udHJvbGxlcnMuYWRkQWNjZXNzQ29udHJvbGxlcih7XG4gIEFjY2Vzc0NvbnRyb2xsZXI6IFRocmVhZEFjY2Vzc0NvbnRyb2xsZXJcbn0pO1xuQWNjZXNzQ29udHJvbGxlcnMuYWRkQWNjZXNzQ29udHJvbGxlcih7XG4gIEFjY2Vzc0NvbnRyb2xsZXI6IE1vZGVyYXRvckFjY2Vzc0NvbnRyb2xsZXJcbn0pO1xuXG52YXIgVGhyZWVJZCA9IHJlcXVpcmUoJy4vM2lkJyk7XG5cbnZhciBQdWJsaWNTdG9yZSA9IHJlcXVpcmUoJy4vcHVibGljU3RvcmUnKTtcblxudmFyIFByaXZhdGVTdG9yZSA9IHJlcXVpcmUoJy4vcHJpdmF0ZVN0b3JlJyk7XG5cbnZhciBWZXJpZmllZCA9IHJlcXVpcmUoJy4vdmVyaWZpZWQnKTtcblxudmFyIFNwYWNlID0gcmVxdWlyZSgnLi9zcGFjZScpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2luZGV4Jyk7XG5cbnZhciBpZFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZCcpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcuanMnKTtcblxudmFyIEFQSSA9IHJlcXVpcmUoJy4vYXBpJyk7XG5cbnZhciBBQ0NPVU5UX1RZUEVTID0ge1xuICBldGhlcmV1bTogJ2V0aGVyZXVtJyxcbiAgZXRoZXJldW1FT0E6ICdldGhlcmV1bS1lb2EnXG59O1xudmFyIEFERFJFU1NfU0VSVkVSX1VSTCA9IGNvbmZpZy5hZGRyZXNzX3NlcnZlcl91cmw7XG52YXIgUElOTklOR19OT0RFID0gY29uZmlnLnBpbm5pbmdfbm9kZTtcbnZhciBQSU5OSU5HX1JPT00gPSBjb25maWcucGlubmluZ19yb29tOyAvLyBjb25zdCBJRlJBTUVfU1RPUkVfVkVSU0lPTiA9ICcwLjAuMydcbi8vIGNvbnN0IElGUkFNRV9TVE9SRV9VUkwgPSBgaHR0cHM6Ly9pZnJhbWUuM2JveC5pby8ke0lGUkFNRV9TVE9SRV9WRVJTSU9OfS9pZnJhbWUuaHRtbGBcblxudmFyIElQRlNfT1BUSU9OUyA9IGNvbmZpZy5pcGZzX29wdGlvbnM7XG52YXIgT1JCSVREQl9PUFRTID0gY29uZmlnLm9yYml0ZGJfb3B0aW9ucztcbnZhciBnbG9iYWxJUEZTLCBnbG9iYWxPcmJpdERCOyAvLyAsIGlwZnNQcm94eSwgY2FjaGVQcm94eSwgaWZyYW1lTG9hZGVkUHJvbWlzZVxuXG4vKlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgaWZyYW1lLnNyYyA9IElGUkFNRV9TVE9SRV9VUkxcbiAgaWZyYW1lLnN0eWxlID0gJ3dpZHRoOjA7IGhlaWdodDowOyBib3JkZXI6MDsgYm9yZGVyOm5vbmUgIWltcG9ydGFudCdcblxuICBpZnJhbWVMb2FkZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7IHJlc29sdmUoKSB9XG4gIH0pXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG4gIC8vIENyZWF0ZSBwcm94eSBjbGllbnRzIHRoYXQgdGFsa3MgdG8gdGhlIGlmcmFtZVxuICBjb25zdCBwb3N0TWVzc2FnZSA9IGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlLmJpbmQoaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gIGlwZnNQcm94eSA9IGNyZWF0ZVByb3h5Q2xpZW50KHsgcG9zdE1lc3NhZ2UgfSlcbiAgY2FjaGVQcm94eSA9IE9yYml0REJDYWNoZVByb3h5KHsgcG9zdE1lc3NhZ2UgfSlcbn0gKi9cblxudmFyIEJveCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBQbGVhc2UgdXNlIHRoZSAqKm9wZW5Cb3gqKiBtZXRob2QgdG8gaW5zdGFudGlhdGUgYSAzQm94XG4gICAqL1xuICBmdW5jdGlvbiBCb3godGhyZWVJZCwgZXRoZXJldW1Qcm92aWRlciwgaXBmcykge1xuICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEJveCk7XG4gICAgdGhpcy5fM2lkID0gdGhyZWVJZDtcbiAgICB0aGlzLl93ZWIzcHJvdmlkZXIgPSBldGhlcmV1bVByb3ZpZGVyO1xuICAgIHRoaXMuX2lwZnMgPSBpcGZzO1xuICAgIHRoaXMuX3NlcnZlclVybCA9IG9wdHMuYWRkcmVzc1NlcnZlciB8fCBBRERSRVNTX1NFUlZFUl9VUkw7XG5cbiAgICB0aGlzLl9vblN5bmNEb25lQ0IgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMuX2JveFN5bmNlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7S2V5VmFsdWVTdG9yZX0gcHVibGljICAgICAgICAgYWNjZXNzIHRoZSBwcm9maWxlIHN0b3JlIG9mIHRoZSB1c2VycyAzQm94XG4gICAgICovXG5cbiAgICB0aGlzW1wicHVibGljXCJdID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0tleVZhbHVlU3RvcmV9IHByaXZhdGUgICAgICAgIGFjY2VzcyB0aGUgcHJpdmF0ZSBzdG9yZSBvZiB0aGUgdXNlcnMgM0JveFxuICAgICAqL1xuXG4gICAgdGhpc1tcInByaXZhdGVcIl0gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVyaWZpZWR9IHZlcmlmaWVkICAgICAgICBjaGVjayBhbmQgY3JlYXRlIHZlcmlmaWNhdGlvbnNcbiAgICAgKi9cblxuICAgIHRoaXMudmVyaWZpZWQgPSBuZXcgVmVyaWZpZWQodGhpcyk7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNwYWNlcyAgICAgICAgICAgIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvcGVuIHNwYWNlcyBpbmRleGVkIGJ5IHRoZWlyIG5hbWUuXG4gICAgICovXG5cbiAgICB0aGlzLnNwYWNlcyA9IHt9OyAvLyBsb2NhbCBzdG9yZSBvZiBhbGwgcGlubmluZyBzZXJ2ZXIgcHVic3ViIG1lc3NhZ2VzIHNlZW4gcmVsYXRlZCB0byBzcGFjZXNcblxuICAgIHRoaXMuc3BhY2VzUHViU3ViTWVzc2FnZXMgPSB7fTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoQm94LCBbe1xuICAgIGtleTogXCJfbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvYWQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgcm9vdFN0b3JlTmFtZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJvb3RTdG9yZUFkZHJlc3MsXG4gICAgICAgICAgICBvbk5ld1BlZXIsXG4gICAgICAgICAgICBfcmVmMixcbiAgICAgICAgICAgIF9yZWYzLFxuICAgICAgICAgICAgcHViU3RvcmVBZGRyZXNzLFxuICAgICAgICAgICAgcHJpdlN0b3JlQWRkcmVzcyxcbiAgICAgICAgICAgIHN5bmNQcm9taXNlcyxcbiAgICAgICAgICAgIGhhc1Jlc3BvbnNlLFxuICAgICAgICAgICAgc3BhY2VNZXNzYWdlRmlsdGVyQWN0aXZlLFxuICAgICAgICAgICAgZmlsdGVyVGltZVNldCxcbiAgICAgICAgICAgIG9uTWVzc2FnZVJlcyxcbiAgICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzLmxlbmd0aCA+IDAgJiYgX2FyZ3MzWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczNbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICByb290U3RvcmVOYW1lID0gdGhpcy5fM2lkLm11cG9ydEZpbmdlcnByaW50ICsgJy5yb290JztcbiAgICAgICAgICAgICAgICB0aGlzLnBpbm5pbmdOb2RlID0gb3B0cy5waW5uaW5nTm9kZSB8fCBQSU5OSU5HX05PREU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pcGZzLnN3YXJtLmNvbm5lY3QodGhpcy5waW5uaW5nTm9kZSwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gT3JiaXREQjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDEgPSB0aGlzLl9pcGZzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MiA9IG9wdHMub3JiaXRQYXRoO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fM2lkLmdldE9kYklkKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My50MyA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50NCA9IHtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogX2NvbnRleHQzLnQyLFxuICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IF9jb250ZXh0My50M1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnQwLmNyZWF0ZUluc3RhbmNlLmNhbGwoX2NvbnRleHQzLnQwLCBfY29udGV4dDMudDEsIF9jb250ZXh0My50NCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmJpdGRiID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgLy8gLCB7IGNhY2hlIH0pXG4gICAgICAgICAgICAgICAgZ2xvYmFsT3JiaXREQiA9IHRoaXMuX29yYml0ZGI7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5fM2lkLmdldEtleXJpbmdCeVNwYWNlTmFtZShyb290U3RvcmVOYW1lKS5nZXRQdWJsaWNLZXlzKHRydWUpLnNpZ25pbmdLZXk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JiaXRkYi5mZWVkKHJvb3RTdG9yZU5hbWUsIF9vYmplY3RTcHJlYWQoe30sIE9SQklUREJfT1BUUywge1xuICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnZGFnLXBiJyxcbiAgICAgICAgICAgICAgICAgIGFjY2Vzc0NvbnRyb2xsZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGU6IFtrZXldLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGVnYWN5LWlwZnMtM2JveCcsXG4gICAgICAgICAgICAgICAgICAgIHNraXBNYW5pZmVzdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RTdG9yZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIHJvb3RTdG9yZUFkZHJlc3MgPSB0aGlzLl9yb290U3RvcmUuYWRkcmVzcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My50NSA9IFB1YnN1YjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMudDYgPSB0aGlzLl9pcGZzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lwZnMuaWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My50NyA9IF9jb250ZXh0My5zZW50LmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1YnN1YiA9IG5ldyBfY29udGV4dDMudDUoX2NvbnRleHQzLnQ2LCBfY29udGV4dDMudDcpO1xuXG4gICAgICAgICAgICAgICAgb25OZXdQZWVyID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0b3BpYywgcGVlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVyID09PSBfdGhpcy5waW5uaW5nTm9kZS5zcGxpdCgnLycpLnBvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHVic3ViLnB1Ymxpc2goUElOTklOR19ST09NLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQSU5fREInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZGJBZGRyZXNzOiByb290U3RvcmVBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWQ6IF90aGlzLkRJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uTmV3UGVlcihfeDIsIF94Mykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzW1wicHVibGljXCJdID0gbmV3IFB1YmxpY1N0b3JlKHRoaXMuX29yYml0ZGIsIHRoaXMuXzNpZC5tdXBvcnRGaW5nZXJwcmludCArICcucHVibGljJywgdGhpcy5fbGlua1Byb2ZpbGUuYmluZCh0aGlzKSwgdGhpcy5fZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQuYmluZCh0aGlzKSwgdGhpcy5fM2lkKTtcbiAgICAgICAgICAgICAgICB0aGlzW1wicHJpdmF0ZVwiXSA9IG5ldyBQcml2YXRlU3RvcmUodGhpcy5fb3JiaXRkYiwgdGhpcy5fM2lkLm11cG9ydEZpbmdlcnByaW50ICsgJy5wcml2YXRlJywgdGhpcy5fZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQuYmluZCh0aGlzKSwgdGhpcy5fM2lkKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDMxO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpc1tcInB1YmxpY1wiXS5fbG9hZCgpLCB0aGlzW1wicHJpdmF0ZVwiXS5fbG9hZCgpXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgICBfcmVmMiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIF9yZWYzID0gKDAsIF9zbGljZWRUb0FycmF5MltcImRlZmF1bHRcIl0pKF9yZWYyLCAyKTtcbiAgICAgICAgICAgICAgICBwdWJTdG9yZUFkZHJlc3MgPSBfcmVmM1swXTtcbiAgICAgICAgICAgICAgICBwcml2U3RvcmVBZGRyZXNzID0gX3JlZjNbMV07XG4gICAgICAgICAgICAgICAgc3luY1Byb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgaGFzUmVzcG9uc2UgPSB7fTsgLy8gRmlsdGVycyBhbmQgc3RvcmUgc3BhY2UgcmVsYXRlZCBtZXNzYWdlcyBmb3IgM3NlY3MsIHRoZSBiZXN0IGVmZm9ydFxuICAgICAgICAgICAgICAgIC8vIHNpbXBsZSBhcHByb2FjaCwgdW50aWwgcmVmYWN0b3JcblxuICAgICAgICAgICAgICAgIHNwYWNlTWVzc2FnZUZpbHRlckFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGltZVNldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgb25NZXNzYWdlUmVzID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHRvcGljLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJUaW1lU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUaW1lU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZU1lc3NhZ2VGaWx0ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEudHlwZSA9PT0gJ0hBU19FTlRSSUVTJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5vZGJBZGRyZXNzID09PSBwcml2U3RvcmVBZGRyZXNzICYmICFoYXNSZXNwb25zZVtwcml2U3RvcmVBZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzLnB1c2goX3RoaXNbXCJwcml2YXRlXCJdLl9zeW5jKGRhdGEubnVtRW50cmllcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVzcG9uc2VbcHJpdlN0b3JlQWRkcmVzc10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm9kYkFkZHJlc3MgPT09IHB1YlN0b3JlQWRkcmVzcyAmJiAhaGFzUmVzcG9uc2VbcHViU3RvcmVBZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Byb21pc2VzLnB1c2goX3RoaXNbXCJwdWJsaWNcIl0uX3N5bmMoZGF0YS5udW1FbnRyaWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSZXNwb25zZVtwdWJTdG9yZUFkZHJlc3NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2VNZXNzYWdlRmlsdGVyQWN0aXZlICYmIGRhdGEub2RiQWRkcmVzcy5pbmNsdWRlcygnc3BhY2UnKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3BhY2VzUHViU3ViTWVzc2FnZXNbZGF0YS5vZGJBZGRyZXNzXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3luY1Byb21pc2VzLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IHN5bmNQcm9taXNlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYm94U3luY2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vblN5bmNEb25lQ0IoKTsgLy8gdGhpcy5fcHVic3ViLnVuc3Vic2NyaWJlKFBJTk5JTkdfUk9PTSlcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uTWVzc2FnZVJlcyhfeDQsIF94NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVic3ViLnN1YnNjcmliZShQSU5OSU5HX1JPT00sIG9uTWVzc2FnZVJlcywgb25OZXdQZWVyKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVJvb3RTdG9yZShyb290U3RvcmVBZGRyZXNzLCBwcml2U3RvcmVBZGRyZXNzLCBwdWJTdG9yZUFkZHJlc3MsIHRoaXMucGlubmluZ05vZGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2xvYWQoKSB7XG4gICAgICAgIHJldHVybiBfbG9hZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9sb2FkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVSb290U3RvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jcmVhdGVSb290U3RvcmUyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHJvb3RTdG9yZUFkZHJlc3MsIHByaXZPZGJBZGRyZXNzLCBwdWJPZGJBZGRyZXNzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBlbnRyaWVzLCBwaW5BZGRyZXNzTGlua3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFN0b3JlLmxvYWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5wYXlsb2FkLnZhbHVlLm9kYkFkZHJlc3MgPT09IHB1Yk9kYkFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFN0b3JlLmFkZCh7XG4gICAgICAgICAgICAgICAgICBvZGJBZGRyZXNzOiBwdWJPZGJBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLnBheWxvYWQudmFsdWUub2RiQWRkcmVzcyA9PT0gcHJpdk9kYkFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICAgIG9kYkFkZHJlc3M6IHByaXZPZGJBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaXNoUm9vdFN0b3JlKHJvb3RTdG9yZUFkZHJlc3MpO1xuXG4gICAgICAgICAgICAgICAgcGluQWRkcmVzc0xpbmtzID1cbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZm9yIGFkZHJlc3MtbGlua3MsIGdldCBDSUQsIGFuZCBnZXQgdG8gcGluIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucGF5bG9hZC52YWx1ZS50eXBlID09PSAnYWRkcmVzcy1saW5rJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuX2lwZnMuZGFnLmdldChlbnRyeS5wYXlsb2FkLnZhbHVlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTQpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGluQWRkcmVzc0xpbmtzKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgcGluQWRkcmVzc0xpbmtzKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfY3JlYXRlUm9vdFN0b3JlKF94NiwgX3g3LCBfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb290U3RvcmUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfY3JlYXRlUm9vdFN0b3JlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIHByb2ZpbGUgb2YgYSBnaXZlbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGFkZHJlc3MgICAgICAgICAgICAgICAgIEFuIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtGdW5jdGlvbn0gIG9wdHMuYmxvY2tsaXN0ICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBhZGRyZXNzIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5tZXRhZGF0YSAgICAgICAgICAgZmxhZyB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5hZGRyZXNzU2VydmVyICAgICAgVVJMIG9mIHRoZSBBZGRyZXNzIFNlcnZlclxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cy5pcGZzICAgICAgICAgICAgICAgQSBqcy1pcGZzIGlwZnMgb2JqZWN0XG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLnVzZUNhY2hlU2VydmljZSAgICBVc2UgM0JveCBBUEkgYW5kIENhY2hlIFNlcnZpY2UgdG8gZmV0Y2ggcHJvZmlsZSBpbnN0ZWFkIG9mIE9yYml0REIuIERlZmF1bHQgdHJ1ZS5cbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMucHJvZmlsZVNlcnZlciAgICAgIFVSTCBvZiBQcm9maWxlIEFQSSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEganNvbiBvYmplY3Qgd2l0aCB0aGUgcHJvZmlsZSBmb3IgdGhlIGdpdmVuIGFkZHJlc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5TcGFjZVwiLFxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHNwYWNlIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIHVzZXJzIDNCb3hcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBuYW1lICAgICAgICAgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgc3BhY2VcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge0Z1bmN0aW9ufSAgICAgICAgICBvcHRzLmNvbnNlbnRDYWxsYmFjayAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgY29uc2VudGVkIHRvIG9wZW5pbmcgdGhlIGJveFxuICAgICAqIEBwYXJhbSAgICAge0Z1bmN0aW9ufSAgICAgICAgICBvcHRzLm9uU3luY0RvbmUgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc3BhY2UgaGFzIGZpbmlzaGVkIHN5bmNpbmcgd2l0aCB0aGUgcGlubmluZyBub2RlXG4gICAgICogQHJldHVybiAgICB7U3BhY2V9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBTcGFjZSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIHNwYWNlIG5hbWVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuU3BhY2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYobmFtZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzNiA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzNi5sZW5ndGggPiAxICYmIF9hcmdzNlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzFdIDoge307XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGFjZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlc1tuYW1lXSA9IG5ldyBTcGFjZShuYW1lLCB0aGlzLl8zaWQsIHRoaXMuX29yYml0ZGIsIHRoaXMuX3Jvb3RTdG9yZSwgdGhpcy5fZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAzO1xuICAgICAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgIG51bUVudHJpZXNNZXNzYWdlczogdGhpcy5zcGFjZXNQdWJTdWJNZXNzYWdlc1xuICAgICAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFjZXNbbmFtZV0ub3BlbihvcHRzKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWRkcmVzc0xpbmtlZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQ2LnNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtBZGRyZXNzKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxMztcbiAgICAgICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zcGFjZXNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9jb250ZXh0Ni50MC5tZXNzYWdlLmluY2x1ZGVzKCdVc2VyIGRlbmllZCBtZXNzYWdlIHNpZ25hdHVyZS4nKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBkZW5pZWQgc3BhY2UgY29uc2VudC4nKTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBvcGVuaW5nIHNwYWNlOiAnLCBfY29udGV4dDYudDAubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMub25TeW5jRG9uZSkge1xuICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIHNwYWNlIGlzIGFscmVhZHkgb3BlbiB3ZSBjYW4gY2FsbCBvblN5bmNEb25lIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICBvcHRzLm9uU3luY0RvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLnNwYWNlc1tuYW1lXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMsIFtbMywgMTNdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW5TcGFjZShfeDkpIHtcbiAgICAgICAgcmV0dXJuIF9vcGVuU3BhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wZW5TcGFjZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2Ugd2hlbiB0aGUgZGIgaXMgZnVsbHkgc3luY2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7RnVuY3Rpb259ICAgICAgc3luY0RvbmUgICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblN5bmNEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3luY0RvbmUoc3luY0RvbmUpIHtcbiAgICAgIHRoaXMuX29uU3luY0RvbmVDQiA9IHN5bmNEb25lO1xuXG4gICAgICBpZiAodGhpcy5fYm94U3luY2VkKSB7XG4gICAgICAgIHRoaXMuX29uU3luY0RvbmVDQigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHVibGlzaFJvb3RTdG9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3B1Ymxpc2hSb290U3RvcmUyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJvb3RTdG9yZUFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NUb2tlbjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8zaWQuc2lnbkpXVCh7XG4gICAgICAgICAgICAgICAgICByb290U3RvcmVBZGRyZXNzOiByb290U3RvcmVBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGFkZHJlc3NUb2tlbiA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMztcbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih0aGlzLl9zZXJ2ZXJVcmwgKyAnL29kYkFkZHJlc3MnLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzX3Rva2VuOiBhZGRyZXNzVG9rZW5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA4O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0N1tcImNhdGNoXCJdKDMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0Ny50MC5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9jb250ZXh0Ny50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcywgW1szLCA4XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfcHVibGlzaFJvb3RTdG9yZShfeDEwKSB7XG4gICAgICAgIHJldHVybiBfcHVibGlzaFJvb3RTdG9yZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wdWJsaXNoUm9vdFN0b3JlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBESUQgICAgICAgIHRoZSBESUQgb2YgdGhlIHVzZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxpbmtBZGRyZXNzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJvb2YgdGhhdCBsaW5rcyBhbiBldGhlcmV1bSBhZGRyZXNzIHRvIHRoZSAzQm94IGFjY291bnQgb2YgdGhlIHVzZXIuIElmIGdpdmVuIHByb29mLCBpdCB3aWxsIHNpbXBseSBiZSBhZGRlZCB0byB0aGUgcm9vdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgW2xpbmtdICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIGxpbmsgb2JqZWN0IHdpdGggdHlwZSBvciBwcm9vZlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgW2xpbmsudHlwZT0nZXRoZXJldW0tZW9hJ10gICAgIFRoZSB0eXBlIG9mIGxpbmsgKGRlZmF1bHQgJ2V0aGVyZXVtJylcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIFtsaW5rLnByb29mXSAgICAgICAgICAgICAgICAgICBQcm9vZiBvYmplY3QsIHNob3VsZCBmb2xsb3cgW3NwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS8zYm94LzNib3gvYmxvYi9tYXN0ZXIvM0lQcy8zaXAtNS5tZClcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9saW5rQWRkcmVzcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgdmFyIGxpbmssXG4gICAgICAgICAgICBfYXJnczggPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGxpbmsgPSBfYXJnczgubGVuZ3RoID4gMCAmJiBfYXJnczhbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFswXSA6IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rLnByb29mKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlQWRkcmVzc0xpbmsobGluay5wcm9vZik7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAoISghbGluay50eXBlIHx8IGxpbmsudHlwZSA9PT0gQUNDT1VOVF9UWVBFUy5ldGhlcmV1bUVPQSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlua1Byb2ZpbGUoKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGlua0FkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBfbGlua0FkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmtBZGRyZXNzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImxpbmtBY2NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGlua0FjY291bnQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoKSB7XG4gICAgICAgIHZhciB0eXBlLFxuICAgICAgICAgICAgX2FyZ3M5ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0eXBlID0gX2FyZ3M5Lmxlbmd0aCA+IDAgJiYgX2FyZ3M5WzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczlbMF0gOiBBQ0NPVU5UX1RZUEVTLmV0aGVyZXVtRU9BO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignbGlua0FjY291bnQ6IGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbGlua0FkZHJlc3MgZ29pbmcgZm9yd2FyZCcpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saW5rQWRkcmVzcyh0eXBlKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGlua0FjY291bnQoKSB7XG4gICAgICAgIHJldHVybiBfbGlua0FjY291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmtBY2NvdW50O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBnaXZlbiBhZGRyZXNzIGxpbmssIHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgYWRkcmVzcyAgICAgIGFkZHJlc3MgdGhhdCBpcyBsaW5rZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVtb3ZlQWRkcmVzc0xpbmsgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGxpbmtFeGlzdCwgcGF5bG9hZCwgb25lSG91ciwgZGVsZXRlVG9rZW47XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBZGRyZXNzTGlua2VkKHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbGlua0V4aXN0ID0gX2NvbnRleHQxMC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlQWRkcmVzc0xpbms6IGxpbmsgZm9yIGdpdmVuIGFkZHJlc3MgZG9lcyBub3QgZXhpc3QnKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImRlbGV0ZS1hZGRyZXNzLWxpbmtcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25lSG91ciA9IDYwICogNjA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5zaWduSldUKHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgIGV4cGlyZXNJbjogb25lSG91clxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgZGVsZXRlVG9rZW4gPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih0aGlzLl9zZXJ2ZXJVcmwgKyAnL2xpbmtkZWxldGUnLCB7XG4gICAgICAgICAgICAgICAgICBkZWxldGVfdG9rZW46IGRlbGV0ZVRva2VuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDE2O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAudDAgPSBfY29udGV4dDEwW1wiY2F0Y2hcIl0oMTEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0MTAudDAuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQxMC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZXRlQWRkcmVzc0xpbmsoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcywgW1sxMSwgMTZdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUFkZHJlc3NMaW5rKF94MTEpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmVBZGRyZXNzTGluay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVtb3ZlQWRkcmVzc0xpbms7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGlzIGEgcHJvb2YgdGhhdCBsaW5rcyBhbiBleHRlcm5hbCBhY2NvdW50IHRvIHRoZSAzQm94IGFjY291bnQgb2YgdGhlIHVzZXIuIElmIG5vdCBwYXJhbXMgZ2l2ZW4gYW5kIGFueSBsaW5rIGV4aXN0cywgcmV0dXJucyB0cnVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIFtxdWVyeV0gICAgICAgICAgICBPcHRpb25hbCBvYmplY3Qgd2l0aCBhZGRyZXNzIGFuZC9vciB0eXBlLlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgW3F1ZXJ5LnR5cGVdICAgICAgIERvZXMgdGhlIGdpdmVuIHR5cGUgb2YgbGluayBleGlzdFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgW3F1ZXJ5LmFkZHJlc3NdICAgIElzIHRoZSBnaXZlbiBhZHJlc3NlZCBsaW5rZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzQWRkcmVzc0xpbmtlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2lzQWRkcmVzc0xpbmtlZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoKSB7XG4gICAgICAgIHZhciBxdWVyeSxcbiAgICAgICAgICAgIGxpbmtzLFxuICAgICAgICAgICAgbGlua3NRdWVyeSxcbiAgICAgICAgICAgIF9hcmdzMTEgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF9hcmdzMTEubGVuZ3RoID4gMCAmJiBfYXJnczExWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczExWzBdIDoge307XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LmFkZHJlc3MpIHF1ZXJ5LmFkZHJlc3MgPSBxdWVyeS5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEFkZHJlc3NMaW5rcygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBsaW5rcyA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgICBsaW5rc1F1ZXJ5ID0gbGlua3MuZmluZChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHF1ZXJ5LmFkZHJlc3MgPyBsaW5rLmFkZHJlc3MgPT09IHF1ZXJ5LmFkZHJlc3MgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5LnR5cGUgPyByZXMgJiYgbGluay50eXBlID09PSBxdWVyeS50eXBlIDogcmVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBCb29sZWFuKGxpbmtzUXVlcnkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpc0FkZHJlc3NMaW5rZWQoKSB7XG4gICAgICAgIHJldHVybiBfaXNBZGRyZXNzTGlua2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0FkZHJlc3NMaW5rZWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBY2NvdW50TGlua2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaXNBY2NvdW50TGlua2VkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMigpIHtcbiAgICAgICAgdmFyIHR5cGUsXG4gICAgICAgICAgICBfYXJnczEyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdHlwZSA9IF9hcmdzMTIubGVuZ3RoID4gMCAmJiBfYXJnczEyWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczEyWzBdIDogQUNDT1VOVF9UWVBFUy5ldGhlcmV1bUVPQTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2lzQWNjb3VudExpbmtlZDogZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBpc0FkZHJlc3NMaW5rZWQgZ29pbmcgZm9yd2FyZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcInJldHVyblwiLCB0aGlzLmlzQWRkcmVzc0xpbmtlZCh0eXBlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaXNBY2NvdW50TGlua2VkKCkge1xuICAgICAgICByZXR1cm4gX2lzQWNjb3VudExpbmtlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNBY2NvdW50TGlua2VkO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFkZHJlc3MgbGlua3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgM0JveFxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgbGluayBvYmplY3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0QWRkcmVzc0xpbmtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGlzdEFkZHJlc3NMaW5rcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoKSB7XG4gICAgICAgIHZhciBlbnRyaWVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZEFkZHJlc3NMaW5rcygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gX2NvbnRleHQxMy5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpO1xuICAgICAgICAgICAgICAgICAgaXRlbS5saW5rSWQgPSBpdGVtLmVudHJ5Lmhhc2g7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5lbnRyeTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH0sIFtdKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGlzdEFkZHJlc3NMaW5rcygpIHtcbiAgICAgICAgcmV0dXJuIF9saXN0QWRkcmVzc0xpbmtzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0QWRkcmVzc0xpbmtzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9saW5rUHJvZmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xpbmtQcm9maWxlMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTQoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzLCBsaW5rRGF0YSwgZGlkLCBjb25zZW50O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuXzNpZC5tYW5hZ2VtZW50QWRkcmVzcztcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQWRkcmVzc0xpbmsoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGxpbmtEYXRhID0gX2NvbnRleHQxNC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmtEYXRhKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpZCA9IHRoaXMuRElEO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZ2V0TGlua0NvbnNlbnQoYWRkcmVzcywgZGlkLCB0aGlzLl93ZWIzcHJvdmlkZXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBjb25zZW50ID0gX2NvbnRleHQxNC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC50MCA9IF9jb250ZXh0MTRbXCJjYXRjaFwiXSg2KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhfY29udGV4dDE0LnQwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgY29uc2VudCBtZXNzYWdlIG11c3QgYmUgc2lnbmVkIGJlZm9yZSBhZGRpbmcgZGF0YSwgdG8gbGluayBhZGRyZXNzIHRvIHN0b3JlJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBsaW5rRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBBQ0NPVU5UX1RZUEVTLmV0aGVyZXVtRU9BLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY29uc2VudC5tc2csXG4gICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGNvbnNlbnQuc2lnLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBjb25zZW50LnRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlQWRkcmVzc0xpbmsobGlua0RhdGEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJwdWJsaWNcIl0uZ2V0KCdwcm9vZl9kaWQnKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDE0LnNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC50MSA9IHRoaXNbXCJwdWJsaWNcIl07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5zaWduSldUKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0LnQyID0gX2NvbnRleHQxNC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQudDMgPSB7XG4gICAgICAgICAgICAgICAgICBub0xpbms6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnQxLnNldC5jYWxsKF9jb250ZXh0MTQudDEsICdwcm9vZl9kaWQnLCBfY29udGV4dDE0LnQyLCBfY29udGV4dDE0LnQzKTtcblxuICAgICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICAgIC8vIFNlbmQgY29uc2VudFNpZ25hdHVyZSB0byAzYm94LWFkZHJlc3Mtc2VydmVyIHRvIGxpbmsgcHJvZmlsZSB3aXRoIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgICAgICAgICAgICB1dGlscy5mZXRjaEpzb24odGhpcy5fc2VydmVyVXJsICsgJy9saW5rJywgbGlua0RhdGEpW1wiY2F0Y2hcIl0oY29uc29sZS5lcnJvcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNCwgdGhpcywgW1s2LCAxMl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2xpbmtQcm9maWxlKCkge1xuICAgICAgICByZXR1cm4gX2xpbmtQcm9maWxlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xpbmtQcm9maWxlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl93cml0ZUFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfd3JpdGVBZGRyZXNzTGluazIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE1KHByb29mKSB7XG4gICAgICAgIHZhciBkYXRhLCBsaW5rRXhpc3QsIGxpbms7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNS5wcmV2ID0gX2NvbnRleHQxNS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pcGZzLmRhZy5wdXQocHJvb2YpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQxNS5zZW50LnRvQmFzZUVuY29kZWRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5rQ0lERXhpc3RzKGRhdGEpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBsaW5rRXhpc3QgPSBfY29udGV4dDE1LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxpbmtFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgbGluayA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzLWxpbmsnLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RTdG9yZS5hZGQobGluayk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF93cml0ZUFkZHJlc3NMaW5rKF94MTIpIHtcbiAgICAgICAgcmV0dXJuIF93cml0ZUFkZHJlc3NMaW5rMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3dyaXRlQWRkcmVzc0xpbms7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xpbmtDSURFeGlzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9saW5rQ0lERXhpc3RzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYoY2lkKSB7XG4gICAgICAgIHZhciBlbnRyaWVzLCBsaW5rRW50cmllcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTYkKF9jb250ZXh0MTYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE2LnByZXYgPSBfY29udGV4dDE2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RTdG9yZS5pdGVyYXRvcih7XG4gICAgICAgICAgICAgICAgICBsaW1pdDogLTFcbiAgICAgICAgICAgICAgICB9KS5jb2xsZWN0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDE2LnNlbnQ7XG4gICAgICAgICAgICAgICAgbGlua0VudHJpZXMgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucGF5bG9hZC52YWx1ZS50eXBlID09PSAnYWRkcmVzcy1saW5rJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwgbGlua0VudHJpZXMuZmluZChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5kYXRhID09PSBjaWQ7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9saW5rQ0lERXhpc3RzKF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9saW5rQ0lERXhpc3RzMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xpbmtDSURFeGlzdHM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlbGV0ZUFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGVsZXRlQWRkcmVzc0xpbmsyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNyhhZGRyZXNzKSB7XG4gICAgICAgIHZhciBsaW5rO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQWRkcmVzc0xpbmsoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGxpbmsgPSBfY29udGV4dDE3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX2RlbGV0ZUFkZHJlc3NMaW5rOiBsaW5rIGZvciBnaXZlbiBhZGRyZXNzIGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9yb290U3RvcmUucmVtb3ZlKGxpbmsuZW50cnkuaGFzaCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9kZWxldGVBZGRyZXNzTGluayhfeDE0KSB7XG4gICAgICAgIHJldHVybiBfZGVsZXRlQWRkcmVzc0xpbmsyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZGVsZXRlQWRkcmVzc0xpbms7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWRBZGRyZXNzTGlua3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkQWRkcmVzc0xpbmtzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBlbnRyaWVzLCBsaW5rRW50cmllcywgcmVzb2x2ZUxpbmtzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOSQoX2NvbnRleHQxOSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxOS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdFN0b3JlLml0ZXJhdG9yKHtcbiAgICAgICAgICAgICAgICAgIGxpbWl0OiAtMVxuICAgICAgICAgICAgICAgIH0pLmNvbGxlY3QoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZW50cmllcyA9IF9jb250ZXh0MTkuc2VudDtcbiAgICAgICAgICAgICAgICBsaW5rRW50cmllcyA9IGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5wYXlsb2FkLnZhbHVlLnR5cGUgPT09ICdhZGRyZXNzLWxpbmsnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVMaW5rcyA9IGxpbmtFbnRyaWVzLm1hcChcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTgucHJldiA9IF9jb250ZXh0MTgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9pcGZzLmRhZy5nZXQoZW50cnkucGF5bG9hZC52YWx1ZS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gX2NvbnRleHQxOC5zZW50LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMucmVjb3ZlclBlcnNvbmFsU2lnbihvYmoubWVzc2FnZSwgb2JqLnNpZ25hdHVyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRyZXNzID0gX2NvbnRleHQxOC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZW50cnkgPSBlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoXCJyZXR1cm5cIiwgb2JqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTgpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94MTUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuYWJydXB0KFwicmV0dXJuXCIsIFByb21pc2UuYWxsKHJlc29sdmVMaW5rcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWFkQWRkcmVzc0xpbmtzKCkge1xuICAgICAgICByZXR1cm4gX3JlYWRBZGRyZXNzTGlua3MyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhZEFkZHJlc3NMaW5rcztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcmVhZEFkZHJlc3NMaW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZEFkZHJlc3NMaW5rMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjAoYWRkcmVzcykge1xuICAgICAgICB2YXIgbGlua3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIwJChfY29udGV4dDIwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMC5wcmV2ID0gX2NvbnRleHQyMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRBZGRyZXNzTGlua3MoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbGlua3MgPSBfY29udGV4dDIwLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuYWJydXB0KFwicmV0dXJuXCIsIGxpbmtzLmZpbmQoZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX3JlYWRBZGRyZXNzTGluayhfeDE2KSB7XG4gICAgICAgIHJldHVybiBfcmVhZEFkZHJlc3NMaW5rMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JlYWRBZGRyZXNzTGluaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9lbnN1cmVQaW5uaW5nTm9kZUNvbm5lY3RlZDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIxKG9kYkFkZHJlc3MsIGlzVGhyZWFkKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciByb29tUGVlcnMsIHJvb3RTdG9yZUFkZHJlc3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIxJChfY29udGV4dDIxKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMS5wcmV2ID0gX2NvbnRleHQyMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pcGZzLnB1YnN1Yi5wZWVycyhvZGJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcm9vbVBlZXJzID0gX2NvbnRleHQyMS5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyb29tUGVlcnMuZmluZChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHAgPT09IF90aGlzNC5waW5uaW5nTm9kZS5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9pcGZzLnN3YXJtLmNvbm5lY3QodGhpcy5waW5uaW5nTm9kZSwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgICAgICAgICAgICByb290U3RvcmVBZGRyZXNzID0gdGhpcy5fcm9vdFN0b3JlLmFkZHJlc3MudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGlzVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1YnN1Yi5wdWJsaXNoKFBJTk5JTkdfUk9PTSwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTWU5DX0RCJyxcbiAgICAgICAgICAgICAgICAgICAgICBvZGJBZGRyZXNzOiBvZGJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgIHRocmVhZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1YnN1Yi5wdWJsaXNoKFBJTk5JTkdfUk9PTSwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQSU5fREInLFxuICAgICAgICAgICAgICAgICAgICAgIG9kYkFkZHJlc3M6IHJvb3RTdG9yZUFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyMSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9lbnN1cmVQaW5uaW5nTm9kZUNvbm5lY3RlZChfeDE3LCBfeDE4KSB7XG4gICAgICAgIHJldHVybiBfZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZW5zdXJlUGlubmluZ05vZGVDb25uZWN0ZWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjIoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIyJChfY29udGV4dDIyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMi5wcmV2ID0gX2NvbnRleHQyMi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmJpdGRiLnN0b3AoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVic3ViLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZ2xvYmFsT3JiaXREQiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgM2JveCBpbnN0YW5jZSBhbmQgY2xlYXJzIGxvY2FsIGNhY2hlLiBJZiB5b3UgY2FsbCB0aGlzLFxuICAgICAqIHVzZXJzIHdpbGwgbmVlZCB0byBzaWduIGEgY29uc2VudCBtZXNzYWdlIHRvIGxvZyBpbiB0aGUgbmV4dCB0aW1lXG4gICAgICogeW91IGNhbGwgb3BlbkJveC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxvZ291dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvZ291dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjMoKSB7XG4gICAgICAgIHZhciBhZGRyZXNzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMyQoX2NvbnRleHQyMykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjMucHJldiA9IF9jb250ZXh0MjMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLl8zaWQubG9nb3V0KCk7XG5cbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5fM2lkLm1hbmFnZW1lbnRBZGRyZXNzO1xuICAgICAgICAgICAgICAgIGxvY2Fsc3RvcmFnZS5yZW1vdmUoJ2xpbmtDb25zZW50XycgKyBhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb2dvdXQoKSB7XG4gICAgICAgIHJldHVybiBfbG9nb3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2dvdXQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgbG9nZ2VkIGluXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGFkZHJlc3MgICAgICAgICAgICAgICAgIEFuIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJuICAgIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgaWYgdGhlIHVzZXIgaXMgbG9nZ2VkIGluXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJESURcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl8zaWQubXVwb3J0RElEO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldFByb2ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQcm9maWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBwcm9maWxlLFxuICAgICAgICAgICAgbm9ybWFsaXplZEFkZHJlc3MsXG4gICAgICAgICAgICBfYXJnczI0ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNCQoX2NvbnRleHQyNCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjQucHJldiA9IF9jb250ZXh0MjQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMjQubGVuZ3RoID4gMSAmJiBfYXJnczI0WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczI0WzFdIDoge307XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBvcHRzLm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgIHVzZUNhY2hlU2VydmljZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sIG9wdHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLnVzZUNhY2hlU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQSS5nZXRQcm9maWxlKGFkZHJlc3MsIG9wdHMucHJvZmlsZVNlcnZlciwge1xuICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHByb2ZpbGUgPSBfY29udGV4dDI0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXR0aW5nIG1ldGFkYXRhIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIG91dHNpZGUgb2YgdGhlIEFQSScpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb2ZpbGVPcmJpdChub3JtYWxpemVkQWRkcmVzcywgb3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBwcm9maWxlID0gX2NvbnRleHQyNC5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuYWJydXB0KFwicmV0dXJuXCIsIHByb2ZpbGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9maWxlKF94MTkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQcm9maWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQcm9maWxlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgcHVibGljIHByb2ZpbGVzIGZvciBnaXZlbiBhZGRyZXNzZXMuIFRoaXMgcmVsaWVzIG9uIDNCb3ggcHJvZmlsZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtBcnJheX0gICAgIGFkZHJlc3MgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGV0aGVyZXVtIGFkZHJlc3Nlc1xuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBqc29uIG9iamVjdCB3aXRoIGVhY2gga2V5IGFuIGFkZHJlc3MgYW5kIHZhbHVlIHRoZSBwcm9maWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcm9maWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFByb2ZpbGVzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNShhZGRyZXNzQXJyYXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczI1ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNSQoX2NvbnRleHQyNSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjUucHJldiA9IF9jb250ZXh0MjUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMjUubGVuZ3RoID4gMSAmJiBfYXJnczI1WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczI1WzFdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIEFQSS5nZXRQcm9maWxlcyhhZGRyZXNzQXJyYXksIG9wdHMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjUpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9maWxlcyhfeDIwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0UHJvZmlsZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFByb2ZpbGVzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIGRhdGEgaW4gYSBzcGFjZSBvZiBhIGdpdmVuIGFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBBbiBldGhlcmV1bSBhZGRyZXNzXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBuYW1lICAgICAgICAgICAgICAgICAgICBBIHNwYWNlIG5hbWVcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtGdW5jdGlvbn0gIG9wdHMuYmxvY2tsaXN0ICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBhZGRyZXNzIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5tZXRhZGF0YSAgICAgICAgICAgZmxhZyB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBqc29uIG9iamVjdCB3aXRoIHRoZSBwdWJsaWMgc3BhY2UgZGF0YVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTcGFjZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjYoYWRkcmVzcywgbmFtZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzMjYgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI2JChfY29udGV4dDI2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNi5wcmV2ID0gX2NvbnRleHQyNi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyNi5sZW5ndGggPiAyICYmIF9hcmdzMjZbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMjZbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLmdldFNwYWNlKGFkZHJlc3MsIG5hbWUsIG9wdHMucHJvZmlsZVNlcnZlciwgb3B0cykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyNik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFNwYWNlKF94MjEsIF94MjIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRTcGFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0U3BhY2U7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwb3N0cyB0aGF0IGFyZSBtYWRlIHRvIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBzcGFjZSAgICAgICAgICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgc3BhY2UgdGhlIHRocmVhZCBpcyBpblxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgbmFtZSAgICAgICAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRocmVhZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgZmlyc3RNb2RlcmF0b3IgICAgICAgICAgVGhlIERJRCAob3IgZXRoZXJldW0gYWRkcmVzcykgb2YgdGhlIGZpcnN0IG1vZGVyYXRvclxuICAgICAqIEBwYXJhbSAgICAge0Jvb2xlYW59ICAgbWVtYmVycyAgICAgICAgICAgICAgICAgVHJ1ZSBpZiBvbmx5IG1lbWJlcnMgYXJlIGFsbG93ZWQgdG8gcG9zdFxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge0FycmF5PE9iamVjdD59ICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgcG9zdHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRocmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRocmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjcoc3BhY2UsIG5hbWUsIGZpcnN0TW9kZXJhdG9yLCBtZW1iZXJzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgX2FyZ3MyNyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMjckKF9jb250ZXh0MjcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI3LnByZXYgPSBfY29udGV4dDI3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczI3Lmxlbmd0aCA+IDQgJiYgX2FyZ3MyN1s0XSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyN1s0XSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LmFicnVwdChcInJldHVyblwiLCBBUEkuZ2V0VGhyZWFkKHNwYWNlLCBuYW1lLCBmaXJzdE1vZGVyYXRvciwgbWVtYmVycywgb3B0cykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyNyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFRocmVhZChfeDIzLCBfeDI0LCBfeDI1LCBfeDI2KSB7XG4gICAgICAgIHJldHVybiBfZ2V0VGhyZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRUaHJlYWQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwb3N0cyB0aGF0IGFyZSBtYWRlIHRvIGEgdGhyZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBUaGUgb3JiaXRkYi1hZGRyZXNzIG9mIHRoZSB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMucHJvZmlsZVNlcnZlciAgICAgIFVSTCBvZiBQcm9maWxlIEFQSSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxPYmplY3Q+fSAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIHBvc3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaHJlYWRCeUFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRUaHJlYWRCeUFkZHJlc3MgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI4KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczI4ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyOCQoX2NvbnRleHQyOCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjgucHJldiA9IF9jb250ZXh0MjgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMjgubGVuZ3RoID4gMSAmJiBfYXJnczI4WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczI4WzFdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjguYWJydXB0KFwicmV0dXJuXCIsIEFQSS5nZXRUaHJlYWRCeUFkZHJlc3MoYWRkcmVzcywgb3B0cykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyOCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFRocmVhZEJ5QWRkcmVzcyhfeDI3KSB7XG4gICAgICAgIHJldHVybiBfZ2V0VGhyZWFkQnlBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRUaHJlYWRCeUFkZHJlc3M7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb25maWd1cmF0aW9uIG9mIGEgdXNlcnMgM0JveFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBUaGUgZXRoZXJldW0gYWRkcmVzc1xuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5wcm9maWxlU2VydmVyICAgICAgVVJMIG9mIFByb2ZpbGUgQVBJIHNlcnZlclxuICAgICAqIEByZXR1cm4gICAge0FycmF5PE9iamVjdD59ICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgcG9zdHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldENvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldENvbmZpZyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMjkoYWRkcmVzcykge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzMjkgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI5JChfY29udGV4dDI5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyOS5wcmV2ID0gX2NvbnRleHQyOS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyOS5sZW5ndGggPiAxICYmIF9hcmdzMjlbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMjlbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLmdldENvbmZpZyhhZGRyZXNzLCBvcHRzKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjkuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI5KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0Q29uZmlnKF94MjgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRDb25maWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldENvbmZpZztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWVzIG9mIGFsbCBzcGFjZXMgYSB1c2VyIGhhc1xuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBBbiBldGhlcmV1bSBhZGRyZXNzXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBvcHRzICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBvcHRzLnByb2ZpbGVTZXJ2ZXIgICAgICBVUkwgb2YgUHJvZmlsZSBBUEkgc2VydmVyXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSB3aXRoIGFsbCBzcGFjZXMgYXMgc3RyaW5nc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdFNwYWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xpc3RTcGFjZXMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMwKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczMwID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMCQoX2NvbnRleHQzMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzAucHJldiA9IF9jb250ZXh0MzAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMzAubGVuZ3RoID4gMSAmJiBfYXJnczMwWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczMwWzFdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzAuYWJydXB0KFwicmV0dXJuXCIsIEFQSS5saXN0U3BhY2VzKGFkZHJlc3MsIG9wdHMucHJvZmlsZVNlcnZlcikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxpc3RTcGFjZXMoX3gyOSkge1xuICAgICAgICByZXR1cm4gX2xpc3RTcGFjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3RTcGFjZXM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFByb2ZpbGVPcmJpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFByb2ZpbGVPcmJpdDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMyKGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICByb290U3RvcmVBZGRyZXNzLFxuICAgICAgICAgICAgdXNpbmdHbG9iYWxJUEZTLFxuICAgICAgICAgICAgaXBmcyxcbiAgICAgICAgICAgIG9yYml0ZGIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHBpbm5pbmdOb2RlLFxuICAgICAgICAgICAgcHVibGljU3RvcmUsXG4gICAgICAgICAgICByb290U3RvcmUsXG4gICAgICAgICAgICByZWFkeVByb21pc2UsXG4gICAgICAgICAgICBwcm9maWxlRW50cnksXG4gICAgICAgICAgICBwcm9maWxlLFxuICAgICAgICAgICAgY2xvc2VBbGwsXG4gICAgICAgICAgICBfYXJnczMyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMiQoX2NvbnRleHQzMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzIucHJldiA9IF9jb250ZXh0MzIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMzIubGVuZ3RoID4gMSAmJiBfYXJnczMyWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczMyWzFdIDoge307XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlkVXRpbHMuaXNNdXBvcnRESUQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RJRCBhcmUgc3VwcG9ydGVkIGluIHRoZSBjYWNoZWQgdmVyc2lvbiBvbmx5Jyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQSS5nZXRSb290U3RvcmVBZGRyZXNzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSwgb3B0cy5hZGRyZXNzU2VydmVyKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcm9vdFN0b3JlQWRkcmVzcyA9IF9jb250ZXh0MzIuc2VudDtcbiAgICAgICAgICAgICAgICB1c2luZ0dsb2JhbElQRlMgPSBmYWxzZTsgLy8gbGV0IHVzaW5nR2xvYmFsT3JiaXREQiA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbElQRlMpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXBmcyA9IGdsb2JhbElQRlM7XG4gICAgICAgICAgICAgICAgdXNpbmdHbG9iYWxJUEZTID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0SVBGUyhvcHRzLmlwZnMsIG9wdHMuaWZyYW1lU3RvcmUsIG9wdHMuaXBmc09wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgaXBmcyA9IF9jb250ZXh0MzIuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxPcmJpdERCKSB7XG4gICAgICAgICAgICAgICAgICBvcmJpdGRiID0gZ2xvYmFsT3JiaXREQjtcbiAgICAgICAgICAgICAgICAgIHVzaW5nR2xvYmFsSVBGUyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlID0gbnVsbDsgLy8gKG9wdHMuaWZyYW1lU3RvcmUgJiYgISFjYWNoZVByb3h5KSA/IGNhY2hlUHJveHkgOiBudWxsXG5cbiAgICAgICAgICAgICAgICAgIG9yYml0ZGIgPSBuZXcgT3JiaXREQihpcGZzLCBvcHRzLm9yYml0UGF0aCwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBpbm5pbmdOb2RlID0gb3B0cy5waW5uaW5nTm9kZSB8fCBQSU5OSU5HX05PREU7XG4gICAgICAgICAgICAgICAgaXBmcy5zd2FybS5jb25uZWN0KHBpbm5pbmdOb2RlLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgcHVibGljU3RvcmUgPSBuZXcgUHVibGljU3RvcmUob3JiaXRkYik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTdG9yZUFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDQxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yYml0ZGIub3Blbihyb290U3RvcmVBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgIHJvb3RTdG9yZSA9IF9jb250ZXh0MzIuc2VudDtcbiAgICAgICAgICAgICAgICByZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICByb290U3RvcmUuZXZlbnRzLm9uKCdyZWFkeScsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJvb3RTdG9yZS5sb2FkKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWR5UHJvbWlzZTtcblxuICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIGlmIChyb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDMyLm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgcm9vdFN0b3JlLmV2ZW50cy5vbigncmVwbGljYXRlLnByb2dyZXNzJywgZnVuY3Rpb24gKF94LCBfeSwgX3osIG51bSwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW0gPT09IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJvb3RTdG9yZS5ldmVudHMub24oJ3JlcGxpY2F0ZWQnLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgICBwcm9maWxlRW50cnkgPSByb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkucGF5bG9hZC52YWx1ZS5vZGJBZGRyZXNzLnNwbGl0KCcuJylbMV0gPT09ICdwdWJsaWMnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDMzO1xuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNTdG9yZS5fbG9hZChwcm9maWxlRW50cnkucGF5bG9hZC52YWx1ZS5vZGJBZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0MzIubmV4dCA9IDM1O1xuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNTdG9yZS5fc3luYygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgICAgcHJvZmlsZSA9IHB1YmxpY1N0b3JlLmFsbCgpO1xuXG4gICAgICAgICAgICAgICAgY2xvc2VBbGwgPVxuICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjcgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMxKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMSQoX2NvbnRleHQzMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzEucHJldiA9IF9jb250ZXh0MzEubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFN0b3JlLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzEubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1N0b3JlLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICghdXNpbmdHbG9iYWxPcmJpdERCKSBhd2FpdCBvcmJpdGRiLnN0b3AoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNpbmdHbG9iYWxJUEZTKSB7fSAvLyBhd2FpdCBpcGZzLnN0b3AoKVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMxKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlQWxsKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpOyAvLyBjbG9zZSBidXQgZG9uJ3Qgd2FpdCBmb3IgaXRcblxuXG4gICAgICAgICAgICAgICAgY2xvc2VBbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMi5hYnJ1cHQoXCJyZXR1cm5cIiwgcHJvZmlsZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMi5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9nZXRQcm9maWxlT3JiaXQoX3gzMCkge1xuICAgICAgICByZXR1cm4gX2dldFByb2ZpbGVPcmJpdDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRQcm9maWxlT3JiaXQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR3JhcGhRTCBmb3IgM0JveCBwcm9maWxlIEFQSVxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBxdWVyeSAgICAgICAgICAgICAgIEEgZ3JhcGhRTCBxdWVyeSBvYmplY3QuXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBvcHRzICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMuZ3JhcGhxbFNlcnZlciAgVVJMIG9mIGdyYXBoUUwgM0JveCBwcm9maWxlIHNlcnZpY2VcbiAgICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgYSBqc29uIG9iamVjdCB3aXRoIGVhY2gga2V5IGFuIGFkZHJlc3MgYW5kIHZhbHVlIHRoZSBwcm9maWxlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9maWxlR3JhcGhRTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Byb2ZpbGVHcmFwaFFMID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMyhxdWVyeSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIF9hcmdzMzMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMzJChfY29udGV4dDMzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzMy5wcmV2ID0gX2NvbnRleHQzMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzMy5sZW5ndGggPiAxICYmIF9hcmdzMzNbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMzNbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLnByb2ZpbGVHcmFwaFFMKHF1ZXJ5LCBvcHRzLmdyYXBocWxTZXJ2ZXIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMzMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwcm9maWxlR3JhcGhRTChfeDMxKSB7XG4gICAgICAgIHJldHVybiBfcHJvZmlsZUdyYXBoUUwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2ZpbGVHcmFwaFFMO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSBwcm9vZnMgb2Ygc29jaWFsIGFjY291bnRzIHRoYXQgaXMgcHJlc2VudCBpbiB0aGUgcHJvZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgICAgICBwcm9maWxlICAgICAgICAgICAgICAgICBBIHVzZXIgcHJvZmlsZSBvYmplY3QsIHJlY2VpdmVkIGZyb20gdGhlIGBnZXRQcm9maWxlYCBmdW5jdGlvblxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYWNjb3VudHMgdGhhdCBoYXZlIGJlZW4gdmVyaWZpZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFZlcmlmaWVkQWNjb3VudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRWZXJpZmllZEFjY291bnRzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNChwcm9maWxlKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM0JChfY29udGV4dDM0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzNC5wcmV2ID0gX2NvbnRleHQzNC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNC5hYnJ1cHQoXCJyZXR1cm5cIiwgQVBJLmdldFZlcmlmaWVkQWNjb3VudHMocHJvZmlsZSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFZlcmlmaWVkQWNjb3VudHMoX3gzMikge1xuICAgICAgICByZXR1cm4gX2dldFZlcmlmaWVkQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFZlcmlmaWVkQWNjb3VudHM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIDNCb3ggYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgYWRkcmVzcyAgICAgICAgICAgICAgICAgQW4gZXRoZXJldW0gYWRkcmVzc1xuICAgICAqIEBwYXJhbSAgICAge2V0aGVyZXVtUHJvdmlkZXJ9ICBldGhlcmV1bVByb3ZpZGVyICAgICAgICBBbiBldGhlcmV1bSBwcm92aWRlclxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgICAgICAgICBvcHRzICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtICAgICB7RnVuY3Rpb259ICAgICAgICAgIG9wdHMuY29uc2VudENhbGxiYWNrICAgIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBjb25zZW50ZWQgdG8gb3BlbmluZyB0aGUgYm94XG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdHMucGlubmluZ05vZGUgICAgICAgIEEgc3RyaW5nIHdpdGggYW4gaXBmcyBtdWx0aS1hZGRyZXNzIHRvIGEgM2JveCBwaW5uaW5nIG5vZGVcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgb3B0cy5pcGZzICAgICAgICAgICAgICAgQSBqcy1pcGZzIGlwZnMgb2JqZWN0XG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIG9wdHMuYWRkcmVzc1NlcnZlciAgICAgIFVSTCBvZiB0aGUgQWRkcmVzcyBTZXJ2ZXJcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgb3B0cy5jb250ZW50U2lnbmF0dXJlICAgQSBzaWduYXR1cmUsIHByb3ZpZGVkIGJ5IGEgY2xpZW50IG9mIDNib3ggdXNpbmcgdGhlIHByaXZhdGUga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGFkZHJlc3MsIG9mIHRoZSAzYm94IGNvbnNlbnQgbWVzc2FnZVxuICAgICAqIEByZXR1cm4gICAge0JveH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgM0JveCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFkZHJlc3NcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5Cb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuQm94ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNShhZGRyZXNzLCBldGhlcmV1bVByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgaXBmcyxcbiAgICAgICAgICAgIF8zaWQsXG4gICAgICAgICAgICBib3gsXG4gICAgICAgICAgICBfYXJnczM1ID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM1JChfY29udGV4dDM1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzNS5wcmV2ID0gX2NvbnRleHQzNS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MzNS5sZW5ndGggPiAyICYmIF9hcmdzMzVbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMzVbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM1LnQwID0gZ2xvYmFsSVBGUztcblxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDM1LnQwKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDM1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdElQRlMob3B0cy5pcGZzLCBvcHRzLmlmcmFtZVN0b3JlLCBvcHRzLmlwZnNPcHRpb25zKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS50MCA9IF9jb250ZXh0MzUuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgaXBmcyA9IF9jb250ZXh0MzUudDA7XG4gICAgICAgICAgICAgICAgZ2xvYmFsSVBGUyA9IGlwZnM7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRocmVlSWQuZ2V0SWRGcm9tRXRoQWRkcmVzcyhhZGRyZXNzLCBldGhlcmV1bVByb3ZpZGVyLCBpcGZzLCBvcHRzKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIF8zaWQgPSBfY29udGV4dDM1LnNlbnQ7XG4gICAgICAgICAgICAgICAgYm94ID0gbmV3IEJveChfM2lkLCBldGhlcmV1bVByb3ZpZGVyLCBpcGZzLCBvcHRzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM1Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94Ll9sb2FkKG9wdHMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzUuYWJydXB0KFwicmV0dXJuXCIsIGJveCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW5Cb3goX3gzMywgX3gzNCkge1xuICAgICAgICByZXR1cm4gX29wZW5Cb3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wZW5Cb3g7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNMb2dnZWRJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xvZ2dlZEluKGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBUaHJlZUlkLmlzTG9nZ2VkSW4oYWRkcmVzcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG5cbmZ1bmN0aW9uIGluaXRJUEZTKF94MzUsIF94MzYsIF94MzcpIHtcbiAgcmV0dXJuIF9pbml0SVBGUy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5pdElQRlMoKSB7XG4gIF9pbml0SVBGUyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTM2KGlwZnMsIGlmcmFtZVN0b3JlLCBpcGZzT3B0aW9ucykge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM2JChfY29udGV4dDM2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MzYucHJldiA9IF9jb250ZXh0MzYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIGlmICghaXBmcyAmJiAhaXBmc1Byb3h5KSB0aHJvdyBuZXcgRXJyb3IoJ05vIElQRlMgb2JqZWN0IGNvbmZpZ3VyZWQgYW5kIG5vIGRlZmF1bHQgYXZhaWxhYmxlIGZvciBlbnZpcm9ubWVudCcpXG4gICAgICAgICAgICBpZiAoISFpcGZzICYmIGlmcmFtZVN0b3JlKSBjb25zb2xlLmxvZygnV2FybmluZzogaWZyYW1lU3RvcmUgdHJ1ZSwgb3JiaXQgZGIgY2FjaGUgaW4gaWZyYW1lLCBidXQgdGhlIGdpdmVuIGlwZnMgb2JqZWN0IGlzIGJlaW5nIHVzZWQsIGFuZCBtYXkgbm90IGJlIHJ1bm5pbmcgaW4gc2FtZSBpZnJhbWUuJyk7XG5cbiAgICAgICAgICAgIGlmICghaXBmcykge1xuICAgICAgICAgICAgICBfY29udGV4dDM2Lm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuYWJydXB0KFwicmV0dXJuXCIsIGlwZnMpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgaXBmcyA9IG5ldyBJUEZTKGlwZnNPcHRpb25zIHx8IElQRlNfT1BUSU9OUyk7XG4gICAgICAgICAgICAgIGlwZnMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlwZnMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGlwZnMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMzYpO1xuICB9KSk7XG4gIHJldHVybiBfaW5pdElQRlMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuQm94LmlkVXRpbHMgPSBpZFV0aWxzO1xubW9kdWxlLmV4cG9ydHMgPSBCb3g7IiwiaW1wb3J0IHsgcGVybWlzc2lvblJwY01ldGhvZHMgfSBmcm9tICdAbWV0YW1hc2svc25hcC1jb250cm9sbGVycyc7XG5pbXBvcnQgeyBzZWxlY3RIb29rcyB9IGZyb20gJ0BtZXRhbWFzay9ycGMtbWV0aG9kcyc7XG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBVTlNVUFBPUlRFRF9SUENfTUVUSE9EUyB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQgbG9jYWxIYW5kbGVycyBmcm9tICcuL2hhbmRsZXJzJztcblxuY29uc3QgYWxsSGFuZGxlcnMgPSBbLi4ubG9jYWxIYW5kbGVycywgLi4ucGVybWlzc2lvblJwY01ldGhvZHMuaGFuZGxlcnNdO1xuXG5jb25zdCBoYW5kbGVyTWFwID0gYWxsSGFuZGxlcnMucmVkdWNlKChtYXAsIGhhbmRsZXIpID0+IHtcbiAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIGhhbmRsZXIubWV0aG9kTmFtZXMpIHtcbiAgICBtYXAuc2V0KG1ldGhvZE5hbWUsIGhhbmRsZXIpO1xuICB9XG4gIHJldHVybiBtYXA7XG59LCBuZXcgTWFwKCkpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBqc29uLXJwYy1lbmdpbmUgbWlkZGxld2FyZSBvZiBSUEMgbWV0aG9kIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBIYW5kbGVycyBjb25zdW1lIGZ1bmN0aW9ucyB0aGF0IGhvb2sgaW50byB0aGUgYmFja2dyb3VuZCwgYW5kIG9ubHkgZGVwZW5kXG4gKiBvbiB0aGVpciBzaWduYXR1cmVzLCBub3QgZS5nLiBjb250cm9sbGVyIGludGVybmFscy5cbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBob29rcyAtIFJlcXVpcmVkIFwiaG9va3NcIiBpbnRvIG91clxuICogY29udHJvbGxlcnMuXG4gKiBAcmV0dXJucyB7KHJlcTogT2JqZWN0LCByZXM6IE9iamVjdCwgbmV4dDogRnVuY3Rpb24sIGVuZDogRnVuY3Rpb24pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUoaG9va3MpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIG1ldGhvZE1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCkge1xuICAgIC8vIFJlamVjdCB1bnN1cHBvcnRlZCBtZXRob2RzLlxuICAgIGlmIChVTlNVUFBPUlRFRF9SUENfTUVUSE9EUy5oYXMocmVxLm1ldGhvZCkpIHtcbiAgICAgIHJldHVybiBlbmQoZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJNYXAuZ2V0KHJlcS5tZXRob2QpO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBjb25zdCB7IGltcGxlbWVudGF0aW9uLCBob29rTmFtZXMgfSA9IGhhbmRsZXI7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbXBsZW1lbnRhdGlvbnMgbWF5IG9yIG1heSBub3QgYmUgYXN5bmMsIHNvIHdlIG11c3QgYXdhaXQgdGhlbS5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGltcGxlbWVudGF0aW9uKFxuICAgICAgICAgIHJlcSxcbiAgICAgICAgICByZXMsXG4gICAgICAgICAgbmV4dCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgc2VsZWN0SG9va3MoaG9va3MsIGhvb2tOYW1lcyksXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9O1xufVxuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTcgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG4vKiBleHBvcnQgYWxsIGNvcmUgZnVuY3Rpb25zIGFuZCB0eXBlcyAqL1xudmFyIGNvcmVfMiA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gY29yZV8yLmFwcGx5T3BlcmF0aW9uO1xuZXhwb3J0cy5hcHBseVBhdGNoID0gY29yZV8yLmFwcGx5UGF0Y2g7XG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGNvcmVfMi5hcHBseVJlZHVjZXI7XG5leHBvcnRzLmdldFZhbHVlQnlQb2ludGVyID0gY29yZV8yLmdldFZhbHVlQnlQb2ludGVyO1xuZXhwb3J0cy52YWxpZGF0ZSA9IGNvcmVfMi52YWxpZGF0ZTtcbmV4cG9ydHMudmFsaWRhdG9yID0gY29yZV8yLnZhbGlkYXRvcjtcbi8qIGV4cG9ydCBzb21lIGhlbHBlcnMgKi9cbnZhciBoZWxwZXJzXzIgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfMi5QYXRjaEVycm9yO1xuZXhwb3J0cy5kZWVwQ2xvbmUgPSBoZWxwZXJzXzIuX2RlZXBDbG9uZTtcbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGhlbHBlcnNfMi5lc2NhcGVQYXRoQ29tcG9uZW50O1xuZXhwb3J0cy51bmVzY2FwZVBhdGhDb21wb25lbnQgPSBoZWxwZXJzXzIudW5lc2NhcGVQYXRoQ29tcG9uZW50O1xudmFyIGJlZm9yZURpY3QgPSBuZXcgV2Vha01hcCgpO1xudmFyIE1pcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3Iob2JqKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB9XG4gICAgcmV0dXJuIE1pcnJvcjtcbn0oKSk7XG52YXIgT2JzZXJ2ZXJJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgfVxuICAgIHJldHVybiBPYnNlcnZlckluZm87XG59KCkpO1xuZnVuY3Rpb24gZ2V0TWlycm9yKG9iaikge1xuICAgIHJldHVybiBiZWZvcmVEaWN0LmdldChvYmopO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWlycm9yLm9ic2VydmVycy5nZXQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpIHtcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlci5jYWxsYmFjayk7XG59XG4vKipcbiAqIERldGFjaCBhbiBvYnNlcnZlciBmcm9tIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiB1bm9ic2VydmUocm9vdCwgb2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoKTtcbn1cbmV4cG9ydHMudW5vYnNlcnZlID0gdW5vYnNlcnZlO1xuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZShvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1pcnJvciA9IGdldE1pcnJvcihvYmopO1xuICAgIGlmICghbWlycm9yKSB7XG4gICAgICAgIG1pcnJvciA9IG5ldyBNaXJyb3Iob2JqKTtcbiAgICAgICAgYmVmb3JlRGljdC5zZXQob2JqLCBtaXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lKG9iaik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xuICAgICAgICB2YXIgZGlydHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZhc3RDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy9ub3QgTm9kZVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcbi8qKlxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlKSB7XG4gICAgaWYgKGludmVydGlibGUgPT09IHZvaWQgMCkgeyBpbnZlcnRpYmxlID0gZmFsc2U7IH1cbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBjb3JlXzEuYXBwbHlQYXRjaChtaXJyb3IudmFsdWUsIG9ic2VydmVyLnBhdGNoZXMpO1xuICAgIH1cbiAgICB2YXIgdGVtcCA9IG9ic2VydmVyLnBhdGNoZXM7XG4gICAgaWYgKHRlbXAubGVuZ3RoID4gMCkge1xuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XG4gICAgICAgIGlmIChvYnNlcnZlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sodGVtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXA7XG59XG5leHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4vLyBEaXJ0eSBjaGVjayBpZiBvYmogaXMgZGlmZmVyZW50IGZyb20gbWlycm9yLCBnZW5lcmF0ZSBwYXRjaGVzIGFuZCB1cGRhdGUgbWlycm9yXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgsIGludmVydGlibGUpIHtcbiAgICBpZiAob2JqID09PSBtaXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuICAgIHZhciBuZXdLZXlzID0gaGVscGVyc18xLl9vYmplY3RLZXlzKG9iaik7XG4gICAgdmFyIG9sZEtleXMgPSBoZWxwZXJzXzEuX29iamVjdEtleXMobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmIChoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWwgPT0gXCJvYmplY3RcIiAmJiBvbGRWYWwgIT0gbnVsbCAmJiB0eXBlb2YgbmV3VmFsID09IFwib2JqZWN0XCIgJiYgbmV3VmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIGludmVydGlibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gbmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUob2xkVmFsKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZShuZXdWYWwpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1pcnJvcikgPT09IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZShvbGRWYWwpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgfSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTsgLy8gcHJvcGVydHkgaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludmVydGlibGUpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJ0ZXN0XCIsIHBhdGg6IHBhdGgsIHZhbHVlOiBtaXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJyZXBsYWNlXCIsIHBhdGg6IHBhdGgsIHZhbHVlOiBvYmogfSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlbGV0ZWQgJiYgbmV3S2V5cy5sZW5ndGggPT0gb2xkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG5ld0tleXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XG4gICAgICAgIGlmICghaGVscGVyc18xLmhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goeyBvcDogXCJhZGRcIiwgcGF0aDogcGF0aCArIFwiL1wiICsgaGVscGVyc18xLmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgdmFsdWU6IGhlbHBlcnNfMS5fZGVlcENsb25lKG9ialtrZXldKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gY29tcGFyZSh0cmVlMSwgdHJlZTIsIGludmVydGlibGUpIHtcbiAgICBpZiAoaW52ZXJ0aWJsZSA9PT0gdm9pZCAwKSB7IGludmVydGlibGUgPSBmYWxzZTsgfVxuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgX2dlbmVyYXRlKHRyZWUxLCB0cmVlMiwgcGF0Y2hlcywgJycsIGludmVydGlibGUpO1xuICAgIHJldHVybiBwYXRjaGVzO1xufVxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbi8qKlxuICogRGVmYXVsdCBleHBvcnQgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuLy8gaW1wb3J0IGp1c3QgdG8gcmUtZXhwb3J0IGFzIGRlZmF1bHRcbnZhciBjb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBoZWxwZXJzXzMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gX19hc3NpZ24oe30sIGNvcmUsIHsgXG4gICAgLy8gZHVwbGV4XG4gICAgdW5vYnNlcnZlOiB1bm9ic2VydmUsXG4gICAgb2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUsXG4gICAgY29tcGFyZTogY29tcGFyZSxcbiAgICAvLyBoZWxwZXJzXG4gICAgSnNvblBhdGNoRXJyb3I6IGhlbHBlcnNfMy5QYXRjaEVycm9yLCBkZWVwQ2xvbmU6IGhlbHBlcnNfMS5fZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50OiBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQ6IGhlbHBlcnNfMy51bmVzY2FwZVBhdGhDb21wb25lbnQgfSk7XG4iLCIvKlxuXHRJU0MgTGljZW5zZVxuXG5cdENvcHlyaWdodCAoYykgMjAxOSwgUGllcnJlLUxvdWlzIERlc3BhaWduZVxuXG5cdFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuXHRwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG5cdGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcblx0V0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuXHRNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuXHRBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG5cdFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuXHRBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuXHRPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKi9cblxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpO1xuXG4vLyBMYWJlbCdzIG1heCBsZW5ndGggaW4gRE5TIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTAzNCNwYWdlLTcpXG5jb25zdCBkbnNMYWJlbE1heExlbmd0aCA9IDYzO1xuXG4vKipcbiAqIFRha2UgYW55IGlwZnNIYXNoIGFuZCBjb252ZXJ0IGl0IHRvIEROUy1jb21wYXRpYmxlIENJRFxuICogQHBhcmFtIHtzdHJpbmd9IGlwZnNIYXNoIGEgcmVndWxhciBpcGZzIGhhc2ggZWl0aGVyIGEgY2lkIHYwIG9yIHYxXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgaXBmcyBoYXNoIGFzIGEgY2lkIHYxXG4gKi9cbmNvbnN0IGNpZEZvcldlYiA9IChpcGZzSGFzaCkgPT4ge1xuXHRsZXQgY2lkID0gbmV3IENJRChpcGZzSGFzaCk7XG5cdGlmIChjaWQudmVyc2lvbiA9PT0gMCkge1xuXHRcdGNpZCA9IGNpZC50b1YxKCk7XG5cdH1cbiAgbGV0IGRuc0xhYmVsID0gY2lkLnRvU3RyaW5nKCdiYXNlMzInKTtcbiAgaWYgKGRuc0xhYmVsLmxlbmd0aCA+IGRuc0xhYmVsTWF4TGVuZ3RoKSB7XG4gICAgY29uc3QgYjM2ID0gY2lkLnRvU3RyaW5nKCdiYXNlMzYnKTtcbiAgICBpZiAoYjM2Lmxlbmd0aCA8PSBkbnNMYWJlbE1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIGIzNjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ0NJRCBpcyBsb25nZXIgdGhhbiBETlMgbGltaXQgb2YgNjMgY2hhcmFjdGVycyBhbmQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBwdWJsaWMgZ2F0ZXdheXMnKTtcbiAgfVxuXHRyZXR1cm4gZG5zTGFiZWw7XG59XG5cbmV4cG9ydHMuY2lkRm9yV2ViID0gY2lkRm9yV2ViO1xuXG5cbi8qKlxuICogVGFrZSBhbnkgaXBmc0hhc2ggYW5kIGNvbnZlcnQgaXQgdG8gYSBDSUQgdjEgZW5jb2RlZCBpbiBiYXNlMzIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBmc0hhc2ggYSByZWd1bGFyIGlwZnMgaGFzaCBlaXRoZXIgYSBjaWQgdjAgb3IgdjEgKHYxIHdpbGwgcmVtYWluIHVuY2hhbmdlZClcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBpcGZzIGhhc2ggYXMgYSBjaWQgdjFcbiAqL1xuY29uc3QgY2lkVjBUb1YxQmFzZTMyID0gKGlwZnNIYXNoKSA9PiB7XG5cdGxldCBjaWQgPSBuZXcgQ0lEKGlwZnNIYXNoKTtcblx0aWYgKGNpZC52ZXJzaW9uID09PSAwKSB7XG5cdFx0Y2lkID0gY2lkLnRvVjEoKTtcblx0fVxuXHRyZXR1cm4gY2lkLnRvU3RyaW5nKCdiYXNlMzInKTtcbn1cblxuZXhwb3J0cy5jaWRWMFRvVjFCYXNlMzIgPSBjaWRWMFRvVjFCYXNlMzI7XG4iLCIvLyBAdHMtY2hlY2tcbi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyoqXG4gKiBNdWx0aWhhc2ggaW1wbGVtZW50YXRpb24gaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11bHRpaGFzaFxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbmNvbnN0IGNvZGVzID0ge31cblxuZm9yIChjb25zdCBrZXkgaW4gbmFtZXMpIHtcbiAgY29kZXNbbmFtZXNba2V5XV0gPSBrZXlcbn1cbmV4cG9ydHMubmFtZXMgPSBuYW1lc1xuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoY29kZXMpXG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0hleFN0cmluZyA9IGZ1bmN0aW9uIHRvSGV4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihoYXNoKVxuICAgID8gaGFzaFxuICAgIDogQnVmZmVyLmZyb20oaGFzaC5idWZmZXIsIGhhc2guYnl0ZU9mZnNldCwgaGFzaC5ieXRlTGVuZ3RoKVxuXG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmZyb21IZXhTdHJpbmcgPSBmdW5jdGlvbiBmcm9tSGV4U3RyaW5nIChoYXNoKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLCAnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBiYXNlNTggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvQjU4U3RyaW5nID0gZnVuY3Rpb24gdG9CNThTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCEoaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShtdWx0aWJhc2UuZW5jb2RlKCdiYXNlNThidGMnLCBoYXNoKSkuc2xpY2UoMSlcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBiYXNlNTggZW5jb2RlZCBzdHJpbmcgdG8gYSBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tQjU4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUI1OFN0cmluZyAoaGFzaCkge1xuICBjb25zdCBlbmNvZGVkID0gaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICA/IHRleHREZWNvZGVyLmRlY29kZShoYXNoKVxuICAgIDogaGFzaFxuXG4gIHJldHVybiBtdWx0aWJhc2UuZGVjb2RlKCd6JyArIGVuY29kZWQpXG59XG5cbi8qKlxuICogRGVjb2RlIGEgaGFzaCBmcm9tIHRoZSBnaXZlbiBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybnMge3tjb2RlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIsIGRpZ2VzdDogQnVmZmVyfX0gcmVzdWx0XG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlIChieXRlcykge1xuICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggbXVzdCBiZSBhIFVpbnQ4QXJyYXknKVxuICB9XG4gIGxldCBidWYgPSBCdWZmZXIuaXNCdWZmZXIoYnl0ZXMpXG4gICAgPyBieXRlc1xuICAgIDogQnVmZmVyLmZyb20oYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKVxuXG4gIGlmIChidWYubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIHRvbyBzaG9ydC4gbXVzdCBiZSA+IDIgYnl0ZXMuJylcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKCFleHBvcnRzLmlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggdW5rbm93biBmdW5jdGlvbiBjb2RlOiAweCR7Y29kZS50b1N0cmluZygxNil9YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBjb25zdCBsZW4gPSB2YXJpbnQuZGVjb2RlKGJ1ZilcbiAgaWYgKGxlbiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBpbnZhbGlkIGxlbmd0aDogJHtsZW59YClcbiAgfVxuICBidWYgPSBidWYuc2xpY2UodmFyaW50LmRlY29kZS5ieXRlcylcblxuICBpZiAoYnVmLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggbGVuZ3RoIGluY29uc2lzdGVudDogMHgke2J1Zi50b1N0cmluZygnaGV4Jyl9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBuYW1lOiBjb2Rlc1tjb2RlXSxcbiAgICBsZW5ndGg6IGxlbixcbiAgICBkaWdlc3Q6IGJ1ZlxuICB9XG59XG5cbi8qKlxuICogIEVuY29kZSBhIGhhc2ggZGlnZXN0IGFsb25nIHdpdGggdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBjb2RlLlxuICpcbiAqID4gKipOb3RlOioqIHRoZSBsZW5ndGggaXMgZGVyaXZlZCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGRpZ2VzdCBpdHNlbGYuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkaWdlc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZSAoZGlnZXN0LCBjb2RlLCBsZW5ndGgpIHtcbiAgaWYgKCFkaWdlc3QgfHwgY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggZW5jb2RlIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBhcmdzOiBkaWdlc3QsIGNvZGUnKVxuICB9XG5cbiAgLy8gZW5zdXJlIGl0J3MgYSBoYXNoZnVuY3Rpb24gY29kZS5cbiAgY29uc3QgaGFzaGZuID0gZXhwb3J0cy5jb2VyY2VDb2RlKGNvZGUpXG5cbiAgaWYgKCEoZGlnZXN0IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBzaG91bGQgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgIGxlbmd0aCA9IGRpZ2VzdC5sZW5ndGhcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgZGlnZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QgbGVuZ3RoIHNob3VsZCBiZSBlcXVhbCB0byBzcGVjaWZpZWQgbGVuZ3RoLicpXG4gIH1cblxuICBjb25zdCBoYXNoID0gdmFyaW50LmVuY29kZShoYXNoZm4pXG4gIGNvbnN0IGxlbiA9IHZhcmludC5lbmNvZGUobGVuZ3RoKVxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoaGFzaC5sZW5ndGggKyBsZW4ubGVuZ3RoICsgZGlnZXN0Lmxlbmd0aClcbiAgYnVmZmVyLnNldChoYXNoLCAwKVxuICBidWZmZXIuc2V0KGxlbiwgaGFzaC5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoZGlnZXN0LCBoYXNoLmxlbmd0aCArIGxlbi5sZW5ndGgpXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhhc2ggZnVuY3Rpb24gbmFtZSBpbnRvIHRoZSBtYXRjaGluZyBjb2RlLlxuICogSWYgcGFzc2VkIGEgbnVtYmVyIGl0IHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgaWYgaXQncyBhIHZhbGlkIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuY29lcmNlQ29kZSA9IGZ1bmN0aW9uIGNvZXJjZUNvZGUgKG5hbWUpIHtcbiAgbGV0IGNvZGUgPSBuYW1lXG5cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmIChuYW1lc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZ1bmN0aW9uIG5hbWVkOiAke25hbWV9YClcbiAgICB9XG4gICAgY29kZSA9IG5hbWVzW25hbWVdXG4gIH1cblxuICBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBIYXNoIGZ1bmN0aW9uIGNvZGUgc2hvdWxkIGJlIGEgbnVtYmVyLiBHb3Q6ICR7Y29kZX1gKVxuICB9XG5cbiAgaWYgKGNvZGVzW2NvZGVdID09PSB1bmRlZmluZWQgJiYgIWV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZnVuY3Rpb24gY29kZTogJHtjb2RlfWApXG4gIH1cblxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgYSBjb2RlIGlzIHBhcnQgb2YgdGhlIGFwcCByYW5nZVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0FwcENvZGUgPSBmdW5jdGlvbiBhcHBDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID4gMCAmJiBjb2RlIDwgMHgxMFxufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgbXVsdGloYXNoIGNvZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDb2RlID0gZnVuY3Rpb24gdmFsaWRDb2RlIChjb2RlKSB7XG4gIGlmIChleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoY29kZXNbY29kZV0pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGJ1ZmZlciBpcyBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUgKG11bHRpaGFzaCkge1xuICBleHBvcnRzLmRlY29kZShtdWx0aWhhc2gpIC8vIHRocm93cyBpZiBiYWQuXG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZml4IGZyb20gYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5wcmVmaXggPSBmdW5jdGlvbiBwcmVmaXggKG11bHRpaGFzaCkge1xuICB2YWxpZGF0ZShtdWx0aWhhc2gpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG11bHRpaGFzaC5idWZmZXIsIG11bHRpaGFzaC5ieXRlT2Zmc2V0LCAyKVxufVxuIiwiLypcblx0SVNDIExpY2Vuc2VcblxuXHRDb3B5cmlnaHQgKGMpIDIwMTksIFBpZXJyZS1Mb3VpcyBEZXNwYWlnbmVcblxuXHRQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcblx0cHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuXHRjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG5cdFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcblx0TUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcblx0QU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuXHRXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cblx0QUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcblx0T1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiovXG5cbmNvbnN0IENJRCA9IHJlcXVpcmUoJ2NpZHMnKTtcbmNvbnN0IG11bHRpSCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJyk7XG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdqcy1iYXNlNjQnKVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgQnVmZmVyLCB0aGUgc3RyaW5nIGNhbiBzdGFydCB3aXRoIG9yIHdpdGhvdXQgJzB4J1xuICogQHBhcmFtIHtzdHJpbmd9IGhleCBhbiBoZXhhZGVjaW1hbCB2YWx1ZVxuICogQHJldHVybiB7QnVmZmVyfSB0aGUgcmVzdWx0aW5nIEJ1ZmZlclxuICovXG5jb25zdCBoZXhTdHJpbmdUb0J1ZmZlciA9IChoZXgpID0+IHtcblx0bGV0IHByZWZpeCA9IGhleC5zbGljZSgwLCAyKTtcblx0bGV0IHZhbHVlID0gaGV4LnNsaWNlKDIpO1xuXHRsZXQgcmVzID0gJyc7XG5cdGlmIChwcmVmaXggPT09ICcweCcpIHJlcyA9IHZhbHVlO1xuXHRlbHNlIHJlcyA9IGhleDtcblx0cmV0dXJuIG11bHRpSC5mcm9tSGV4U3RyaW5nKHJlcyk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIElQTlMgaWRlbnRpZmllciAgdG8gc2FmZWd1YXJkIGFnYWluc3QgaW5zZWN1cmUgbmFtZXMuXG4gKiBAcGFyYW0ge0NJRH0gbmFtZSBpc2VkIGluIGlwbnMtbnNcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbmNvbnN0IGlzQ3J5cHRvZ3JhcGhpY0lQTlMgPSAgKGNpZCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgbXVsdGloYXNoIH0gPSBjaWRcbiAgICAvLyBBZGRpdGlvbmFsIGNoZWNrIGZvciBpZGVudGlmaWVycyBzaG9ydGVyXG4gICAgLy8gdGhhbiB3aGF0IGlubGluZWQgRUQyNTUxOSBwdWJrZXkgd291bGQgYmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW5zZG9tYWlucy9lbnMtYXBwL2lzc3Vlcy84NDkjaXNzdWVjb21tZW50LTc3NzA4ODk1MFxuICAgIGlmIChtdWx0aWhhc2gubGVuZ3RoIDwgMzgpIHtcbiAgICAgIGNvbnN0IG1oID0gbXVsdGlILmRlY29kZShtdWx0aWhhc2gpXG4gICAgICAvLyBFRDI1NTE5IHB1YmtleXMgYXJlIGlubGluZWQgdXNpbmcgaWRlbnRpdHkgaGFzaCBmdW5jdGlvblxuICAgICAgLy8gYW5kIHdlIHNob3VsZCBub3Qgc2VlIGFueXRoaW5nIHNob3J0ZXIgdGhhbiB0aGF0XG4gICAgICBpZiAobWgubmFtZSA9PT0gJ2lkZW50aXR5JyAmJiBtaC5sZW5ndGggPCAzNikge1xuICAgICAgICAvLyBPbmUgY2FuIHJlYWQgaW5saW5lZCBzdHJpbmcgdmFsdWUgdmlhOlxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXBucy1ucyBpZDonLCBTdHJpbmcobXVsdGlILmRlY29kZShuZXcgQ0lEKHZhbHVlKS5tdWx0aWhhc2gpLmRpZ2VzdCkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBvaywgQ0lEIGxvb2tzIGZpbmVcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChfKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiogbGlzdCBvZiBrbm93biBlbmNvZGluZyxcbiogZW5jb2Rpbmcgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGBzdHJpbmdgIGlucHV0LFxuKiBhbmQgcmV0dXJuIGEgYEJ1ZmZlcmAgcmVzdWx0XG4qL1xuY29uc3QgZW5jb2RlcyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBza3luZXQ6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBiYXNlNjQudG9VaW50OEFycmF5KHZhbHVlKVxuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIHN3YXJtOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBtdWx0aUguZW5jb2RlKGhleFN0cmluZ1RvQnVmZmVyKHZhbHVlKSwgJ2tlY2Nhay0yNTYnKTtcblx0XHRyZXR1cm4gbmV3IENJRCgxLCAnc3dhcm0tbWFuaWZlc3QnLCBtdWx0aWhhc2gpLmJ5dGVzO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIGlwZnM6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuZXcgQ0lEKHZhbHVlKS50b1YxKCkuYnl0ZXM7XG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgaXBuczogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSlcbiAgICBpZiAoIWlzQ3J5cHRvZ3JhcGhpY0lQTlMoY2lkKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignaXBucy1ucyBhbGxvd3Mgb25seSB2YWxpZCBjcnlwdG9ncmFwaGljIGxpYnAycC1rZXkgaWRlbnRpZmllcnMsIHRyeSB1c2luZyBFRDI1NTE5IHB1YmtleSBpbnN0ZWFkJylcbiAgICB9XG4gICAgLy8gUmVwcmVzZW50IElQTlMgbmFtZSBhcyBhIENJRCB3aXRoIGxpYnAycC1rZXkgY29kZWNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGlicDJwL3NwZWNzL2Jsb2IvbWFzdGVyL1JGQy8wMDAxLXRleHQtcGVlcmlkLWNpZC5tZFxuICAgIHJldHVybiBuZXcgQ0lEKDEsICdsaWJwMnAta2V5JywgY2lkLm11bHRpaGFzaCkuYnl0ZXNcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICB1dGY4OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gIH0sXG59O1xuXG4vKiogXG4qIGxpc3Qgb2Yga25vd24gZGVjb2RpbmcsXG4qIGRlY29kaW5nIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgQnVmZmVyYCBpbnB1dCxcbiogYW5kIHJldHVybiBhIGBzdHJpbmdgIHJlc3VsdFxuKi9cbmNvbnN0IGRlY29kZXMgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBcbiAgKi9cbiAgaGV4TXVsdGlIYXNoOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKTtcbiAgICByZXR1cm4gbXVsdGlILmRlY29kZShjaWQubXVsdGloYXNoKS5kaWdlc3QudG9TdHJpbmcoJ2hleCcpO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIGlwZnM6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQodmFsdWUpLnRvVjEoKTtcbiAgICByZXR1cm4gY2lkLnRvU3RyaW5nKGNpZC5jb2RlYyA9PT0gJ2xpYnAycC1rZXknID8gJ2Jhc2UzNicgOiAnYmFzZTMyJylcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICBpcG5zOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKS50b1YxKClcbiAgICBpZiAoIWlzQ3J5cHRvZ3JhcGhpY0lQTlMoY2lkKSkge1xuICAgICAgICAvLyBWYWx1ZSBpcyBub3QgYSBsaWJwMnAta2V5LCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nXG4gICAgICAgIGNvbnNvbGUud2FybignW2Vuc2RvbWFpbnMvY29udGVudC1oYXNoXSB1c2Ugb2Ygbm9uLWNyeXB0b2dyYXBoaWMgaWRlbnRpZmllcnMgaW4gaXBucy1ucyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQsIG1pZ3JhdGUgdG8gRUQyNTUxOSBsaWJwMnAta2V5JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyhtdWx0aUguZGVjb2RlKG5ldyBDSUQodmFsdWUpLm11bHRpaGFzaCkuZGlnZXN0KVxuICAgICAgICAvLyBUT0RPOiBzdGFydCB0aHJvd2luZyBhbiBlcnJvciAoYWZ0ZXIgc29tZSBkZXByZWNhdGlvbiBwZXJpb2QpXG4gICAgICAgIC8vIHRocm93IEVycm9yKCdpcG5zLW5zIGFsbG93cyBvbmx5IHZhbGlkIGNyeXB0b2dyYXBoaWMgbGlicDJwLWtleSBpZGVudGlmaWVycywgdHJ5IHVzaW5nIEVEMjU1MTkgcHVia2V5IGluc3RlYWQnKVxuICAgIH1cbiAgICByZXR1cm4gY2lkLnRvU3RyaW5nKCdiYXNlMzYnKVxuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIHV0Zjg6ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygndXRmOCcpO1xuICB9LFxuICBiYXNlNjQ6ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGB0cnVlYCBvcHRpb24gbWFrZXMgaXQgVVJMIHNhZmUgKHJlcGxhY2VzIC8gYW5kICsgd2l0aCAtIGFuZCBfIClcbiAgICByZXR1cm4gYmFzZTY0LmZyb21VaW50OEFycmF5KHZhbHVlLCB0cnVlKVxuICB9XG59O1xuXG4vKipcbiogbGlzdCBvZiBrbm93biBlbmNvZGluZy9kZWNvZGluZyBmb3IgYSBnaXZlbiBjb2RlYyxcbiogYGVuY29kZWAgc2hvdWxkIGJlIGNob3NlbiBhbW9uZyB0aGUgYGVuY29kZXNgIGZ1bmN0aW9uc1xuKiBgZGVjb2RlYCBzaG91bGQgYmUgY2hvc2VuIGFtb25nIHRoZSBgZGVjb2Rlc2AgZnVuY3Rpb25zXG4qL1xuY29uc3QgcHJvZmlsZXMgPSB7XG4gICdza3luZXQtbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnNreW5ldCxcbiAgICBkZWNvZGU6IGRlY29kZXMuYmFzZTY0LFxuICB9LFxuICAnc3dhcm0tbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnN3YXJtLFxuICAgIGRlY29kZTogZGVjb2Rlcy5oZXhNdWx0aUhhc2gsXG4gIH0sXG4gICdpcGZzLW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5pcGZzLFxuICAgIGRlY29kZTogZGVjb2Rlcy5pcGZzLFxuICB9LFxuICAnaXBucy1ucyc6IHtcbiAgICBlbmNvZGU6IGVuY29kZXMuaXBucyxcbiAgICBkZWNvZGU6IGRlY29kZXMuaXBucyxcbiAgfSxcbiAgJ2RlZmF1bHQnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLnV0ZjgsXG4gICAgZGVjb2RlOiBkZWNvZGVzLnV0ZjgsXG4gIH0sXG59O1xuXG5leHBvcnRzLmhleFN0cmluZ1RvQnVmZmVyID0gaGV4U3RyaW5nVG9CdWZmZXI7XG5leHBvcnRzLnByb2ZpbGVzID0gcHJvZmlsZXM7XG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBtdWx0aWNvZGVjIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBtdWx0aWNvZGVjXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuICpcbiAqIGNvbnN0IHByZWZpeGVkUHJvdG9idWYgPSBtdWx0aWNvZGVjLmFkZFByZWZpeCgncHJvdG9idWYnLCBwcm90b2J1ZkJ1ZmZlcilcbiAqIC8vIHByZWZpeGVkUHJvdG9idWYgMHg1MC4uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTnVtYmVyfSBDb2RlY051bWJlciAqL1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgaW50VGFibGUgPSByZXF1aXJlKCcuL2ludC10YWJsZScpXG5jb25zdCBjb2RlY05hbWVUb0NvZGVWYXJpbnQgPSByZXF1aXJlKCcuL3ZhcmludC10YWJsZScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHVpbnQ4QXJyYXlDb25jYXQgPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuXG4vKipcbiAqIFByZWZpeCBhIGJ1ZmZlciB3aXRoIGEgbXVsdGljb2RlYy1wYWNrZWQuXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV8VWludDhBcnJheX0gbXVsdGljb2RlY1N0ck9yQ29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gYWRkUHJlZml4IChtdWx0aWNvZGVjU3RyT3JDb2RlLCBkYXRhKSB7XG4gIGxldCBwcmVmaXhcblxuICBpZiAobXVsdGljb2RlY1N0ck9yQ29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBwcmVmaXggPSB1dGlsLnZhcmludFVpbnQ4QXJyYXlFbmNvZGUobXVsdGljb2RlY1N0ck9yQ29kZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoY29kZWNOYW1lVG9Db2RlVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdKSB7XG4gICAgICBwcmVmaXggPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWNvZGVjIG5vdCByZWNvZ25pemVkJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW3ByZWZpeCwgZGF0YV0sIHByZWZpeC5sZW5ndGggKyBkYXRhLmxlbmd0aClcbn1cblxuLyoqXG4gKiBEZWNhcHN1bGF0ZSB0aGUgbXVsdGljb2RlYy1wYWNrZWQgcHJlZml4IGZyb20gdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gcm1QcmVmaXggKGRhdGEpIHtcbiAgdmFyaW50LmRlY29kZShkYXRhKVxuICByZXR1cm4gZGF0YS5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVjIChwcmVmaXhlZERhdGEpIHtcbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUocHJlZml4ZWREYXRhKVxuICBjb25zdCBjb2RlY05hbWUgPSBpbnRUYWJsZS5nZXQoY29kZSlcbiAgaWYgKGNvZGVjTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlICR7Y29kZX0gbm90IGZvdW5kYClcbiAgfVxuICByZXR1cm4gY29kZWNOYW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb2RlYy5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTnVtYmVyfSBjb2RlY1xuICogQHJldHVybnMge0NvZGVjTmFtZXx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUgKGNvZGVjKSB7XG4gIHJldHVybiBpbnRUYWJsZS5nZXQoY29kZWMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBjb2RlY1xuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7Q29kZWNOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlciAobmFtZSkge1xuICBjb25zdCBjb2RlID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W25hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgbmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIHZhcmludC5kZWNvZGUoY29kZSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZSAocHJlZml4ZWREYXRhKSB7XG4gIHJldHVybiB2YXJpbnQuZGVjb2RlKHByZWZpeGVkRGF0YSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgYXMgdmFyaW50IG9mIGEgY29kZWMgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gY29kZWNOYW1lXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZVZhcmludCAoY29kZWNOYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbY29kZWNOYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlYyBgJyArIGNvZGVjTmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhcmludCBvZiBhIGNvZGUuXG4gKlxuICogQHBhcmFtIHtDb2RlY051bWJlcn0gY29kZVxuICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICovXG5mdW5jdGlvbiBnZXRWYXJpbnQgKGNvZGUpIHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGUoY29kZSlcbn1cblxuLy8gTWFrZSB0aGUgY29uc3RhbnRzIHRvcC1sZXZlbCBjb25zdGFudHNcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gSHVtYW4gZnJpZW5kbHkgbmFtZXMgZm9yIHByaW50aW5nLCBlLmcuIGluIGVycm9yIG1lc3NhZ2VzXG5jb25zdCBwcmludCA9IHJlcXVpcmUoJy4vcHJpbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkUHJlZml4LFxuICBybVByZWZpeCxcbiAgZ2V0Q29kZWMsXG4gIGdldE5hbWUsXG4gIGdldE51bWJlcixcbiAgZ2V0Q29kZSxcbiAgZ2V0Q29kZVZhcmludCxcbiAgZ2V0VmFyaW50LFxuICBwcmludCxcbiAgLi4uY29uc3RhbnRzXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImFuYWx5dGljcy1ub2RlXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuNC4wLWJldGEuM1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGhhc3NsZS1mcmVlIHdheSB0byBpbnRlZ3JhdGUgYW5hbHl0aWNzIGludG8gYW55IE5vZGUuanMgYXBwbGljYXRpb25cIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwicmVwb3NpdG9yeVwiOiBcInNlZ21lbnRpby9hbmFseXRpY3Mtbm9kZVwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VnbWVudFwiLFxuICAgIFwiZW1haWxcIjogXCJ0b29scytucG1Ac2VnbWVudC5jb21cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vc2VnbWVudC5jb21cIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49NFwiXG4gIH0sXG4gIFwic2l6ZS1saW1pdFwiOiBbXG4gICAge1xuICAgICAgXCJsaW1pdFwiOiBcIjI1IEtCXCIsXG4gICAgICBcInBhdGhcIjogXCJpbmRleC5qc1wiXG4gICAgfVxuICBdLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiY2lyY2xlLWxpbnRcIjogXCIuYnVpbGRzY3JpcHQvY2lyY2xlLnNoXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIjogXCJ5YXJuXCIsXG4gICAgXCJzaXplXCI6IFwic2l6ZS1saW1pdFwiLFxuICAgIFwidGVzdFwiOiBcInN0YW5kYXJkICYmIG55YyBhdmEgLS10aW1lb3V0PTIwcyYmIC5idWlsZHNjcmlwdC9lMmUuc2hcIixcbiAgICBcInJlcG9ydC1jb3ZlcmFnZVwiOiBcIm55YyByZXBvcnQgLS1yZXBvcnRlcj1sY292ID4gY292ZXJhZ2UubGNvdiAmJiBjb2RlY292XCIsXG4gICAgXCJucFwiOiBcIm5wIC0tbm8tcHVibGlzaFwiLFxuICAgIFwicmVsZWFzZVwiOiBcInlhcm4gcnVuIG5wXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJpbmRleC5qc1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiYW5hbHl0aWNzXCIsXG4gICAgXCJzdGF0c1wiLFxuICAgIFwic2VnbWVudC5pb1wiLFxuICAgIFwic2VnbWVudGlvXCIsXG4gICAgXCJzZWdtZW50XCIsXG4gICAgXCJjbGllbnRcIixcbiAgICBcImRyaXZlclwiXG4gIF0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBzZWdtZW50L2xvb3NlbHktdmFsaWRhdGUtZXZlbnRcIjogXCJeMi4wLjBcIixcbiAgICBcImF4aW9zXCI6IFwiXjAuMTkuMlwiLFxuICAgIFwiYXhpb3MtcmV0cnlcIjogXCJeMy4wLjJcIixcbiAgICBcImxvZGFzaC5pc3N0cmluZ1wiOiBcIl40LjAuMVwiLFxuICAgIFwibWQ1XCI6IFwiXjIuMi4xXCIsXG4gICAgXCJtc1wiOiBcIl4yLjAuMFwiLFxuICAgIFwicmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCI6IFwiXjAuMS4wXCIsXG4gICAgXCJ1dWlkXCI6IFwiXjMuMi4xXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYXZhXCI6IFwiXjAuMjUuMFwiLFxuICAgIFwiYmFzaWMtYXV0aFwiOiBcIl4yLjAuMVwiLFxuICAgIFwiYm9keS1wYXJzZXJcIjogXCJeMS4xNy4xXCIsXG4gICAgXCJjb2RlY292XCI6IFwiXjMuMC4wXCIsXG4gICAgXCJjb21tYW5kZXJcIjogXCJeMi45LjBcIixcbiAgICBcImRlbGF5XCI6IFwiXjQuMi4wXCIsXG4gICAgXCJleHByZXNzXCI6IFwiXjQuMTUuMlwiLFxuICAgIFwiaHVza3lcIjogXCJeMy4wLjRcIixcbiAgICBcIm55Y1wiOiBcIl4xNC4xLjFcIixcbiAgICBcInBpZnlcIjogXCJeNC4wLjFcIixcbiAgICBcInNpbm9uXCI6IFwiXjcuMy4yXCIsXG4gICAgXCJzaXplLWxpbWl0XCI6IFwiXjEuMy41XCIsXG4gICAgXCJzbnlrXCI6IFwiXjEuMTcxLjFcIixcbiAgICBcInN0YW5kYXJkXCI6IFwiXjEyLjAuMVwiXG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBSZW1vdmUgdHJhaWxpbmcgc2xhc2hlcyBmcm9tIHRoZSBnaXZlbiBgc3RyYFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoZXhwb3J0cy5leHByLCAnJyk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSB0aGUgcmVnZXhcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmV4cG9ydHMuZXhwciA9IC9cXC8rJC87XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvKipcbiAqIGxvZGFzaCA0LjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNiBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcbiIsIihmdW5jdGlvbigpe1xyXG4gIHZhciBjcnlwdCA9IHJlcXVpcmUoJ2NyeXB0JyksXHJcbiAgICAgIHV0ZjggPSByZXF1aXJlKCdjaGFyZW5jJykudXRmOCxcclxuICAgICAgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKSxcclxuICAgICAgYmluID0gcmVxdWlyZSgnY2hhcmVuYycpLmJpbixcclxuXHJcbiAgLy8gVGhlIGNvcmVcclxuICBtZDUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XHJcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKVxyXG4gICAgICAgIG1lc3NhZ2UgPSBiaW4uc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICBlbHNlIGlmIChpc0J1ZmZlcihtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UsIDApO1xyXG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciAhPT0gVWludDhBcnJheSlcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgIC8vIGVsc2UsIGFzc3VtZSBieXRlIGFycmF5IGFscmVhZHlcclxuXHJcbiAgICB2YXIgbSA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcclxuICAgICAgICBsID0gbWVzc2FnZS5sZW5ndGggKiA4LFxyXG4gICAgICAgIGEgPSAgMTczMjU4NDE5MyxcclxuICAgICAgICBiID0gLTI3MTczMzg3OSxcclxuICAgICAgICBjID0gLTE3MzI1ODQxOTQsXHJcbiAgICAgICAgZCA9ICAyNzE3MzM4Nzg7XHJcblxyXG4gICAgLy8gU3dhcCBlbmRpYW5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtW2ldID0gKChtW2ldIDw8ICA4KSB8IChtW2ldID4+PiAyNCkpICYgMHgwMEZGMDBGRiB8XHJcbiAgICAgICAgICAgICAoKG1baV0gPDwgMjQpIHwgKG1baV0gPj4+ICA4KSkgJiAweEZGMDBGRjAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhZGRpbmdcclxuICAgIG1bbCA+Pj4gNV0gfD0gMHg4MCA8PCAobCAlIDMyKTtcclxuICAgIG1bKCgobCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsO1xyXG5cclxuICAgIC8vIE1ldGhvZCBzaG9ydGN1dHNcclxuICAgIHZhciBGRiA9IG1kNS5fZmYsXHJcbiAgICAgICAgR0cgPSBtZDUuX2dnLFxyXG4gICAgICAgIEhIID0gbWQ1Ll9oaCxcclxuICAgICAgICBJSSA9IG1kNS5faWk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xyXG5cclxuICAgICAgdmFyIGFhID0gYSxcclxuICAgICAgICAgIGJiID0gYixcclxuICAgICAgICAgIGNjID0gYyxcclxuICAgICAgICAgIGRkID0gZDtcclxuXHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDBdLCAgNywgLTY4MDg3NjkzNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDcsIC0xNzY0MTg4OTcpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgOF0sICA3LCAgMTc3MDAzNTQxNik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDcsICAxODA0NjAzNjgyKTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XHJcblxyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyAxXSwgIDUsIC0xNjU3OTY1MTApO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyA2XSwgIDksIC0xMDY5NTAxNjMyKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgNV0sICA1LCAtNzAxNTU4NjkxKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxMF0sICA5LCAgMzgwMTYwODMpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA5XSwgIDUsICA1Njg0NDY0MzgpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzE0XSwgIDksIC0xMDE5ODAzNjkwKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKyAyXSwgIDksIC01MTQwMzc4NCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDVdLCAgNCwgLTM3ODU1OCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKzEzXSwgIDQsICA2ODEyNzkxNzQpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDldLCAgNCwgLTY0MDM2NDQ4Nyk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDJdLCAyMywgLTk5NTMzODY1MSk7XHJcblxyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDYsIC0xOTg2MzA4NDQpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsxMl0sICA2LCAgMTcwMDQ4NTU3MSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgNF0sICA2LCAtMTQ1NTIzMDcwKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XHJcblxyXG4gICAgICBhID0gKGEgKyBhYSkgPj4+IDA7XHJcbiAgICAgIGIgPSAoYiArIGJiKSA+Pj4gMDtcclxuICAgICAgYyA9IChjICsgY2MpID4+PiAwO1xyXG4gICAgICBkID0gKGQgKyBkZCkgPj4+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyeXB0LmVuZGlhbihbYSwgYiwgYywgZF0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEF1eGlsaWFyeSBmdW5jdGlvbnNcclxuICBtZDUuX2ZmICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGMgfCB+YiAmIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2dnICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiAmIGQgfCBjICYgfmQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2hoICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9paSAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG5cclxuICAvLyBQYWNrYWdlIHByaXZhdGUgYmxvY2tzaXplXHJcbiAgbWQ1Ll9ibG9ja3NpemUgPSAxNjtcclxuICBtZDUuX2RpZ2VzdHNpemUgPSAxNjtcclxuXHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQgJyArIG1lc3NhZ2UpO1xyXG5cclxuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhtZDUobWVzc2FnZSwgb3B0aW9ucykpO1xyXG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc0J5dGVzID8gZGlnZXN0Ynl0ZXMgOlxyXG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XHJcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcbiIsInZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKVxudmFyIGpvaW4gPSByZXF1aXJlKCdqb2luLWNvbXBvbmVudCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxuLy8gU2VnbWVudCBtZXNzYWdlcyBjYW4gYmUgYSBtYXhpbXVtIG9mIDMya2IuXG52YXIgTUFYX1NJWkUgPSAzMiA8PCAxMFxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb3NlbHlWYWxpZGF0ZUV2ZW50XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gZXZlbnQuXG4gKi9cblxuZnVuY3Rpb24gbG9vc2VseVZhbGlkYXRlRXZlbnQgKGV2ZW50LCB0eXBlKSB7XG4gIHZhbGlkYXRlR2VuZXJpY0V2ZW50KGV2ZW50KVxuICB0eXBlID0gdHlwZSB8fCBldmVudC50eXBlXG4gIGFzc2VydCh0eXBlLCAnWW91IG11c3QgcGFzcyBhbiBldmVudCB0eXBlLicpXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgIHJldHVybiB2YWxpZGF0ZVRyYWNrRXZlbnQoZXZlbnQpXG4gICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgcmV0dXJuIHZhbGlkYXRlR3JvdXBFdmVudChldmVudClcbiAgICBjYXNlICdpZGVudGlmeSc6XG4gICAgICByZXR1cm4gdmFsaWRhdGVJZGVudGlmeUV2ZW50KGV2ZW50KVxuICAgIGNhc2UgJ3BhZ2UnOlxuICAgICAgcmV0dXJuIHZhbGlkYXRlUGFnZUV2ZW50KGV2ZW50KVxuICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICByZXR1cm4gdmFsaWRhdGVTY3JlZW5FdmVudChldmVudClcbiAgICBjYXNlICdhbGlhcyc6XG4gICAgICByZXR1cm4gdmFsaWRhdGVBbGlhc0V2ZW50KGV2ZW50KVxuICAgIGRlZmF1bHQ6XG4gICAgICBhc3NlcnQoMCwgJ0ludmFsaWQgZXZlbnQgdHlwZTogXCInICsgdHlwZSArICdcIicpXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIFwidHJhY2tcIiBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVRyYWNrRXZlbnQgKGV2ZW50KSB7XG4gIGFzc2VydChldmVudC5hbm9ueW1vdXNJZCB8fCBldmVudC51c2VySWQsICdZb3UgbXVzdCBwYXNzIGVpdGhlciBhbiBcImFub255bW91c0lkXCIgb3IgYSBcInVzZXJJZFwiLicpXG4gIGFzc2VydChldmVudC5ldmVudCwgJ1lvdSBtdXN0IHBhc3MgYW4gXCJldmVudFwiLicpXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSBcImdyb3VwXCIgZXZlbnQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVHcm91cEV2ZW50IChldmVudCkge1xuICBhc3NlcnQoZXZlbnQuYW5vbnltb3VzSWQgfHwgZXZlbnQudXNlcklkLCAnWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi4nKVxuICBhc3NlcnQoZXZlbnQuZ3JvdXBJZCwgJ1lvdSBtdXN0IHBhc3MgYSBcImdyb3VwSWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgXCJpZGVudGlmeVwiIGV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlSWRlbnRpZnlFdmVudCAoZXZlbnQpIHtcbiAgYXNzZXJ0KGV2ZW50LmFub255bW91c0lkIHx8IGV2ZW50LnVzZXJJZCwgJ1lvdSBtdXN0IHBhc3MgZWl0aGVyIGFuIFwiYW5vbnltb3VzSWRcIiBvciBhIFwidXNlcklkXCIuJylcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIFwicGFnZVwiIGV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFnZUV2ZW50IChldmVudCkge1xuICBhc3NlcnQoZXZlbnQuYW5vbnltb3VzSWQgfHwgZXZlbnQudXNlcklkLCAnWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgXCJzY3JlZW5cIiBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVNjcmVlbkV2ZW50IChldmVudCkge1xuICBhc3NlcnQoZXZlbnQuYW5vbnltb3VzSWQgfHwgZXZlbnQudXNlcklkLCAnWW91IG11c3QgcGFzcyBlaXRoZXIgYW4gXCJhbm9ueW1vdXNJZFwiIG9yIGEgXCJ1c2VySWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIFwiYWxpYXNcIiBldmVudC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFsaWFzRXZlbnQgKGV2ZW50KSB7XG4gIGFzc2VydChldmVudC51c2VySWQsICdZb3UgbXVzdCBwYXNzIGEgXCJ1c2VySWRcIi4nKVxuICBhc3NlcnQoZXZlbnQucHJldmlvdXNJZCwgJ1lvdSBtdXN0IHBhc3MgYSBcInByZXZpb3VzSWRcIi4nKVxufVxuXG4vKipcbiAqIFZhbGlkYXRpb24gcnVsZXMuXG4gKi9cblxudmFyIGdlbmVyaWNWYWxpZGF0aW9uUnVsZXMgPSB7XG4gIGFub255bW91c0lkOiBbICdzdHJpbmcnLCAnbnVtYmVyJyBdLFxuICBjYXRlZ29yeTogJ3N0cmluZycsXG4gIGNvbnRleHQ6ICdvYmplY3QnLFxuICBldmVudDogJ3N0cmluZycsXG4gIGdyb3VwSWQ6IFsgJ3N0cmluZycsICdudW1iZXInIF0sXG4gIGludGVncmF0aW9uczogJ29iamVjdCcsXG4gIG5hbWU6ICdzdHJpbmcnLFxuICBwcmV2aW91c0lkOiBbICdzdHJpbmcnLCAnbnVtYmVyJyBdLFxuICB0aW1lc3RhbXA6ICdkYXRlJyxcbiAgdXNlcklkOiBbICdzdHJpbmcnLCAnbnVtYmVyJyBdLFxuICB0eXBlOiAnc3RyaW5nJ1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIGV2ZW50IG9iamVjdC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUdlbmVyaWNFdmVudCAoZXZlbnQpIHtcbiAgYXNzZXJ0KHR5cGUoZXZlbnQpID09PSAnb2JqZWN0JywgJ1lvdSBtdXN0IHBhc3MgYSBtZXNzYWdlIG9iamVjdC4nKVxuICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGV2ZW50KVxuICAvLyBTdHJpbmdzIGFyZSB2YXJpYWJsZSBieXRlIGVuY29kZWQsIHNvIGpzb24ubGVuZ3RoIGlzIG5vdCBzdWZmaWNpZW50LlxuICBhc3NlcnQoQnVmZmVyLmJ5dGVMZW5ndGgoanNvbiwgJ3V0ZjgnKSA8IE1BWF9TSVpFLCAnWW91ciBtZXNzYWdlIG11c3QgYmUgPCAzMmtiLicpXG5cbiAgZm9yICh2YXIga2V5IGluIGdlbmVyaWNWYWxpZGF0aW9uUnVsZXMpIHtcbiAgICB2YXIgdmFsID0gZXZlbnRba2V5XVxuICAgIGlmICghdmFsKSBjb250aW51ZVxuICAgIHZhciBydWxlID0gZ2VuZXJpY1ZhbGlkYXRpb25SdWxlc1trZXldXG4gICAgaWYgKHR5cGUocnVsZSkgIT09ICdhcnJheScpIHtcbiAgICAgIHJ1bGUgPSBbIHJ1bGUgXVxuICAgIH1cbiAgICB2YXIgYSA9IHJ1bGVbMF0gPT09ICdvYmplY3QnID8gJ2FuJyA6ICdhJ1xuICAgIGFzc2VydChcbiAgICAgIHJ1bGUuc29tZShmdW5jdGlvbiAoZSkgeyByZXR1cm4gdHlwZSh2YWwpID09PSBlIH0pLFxuICAgICAgJ1wiJyArIGtleSArICdcIiBtdXN0IGJlICcgKyBhICsgJyAnICsgam9pbihydWxlLCAnb3InKSArICcuJ1xuICAgIClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpLmRlZmF1bHQ7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBleHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1hZGFwdGVyJyk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG5leHBvcnRzLkJOID0gQk47XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbmV4cG9ydHMucmxwID0gcmxwO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBldGhqc1V0aWwpO1xuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFB1YmxpYy1rZXkgY3J5cHRvZ3JhcGh5IChzZWNwMjU2azEpIGFuZCBhZGRyZXNzZXNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIYXNoIGZ1bmN0aW9uc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEVDRFNBIHNpZ25hdHVyZVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmF0dXJlXCIpLCBleHBvcnRzKTtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgQnVmZmVycywgYnl0ZSBhcnJheXMsIGV0Yy5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogRnVuY3Rpb24gZm9yIGRlZmluaW5pbmcgcHJvcGVydGllcyBvbiBhbiBvYmplY3RcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgcGJrZGYyU3luYyA9IHJlcXVpcmUoJ3Bia2RmMicpLnBia2RmMlN5bmNcblxudmFyIE1BWF9WQUxVRSA9IDB4N2ZmZmZmZmZcblxuLy8gTiA9IENwdSBjb3N0LCByID0gTWVtb3J5IGNvc3QsIHAgPSBwYXJhbGxlbGl6YXRpb24gY29zdFxuZnVuY3Rpb24gc2NyeXB0IChrZXksIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gIGlmIChOID09PSAwIHx8IChOICYgKE4gLSAxKSkgIT09IDApIHRocm93IEVycm9yKCdOIG11c3QgYmUgPiAwIGFuZCBhIHBvd2VyIG9mIDInKVxuXG4gIGlmIChOID4gTUFYX1ZBTFVFIC8gMTI4IC8gcikgdGhyb3cgRXJyb3IoJ1BhcmFtZXRlciBOIGlzIHRvbyBsYXJnZScpXG4gIGlmIChyID4gTUFYX1ZBTFVFIC8gMTI4IC8gcCkgdGhyb3cgRXJyb3IoJ1BhcmFtZXRlciByIGlzIHRvbyBsYXJnZScpXG5cbiAgdmFyIFhZID0gbmV3IEJ1ZmZlcigyNTYgKiByKVxuICB2YXIgViA9IG5ldyBCdWZmZXIoMTI4ICogciAqIE4pXG5cbiAgLy8gcHNldWRvIGdsb2JhbFxuICB2YXIgQjMyID0gbmV3IEludDMyQXJyYXkoMTYpIC8vIHNhbHNhMjBfOFxuICB2YXIgeCA9IG5ldyBJbnQzMkFycmF5KDE2KSAvLyBzYWxzYTIwXzhcbiAgdmFyIF9YID0gbmV3IEJ1ZmZlcig2NCkgLy8gYmxvY2ttaXhfc2Fsc2E4XG5cbiAgLy8gcHNldWRvIGdsb2JhbFxuICB2YXIgQiA9IHBia2RmMlN5bmMoa2V5LCBzYWx0LCAxLCBwICogMTI4ICogciwgJ3NoYTI1NicpXG5cbiAgdmFyIHRpY2tDYWxsYmFja1xuICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHZhciB0b3RhbE9wcyA9IHAgKiBOICogMlxuICAgIHZhciBjdXJyZW50T3AgPSAwXG5cbiAgICB0aWNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICArK2N1cnJlbnRPcFxuXG4gICAgICAvLyBzZW5kIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgb25jZSBldmVyeSAxLDAwMCBvcHNcbiAgICAgIGlmIChjdXJyZW50T3AgJSAxMDAwID09PSAwKSB7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRPcCxcbiAgICAgICAgICB0b3RhbDogdG90YWxPcHMsXG4gICAgICAgICAgcGVyY2VudDogKGN1cnJlbnRPcCAvIHRvdGFsT3BzKSAqIDEwMC4wXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwOyBpKyspIHtcbiAgICBzbWl4KEIsIGkgKiAxMjggKiByLCByLCBOLCBWLCBYWSlcbiAgfVxuXG4gIHJldHVybiBwYmtkZjJTeW5jKGtleSwgQiwgMSwgZGtMZW4sICdzaGEyNTYnKVxuXG4gIC8vIGFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgYXJlIGFjdHVhbGx5IG1vdmVkIHRvIHRoZSB0b3BcbiAgLy8gZHVlIHRvIGZ1bmN0aW9uIGhvaXN0aW5nXG5cbiAgZnVuY3Rpb24gc21peCAoQiwgQmksIHIsIE4sIFYsIFhZKSB7XG4gICAgdmFyIFhpID0gMFxuICAgIHZhciBZaSA9IDEyOCAqIHJcbiAgICB2YXIgaVxuXG4gICAgQi5jb3B5KFhZLCBYaSwgQmksIEJpICsgWWkpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBYWS5jb3B5KFYsIGkgKiBZaSwgWGksIFhpICsgWWkpXG4gICAgICBibG9ja21peF9zYWxzYTgoWFksIFhpLCBZaSwgcilcblxuICAgICAgaWYgKHRpY2tDYWxsYmFjaykgdGlja0NhbGxiYWNrKClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gWGkgKyAoMiAqIHIgLSAxKSAqIDY0XG4gICAgICB2YXIgaiA9IFhZLnJlYWRVSW50MzJMRShvZmZzZXQpICYgKE4gLSAxKVxuICAgICAgYmxvY2t4b3IoViwgaiAqIFlpLCBYWSwgWGksIFlpKVxuICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBYaSwgWWksIHIpXG5cbiAgICAgIGlmICh0aWNrQ2FsbGJhY2spIHRpY2tDYWxsYmFjaygpXG4gICAgfVxuXG4gICAgWFkuY29weShCLCBCaSwgWGksIFhpICsgWWkpXG4gIH1cblxuICBmdW5jdGlvbiBibG9ja21peF9zYWxzYTggKEJZLCBCaSwgWWksIHIpIHtcbiAgICB2YXIgaVxuXG4gICAgYXJyYXljb3B5KEJZLCBCaSArICgyICogciAtIDEpICogNjQsIF9YLCAwLCA2NClcblxuICAgIGZvciAoaSA9IDA7IGkgPCAyICogcjsgaSsrKSB7XG4gICAgICBibG9ja3hvcihCWSwgaSAqIDY0LCBfWCwgMCwgNjQpXG4gICAgICBzYWxzYTIwXzgoX1gpXG4gICAgICBhcnJheWNvcHkoX1gsIDAsIEJZLCBZaSArIChpICogNjQpLCA2NClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgICBhcnJheWNvcHkoQlksIFlpICsgKGkgKiAyKSAqIDY0LCBCWSwgQmkgKyAoaSAqIDY0KSwgNjQpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMiArIDEpICogNjQsIEJZLCBCaSArIChpICsgcikgKiA2NCwgNjQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gUiAoYSwgYikge1xuICAgIHJldHVybiAoYSA8PCBiKSB8IChhID4+PiAoMzIgLSBiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbHNhMjBfOCAoQikge1xuICAgIHZhciBpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgQjMyW2ldID0gKEJbaSAqIDQgKyAwXSAmIDB4ZmYpIDw8IDBcbiAgICAgIEIzMltpXSB8PSAoQltpICogNCArIDFdICYgMHhmZikgPDwgOFxuICAgICAgQjMyW2ldIHw9IChCW2kgKiA0ICsgMl0gJiAweGZmKSA8PCAxNlxuICAgICAgQjMyW2ldIHw9IChCW2kgKiA0ICsgM10gJiAweGZmKSA8PCAyNFxuICAgICAgLy8gQjMyW2ldID0gQi5yZWFkVUludDMyTEUoaSo0KSAgIDwtLS0gdGhpcyBpcyBzaWduZmljYW50bHkgc2xvd2VyIGV2ZW4gaW4gTm9kZS5qc1xuICAgIH1cblxuICAgIGFycmF5Y29weShCMzIsIDAsIHgsIDAsIDE2KVxuXG4gICAgZm9yIChpID0gODsgaSA+IDA7IGkgLT0gMikge1xuICAgICAgeFsgNF0gXj0gUih4WyAwXSArIHhbMTJdLCA3KVxuICAgICAgeFsgOF0gXj0gUih4WyA0XSArIHhbIDBdLCA5KVxuICAgICAgeFsxMl0gXj0gUih4WyA4XSArIHhbIDRdLCAxMylcbiAgICAgIHhbIDBdIF49IFIoeFsxMl0gKyB4WyA4XSwgMTgpXG4gICAgICB4WyA5XSBePSBSKHhbIDVdICsgeFsgMV0sIDcpXG4gICAgICB4WzEzXSBePSBSKHhbIDldICsgeFsgNV0sIDkpXG4gICAgICB4WyAxXSBePSBSKHhbMTNdICsgeFsgOV0sIDEzKVxuICAgICAgeFsgNV0gXj0gUih4WyAxXSArIHhbMTNdLCAxOClcbiAgICAgIHhbMTRdIF49IFIoeFsxMF0gKyB4WyA2XSwgNylcbiAgICAgIHhbIDJdIF49IFIoeFsxNF0gKyB4WzEwXSwgOSlcbiAgICAgIHhbIDZdIF49IFIoeFsgMl0gKyB4WzE0XSwgMTMpXG4gICAgICB4WzEwXSBePSBSKHhbIDZdICsgeFsgMl0sIDE4KVxuICAgICAgeFsgM10gXj0gUih4WzE1XSArIHhbMTFdLCA3KVxuICAgICAgeFsgN10gXj0gUih4WyAzXSArIHhbMTVdLCA5KVxuICAgICAgeFsxMV0gXj0gUih4WyA3XSArIHhbIDNdLCAxMylcbiAgICAgIHhbMTVdIF49IFIoeFsxMV0gKyB4WyA3XSwgMTgpXG4gICAgICB4WyAxXSBePSBSKHhbIDBdICsgeFsgM10sIDcpXG4gICAgICB4WyAyXSBePSBSKHhbIDFdICsgeFsgMF0sIDkpXG4gICAgICB4WyAzXSBePSBSKHhbIDJdICsgeFsgMV0sIDEzKVxuICAgICAgeFsgMF0gXj0gUih4WyAzXSArIHhbIDJdLCAxOClcbiAgICAgIHhbIDZdIF49IFIoeFsgNV0gKyB4WyA0XSwgNylcbiAgICAgIHhbIDddIF49IFIoeFsgNl0gKyB4WyA1XSwgOSlcbiAgICAgIHhbIDRdIF49IFIoeFsgN10gKyB4WyA2XSwgMTMpXG4gICAgICB4WyA1XSBePSBSKHhbIDRdICsgeFsgN10sIDE4KVxuICAgICAgeFsxMV0gXj0gUih4WzEwXSArIHhbIDldLCA3KVxuICAgICAgeFsgOF0gXj0gUih4WzExXSArIHhbMTBdLCA5KVxuICAgICAgeFsgOV0gXj0gUih4WyA4XSArIHhbMTFdLCAxMylcbiAgICAgIHhbMTBdIF49IFIoeFsgOV0gKyB4WyA4XSwgMTgpXG4gICAgICB4WzEyXSBePSBSKHhbMTVdICsgeFsxNF0sIDcpXG4gICAgICB4WzEzXSBePSBSKHhbMTJdICsgeFsxNV0sIDkpXG4gICAgICB4WzE0XSBePSBSKHhbMTNdICsgeFsxMl0sIDEzKVxuICAgICAgeFsxNV0gXj0gUih4WzE0XSArIHhbMTNdLCAxOClcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkgQjMyW2ldID0geFtpXSArIEIzMltpXVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHZhciBiaSA9IGkgKiA0XG4gICAgICBCW2JpICsgMF0gPSAoQjMyW2ldID4+IDAgJiAweGZmKVxuICAgICAgQltiaSArIDFdID0gKEIzMltpXSA+PiA4ICYgMHhmZilcbiAgICAgIEJbYmkgKyAyXSA9IChCMzJbaV0gPj4gMTYgJiAweGZmKVxuICAgICAgQltiaSArIDNdID0gKEIzMltpXSA+PiAyNCAmIDB4ZmYpXG4gICAgICAvLyBCLndyaXRlSW50MzJMRShCMzJbaV0sIGkqNCkgIC8vPC0tLSB0aGlzIGlzIHNpZ25maWNhbnRseSBzbG93ZXIgZXZlbiBpbiBOb2RlLmpzXG4gICAgfVxuICB9XG5cbiAgLy8gbmFpdmUgYXBwcm9hY2guLi4gZ29pbmcgYmFjayB0byBsb29wIHVucm9sbGluZyBtYXkgeWllbGQgYWRkaXRpb25hbCBwZXJmb3JtYW5jZVxuICBmdW5jdGlvbiBibG9ja3hvciAoUywgU2ksIEQsIERpLCBsZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBEW0RpICsgaV0gXj0gU1tTaSArIGldXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5Y29weSAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykgJiYgQnVmZmVyLmlzQnVmZmVyKGRlc3QpKSB7XG4gICAgc3JjLmNvcHkoZGVzdCwgZGVzdFBvcywgc3JjUG9zLCBzcmNQb3MgKyBsZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2NyeXB0XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiY29uc3QgY3JlYXRlU3dhcHBhYmxlUHJveHkgPSByZXF1aXJlKCcuL2NyZWF0ZVN3YXBwYWJsZVByb3h5JylcbmNvbnN0IGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5ID0gcmVxdWlyZSgnLi9jcmVhdGVFdmVudEVtaXR0ZXJQcm94eScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVTd2FwcGFibGVQcm94eSxcbiAgY3JlYXRlRXZlbnRFbWl0dGVyUHJveHksXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVBc3luY01pZGRsZXdhcmUsIG1lcmdlTWlkZGxld2FyZSB9IGZyb20gJ2pzb24tcnBjLWVuZ2luZSc7XG5pbXBvcnQge1xuICBjcmVhdGVGZXRjaE1pZGRsZXdhcmUsXG4gIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUsXG4gIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlLFxuICBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSxcbiAgY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSxcbiAgcHJvdmlkZXJGcm9tTWlkZGxld2FyZSxcbn0gZnJvbSAnZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgUG9sbGluZ0Jsb2NrVHJhY2tlciB9IGZyb20gJ2V0aC1ibG9jay10cmFja2VyJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5cbmNvbnN0IGluVGVzdCA9IHByb2Nlc3MuZW52LklOX1RFU1Q7XG5jb25zdCBibG9ja1RyYWNrZXJPcHRzID0gaW5UZXN0ID8geyBwb2xsaW5nSW50ZXJ2YWw6IFNFQ09ORCB9IDoge307XG5jb25zdCBnZXRUZXN0TWlkZGxld2FyZXMgPSAoKSA9PiB7XG4gIHJldHVybiBpblRlc3QgPyBbY3JlYXRlRXN0aW1hdGVHYXNEZWxheVRlc3RNaWRkbGV3YXJlKCldIDogW107XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVKc29uUnBjQ2xpZW50KHsgcnBjVXJsLCBjaGFpbklkIH0pIHtcbiAgY29uc3QgZmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKHsgcnBjVXJsIH0pO1xuICBjb25zdCBibG9ja1Byb3ZpZGVyID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShmZXRjaE1pZGRsZXdhcmUpO1xuICBjb25zdCBibG9ja1RyYWNrZXIgPSBuZXcgUG9sbGluZ0Jsb2NrVHJhY2tlcih7XG4gICAgLi4uYmxvY2tUcmFja2VyT3B0cyxcbiAgICBwcm92aWRlcjogYmxvY2tQcm92aWRlcixcbiAgfSk7XG5cbiAgY29uc3QgbmV0d29ya01pZGRsZXdhcmUgPSBtZXJnZU1pZGRsZXdhcmUoW1xuICAgIC4uLmdldFRlc3RNaWRkbGV3YXJlcygpLFxuICAgIGNyZWF0ZUNoYWluSWRNaWRkbGV3YXJlKGNoYWluSWQpLFxuICAgIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIgfSksXG4gICAgY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIgfSksXG4gICAgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSxcbiAgICBjcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyIH0pLFxuICAgIGZldGNoTWlkZGxld2FyZSxcbiAgXSk7XG5cbiAgcmV0dXJuIHsgbmV0d29ya01pZGRsZXdhcmUsIGJsb2NrVHJhY2tlciB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbklkTWlkZGxld2FyZShjaGFpbklkKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIGlmIChyZXEubWV0aG9kID09PSAnZXRoX2NoYWluSWQnKSB7XG4gICAgICByZXMucmVzdWx0ID0gY2hhaW5JZDtcbiAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGb3IgdXNlIGluIHRlc3RzIG9ubHkuXG4gKiBBZGRzIGEgZGVsYXkgdG8gYGV0aF9lc3RpbWF0ZUdhc2AgY2FsbHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVzdGltYXRlR2FzRGVsYXlUZXN0TWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCBfLCBuZXh0KSA9PiB7XG4gICAgaWYgKHJlcS5tZXRob2QgPT09ICdldGhfZXN0aW1hdGVHYXMnKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBTRUNPTkQgKiAyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlLCBtZXJnZU1pZGRsZXdhcmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlLFxuICBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlLFxuICBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSxcbiAgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUsXG4gIGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUsXG4gIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUsXG59IGZyb20gJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlJztcblxuaW1wb3J0IGNyZWF0ZUluZnVyYU1pZGRsZXdhcmUgZnJvbSAnZXRoLWpzb24tcnBjLWluZnVyYSc7XG5pbXBvcnQgeyBQb2xsaW5nQmxvY2tUcmFja2VyIH0gZnJvbSAnZXRoLWJsb2NrLXRyYWNrZXInO1xuXG5pbXBvcnQgeyBORVRXT1JLX1RZUEVfVE9fSURfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlSW5mdXJhQ2xpZW50KHsgbmV0d29yaywgcHJvamVjdElkIH0pIHtcbiAgY29uc3QgaW5mdXJhTWlkZGxld2FyZSA9IGNyZWF0ZUluZnVyYU1pZGRsZXdhcmUoe1xuICAgIG5ldHdvcmssXG4gICAgcHJvamVjdElkLFxuICAgIG1heEF0dGVtcHRzOiA1LFxuICAgIHNvdXJjZTogJ21ldGFtYXNrJyxcbiAgfSk7XG4gIGNvbnN0IGluZnVyYVByb3ZpZGVyID0gcHJvdmlkZXJGcm9tTWlkZGxld2FyZShpbmZ1cmFNaWRkbGV3YXJlKTtcbiAgY29uc3QgYmxvY2tUcmFja2VyID0gbmV3IFBvbGxpbmdCbG9ja1RyYWNrZXIoeyBwcm92aWRlcjogaW5mdXJhUHJvdmlkZXIgfSk7XG5cbiAgY29uc3QgbmV0d29ya01pZGRsZXdhcmUgPSBtZXJnZU1pZGRsZXdhcmUoW1xuICAgIGNyZWF0ZU5ldHdvcmtBbmRDaGFpbklkTWlkZGxld2FyZSh7IG5ldHdvcmsgfSksXG4gICAgY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIgfSksXG4gICAgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUoKSxcbiAgICBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyOiBpbmZ1cmFQcm92aWRlciB9KSxcbiAgICBjcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCBwcm92aWRlcjogaW5mdXJhUHJvdmlkZXIgfSksXG4gICAgY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciB9KSxcbiAgICBpbmZ1cmFNaWRkbGV3YXJlLFxuICBdKTtcbiAgcmV0dXJuIHsgbmV0d29ya01pZGRsZXdhcmUsIGJsb2NrVHJhY2tlciB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXR3b3JrQW5kQ2hhaW5JZE1pZGRsZXdhcmUoeyBuZXR3b3JrIH0pIHtcbiAgaWYgKCFORVRXT1JLX1RZUEVfVE9fSURfTUFQW25ldHdvcmtdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVJbmZ1cmFDbGllbnQgLSB1bmtub3duIG5ldHdvcmsgXCIke25ldHdvcmt9XCJgKTtcbiAgfVxuXG4gIGNvbnN0IHsgY2hhaW5JZCwgbmV0d29ya0lkIH0gPSBORVRXT1JLX1RZUEVfVE9fSURfTUFQW25ldHdvcmtdO1xuXG4gIHJldHVybiBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgIGV0aF9jaGFpbklkOiBjaGFpbklkLFxuICAgIG5ldF92ZXJzaW9uOiBuZXR3b3JrSWQsXG4gIH0pO1xufVxuIiwidmFyIGJhc2U1OCA9IHJlcXVpcmUoJ2JzNTgnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5cbmZ1bmN0aW9uIGVuY29kZSAocGF5bG9hZCwgdmVyc2lvbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSB8fCBwYXlsb2FkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHBheWxvYWQgPSBuZXcgQnVmZmVyKHBheWxvYWQpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmICh2ZXJzaW9uICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgICB2ZXJzaW9uID0gbmV3IEJ1ZmZlcihbdmVyc2lvbl0pXG4gICAgfVxuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ZlcnNpb24sIHBheWxvYWRdKVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IHBheWxvYWRcbiAgfVxuXG4gIHZhciBjaGVja3N1bSA9IHNoYTI1NngyKGJ1Zikuc2xpY2UoMCwgNClcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgY2hlY2tzdW1dKVxuICByZXR1cm4gYmFzZTU4LmVuY29kZShyZXN1bHQpXG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoYmFzZTU4c3RyLCB2ZXJzaW9uKSB7XG4gIHZhciBhcnIgPSBiYXNlNTguZGVjb2RlKGJhc2U1OHN0cilcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYXJyKVxuICB2YXIgdmVyc2lvbkxlbmd0aFxuXG4gIGlmICh2ZXJzaW9uID09IG51bGwpIHtcbiAgICB2ZXJzaW9uTGVuZ3RoID0gMFxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHZlcnNpb24gPSBuZXcgQnVmZmVyKFt2ZXJzaW9uXSlcblxuICAgIHZlcnNpb25MZW5ndGggPSB2ZXJzaW9uLmxlbmd0aFxuICAgIHZhciB2ZXJzaW9uQ29tcGFyZSA9IGJ1Zi5zbGljZSgwLCB2ZXJzaW9uTGVuZ3RoKVxuICAgIGlmICh2ZXJzaW9uQ29tcGFyZS50b1N0cmluZygnaGV4JykgIT09IHZlcnNpb24udG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbicpXG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrc3VtID0gYnVmLnNsaWNlKC00KVxuICB2YXIgZW5kUG9zID0gYnVmLmxlbmd0aCAtIDRcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKDAsIGVuZFBvcylcblxuICB2YXIgbmV3Q2hlY2tzdW0gPSBzaGEyNTZ4MihieXRlcykuc2xpY2UoMCwgNClcbiAgaWYgKGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSAhPT0gbmV3Q2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJylcbiAgfVxuXG4gIHJldHVybiBieXRlcy5zbGljZSh2ZXJzaW9uTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkIChiYXNlNThzdHIsIHZlcnNpb24pIHtcbiAgdHJ5IHtcbiAgICBkZWNvZGUoYmFzZTU4c3RyLCB2ZXJzaW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyICh2ZXJzaW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIHJldHVybiBlbmNvZGUocGF5bG9hZCwgdmVyc2lvbilcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVyICh2ZXJzaW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYmFzZTU4c3RyKSB7XG4gICAgcmV0dXJuIGRlY29kZShiYXNlNThzdHIsIHZlcnNpb24pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yICh2ZXJzaW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYmFzZTU4c3RyKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQoYmFzZTU4c3RyLCB2ZXJzaW9uKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNoYTI1NngyIChidWZmZXIpIHtcbiAgdmFyIHNoYSA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2hhKS5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlLFxuICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICBjcmVhdGVFbmNvZGVyOiBjcmVhdGVFbmNvZGVyLFxuICBjcmVhdGVEZWNvZGVyOiBjcmVhdGVEZWNvZGVyLFxuICBjcmVhdGVWYWxpZGF0b3I6IGNyZWF0ZVZhbGlkYXRvclxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYXBpID0gcmVxdWlyZShcIi4vYXBpXCIpO1xuXG5PYmplY3Qua2V5cyhfYXBpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfYXBpW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2FwaVtrZXldO1xufSk7XG5cbnZhciBfZXZlbnRzID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xuXG5PYmplY3Qua2V5cyhfZXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZXZlbnRzW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2V2ZW50c1trZXldO1xufSk7XG5cbnZhciBfbWlzYyA9IHJlcXVpcmUoXCIuL21pc2NcIik7XG5cbk9iamVjdC5rZXlzKF9taXNjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfbWlzY1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9taXNjW2tleV07XG59KTtcblxudmFyIF9wYXJhbXMgPSByZXF1aXJlKFwiLi9wYXJhbXNcIik7XG5cbk9iamVjdC5rZXlzKF9wYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9wYXJhbXNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfcGFyYW1zW2tleV07XG59KTtcblxudmFyIF9hY2NvdW50ID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcblxuT2JqZWN0LmtleXMoX2FjY291bnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9hY2NvdW50W2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2FjY291bnRba2V5XTtcbn0pO1xuXG52YXIgX2RldmljZSA9IHJlcXVpcmUoXCIuL3RyZXpvci9kZXZpY2VcIik7XG5cbk9iamVjdC5rZXlzKF9kZXZpY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9kZXZpY2Vba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfZGV2aWNlW2tleV07XG59KTtcblxudmFyIF9tYW5hZ2VtZW50ID0gcmVxdWlyZShcIi4vdHJlem9yL21hbmFnZW1lbnRcIik7XG5cbk9iamVjdC5rZXlzKF9tYW5hZ2VtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfbWFuYWdlbWVudFtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9tYW5hZ2VtZW50W2tleV07XG59KTtcblxudmFyIF9iaXRjb2luID0gcmVxdWlyZShcIi4vbmV0d29ya3MvYml0Y29pblwiKTtcblxuT2JqZWN0LmtleXMoX2JpdGNvaW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9iaXRjb2luW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2JpdGNvaW5ba2V5XTtcbn0pO1xuXG52YXIgX2JpbmFuY2UgPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9iaW5hbmNlXCIpO1xuXG5PYmplY3Qua2V5cyhfYmluYW5jZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2JpbmFuY2Vba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfYmluYW5jZVtrZXldO1xufSk7XG5cbnZhciBfY2FyZGFubyA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL2NhcmRhbm9cIik7XG5cbk9iamVjdC5rZXlzKF9jYXJkYW5vKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfY2FyZGFub1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9jYXJkYW5vW2tleV07XG59KTtcblxudmFyIF9jb2luSW5mbyA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL2NvaW5JbmZvXCIpO1xuXG5PYmplY3Qua2V5cyhfY29pbkluZm8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jb2luSW5mb1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9jb2luSW5mb1trZXldO1xufSk7XG5cbnZhciBfZW9zID0gcmVxdWlyZShcIi4vbmV0d29ya3MvZW9zXCIpO1xuXG5PYmplY3Qua2V5cyhfZW9zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZW9zW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2Vvc1trZXldO1xufSk7XG5cbnZhciBfZXRoZXJldW0gPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9ldGhlcmV1bVwiKTtcblxuT2JqZWN0LmtleXMoX2V0aGVyZXVtKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZXRoZXJldW1ba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfZXRoZXJldW1ba2V5XTtcbn0pO1xuXG52YXIgX25lbSA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL25lbVwiKTtcblxuT2JqZWN0LmtleXMoX25lbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX25lbVtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9uZW1ba2V5XTtcbn0pO1xuXG52YXIgX3JpcHBsZSA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL3JpcHBsZVwiKTtcblxuT2JqZWN0LmtleXMoX3JpcHBsZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3JpcHBsZVtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9yaXBwbGVba2V5XTtcbn0pO1xuXG52YXIgX3N0ZWxsYXIgPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9zdGVsbGFyXCIpO1xuXG5PYmplY3Qua2V5cyhfc3RlbGxhcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3N0ZWxsYXJba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfc3RlbGxhcltrZXldO1xufSk7XG5cbnZhciBfdGV6b3MgPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy90ZXpvc1wiKTtcblxuT2JqZWN0LmtleXMoX3Rlem9zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdGV6b3Nba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdGV6b3Nba2V5XTtcbn0pO1xuXG52YXIgX2Jsb2NrY2hhaW4gPSByZXF1aXJlKFwiLi9iYWNrZW5kL2Jsb2NrY2hhaW5cIik7XG5cbk9iamVjdC5rZXlzKF9ibG9ja2NoYWluKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfYmxvY2tjaGFpbltrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9ibG9ja2NoYWluW2tleV07XG59KTtcblxudmFyIF90cmFuc2FjdGlvbnMgPSByZXF1aXJlKFwiLi9iYWNrZW5kL3RyYW5zYWN0aW9uc1wiKTtcblxuT2JqZWN0LmtleXMoX3RyYW5zYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3RyYW5zYWN0aW9uc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF90cmFuc2FjdGlvbnNba2V5XTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DQVJEQU5PID0gZXhwb3J0cy5VSSA9IGV4cG9ydHMuVFJBTlNQT1JUID0gZXhwb3J0cy5QT1BVUCA9IGV4cG9ydHMuTkVUV09SSyA9IGV4cG9ydHMuSUZSQU1FID0gZXhwb3J0cy5FUlJPUlMgPSBleHBvcnRzLkRFVklDRSA9IGV4cG9ydHMuQkxPQ0tDSEFJTiA9IGV4cG9ydHMuQkxPQ0tDSEFJTl9FVkVOVCA9IGV4cG9ydHMuUkVTUE9OU0VfRVZFTlQgPSBleHBvcnRzLlRSQU5TUE9SVF9FVkVOVCA9IGV4cG9ydHMuREVWSUNFX0VWRU5UID0gZXhwb3J0cy5VSV9FVkVOVCA9IGV4cG9ydHMuQ09SRV9FVkVOVCA9IHZvaWQgMDtcblxudmFyIEJMT0NLQ0hBSU4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9ibG9ja2NoYWluXCIpKTtcblxuZXhwb3J0cy5CTE9DS0NIQUlOID0gQkxPQ0tDSEFJTjtcblxudmFyIERFVklDRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2RldmljZVwiKSk7XG5cbmV4cG9ydHMuREVWSUNFID0gREVWSUNFO1xuXG52YXIgRVJST1JTID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZXJyb3JzXCIpKTtcblxuZXhwb3J0cy5FUlJPUlMgPSBFUlJPUlM7XG5cbnZhciBJRlJBTUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9pZnJhbWVcIikpO1xuXG5leHBvcnRzLklGUkFNRSA9IElGUkFNRTtcblxudmFyIE5FVFdPUksgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3JrXCIpKTtcblxuZXhwb3J0cy5ORVRXT1JLID0gTkVUV09SSztcblxudmFyIFBPUFVQID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcG9wdXBcIikpO1xuXG5leHBvcnRzLlBPUFVQID0gUE9QVVA7XG5cbnZhciBUUkFOU1BPUlQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi90cmFuc3BvcnRcIikpO1xuXG5leHBvcnRzLlRSQU5TUE9SVCA9IFRSQU5TUE9SVDtcblxudmFyIFVJID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdWlcIikpO1xuXG5leHBvcnRzLlVJID0gVUk7XG5cbnZhciBDQVJEQU5PID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY2FyZGFub1wiKSk7XG5cbmV4cG9ydHMuQ0FSREFOTyA9IENBUkRBTk87XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbnZhciBDT1JFX0VWRU5UID0gJ0NPUkVfRVZFTlQnO1xuZXhwb3J0cy5DT1JFX0VWRU5UID0gQ09SRV9FVkVOVDtcbnZhciBVSV9FVkVOVCA9ICdVSV9FVkVOVCc7XG5leHBvcnRzLlVJX0VWRU5UID0gVUlfRVZFTlQ7XG52YXIgREVWSUNFX0VWRU5UID0gJ0RFVklDRV9FVkVOVCc7XG5leHBvcnRzLkRFVklDRV9FVkVOVCA9IERFVklDRV9FVkVOVDtcbnZhciBUUkFOU1BPUlRfRVZFTlQgPSAnVFJBTlNQT1JUX0VWRU5UJztcbmV4cG9ydHMuVFJBTlNQT1JUX0VWRU5UID0gVFJBTlNQT1JUX0VWRU5UO1xudmFyIFJFU1BPTlNFX0VWRU5UID0gJ1JFU1BPTlNFX0VWRU5UJztcbmV4cG9ydHMuUkVTUE9OU0VfRVZFTlQgPSBSRVNQT05TRV9FVkVOVDtcbnZhciBCTE9DS0NIQUlOX0VWRU5UID0gJ0JMT0NLQ0hBSU5fRVZFTlQnO1xuZXhwb3J0cy5CTE9DS0NIQUlOX0VWRU5UID0gQkxPQ0tDSEFJTl9FVkVOVDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRpc2FibGVXZWJVU0IgPSBleHBvcnRzLnJlcXVlc3RMb2dpbiA9IGV4cG9ydHMuY3VzdG9tTWVzc2FnZSA9IGV4cG9ydHMuZ2V0U2V0dGluZ3MgPSBleHBvcnRzLnJlbmRlcldlYlVTQkJ1dHRvbiA9IGV4cG9ydHMudWlSZXNwb25zZSA9IGV4cG9ydHMuY2FsbCA9IGV4cG9ydHMuaW5pdCA9IGV4cG9ydHMuY2FuY2VsID0gZXhwb3J0cy5kaXNwb3NlID0gZXhwb3J0cy5tYW5pZmVzdCA9IGV4cG9ydHMuZXZlbnRFbWl0dGVyID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9ldmVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJldmVudHNcIikpO1xuXG52YXIgX1BvcHVwTWFuYWdlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3BvcHVwL1BvcHVwTWFuYWdlclwiKSk7XG5cbnZhciBpZnJhbWUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vLi4vaWZyYW1lL2J1aWxkZXJcIikpO1xuXG52YXIgX2J1dHRvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3dlYnVzYi9idXR0b25cIikpO1xuXG52YXIgX21lc3NhZ2UgPSByZXF1aXJlKFwiLi4vLi4vbWVzc2FnZVwiKTtcblxudmFyIF9idWlsZGVyMiA9IHJlcXVpcmUoXCIuLi8uLi9tZXNzYWdlL2J1aWxkZXJcIik7XG5cbnZhciBfQ29ubmVjdFNldHRpbmdzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEvQ29ubmVjdFNldHRpbmdzXCIpO1xuXG52YXIgX2RlYnVnID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2RlYnVnXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG5cbnZhciAkVCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi8uLi90eXBlc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBldmVudEVtaXR0ZXIgPSBuZXcgX2V2ZW50c1tcImRlZmF1bHRcIl0oKTtcbmV4cG9ydHMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuXG52YXIgX2xvZyA9ICgwLCBfZGVidWcuaW5pdExvZykoJ1t0cmV6b3ItY29ubmVjdC5qc10nKTtcblxudmFyIF9zZXR0aW5ncztcblxudmFyIF9wb3B1cE1hbmFnZXI7XG5cbnZhciBpbml0UG9wdXBNYW5hZ2VyID0gZnVuY3Rpb24gaW5pdFBvcHVwTWFuYWdlcigpIHtcbiAgdmFyIHBtID0gbmV3IF9Qb3B1cE1hbmFnZXJbXCJkZWZhdWx0XCJdKF9zZXR0aW5ncyk7XG4gIHBtLm9uKF9jb25zdGFudHMuUE9QVVAuQ0xPU0VELCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogX2NvbnN0YW50cy5QT1BVUC5DTE9TRUQsXG4gICAgICBwYXlsb2FkOiBlcnJvciA/IHtcbiAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICB9IDogbnVsbFxuICAgIH0sIGZhbHNlKTtcbiAgfSk7XG4gIHJldHVybiBwbTtcbn07XG5cbnZhciBtYW5pZmVzdCA9IGZ1bmN0aW9uIG1hbmlmZXN0KGRhdGEpIHtcbiAgX3NldHRpbmdzID0gKDAsIF9Db25uZWN0U2V0dGluZ3MucGFyc2UpKHtcbiAgICBtYW5pZmVzdDogZGF0YVxuICB9KTtcbn07XG5cbmV4cG9ydHMubWFuaWZlc3QgPSBtYW5pZmVzdDtcblxudmFyIGRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICBldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmcmFtZS5kaXNwb3NlKCk7XG5cbiAgaWYgKF9wb3B1cE1hbmFnZXIpIHtcbiAgICBfcG9wdXBNYW5hZ2VyLmNsb3NlKCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGlzcG9zZSA9IGRpc3Bvc2U7XG5cbnZhciBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoZXJyb3IpIHtcbiAgaWYgKF9wb3B1cE1hbmFnZXIpIHtcbiAgICBfcG9wdXBNYW5hZ2VyLmVtaXQoX2NvbnN0YW50cy5QT1BVUC5DTE9TRUQsIGVycm9yKTtcbiAgfVxufTsgLy8gaGFuZGxlIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBpZnJhbWVcblxuXG5leHBvcnRzLmNhbmNlbCA9IGNhbmNlbDtcblxudmFyIGhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2VFdmVudCkge1xuICAvLyBpZ25vcmUgbWVzc2FnZXMgZnJvbSBkb21haW4gb3RoZXIgdGhlbiBpZnJhbWUgb3JpZ2luXG4gIGlmIChtZXNzYWdlRXZlbnQub3JpZ2luICE9PSBpZnJhbWUub3JpZ2luKSByZXR1cm47XG4gIHZhciBtZXNzYWdlID0gKDAsIF9tZXNzYWdlLnBhcnNlTWVzc2FnZSkobWVzc2FnZUV2ZW50LmRhdGEpO1xuICB2YXIgZXZlbnQgPSBtZXNzYWdlLmV2ZW50LFxuICAgICAgdHlwZSA9IG1lc3NhZ2UudHlwZSxcbiAgICAgIHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG4gIHZhciBpZCA9IG1lc3NhZ2UuaWQgfHwgMDtcblxuICBfbG9nLmxvZygnaGFuZGxlTWVzc2FnZScsIG1lc3NhZ2UpO1xuXG4gIHN3aXRjaCAoZXZlbnQpIHtcbiAgICBjYXNlIF9jb25zdGFudHMuUkVTUE9OU0VfRVZFTlQ6XG4gICAgICBpZiAoaWZyYW1lLm1lc3NhZ2VQcm9taXNlc1tpZF0pIHtcbiAgICAgICAgLy8gcmVzb2x2ZSBtZXNzYWdlIHByb21pc2UgKHNlbmQgcmVzdWx0IG9mIGNhbGwgbWV0aG9kKVxuICAgICAgICBpZnJhbWUubWVzc2FnZVByb21pc2VzW2lkXS5yZXNvbHZlKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgc3VjY2VzczogbWVzc2FnZS5zdWNjZXNzLFxuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBpZnJhbWUubWVzc2FnZVByb21pc2VzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9sb2cud2FybihcIlVua25vd24gbWVzc2FnZSBpZCBcIiArIGlkKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIF9jb25zdGFudHMuREVWSUNFX0VWRU5UOlxuICAgICAgLy8gcGFzcyBERVZJQ0UgZXZlbnQgdXAgdG8gaHRtbFxuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQsIG1lc3NhZ2UpO1xuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQodHlwZSwgcGF5bG9hZCk7IC8vIERFVklDRV9FVkVOVCBhbHNvIGVtaXQgc2luZ2xlIGV2ZW50cyAoY29ubmVjdC9kaXNjb25uZWN0Li4uKVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX2NvbnN0YW50cy5UUkFOU1BPUlRfRVZFTlQ6XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdCh0eXBlLCBwYXlsb2FkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBfY29uc3RhbnRzLkJMT0NLQ0hBSU5fRVZFTlQ6XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdCh0eXBlLCBwYXlsb2FkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBfY29uc3RhbnRzLlVJX0VWRU5UOlxuICAgICAgaWYgKHR5cGUgPT09IF9jb25zdGFudHMuSUZSQU1FLkJPT1RTVFJBUCkge1xuICAgICAgICBpZnJhbWUuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gX2NvbnN0YW50cy5JRlJBTUUuTE9BREVEKSB7XG4gICAgICAgIGlmcmFtZS5pbml0UHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBfY29uc3RhbnRzLklGUkFNRS5FUlJPUikge1xuICAgICAgICBpZnJhbWUuaW5pdFByb21pc2UucmVqZWN0KHBheWxvYWQuZXJyb3IpO1xuICAgICAgfSAvLyBwYXNzIFVJIGV2ZW50IHVwXG5cblxuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQsIG1lc3NhZ2UpO1xuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQodHlwZSwgcGF5bG9hZCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBfbG9nLmxvZygnVW5kZWZpbmVkIG1lc3NhZ2UnLCBldmVudCwgbWVzc2FnZUV2ZW50KTtcblxuICB9XG59O1xuXG52YXIgaW5pdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpZnJhbWUuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdJbml0X0FscmVhZHlJbml0aWFsaXplZCcpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKCFfc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgX3NldHRpbmdzID0gKDAsIF9Db25uZWN0U2V0dGluZ3MucGFyc2UpKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9zZXR0aW5ncy5tYW5pZmVzdCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfTWFuaWZlc3RNaXNzaW5nJyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAoIV9zZXR0aW5ncy5sYXp5TG9hZCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IFwibGF6eUxvYWRcIiBhZnRlciBmaXJzdCB1c2VcbiAgICAgICAgICAgIF9zZXR0aW5ncy5sYXp5TG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGlmICghX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyID0gaW5pdFBvcHVwTWFuYWdlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfbG9nLmVuYWJsZWQgPSAhIV9zZXR0aW5ncy5kZWJ1ZztcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgZGlzcG9zZSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICByZXR1cm4gaWZyYW1lLmluaXQoX3NldHRpbmdzKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXQoX3gpIHtcbiAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuXG52YXIgY2FsbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihwYXJhbXMpIHtcbiAgICB2YXIgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISghaWZyYW1lLmluc3RhbmNlICYmICFpZnJhbWUudGltZW91dCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluaXQgcG9wdXAgd2l0aCBsYXp5IGxvYWRpbmcgYmVmb3JlIGlmcmFtZSBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgX3NldHRpbmdzID0gKDAsIF9Db25uZWN0U2V0dGluZ3MucGFyc2UpKF9zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIGlmIChfc2V0dGluZ3MubWFuaWZlc3QpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9NYW5pZmVzdE1pc3NpbmcnKSkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKCFfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIgPSBpbml0UG9wdXBNYW5hZ2VyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIucmVxdWVzdCh0cnVlKTsgLy8gYXV0byBpbml0IHdpdGggZGVmYXVsdCBzZXR0aW5nc1xuXG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiBpbml0KF9zZXR0aW5ncyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDYpO1xuXG4gICAgICAgICAgICBpZiAoX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICAvLyBDYXRjaCBmYXRhbCBpZnJhbWUgZXJyb3JzIChub3QgbG9hZGluZylcbiAgICAgICAgICAgICAgaWYgKFsnSW5pdF9JZnJhbWVCbG9ja2VkJywgJ0luaXRfSWZyYW1lVGltZW91dCddLmluY2x1ZGVzKF9jb250ZXh0Mi50MC5jb2RlKSkge1xuICAgICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIucG9zdE1lc3NhZ2UoKDAsIF9idWlsZGVyMi5VaU1lc3NhZ2UpKF9jb25zdGFudHMuVUkuSUZSQU1FX0ZBSUxVUkUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnRleHQyLnQwKSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCFpZnJhbWUudGltZW91dCkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9NYW5pZmVzdE1pc3NpbmcnKSkpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIGlmICghaWZyYW1lLmVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShpZnJhbWUuZXJyb3IpKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAvLyByZXF1ZXN0IHBvcHVwIHdpbmRvdyBpdCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICAgIGlmIChfc2V0dGluZ3MucG9wdXAgJiYgX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLnJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0gLy8gcG9zdCBtZXNzYWdlIHRvIGlmcmFtZVxuXG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjA7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgcmV0dXJuIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuSUZSQU1FLkNBTEwsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHBhcmFtc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLnBheWxvYWQuY29kZSAhPT0gJ0RldmljZV9DYWxsSW5Qcm9ncmVzcycgJiYgX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLnVubG9jaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgaWYgKF9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlci51bmxvY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignTWV0aG9kX05vUmVzcG9uc2UnKSkpO1xuXG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMzE7XG4gICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgyMCk7XG5cbiAgICAgICAgICAgIF9sb2cuZXJyb3IoJ19fY2FsbCBlcnJvcicsIF9jb250ZXh0Mi50MSk7XG5cbiAgICAgICAgICAgIGlmIChfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnRleHQyLnQxKSk7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbNiwgMTFdLCBbMjAsIDMxXV0pO1xuICB9KSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbGwoX3gyKSB7XG4gICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuY2FsbCA9IGNhbGw7XG5cbnZhciBjdXN0b21NZXNzYWdlUmVzcG9uc2UgPSBmdW5jdGlvbiBjdXN0b21NZXNzYWdlUmVzcG9uc2UocGF5bG9hZCkge1xuICBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLlVJX0VWRU5ULFxuICAgIHR5cGU6IF9jb25zdGFudHMuVUkuQ1VTVE9NX01FU1NBR0VfUkVTUE9OU0UsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9KTtcbn07XG5cbnZhciB1aVJlc3BvbnNlID0gZnVuY3Rpb24gdWlSZXNwb25zZShyZXNwb25zZSkge1xuICB2YXIgdHlwZSA9IHJlc3BvbnNlLnR5cGUsXG4gICAgICBwYXlsb2FkID0gcmVzcG9uc2UucGF5bG9hZDtcbiAgaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICBldmVudDogX2NvbnN0YW50cy5VSV9FVkVOVCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgfSk7XG59O1xuXG5leHBvcnRzLnVpUmVzcG9uc2UgPSB1aVJlc3BvbnNlO1xuXG52YXIgcmVuZGVyV2ViVVNCQnV0dG9uID0gZnVuY3Rpb24gcmVuZGVyV2ViVVNCQnV0dG9uKGNsYXNzTmFtZSkge1xuICAoMCwgX2J1dHRvbltcImRlZmF1bHRcIl0pKGNsYXNzTmFtZSwgX3NldHRpbmdzLndlYnVzYlNyYywgaWZyYW1lLm9yaWdpbik7XG59O1xuXG5leHBvcnRzLnJlbmRlcldlYlVTQkJ1dHRvbiA9IHJlbmRlcldlYlVTQkJ1dHRvbjtcblxudmFyIGdldFNldHRpbmdzID0gZnVuY3Rpb24gZ2V0U2V0dGluZ3MoKSB7XG4gIGlmICghaWZyYW1lLmluc3RhbmNlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdJbml0X05vdEluaXRpYWxpemVkJykpKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsKHtcbiAgICBtZXRob2Q6ICdnZXRTZXR0aW5ncydcbiAgfSk7XG59O1xuXG5leHBvcnRzLmdldFNldHRpbmdzID0gZ2V0U2V0dGluZ3M7XG5cbnZhciBjdXN0b21NZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHBhcmFtcykge1xuICAgIHZhciBjYWxsYmFjaywgY3VzdG9tTWVzc2FnZUxpc3RlbmVyLCByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBwYXJhbXMuY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ01ldGhvZF9DdXN0b21NZXNzYWdlX0NhbGxiYWNrJykpKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIFRPRE86IHNldCBtZXNzYWdlIGxpc3RlbmVyIG9ubHkgaWYgaWZyYW1lIGlzIGxvYWRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zLmNhbGxiYWNrO1xuXG4gICAgICAgICAgICBjdXN0b21NZXNzYWdlTGlzdGVuZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX3JlZjQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSwgcGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEudHlwZSA9PT0gX2NvbnN0YW50cy5VSS5DVVNUT01fTUVTU0FHRV9SRVFVRVNUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YS5wYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tTWVzc2FnZVJlc3BvbnNlKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tTWVzc2FnZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAncmVsZWFzZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMyk7XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VzdG9tTWVzc2FnZUxpc3RlbmVyKF94NCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGN1c3RvbU1lc3NhZ2VMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIGNhbGwoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnY3VzdG9tTWVzc2FnZSdcbiAgICAgICAgICAgIH0sIHBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjdXN0b21NZXNzYWdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjdXN0b21NZXNzYWdlKF94Mykge1xuICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmN1c3RvbU1lc3NhZ2UgPSBjdXN0b21NZXNzYWdlO1xuXG52YXIgcmVxdWVzdExvZ2luID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWY1ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHBhcmFtcykge1xuICAgIHZhciBjYWxsYmFjaywgbG9naW5DaGFsbGVuZ2VMaXN0ZW5lciwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgcGFyYW1zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcy5jYWxsYmFjazsgLy8gVE9ETzogc2V0IG1lc3NhZ2UgbGlzdGVuZXIgb25seSBpZiBpZnJhbWUgaXMgbG9hZGVkIGNvcnJlY3RseVxuXG4gICAgICAgICAgICBsb2dpbkNoYWxsZW5nZUxpc3RlbmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEsIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLnR5cGUgPT09IF9jb25zdGFudHMuVUkuTE9HSU5fQ0hBTExFTkdFX1JFUVVFU1QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBfY29uc3RhbnRzLlVJX0VWRU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfY29uc3RhbnRzLlVJLkxPR0lOX0NIQUxMRU5HRV9SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUudDAgPSBfY29udGV4dDVbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBfY29uc3RhbnRzLlVJX0VWRU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfY29uc3RhbnRzLlVJLkxPR0lOX0NIQUxMRU5HRV9SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogX2NvbnRleHQ1LnQwLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU1LCBudWxsLCBbWzIsIDldXSk7XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbG9naW5DaGFsbGVuZ2VMaXN0ZW5lcihfeDYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsb2dpbkNoYWxsZW5nZUxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gY2FsbChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICBtZXRob2Q6ICdyZXF1ZXN0TG9naW4nXG4gICAgICAgICAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgICAgICAgICBhc3luY0NoYWxsZW5nZTogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxvZ2luQ2hhbGxlbmdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgY2FsbChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAncmVxdWVzdExvZ2luJ1xuICAgICAgICAgICAgfSwgcGFyYW1zKSkpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2KTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0TG9naW4oX3g1KSB7XG4gICAgcmV0dXJuIF9yZWY1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMucmVxdWVzdExvZ2luID0gcmVxdWVzdExvZ2luO1xuXG52YXIgZGlzYWJsZVdlYlVTQiA9IGZ1bmN0aW9uIGRpc2FibGVXZWJVU0IoKSB7XG4gIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuVUlfRVZFTlQsXG4gICAgdHlwZTogX2NvbnN0YW50cy5UUkFOU1BPUlQuRElTQUJMRV9XRUJVU0JcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRpc2FibGVXZWJVU0IgPSBkaXNhYmxlV2ViVVNCOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoJ2tlY2NhaycpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHJscCA9IHJlcXVpcmUoJ3JscCcpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVxdWlyZSgnZXRoanMtdXRpbCcpKTtcblxuLyoqXG4gKiB0aGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGUgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gTUFYX0lOVEVHRVJcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcblxuLyoqXG4gKiAyXjI1NiAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBUV09fUE9XMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfTlVMTF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbmV4cG9ydHMuU0hBM19OVUxMX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfTlVMTFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEw7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX0FSUkFZX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBfQVJSQVlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVk7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG5leHBvcnRzLlNIQTNfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUDtcblxuLyoqXG4gKiBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5CTiA9IEJOO1xuXG4vKipcbiAqIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMucmxwID0gcmxwO1xuXG4vKipcbiAqIFtgc2VjcDI1NmsxYF0oaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS8pXG4gKiBAdmFyIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuXG4vKipcbiAgKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCB6ZXJvQWRkcmVzc1xuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KHplcm9BZGRyZXNzKTtcbn07XG5cbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBtZXRob2QgbHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICBpZiAocmlnaHQpIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWBcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ30gYVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fFN0cmluZ31cbiAqL1xuZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGEpO1xuICB2YXIgZmlyc3QgPSBhWzBdO1xuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0geyp9IHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShleHBvcnRzLnBhZFRvRXZlbihleHBvcnRzLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gZXhwb3J0cy5pbnRUb0J1ZmZlcih2KTtcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH0gZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBudW1cbiAqIEByZXR1cm4ge0JOfVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qk59IG51bVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBLZWNjYWsgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgaWYgKCFiaXRzKSBiaXRzID0gMjU2O1xuXG4gIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKCdrZWNjYWsnICsgYml0cykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyAoS2VjY2FrKSBoYXNoIG9mIHRoZSBpbnB1dCBbT0JTT0xFVEVdXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgU0hBLTMgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEzID0gZXhwb3J0cy5rZWNjYWs7XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFkZGVkIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChoYXNoLCAzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgfVxuXG4gIGlmICghc2FuaXRpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgcHViS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJLZXkpO1xuICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICBwcml2YXRlS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICBwdWJsaWNLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBwdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5KSB7XG4gIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcblxuICB2YXIgcmV0ID0ge307XG4gIHJldC5yID0gc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMik7XG4gIHJldC5zID0gc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICByZXQudiA9IHNpZy5yZWNvdmVyeSArIDI3O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBoYXNoXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwcmVmaXggPSBleHBvcnRzLnRvQnVmZmVyKCdcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gcHVibGljS2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoKHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICB2YXIgcmVjb3ZlcnkgPSB2IC0gMjc7XG4gIGlmIChyZWNvdmVyeSAhPT0gMCAmJiByZWNvdmVyeSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICB9XG4gIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge1N0cmluZ30gc2lnXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcykge1xuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgfVxuXG4gIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gIC8vIEZJWE1FOiB0aGlzIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGV4cG9ydHMudG9CdWZmZXIodiAtIDI3KV0pKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHNpZyA9IGV4cG9ydHMudG9CdWZmZXIoc2lnKTtcblxuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAoc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFyIHYgPSBzaWdbNjRdO1xuICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgaWYgKHYgPCAyNykge1xuICAgIHYgKz0gMjc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHY6IHYsXG4gICAgcjogc2lnLnNsaWNlKDAsIDMyKSxcbiAgICBzOiBzaWcuc2xpY2UoMzIsIDY0KVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiAoL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcylcbiAgKTtcbn07XG5cbi8qKlxuICAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIGlzWmVyb0FkZHJlc3NcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gIHJldHVybiB6ZXJvQWRkcmVzcyA9PT0gZXhwb3J0cy5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc2ggPSBleHBvcnRzLmtlY2NhayhhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciByZXQgPSAnMHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IGZyb20gdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IG5vbmNlIHRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gIGZyb20gPSBleHBvcnRzLnRvQnVmZmVyKGZyb20pO1xuICBub25jZSA9IG5ldyBCTihub25jZSk7XG5cbiAgaWYgKG5vbmNlLmlzWmVybygpKSB7XG4gICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICBub25jZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9uY2UgPSBCdWZmZXIuZnJvbShub25jZS50b0FycmF5KCkpO1xuICB9XG5cbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLnJscGhhc2goW2Zyb20sIG5vbmNlXSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciBhID0gZXhwb3J0cy51bnBhZChhZGRyZXNzKTtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuXG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIEVDRFNBIHNpZ25hdHVyZVxuICogQG1ldGhvZCBpc1ZhbGlkU2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtob21lc3RlYWQ9dHJ1ZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZCkge1xuICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcblxuICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHIgPSBuZXcgQk4ocik7XG4gIHMgPSBuZXcgQk4ocyk7XG5cbiAgaWYgKHIuaXNaZXJvKCkgfHwgci5ndChTRUNQMjU2SzFfTikgfHwgcy5pc1plcm8oKSB8fCBzLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChob21lc3RlYWQgPT09IGZhbHNlICYmIG5ldyBCTihzKS5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gYmFcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ3xudWxsfVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgcmV0dXJuICcweCcgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSB7Kn0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gIHNlbGYucmF3ID0gW107XG4gIHNlbGYuX2ZpZWxkcyA9IFtdO1xuXG4gIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBvYmpbZmllbGRdID0gJzB4JyArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuYmFUb0pTT04odGhpcy5yYXcpO1xuICB9O1xuXG4gIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgfTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICB2ID0gZXhwb3J0cy50b0J1ZmZlcih2KTtcblxuICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgdiA9IGV4cG9ydHMuc3RyaXBaZXJvcyh2KTtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBub3QgaGF2ZSBtb3JlICcgKyBmaWVsZC5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gICAgICB9IGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAnICsgZmllbGQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShleHBvcnRzLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBleHBvcnRzLnRvQnVmZmVyKGQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICB9XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhY2hlVHlwZUZvclBheWxvYWQgPSBleHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gZXhwb3J0cy5ibG9ja1RhZ0ZvclBheWxvYWQgPSBleHBvcnRzLmNhbkNhY2hlID0gZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkID0gdm9pZCAwO1xuY29uc3QganNvbl9zdGFibGVfc3RyaW5naWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKSk7XG5mdW5jdGlvbiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHNraXBCbG9ja1JlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaW1wbGVQYXJhbXMgPSBza2lwQmxvY2tSZWZcbiAgICAgICAgPyBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZClcbiAgICAgICAgOiAoX2EgPSBwYXlsb2FkLnBhcmFtcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgaWYgKGNhbkNhY2hlKHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybiBgJHtwYXlsb2FkLm1ldGhvZH06JHsoMCwganNvbl9zdGFibGVfc3RyaW5naWZ5XzEuZGVmYXVsdCkoc2ltcGxlUGFyYW1zKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCA9IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQ7XG5mdW5jdGlvbiBjYW5DYWNoZShwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCkgIT09ICduZXZlcic7XG59XG5leHBvcnRzLmNhbkNhY2hlID0gY2FuQ2FjaGU7XG5mdW5jdGlvbiBibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCkge1xuICAgIGlmICghcGF5bG9hZC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1tpbmRleF07XG59XG5leHBvcnRzLmJsb2NrVGFnRm9yUGF5bG9hZCA9IGJsb2NrVGFnRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXlsb2FkLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXM7XG4gICAgfVxuICAgIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDAsIGluZGV4KTtcbn1cbmV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gcGFyYW1zV2l0aG91dEJsb2NrVGFnO1xuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDJcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMVxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMFxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gYmxvY2tUYWdcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXg7XG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgICAgIGNhc2UgJ3dlYjNfY2xpZW50VmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlTExMJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgICAgIGNhc2UgJ3NoaF92ZXJzaW9uJzpcbiAgICAgICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAncGVybWEnO1xuICAgICAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuICdmb3JrJztcbiAgICAgICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVHYXMnOlxuICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICAgICAgY2FzZSAndGVzdF9ibG9ja0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2snO1xuICAgICAgICAvLyBuZXZlciBjYWNoZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICduZXZlcic7XG4gICAgfVxufVxuZXhwb3J0cy5jYWNoZVR5cGVGb3JQYXlsb2FkID0gY2FjaGVUeXBlRm9yUGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBldGhBYmkgPSByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNvbmNhdFNpZzogZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpXG4gICAgY29uc3Qgc1NpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChzKVxuICAgIGNvbnN0IHZTaWcgPSBldGhVdGlsLmJ1ZmZlclRvSW50KHYpXG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3QgdlN0ciA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZXRoVXRpbC5pbnRUb0hleCh2U2lnKSlcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gJyByZWNlaXZlZCAnICsgKHR5cGVvZiBpbnB1dCkgKyAnOiAnICsgaW5wdXRcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpXG4gIH0sXG5cbiAgcGVyc29uYWxTaWduOiBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIHZhciBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gICAgdmFyIHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlOiBmdW5jdGlvbiAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gICAgcmV0dXJuIHNlbmRlckhleFxuICB9LFxuXG4gIGV4dHJhY3RQdWJsaWNLZXk6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIHJldHVybiAnMHgnICsgcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIHR5cGVkU2lnbmF0dXJlSGFzaDogZnVuY3Rpb24gKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YTogZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmU6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKVxuICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHwgIXR5cGVkRGF0YS5sZW5ndGgpIHRocm93IGVycm9yXG5cbiAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlID09PSAnYnl0ZXMnID8gZXRoVXRpbC50b0J1ZmZlcihlLnZhbHVlKSA6IGUudmFsdWVcbiAgfSlcbiAgY29uc3QgdHlwZXMgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnR5cGUgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBlLnR5cGUgKyAnICcgKyBlLm5hbWVcbiAgfSlcblxuICByZXR1cm4gZXRoQWJpLnNvbGlkaXR5U0hBMyhcbiAgICBbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLFxuICAgIFtcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSlcbiAgICBdXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShoYXNoLCBzaWcpIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gZXRoVXRpbC50b0J1ZmZlcihzaWcpXG4gIGNvbnN0IHNpZ1BhcmFtcyA9IGV0aFV0aWwuZnJvbVJwY1NpZyhzaWduYXR1cmUpXG4gIHJldHVybiBldGhVdGlsLmVjcmVjb3ZlcihoYXNoLCBzaWdQYXJhbXMudiwgc2lnUGFyYW1zLnIsIHNpZ1BhcmFtcy5zKVxufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3IgKG1zZ1BhcmFtcykge1xuICBjb25zdCBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgY29uc3QgbXNnSGFzaCA9IGV0aFV0aWwuaGFzaFBlcnNvbmFsTWVzc2FnZShtZXNzYWdlKVxuICByZXR1cm4gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBtc2dQYXJhbXMuc2lnKVxufVxuXG5cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMgKG51bWJlciwgbGVuZ3RoKSB7XG4gIHZhciBteVN0cmluZyA9ICcnICsgbnVtYmVyXG4gIHdoaWxlIChteVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBteVN0cmluZyA9ICcwJyArIG15U3RyaW5nXG4gIH1cbiAgcmV0dXJuIG15U3RyaW5nXG59XG4iLCJjb25zdCBiaXR3aXNlID0gcmVxdWlyZSgnYml0d2lzZScpO1xuY29uc3Qgc3VwZXJhZ2VudCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcbmNvbnN0IGJpdGNvaW4gPSByZXF1aXJlKCcuL2JpdGNvaW4nKTtcbmNvbnN0IGV0aGVyZXVtID0gcmVxdWlyZSgnLi9ldGhlcmV1bScpO1xuY29uc3QgeyBidWlsZEFkZEFiaVBheWxvYWQsIGFiaVBhcnNlcnMsIE1BWF9BQklfREVGUyB9ID0gcmVxdWlyZSgnLi9ldGhlcmV1bUFiaScpO1xuY29uc3Qge1xuICBpc1ZhbGlkQXNzZXRQYXRoLFxuICBpc1ZhbGlkQ29pblR5cGUsXG4gIHNpZ25SZXFSZXNvbHZlcixcbiAgYWVzMjU2X2RlY3J5cHQsXG4gIGFlczI1Nl9lbmNyeXB0LFxuICBwYXJzZURFUixcbiAgY2hlY2tzdW0sXG4gIGVuc3VyZUhleEJ1ZmZlcixcbiAgZ2V0UDI1NktleVBhaXIsXG4gIGdldFAyNTZLZXlQYWlyRnJvbVB1YixcbiAgcGFyc2VMYXR0aWNlMVJlc3BvbnNlLFxuICB0b1BhZGRlZERFUixcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IHtcbiAgQVNDSUlfUkVHRVgsXG4gIGdldEZ3VmVyc2lvbkNvbnN0LFxuICBBRERSX1NUUl9MRU4sXG4gIEVOQ19NU0dfTEVOLFxuICBkZWNSZXNMZW5ndGhzLFxuICBkZXZpY2VDb2RlcyxcbiAgZW5jUmVxQ29kZXMsXG4gIHJlc3BvbnNlQ29kZXMsXG4gIFJFUVVFU1RfVFlQRV9CWVRFLFxuICBWRVJTSU9OX0JZVEUsXG4gIG1lc3NhZ2VDb25zdGFudHMsXG4gIEJBU0VfVVJMLFxuICBzaWduaW5nU2NoZW1hLFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xuY29uc3QgRU1QVFlfV0FMTEVUX1VJRCA9IEJ1ZmZlci5hbGxvYygzMik7XG5cbmNsYXNzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHsgYmFzZVVybCwgY3J5cHRvLCBuYW1lLCBwcml2S2V5LCB0aW1lb3V0LCByZXRyeUNvdW50IH0gPSB7fSkge1xuICAgIC8vIERlZmluaXRpb25zXG4gICAgLy8gaWYgKCFiYXNlVXJsKSB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2VVcmwgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAobmFtZSAmJiBuYW1lLmxlbmd0aCA+IDI0KSB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBsZXNzIHRoYW4gMjQgY2hhcmFjdGVycycpO1xuICAgIGlmICghY3J5cHRvKSB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0byBwcm92aWRlciBpcyByZXF1aXJlZCcpO1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmwgfHwgQkFTRV9VUkw7XG4gICAgdGhpcy5jcnlwdG8gPSBjcnlwdG87XG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnVW5rbm93bic7XG4gICAgXG4gICAgLy8gRGVyaXZlIGFuIEVDRFNBIGtleXBhaXIgdXNpbmcgdGhlIHAyNTYgY3VydmUuIFRoZSBwdWJsaWMga2V5IHdpbGxcbiAgICAvLyBiZSB1c2VkIGFzIGFuIGlkZW50aWZpZXJcbiAgICB0aGlzLnByaXZLZXkgPSBwcml2S2V5IHx8IHRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICB0aGlzLmtleSA9IGdldFAyNTZLZXlQYWlyKHRoaXMucHJpdktleSk7Ly8uZW5jb2RlKCdoZXgnKTtcblxuICAgIC8vIFN0YXRlZnVsIHBhcmFtc1xuICAgIHRoaXMuZXBoZW1lcmFsUHViID0gbnVsbDtcbiAgICB0aGlzLnNoYXJlZFNlY3JldCA9IG51bGw7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCA2MDAwMDtcbiAgICB0aGlzLmRldmljZUlkID0gbnVsbDtcbiAgICB0aGlzLmlzUGFpcmVkID0gZmFsc2U7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gcmV0cnlDb3VudCB8fCAzO1xuXG4gICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgd2FsbGV0LiBTaG91bGQgYmUgbnVsbCB1bmxlc3Mgd2Uga25vdyBhIHdhbGxldCBpcyBwcmVzZW50XG4gICAgdGhpcy5hY3RpdmVXYWxsZXRzID0ge1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgdWlkOiBFTVBUWV9XQUxMRVRfVUlELCAgICAgICAgICAgLy8gMzIgYnl0ZSBpZFxuICAgICAgICBuYW1lOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAvLyAyMCBjaGFyIChtYXgpIHN0cmluZ1xuICAgICAgICBjYXBhYmlsaXRpZXM6IG51bGwsICAgICAgICAgICAgICAvLyA0IGJ5dGUgZmxhZ1xuICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICB9LFxuICAgICAgZXh0ZXJuYWw6IHtcbiAgICAgICAgdWlkOiBFTVBUWV9XQUxMRVRfVUlELCAgICAgICAgICAgLy8gMzIgYnl0ZSBpZFxuICAgICAgICBuYW1lOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAvLyAyMCBjaGFyIChtYXgpIHN0cmluZ1xuICAgICAgICBjYXBhYmlsaXRpZXM6IG51bGwsICAgICAgICAgICAgICAvLyA0IGJ5dGUgZmxhZ1xuICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTEFUVElDRSBGVU5DVElPTlNcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vIGBDb25uZWN0YCB3aWxsIGF0dGVtcHQgdG8gY29udGFjdCBhIGRldmljZSBiYXNlZCBvbiBpdHMgZGV2aWNlSWQuXG4gIC8vIFRoZSByZXNwb25zZSBzaG91bGQgaW5jbHVkZSBhbiBlcGhlbWVyYWwgcHVibGljIGtleSwgd2hpY2ggaXMgdXNlZCB0b1xuICAvLyBwYWlyIHdpdGggdGhlIGRldmljZSBpbiBhIGxhdGVyIHJlcXVlc3RcbiAgY29ubmVjdChkZXZpY2VJZCwgY2IpIHtcbiAgICAvLyBVc2VyIG1heSBcInJlLWNvbm5lY3RcIiBpZiBhIGRldmljZSBJRCBoYXMgcHJldmlvdXNseSBiZWVuIHN0b3JlZFxuICAgIGlmICh0eXBlb2YgZGV2aWNlSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICghdGhpcy5kZXZpY2VJZCkgXG4gICAgICAgIHJldHVybiBjYignTm8gZGV2aWNlIElEIGhhcyBiZWVuIHN0b3JlZC4gUGxlYXNlIGNvbm5lY3Qgd2l0aCB5b3VyIGRldmljZSBJRCBmaXJzdC4nKVxuICAgICAgY2IgPSBkZXZpY2VJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgZGV2aWNlIElELCBjb25uZWN0IHRvIHRoYXQgZGV2aWNlIGFuZCBzYXZlXG4gICAgICAvLyB0aGUgbmV3IElEIGZvciBmdXR1cmUgdXNlLlxuICAgICAgdGhpcy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuX2J1aWxkUmVxdWVzdChkZXZpY2VDb2Rlcy5DT05ORUNULCB0aGlzLnB1YktleUJ5dGVzKCkpO1xuICAgIHRoaXMuX3JlcXVlc3QocGFyYW0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICB0aGlzLmlzUGFpcmVkID0gdGhpcy5faGFuZGxlQ29ubmVjdChyZXMpIHx8IGZhbHNlO1xuICAgICAgLy8gQ2hlY2sgZm9yIGFuIGFjdGl2ZSB3YWxsZXQuIFRoaXMgd2lsbCBnZXQgYnlwYXNzZWQgaWYgd2UgYXJlIG5vdCBwYWlyZWQuXG4gICAgICBpZiAodGhpcy5pc1BhaXJlZCkge1xuICAgICAgICB0aGlzLl9nZXRBY3RpdmVXYWxsZXQoKGVycikgPT4ge1xuICAgICAgICAgIHJldHVybiBjYihlcnIsIHRoaXMuaXNQYWlyZWQpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0pO1xuICB9XG5cbiAgcGFpcihwYWlyaW5nU2VjcmV0LCBjYikge1xuICAgIC8vIEJ1aWxkIHRoZSBzZWNyZXQgaGFzaCBmcm9tIHRoZSBzYWx0XG4gICAgY29uc3QgcHViS2V5ID0gdGhpcy5wdWJLZXlCeXRlcygpO1xuICAgIGNvbnN0IG5hbWVCdWYgPSBCdWZmZXIuYWxsb2MoMjUpO1xuICAgIGlmICh0aGlzLm5hbWUubGVuZ3RoID4gMjQpIHtcbiAgICAgIHJldHVybiBjYignTmFtZSBpcyB0b28gbWFueSBjaGFyYWN0ZXJzLiBQbGVhc2UgY2hhbmdlIGl0IHRvIDwyNSBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICBuYW1lQnVmLndyaXRlKHRoaXMubmFtZSk7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIG51bGwgdGVybWluYXRpb24gYnl0ZSB0byB0aGUgcGFpcmluZyBzZWNyZXRcbiAgICBjb25zdCBwcmVJbWFnZSA9IEJ1ZmZlci5jb25jYXQoW3B1YktleSwgbmFtZUJ1ZiwgQnVmZmVyLmZyb20ocGFpcmluZ1NlY3JldCldKTtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5jcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHByZUltYWdlKS5kaWdlc3QoKTtcbiAgICBjb25zdCBzaWcgPSB0aGlzLmtleS5zaWduKGhhc2gpOyAvLyByZXR1cm5zIGFuIGFycmF5LCBub3QgYSBidWZmZXJcbiAgICBjb25zdCBkZXJTaWcgPSB0b1BhZGRlZERFUihzaWcpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuY29uY2F0KFtuYW1lQnVmLCBkZXJTaWddKTtcblxuICAgIC8vIEJ1aWxkIHRoZSByZXF1ZXN0XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLl9idWlsZEVuY1JlcXVlc3QoZW5jUmVxQ29kZXMuRklOQUxJWkVfUEFJUklORywgcGF5bG9hZCk7XG4gICAgdGhpcy5fcmVxdWVzdChwYXJhbSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgIC8vIFJlY292ZXIgdGhlIGVwaGVtZXJhbCBrZXlcbiAgICAgIGNvbnN0IGVyclN0ciA9IHRoaXMuX2hhbmRsZVBhaXIocmVzKTtcbiAgICAgIGlmIChlcnJTdHIpIHJldHVybiBjYihlcnJTdHIpO1xuICAgICAgLy8gVHJ5IHRvIGdldCB0aGUgYWN0aXZlIHdhbGxldCBvbmNlIHBhaXJpbmcgaXMgc3VjY2Vzc2Z1bFxuICAgICAgdGhpcy5fZ2V0QWN0aXZlV2FsbGV0KChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIHJldHVybiBjYihudWxsLCB0aGlzLmhhc0FjdGl2ZVdhbGxldCgpKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH0pICBcbiAgfVxuXG4gIHRlc3QoZGF0YSwgY2IpIHtcbiAgICBpZiAoIWRhdGEucGF5bG9hZClcbiAgICAgIHJldHVybiBjYignRmlyc3QgYXJndW1lbnQgbXVzdCBjb250YWluIGB0ZXN0SURgIGFuZCBgcGF5bG9hZGAgZmllbGRzLicpO1xuICAgIGNvbnN0IFRFU1RfREFUQV9TWiA9IDUwMDtcbiAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKFRFU1RfREFUQV9TWiArIDYpO1xuICAgIHBheWxvYWQud3JpdGVVSW50MzJCRShkYXRhLnRlc3RJRCwgMCk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQxNkJFKGRhdGEucGF5bG9hZC5sZW5ndGgsIDQpO1xuICAgIGRhdGEucGF5bG9hZC5jb3B5KHBheWxvYWQsIDYpO1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fYnVpbGRFbmNSZXF1ZXN0KGVuY1JlcUNvZGVzLlRFU1QsIHBheWxvYWQpO1xuICAgIHRoaXMuX3JlcXVlc3QocGFyYW0sIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSB0aGlzLl9oYW5kbGVFbmNSZXNwb25zZShyZXMsIGRlY1Jlc0xlbmd0aHMudGVzdCk7XG4gICAgICBpZiAoZGVjcnlwdGVkLmVyciAhPT0gbnVsbCApIFxuICAgICAgICByZXR1cm4gY2IoZGVjcnlwdGVkLmVycik7XG4gICAgICByZXR1cm4gY2IobnVsbCwgZGVjcnlwdGVkLmRhdGEuc2xpY2UoNjUpKTsgLy8gcmVtb3ZlIGVwaGVtIHB1YlxuICAgIH0pXG4gIH1cblxuICBnZXRBZGRyZXNzZXMob3B0cywgY2IpIHtcbiAgICBjb25zdCBTS0lQX0NBQ0hFX0ZMQUcgPSAxO1xuICAgIGNvbnN0IE1BWF9BRERSID0gMTA7XG4gICAgY29uc3QgeyBzdGFydFBhdGgsIG4sIHNraXBDYWNoZT10cnVlIH0gPSBvcHRzO1xuICAgIGlmIChzdGFydFBhdGggPT09IHVuZGVmaW5lZCB8fCBuID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gY2IoJ1BsZWFzZSBwcm92aWRlIGBzdGFydFBhdGhgIGFuZCBgbmAgb3B0aW9ucycpO1xuICAgIGlmIChzdGFydFBhdGgubGVuZ3RoIDwgMiB8fCBzdGFydFBhdGgubGVuZ3RoID4gNSlcbiAgICAgIHJldHVybiBjYignUGF0aCBtdXN0IGluY2x1ZGUgYmV0d2VlbiAyIGFuZCA1IGluZGljZXMnKTtcbiAgICBpZiAobiA+IE1BWF9BRERSKVxuICAgICAgcmV0dXJuIGNiKGBZb3UgbWF5IG9ubHkgcmVxdWVzdCAke01BWF9BRERSfSBhZGRyZXNzZXMgYXQgb25jZS5gKTtcblxuICAgIGlmICgoc2tpcENhY2hlID09PSBmYWxzZSAmJiBmYWxzZSA9PT0gaXNWYWxpZEFzc2V0UGF0aChzdGFydFBhdGgpKSB8fFxuICAgICAgICAoc2tpcENhY2hlID09PSB0cnVlICYmIGZhbHNlID09PSBpc1ZhbGlkQ29pblR5cGUoc3RhcnRQYXRoKSkgKVxuICAgICAgcmV0dXJuIGNiKCdQYXJlbnQgcGF0aCBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBjb25zdCBmd0NvbnN0YW50cyA9IGdldEZ3VmVyc2lvbkNvbnN0KHRoaXMuZndWZXJzaW9uKTtcbiAgICBsZXQgc3ogPSAzMiArIDIwICsgMTsgLy8gd2FsbGV0VUlEICsgNSB1MzIgaW5kaWNlcyArIGNvdW50L2ZsYWdcbiAgICBpZiAoZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQpIHtcbiAgICAgIHN6ICs9IDE7ICAvLyBwYXRoRGVwdGhcbiAgICB9IGVsc2UgaWYgKHN0YXJ0UGF0aC5sZW5ndGggIT09IDUpIHtcbiAgICAgIHJldHVybiBjYignWW91ciBMYXR0aWNlIGZpcm13YXJlIG9ubHkgc3VwcG9ydHMgZGVyaXZhdGlvbiBwYXRocyB3aXRoIDUgaW5kaWNlcy4gUGxlYXNlIHVwZ3JhZGUuJylcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhzeik7XG4gICAgbGV0IG9mZiA9IDA7XG5cbiAgICAvLyBXYWxsZXRVSURcbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLmdldEFjdGl2ZVdhbGxldCgpO1xuICAgIGlmICh3YWxsZXQgPT09IG51bGwpIHJldHVybiBjYignTm8gYWN0aXZlIHdhbGxldC4nKTtcbiAgICB3YWxsZXQudWlkLmNvcHkocGF5bG9hZCwgb2ZmKTsgb2ZmICs9IDMyO1xuICAgIC8vIEJ1aWxkIHRoZSBzdGFydCBwYXRoICg1eCB1MzIgaW5kaWNlcylcbiAgICBpZiAoZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQpIHtcbiAgICAgIHBheWxvYWQud3JpdGVVSW50OChzdGFydFBhdGgubGVuZ3RoLCBvZmYpO1xuICAgICAgb2ZmICs9IDE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICBpZiAoaSA8PSBzdGFydFBhdGgubGVuZ3RoKVxuICAgICAgICBwYXlsb2FkLndyaXRlVUludDMyQkUoc3RhcnRQYXRoW2ldLCBvZmYpO1xuICAgICAgb2ZmICs9IDQ7XG4gICAgfVxuICAgIC8vIFNwZWNpZnkgdGhlIG51bWJlciBvZiBzdWJzZXF1ZW50IGFkZHJlc3NlcyB0byByZXF1ZXN0LlxuICAgIC8vIFdlIGFsc28gYWxsb3cgdGhlIHVzZXIgdG8gc2tpcCB0aGUgY2FjaGUgYW5kIHJlcXVlc3QgYW55IGFkZHJlc3MgcmVsYXRlZCB0byB0aGUgYXNzZXRcbiAgICAvLyBpbiB0aGUgd2FsbGV0LlxuICAgIGxldCB2YWw7XG4gICAgaWYgKHRydWUgPT09IGZ3Q29uc3RhbnRzLmFkZHJGbGFnc0FsbG93ZWQpIHtcbiAgICAgIGNvbnN0IGZsYWcgPSBza2lwQ2FjaGUgPT09IHRydWUgPyBiaXR3aXNlLm5pYmJsZS5yZWFkKFNLSVBfQ0FDSEVfRkxBRykgOiBiaXR3aXNlLm5pYmJsZS5yZWFkKDApO1xuICAgICAgY29uc3QgY291bnQgPSBiaXR3aXNlLm5pYmJsZS5yZWFkKG4pO1xuICAgICAgdmFsID0gYml0d2lzZS5ieXRlLndyaXRlKGZsYWcuY29uY2F0KGNvdW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IG47XG4gICAgfVxuICAgIHBheWxvYWQud3JpdGVVSW50OCh2YWwsIG9mZik7IG9mZisrO1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fYnVpbGRFbmNSZXF1ZXN0KGVuY1JlcUNvZGVzLkdFVF9BRERSRVNTRVMsIHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHBhcmFtLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgY29uc3QgcGFyc2VkUmVzID0gdGhpcy5faGFuZGxlR2V0QWRkcmVzc2VzKHJlcyk7XG4gICAgICBpZiAocGFyc2VkUmVzLmVycikgcmV0dXJuIGNiKHBhcnNlZFJlcy5lcnIpO1xuICAgICAgcmV0dXJuIGNiKG51bGwsIHBhcnNlZFJlcy5kYXRhKTtcbiAgICB9KVxuICB9XG5cbiAgc2lnbihvcHRzLCBjYiwgY2FjaGVkRGF0YT1udWxsLCBuZXh0Q29kZT1udWxsKSB7XG4gICAgY29uc3QgeyBjdXJyZW5jeSB9ID0gb3B0cztcbiAgICBsZXQgeyBkYXRhIH0gPSBvcHRzO1xuICAgIGlmIChjdXJyZW5jeSA9PT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNiKCdQbGVhc2UgcHJvdmlkZSBgY3VycmVuY3lgIGFuZCBgZGF0YWAgb3B0aW9ucycpO1xuICAgIH0gZWxzZSBpZiAoc2lnblJlcVJlc29sdmVyW2N1cnJlbmN5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2IoJ1Vuc3VwcG9ydGVkIGN1cnJlbmN5Jyk7XG4gICAgfVxuICAgIC8vIEFsbCB0cmFuc2FjdGlvbiByZXF1ZXN0cyBtdXN0IGJlIHB1dCBpbnRvIHRoZSBzYW1lIHNpemVkIGJ1ZmZlci5cbiAgICAvLyBUaGlzIGNvbWVzIGZyb20gc2l6ZW9mKEdwVHJhbnNhY3Rpb25SZXF1ZXN0X3QpLCBidXQgbm90ZSB3ZSByZW1vdmVcbiAgICAvLyB0aGUgMi1ieXRlIHNjaGVtYUlkIHNpbmNlIGl0IGlzIG5vdCByZXR1cm5lZCBmcm9tIG91ciByZXNvbHZlci5cbiAgICAvLyBOb3RlIHRoYXQgZGlmZmVyZW50IGZpcm13YXJlIHZlcnNpb25zIG1heSBoYXZlIGRpZmZlcmVudCBkYXRhIHNpemVzLlxuICAgIGNvbnN0IGZ3Q29uc3RhbnRzID0gZ2V0RndWZXJzaW9uQ29uc3QodGhpcy5md1ZlcnNpb24pO1xuICAgIC8vIEJ1aWxkIHRoZSBzaWduaW5nIHJlcXVlc3QgcGF5bG9hZCB0byBzZW5kIHRvIHRoZSBkZXZpY2UuIElmIHdlIGNhdGNoXG4gICAgLy8gYmFkIHBhcmFtcywgcmV0dXJuIGFuIGVycm9yIGluc3RlYWRcbiAgICBkYXRhID0geyBmd0NvbnN0YW50cywgLi4uZGF0YX07XG4gICAgbGV0IHJlcSwgcmVxUGF5bG9hZDtcbiAgICBsZXQgc2NoZW1hO1xuICAgIGlmIChjYWNoZWREYXRhICE9PSBudWxsICYmIG5leHRDb2RlICE9PSBudWxsKSB7XG4gICAgICByZXEgPSBjYWNoZWREYXRhO1xuICAgICAgcmVxUGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoW25leHRDb2RlLCByZXEuZXh0cmFEYXRhUGF5bG9hZHMuc2hpZnQoKV0pXG4gICAgICBzY2hlbWEgPSBzaWduaW5nU2NoZW1hLkVYVFJBX0RBVEE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcSA9IHNpZ25SZXFSZXNvbHZlcltjdXJyZW5jeV0oZGF0YSk7XG4gICAgICBpZiAocmVxLmVyciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gY2IocmVxLmVycik7XG4gICAgICBpZiAocmVxLnBheWxvYWQubGVuZ3RoID4gZndDb25zdGFudHMucmVxTWF4RGF0YVN6KVxuICAgICAgICByZXR1cm4gY2IoJ1RyYW5zYWN0aW9uIGlzIHRvbyBsYXJnZScpO1xuICAgICAgcmVxUGF5bG9hZCA9IHJlcS5wYXlsb2FkO1xuICAgICAgc2NoZW1hID0gcmVxLnNjaGVtYTtcbiAgICB9XG4gICAgLy8gQnVpbGQgdGhlIHBheWxvYWRcbiAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKDIgKyBmd0NvbnN0YW50cy5yZXFNYXhEYXRhU3opO1xuICAgIGxldCBvZmYgPSAwO1xuICAgIC8vIFdoZXRoZXIgdGhlcmUgd2lsbCBiZSBmb2xsb3cgdXAgcmVxdWVzdHNcbiAgICBjb25zdCBoYXNFeHRyYVBheWxvYWRzID0gcmVxLmV4dHJhRGF0YVBheWxvYWRzICYmIE51bWJlcihyZXEuZXh0cmFEYXRhUGF5bG9hZHMubGVuZ3RoID4gMCk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KGhhc0V4dHJhUGF5bG9hZHMsIG9mZik7IG9mZiArPSAxOyAgXG4gICAgLy8gQ29weSByZXF1ZXN0IHNjaGVtYSAoZS5nLiBFVEggb3IgQlRDIHRyYW5zZmVyKVxuICAgIHBheWxvYWQud3JpdGVVSW50OChzY2hlbWEsIG9mZik7IG9mZiArPSAxO1xuICAgIC8vIENvcHkgdGhlIHdhbGxldCBVSURcbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLmdldEFjdGl2ZVdhbGxldCgpO1xuICAgIGlmICh3YWxsZXQgPT09IG51bGwpIHJldHVybiBjYignTm8gYWN0aXZlIHdhbGxldC4nKTtcbiAgICB3YWxsZXQudWlkLmNvcHkocGF5bG9hZCwgb2ZmKTsgb2ZmICs9IHdhbGxldC51aWQubGVuZ3RoO1xuICAgIC8vIEJ1aWxkIGRhdGEgYmFzZWQgb24gdGhlIHR5cGUgb2YgcmVxdWVzdFxuICAgIC8vIENvcHkgdGhlIHBheWxvYWQgb2YgdGhlIHJlcXVlc3RcbiAgICByZXFQYXlsb2FkLmNvcHkocGF5bG9hZCwgb2ZmKTtcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVuY3J5cHRlZCByZXF1ZXN0IGFuZCBzZW5kIGl0XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLl9idWlsZEVuY1JlcXVlc3QoZW5jUmVxQ29kZXMuU0lHTl9UUkFOU0FDVElPTiwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QocGFyYW0sIChlcnIsIHJlcywgcmVzcG9uc2VDb2RlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2VDb2RlID09PSByZXNwb25zZUNvZGVzLlJFU1BfRVJSX1dBTExFVF9OT1RfUFJFU0VOVCkge1xuICAgICAgICAvLyBJZiB3ZSBjYXRjaCBhIGNhc2Ugd2hlcmUgdGhlIHdhbGxldCBoYXMgY2hhbmdlZCwgdHJ5IGdldHRpbmcgdGhlIG5ldyBhY3RpdmUgd2FsbGV0XG4gICAgICAgIC8vIGFuZCByZWN1cnNpdmVseSBtYWtlIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICB0aGlzLl9nZXRBY3RpdmVXYWxsZXQoKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgZWxzZSAgICAgcmV0dXJuIHRoaXMuc2lnbihvcHRzLCBjYiwgY2FjaGVkRGF0YSwgbmV4dENvZGUpO1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFub3RoZXIgZXJyb3IgY2F1Z2h0LCByZXR1cm4gaXRcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICB9IGVsc2UgaWYgKGhhc0V4dHJhUGF5bG9hZHMpIHtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkID0gdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UocmVzLCBkZWNSZXNMZW5ndGhzLnNpZ24pO1xuICAgICAgICBuZXh0Q29kZSA9IGRlY3J5cHRlZC5kYXRhLnNsaWNlKDY1LCA3Myk7XG4gICAgICAgIGlmICghY2FjaGVkRGF0YSlcbiAgICAgICAgICBjYWNoZWREYXRhID0gcmVxO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduKG9wdHMsIGNiLCBjYWNoZWREYXRhLCBuZXh0Q29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb3JyZWN0IHdhbGxldCBhbmQgbm8gZXJyb3JzIC0tIGhhbmRsZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgY29uc3QgcGFyc2VkUmVzID0gdGhpcy5faGFuZGxlU2lnbihyZXMsIGN1cnJlbmN5LCByZXEpO1xuICAgICAgICByZXR1cm4gY2IocGFyc2VkUmVzLmVyciwgcGFyc2VkUmVzLmRhdGEpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhZGRBYmlEZWZzKGRlZnMsIGNiLCBuZXh0Q29kZT1udWxsKSB7XG4gICAgY29uc3QgZGVmc1RvQWRkID0gZGVmcy5zbGljZSgwLCBNQVhfQUJJX0RFRlMpO1xuICAgIGRlZnMgPSBkZWZzLnNsaWNlKE1BWF9BQklfREVGUyk7XG4gICAgbGV0IGFiaVBheWxvYWQ7XG4gICAgdHJ5IHtcbiAgICAgIGFiaVBheWxvYWQgPSBidWlsZEFkZEFiaVBheWxvYWQoZGVmc1RvQWRkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmFsbG9jKGFiaVBheWxvYWQubGVuZ3RoICsgMTApO1xuICAgIC8vIExldCB0aGUgZmlybXdhcmUga25vdyBob3cgbWFueSBkZWZzIGFyZSByZW1haW5pbmcgKmFmdGVyIHRoaXMgb25lKi5cbiAgICAvLyBJZiB0aGlzIGlzIGEgcG9zaXRpdmUgbnVtYmVyLCBmaXJtd2FyZSB3aWxsIHNlbmQgdXMgYSB0ZW1wb3JhcnkgY29kZVxuICAgIC8vIHRvIGJ5cGFzcyB1c2VyIGF1dGhvcml6YXRpb24gaWYgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZWFzeSBBQkkgbG9hZGluZy5cbiAgICBwYXlsb2FkLndyaXRlVUludDE2TEUoZGVmcy5sZW5ndGgpO1xuICAgIC8vIElmIHRoaXMgaXMgYSBmb2xsb3ctdXAgcmVxdWVzdCwgd2UgZG9uJ3QgbmVlZCB0byBhc2sgZm9yIHVzZXIgYXV0aG9yaXphdGlvblxuICAgIC8vIGlmIHdlIHVzZSB0aGUgY29ycmVjdCB0ZW1wb3JhcnkgdTY0XG4gICAgaWYgKG5leHRDb2RlICE9PSBudWxsKVxuICAgICAgbmV4dENvZGUuY29weShwYXlsb2FkLCAyKTtcbiAgICBhYmlQYXlsb2FkLmNvcHkocGF5bG9hZCwgMTApO1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fYnVpbGRFbmNSZXF1ZXN0KGVuY1JlcUNvZGVzLkFERF9BQklfREVGUywgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QocGFyYW0sIChlcnIsIHJlcywgcmVzcG9uc2VDb2RlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2VDb2RlICYmIHJlc3BvbnNlQ29kZSAhPT0gcmVzcG9uc2VDb2Rlcy5SRVNQX1NVQ0NFU1MpXG4gICAgICAgIHJldHVybiBjYignRXJyb3IgbWFraW5nIHJlcXVlc3QuJyk7XG4gICAgICBlbHNlIGlmIChlcnIpXG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UocmVzLCBkZWNSZXNMZW5ndGhzLmFkZEFiaURlZnMpO1xuICAgICAgLy8gR3JhYiB0aGUgOCBieXRlIGNvZGUgdG8gZmFzdCB0cmFjayBvdXIgbmV4dCByZXF1ZXN0LCBpZiBuZWVkZWRcbiAgICAgIG5leHRDb2RlID0gZGVjcnlwdGVkLmRhdGEuc2xpY2UoNjUsIDczKTsgXG4gICAgICAvLyBObyBkZWZzIGxlZnQ/IFJldHVybiBzdWNjZXNzXG4gICAgICBpZiAoZGVmcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICAgIC8vIEFkZCB0aGUgbmV4dCBzZXRcbiAgICAgIHRoaXMuYWRkQWJpRGVmcyhkZWZzLCBjYiwgbmV4dENvZGUsIGRlZnMpO1xuICAgIH0pXG4gIH1cbiAgXG4gIGFkZFBlcm1pc3Npb25WMChvcHRzLCBjYikge1xuICAgIGNvbnN0IHsgY3VycmVuY3ksIHRpbWVXaW5kb3csIGxpbWl0LCBkZWNpbWFscywgYXNzZXQgfSA9IG9wdHM7XG4gICAgaWYgKCFjdXJyZW5jeSB8fCB0aW1lV2luZG93ID09PSB1bmRlZmluZWQgfHwgbGltaXQgPT09IHVuZGVmaW5lZCB8fCBkZWNpbWFscyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHRpbWVXaW5kb3cgPT09IG51bGwgfHwgbGltaXQgPT09IG51bGwgfHwgZGVjaW1hbHMgPT09IG51bGwpXG4gICAgICByZXR1cm4gY2IoJ2N1cnJlbmN5LCB0aW1lV2luZG93LCBkZWNpbWFscywgYW5kIGxpbWl0IGFyZSBhbGwgcmVxdWlyZWQgb3B0aW9ucy4nKTtcbiAgICBlbHNlIGlmICh0aW1lV2luZG93ID09PSAwIHx8IGxpbWl0ID09PSAwKVxuICAgICAgcmV0dXJuIGNiKCdUaW1lIHdpbmRvdyBhbmQgc3BlbmRpbmcgbGltaXQgbXVzdCBiZSBwb3NpdGl2ZS4nKTtcbiAgICAvLyBCdWlsZCB0aGUgbmFtZSBvZiB0aGUgcGVybWlzc2lvblxuICAgIGxldCBuYW1lID0gY3VycmVuY3k7XG4gICAgaWYgKGFzc2V0KVxuICAgICAgbmFtZSArPSBgXyR7YXNzZXR9YDtcbiAgICAvLyBTdGFydCBidWlsZGluZyB0aGUgcGF5bG9hZFxuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoMjkzKTtcbiAgICAvLyBDb3B5IHRoZSBuYW1lXG4gICAgaWYgKEJ1ZmZlci5mcm9tKG5hbWUpLmxlbmd0aCA+IDI1NSlcbiAgICAgIHJldHVybiBjYignQXNzZXQgbmFtZSB0b28gbG9uZy4nKTtcbiAgICBCdWZmZXIuZnJvbShuYW1lKS5jb3B5KHBheWxvYWQsIDApO1xuICAgIC8vIENvbnZlcnQgdGhlIGxpbWl0IHRvIGEgMzIgYnl0ZSBoZXggYnVmZmVyIGFuZCBjb3B5IGl0IGluXG4gICAgY29uc3QgbGltaXRCdWYgPSBlbnN1cmVIZXhCdWZmZXIobGltaXQpXG4gICAgaWYgKGxpbWl0QnVmLmxlbmd0aCA+IDMyKVxuICAgICAgcmV0dXJuIGNiKCdMaW1pdCB0b28gbGFyZ2UuJyk7XG4gICAgbGltaXRCdWYuY29weShwYXlsb2FkLCAyNTYgKyAoMzIgLSBsaW1pdEJ1Zi5sZW5ndGgpKTtcbiAgICAvLyBDb3B5IHRoZSB0aW1lIHdpbmRvdyAoc2Vjb25kcylcbiAgICBwYXlsb2FkLndyaXRlVUludDMyQkUodGltZVdpbmRvdywgMjg4KTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgoZGVjaW1hbHMsIDI5Mik7XG4gICAgLy8gRW5jcnlwdCB0aGUgcmVxdWVzdCBhbmQgc2VuZCBpdCB0byB0aGUgTGF0dGljZS5cbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuX2J1aWxkRW5jUmVxdWVzdChlbmNSZXFDb2Rlcy5BRERfUEVSTUlTU0lPTl9WMCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVlc3QocGFyYW0sIChlcnIsIHJlcywgcmVzcG9uc2VDb2RlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2VDb2RlID09PSByZXNwb25zZUNvZGVzLlJFU1BfRVJSX1dBTExFVF9OT1RfUFJFU0VOVCkge1xuICAgICAgICAvLyBJZiB3ZSBjYXRjaCBhIGNhc2Ugd2hlcmUgdGhlIHdhbGxldCBoYXMgY2hhbmdlZCwgdHJ5IGdldHRpbmcgdGhlIG5ldyBhY3RpdmUgd2FsbGV0XG4gICAgICAgIC8vIGFuZCByZWN1cnNpdmVseSBtYWtlIHRoZSBvcmlnaW5hbCByZXF1ZXN0LlxuICAgICAgICB0aGlzLl9nZXRBY3RpdmVXYWxsZXQoKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgZWxzZSAgICAgcmV0dXJuIHRoaXMuYWRkUGVybWlzc2lvblYwKG9wdHMsIGNiKTtcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbm90aGVyIGVycm9yIGNhdWdodCwgcmV0dXJuIGl0XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29ycmVjdCB3YWxsZXQgYW5kIG5vIGVycm9ycyAtLSBoYW5kbGUgdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLl9oYW5kbGVFbmNSZXNwb25zZShyZXMsIGRlY1Jlc0xlbmd0aHMuZW1wdHkpO1xuICAgICAgICBpZiAoZC5lcnIpXG4gICAgICAgICAgcmV0dXJuIGNiKGQuZXJyKTtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBnZXRLdlJlY29yZHMob3B0cywgY2IpIHtcbiAgICBjb25zdCB7IHR5cGUgPSAwLCBuID0gMSwgc3RhcnQgPSAwIH0gPSBvcHRzO1xuICAgIGNvbnN0IGZ3Q29uc3RhbnRzID0gZ2V0RndWZXJzaW9uQ29uc3QodGhpcy5md1ZlcnNpb24pO1xuICAgIGlmICghZndDb25zdGFudHMua3ZBY3Rpb25zQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNiKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICB9IGVsc2UgaWYgKG4gPCAxKSB7XG4gICAgICByZXR1cm4gY2IoJ1lvdSBtdXN0IHJlcXVlc3QgYXQgbGVhc3Qgb25lIHJlY29yZC4nKTtcbiAgICB9IGVsc2UgaWYgKG4gPiBmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bSkge1xuICAgICAgcmV0dXJuIGNiKGBZb3UgbWF5IG9ubHkgcmVxdWVzdCB1cCB0byAke2Z3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtfSByZWNvcmRzIGF0IG9uY2UuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoOSk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUpO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChuLCA0KTtcbiAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoc3RhcnQsIDUpO1xuICAgIC8vIEVuY3J5cHQgdGhlIHJlcXVlc3QgYW5kIHNlbmQgaXQgdG8gdGhlIExhdHRpY2UuXG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLl9idWlsZEVuY1JlcXVlc3QoZW5jUmVxQ29kZXMuR0VUX0tWX1JFQ09SRFMsIHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHBhcmFtLCAoZXJyLCByZXMsIHJlc3BvbnNlQ29kZSkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlQ29kZSA9PT0gcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9XQUxMRVRfTk9UX1BSRVNFTlQpIHtcbiAgICAgICAgLy8gSWYgd2UgY2F0Y2ggYSBjYXNlIHdoZXJlIHRoZSB3YWxsZXQgaGFzIGNoYW5nZWQsIHRyeSBnZXR0aW5nIHRoZSBuZXcgYWN0aXZlIHdhbGxldFxuICAgICAgICAvLyBhbmQgcmVjdXJzaXZlbHkgbWFrZSB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgdGhpcy5fZ2V0QWN0aXZlV2FsbGV0KChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIGVsc2UgICAgIHJldHVybiB0aGlzLmdldEt2UmVjb3JkcyhvcHRzLCBjYik7XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW5vdGhlciBlcnJvciBjYXVnaHQsIHJldHVybiBpdFxuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvcnJlY3Qgd2FsbGV0IGFuZCBubyBlcnJvcnMgLS0gaGFuZGxlIHRoZSByZXNwb25zZVxuICAgICAgICBjb25zdCBkID0gdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UocmVzLCBkZWNSZXNMZW5ndGhzLmdldEt2UmVjb3Jkcyk7XG4gICAgICAgIGlmIChkLmVycilcbiAgICAgICAgICByZXR1cm4gY2IoZC5lcnIpO1xuICAgICAgICAvLyBEZWNvZGUgdGhlIHJlc3BvbnNlXG4gICAgICAgIGxldCBvZmYgPSA2NTsgLy8gU2tpcCA2NSBieXRlIHB1YmtleSBwcmVmaXhcbiAgICAgICAgY29uc3QgblRvdGFsID0gcGFyc2VJbnQoZC5kYXRhLnNsaWNlKG9mZiwgb2ZmKzQpLnRvU3RyaW5nKCdoZXgnKSwgMTYpOyBvZmYgKz0gNDtcbiAgICAgICAgY29uc3QgbkZldGNoZWQgPSBwYXJzZUludChkLmRhdGEuc2xpY2Uob2ZmLCBvZmYrMSkudG9TdHJpbmcoJ2hleCcpLCAxNik7IG9mZiArPSAxO1xuICAgICAgICBpZiAobkZldGNoZWQgPiBmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bSlcbiAgICAgICAgICByZXR1cm4gY2IoJ1RvbyBtYW55IHJlY29yZHMgZmV0Y2hlZC4gRmlybXdhcmUgZXJyb3IuJyk7XG4gICAgICAgIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRmV0Y2hlZDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgciA9IHt9O1xuICAgICAgICAgIHIuaWQgPSBwYXJzZUludChkLmRhdGEuc2xpY2Uob2ZmLCBvZmYgKyA0KS50b1N0cmluZygnaGV4JyksIDE2KTsgb2ZmICs9IDQ7XG4gICAgICAgICAgci50eXBlID0gcGFyc2VJbnQoZC5kYXRhLnNsaWNlKG9mZiwgb2ZmICsgNCkudG9TdHJpbmcoJ2hleCcpLCAxNik7IG9mZiArPSA0O1xuICAgICAgICAgIHIuY2FzZVNlbnNpdGl2ZSA9IHBhcnNlSW50KGQuZGF0YS5zbGljZShvZmYsIG9mZiArIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpID09PSAxID8gdHJ1ZSA6IGZhbHNlOyBvZmYgKz0gMTtcbiAgICAgICAgICBjb25zdCBrZXlTeiA9IHBhcnNlSW50KGQuZGF0YS5zbGljZShvZmYsIG9mZiArIDEpLnRvU3RyaW5nKCdoZXgnKSwgMTYpOyBvZmYgKz0gMTtcbiAgICAgICAgICByLmtleSA9IGQuZGF0YS5zbGljZShvZmYsIG9mZiArIGtleVN6LTEpLnRvU3RyaW5nKCk7IG9mZiArPSAoZndDb25zdGFudHMua3ZLZXlNYXhTdHJTeiArIDEpO1xuICAgICAgICAgIGNvbnN0IHZhbFN6ID0gcGFyc2VJbnQoZC5kYXRhLnNsaWNlKG9mZiwgb2ZmICsgMSkudG9TdHJpbmcoJ2hleCcpLCAxNik7IG9mZiArPSAxO1xuICAgICAgICAgIHIudmFsID0gZC5kYXRhLnNsaWNlKG9mZiwgb2ZmICsgdmFsU3otMSkudG9TdHJpbmcoKTsgb2ZmICs9IChmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6ICsgMSk7XG4gICAgICAgICAgcmVjb3Jkcy5wdXNoKHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYihudWxsLCB7IHJlY29yZHMsIHRvdGFsOiBuVG90YWwsIGZldGNoZWQ6IG5GZXRjaGVkIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhZGRLdlJlY29yZHMob3B0cywgY2IpIHtcbiAgICBjb25zdCB7IHR5cGUgPSAwLCByZWNvcmRzID0ge30sIGNhc2VTZW5zaXRpdmU9ZmFsc2UgfSA9IG9wdHM7XG4gICAgY29uc3QgZndDb25zdGFudHMgPSBnZXRGd1ZlcnNpb25Db25zdCh0aGlzLmZ3VmVyc2lvbik7XG4gICAgaWYgKCFmd0NvbnN0YW50cy5rdkFjdGlvbnNBbGxvd2VkKSB7XG4gICAgICByZXR1cm4gY2IoJ1Vuc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIGZpcm13YXJlLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlY29yZHMgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKHJlY29yZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNiKCdPbmUgb3IgbW9yZSBrZXktdmFsdWUgbWFwcGluZyBtdXN0IGJlIHByb3ZpZGVkIGluIGByZWNvcmRzYCBwYXJhbS4nKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHJlY29yZHMpLmxlbmd0aCA+IGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKSB7XG4gICAgICByZXR1cm4gY2IoYFRvbyBtYW55IGtleXMgcHJvdmlkZWQuIFBsZWFzZSBvbmx5IHByb3ZpZGUgdXAgdG8gJHtmd0NvbnN0YW50cy5rdkFjdGlvbk1heE51bX0uYCk7XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhyZWNvcmRzKS5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gY2IoJ1lvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIGtleSB0byBhZGQuJylcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYygxICsgKDEzOSAqIGZ3Q29uc3RhbnRzLmt2QWN0aW9uTWF4TnVtKSk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KE9iamVjdC5rZXlzKHJlY29yZHMpLmxlbmd0aCk7XG4gICAgbGV0IG9mZiA9IDE7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5rZXlzKHJlY29yZHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgU3RyaW5nKGtleSkubGVuZ3RoID4gZndDb25zdGFudHMua3ZLZXlNYXhTdHJTeikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7a2V5fSB0b28gbGFyZ2UuIE11c3QgYmUgPD0ke2Z3Q29uc3RhbnRzLmt2S2V5TWF4U3RyU3p9IGNoYXJhY3RlcnMuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlY29yZHNba2V5XSAhPT0gJ3N0cmluZycgfHwgU3RyaW5nKHJlY29yZHNba2V5XSkubGVuZ3RoID4gZndDb25zdGFudHMua3ZWYWxNYXhTdHJTeikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHtyZWNvcmRzW2tleV19IHRvbyBsYXJnZS4gTXVzdCBiZSA8JD17ZndDb25zdGFudHMua3ZWYWxNYXhTdHJTen0gY2hhcmFjdGVycy5gKTtcbiAgICAgICAgfSBlbHNlIGlmIChTdHJpbmcoa2V5KS5sZW5ndGggPT09IDAgfHwgU3RyaW5nKHJlY29yZHNba2V5XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzIGFuZCB2YWx1ZXMgbXVzdCBiZSA+MCBjaGFyYWN0ZXJzLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBU0NJSV9SRUdFWC50ZXN0KGtleSkgfHwgIUFTQ0lJX1JFR0VYLnRlc3QocmVjb3Jkc1trZXldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgdGhlIElEIHBvcnRpb24uIFRoaXMgd2lsbCBnZXQgYWRkZWQgYnkgZmlybXdhcmUuXG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSgwLCBvZmYpOyBvZmYgKz0gNDtcbiAgICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHR5cGUsIG9mZik7IG9mZiArPSA0O1xuICAgICAgICBwYXlsb2FkLndyaXRlVUludDgoY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSwgb2ZmKTsgb2ZmICs9IDE7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50OChTdHJpbmcoa2V5KS5sZW5ndGggKyAxLCBvZmYpOyBvZmYgKz0gMTtcbiAgICAgICAgQnVmZmVyLmZyb20oU3RyaW5nKGtleSkpLmNvcHkocGF5bG9hZCwgb2ZmKTsgb2ZmICs9IChmd0NvbnN0YW50cy5rdktleU1heFN0clN6ICsgMSk7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50OChTdHJpbmcocmVjb3Jkc1trZXldKS5sZW5ndGggKyAxLCBvZmYpOyBvZmYgKz0gMTtcbiAgICAgICAgQnVmZmVyLmZyb20oU3RyaW5nKHJlY29yZHNba2V5XSkpLmNvcHkocGF5bG9hZCwgb2ZmKTsgb2ZmICs9IChmd0NvbnN0YW50cy5rdlZhbE1heFN0clN6ICsgMSk7XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGBFcnJvciBidWlsZGluZyByZXF1ZXN0OiAke2Vyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICAvLyBFbmNyeXB0IHRoZSByZXF1ZXN0IGFuZCBzZW5kIGl0IHRvIHRoZSBMYXR0aWNlLlxuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fYnVpbGRFbmNSZXF1ZXN0KGVuY1JlcUNvZGVzLkFERF9LVl9SRUNPUkRTLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChwYXJhbSwgKGVyciwgcmVzLCByZXNwb25zZUNvZGUpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZUNvZGUgPT09IHJlc3BvbnNlQ29kZXMuUkVTUF9FUlJfV0FMTEVUX05PVF9QUkVTRU5UKSB7XG4gICAgICAgIC8vIElmIHdlIGNhdGNoIGEgY2FzZSB3aGVyZSB0aGUgd2FsbGV0IGhhcyBjaGFuZ2VkLCB0cnkgZ2V0dGluZyB0aGUgbmV3IGFjdGl2ZSB3YWxsZXRcbiAgICAgICAgLy8gYW5kIHJlY3Vyc2l2ZWx5IG1ha2UgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICAgIHRoaXMuX2dldEFjdGl2ZVdhbGxldCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICBlbHNlICAgICByZXR1cm4gdGhpcy5hZGRLdlJlY29yZHMob3B0cywgY2IpO1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFub3RoZXIgZXJyb3IgY2F1Z2h0LCByZXR1cm4gaXRcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb3JyZWN0IHdhbGxldCBhbmQgbm8gZXJyb3JzIC0tIGhhbmRsZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKHJlcywgZGVjUmVzTGVuZ3Rocy5lbXB0eSk7XG4gICAgICAgIGlmIChkLmVycilcbiAgICAgICAgICByZXR1cm4gY2IoZC5lcnIpO1xuICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJlbW92ZUt2UmVjb3JkcyhvcHRzLCBjYikge1xuICAgIGNvbnN0IHsgdHlwZSA9IDAsIGlkcyA9IFtdIH0gPSBvcHRzO1xuICAgIGNvbnN0IGZ3Q29uc3RhbnRzID0gZ2V0RndWZXJzaW9uQ29uc3QodGhpcy5md1ZlcnNpb24pO1xuICAgIGlmICghZndDb25zdGFudHMua3ZBY3Rpb25zQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNiKCdVbnN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSBmaXJtd2FyZS4nKTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGlkcykgfHwgaWRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBjYignWW91IG11c3QgaW5jbHVkZSBvbmUgb3IgbW9yZSBgaWRzYCB0byByZW1vdmVkLicpXG4gICAgfSBlbHNlIGlmIChpZHMubGVuZ3RoID4gZndDb25zdGFudHMua3ZSZW1vdmVNYXhOdW0pIHtcbiAgICAgIHJldHVybiBjYihgT25seSB1cCB0byAke2Z3Q29uc3RhbnRzLmt2UmVtb3ZlTWF4TnVtfSByZWNvcmRzIG1heSBiZSByZW1vdmVkIGF0IG9uY2UuYClcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyg1ICsgKDQgKiBmd0NvbnN0YW50cy5rdlJlbW92ZU1heE51bSkpO1xuICAgIHBheWxvYWQud3JpdGVVSW50MzJMRSh0eXBlKTtcbiAgICBwYXlsb2FkLndyaXRlVUludDgoaWRzLmxlbmd0aCwgNCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShpZHNbaV0sIDUgKyAoNCAqIGkpKVxuICAgIH1cbiAgICAvLyBFbmNyeXB0IHRoZSByZXF1ZXN0IGFuZCBzZW5kIGl0IHRvIHRoZSBMYXR0aWNlLlxuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fYnVpbGRFbmNSZXF1ZXN0KGVuY1JlcUNvZGVzLlJFTU9WRV9LVl9SRUNPUkRTLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChwYXJhbSwgKGVyciwgcmVzLCByZXNwb25zZUNvZGUpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZUNvZGUgPT09IHJlc3BvbnNlQ29kZXMuUkVTUF9FUlJfV0FMTEVUX05PVF9QUkVTRU5UKSB7XG4gICAgICAgIC8vIElmIHdlIGNhdGNoIGEgY2FzZSB3aGVyZSB0aGUgd2FsbGV0IGhhcyBjaGFuZ2VkLCB0cnkgZ2V0dGluZyB0aGUgbmV3IGFjdGl2ZSB3YWxsZXRcbiAgICAgICAgLy8gYW5kIHJlY3Vyc2l2ZWx5IG1ha2UgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICAgIHRoaXMuX2dldEFjdGl2ZVdhbGxldCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICBlbHNlICAgICByZXR1cm4gdGhpcy5yZW1vdmVLdlJlY29yZHMob3B0cywgY2IpO1xuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFub3RoZXIgZXJyb3IgY2F1Z2h0LCByZXR1cm4gaXRcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb3JyZWN0IHdhbGxldCBhbmQgbm8gZXJyb3JzIC0tIGhhbmRsZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuX2hhbmRsZUVuY1Jlc3BvbnNlKHJlcywgZGVjUmVzTGVuZ3Rocy5lbXB0eSk7XG4gICAgICAgIGlmIChkLmVycilcbiAgICAgICAgICByZXR1cm4gY2IoZC5lcnIpO1xuICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSU5URVJOQUwgRlVOQ1RJT05TXG4gIC8vIFRoZXNlIGhhbmRsZSB0aGUgbG9naWMgYXJvdW5kIGJ1aWxkaW5nIHJlcXVlc3RzIGFuZCBjb25zdW1pbmdcbiAgLy8gcmVzcG9uc2VzLiBUaGV5IHRha2UgaW50byBhY2NvdW50IHRoZSBMYXR0aWNlJ3Mgc2VyaWFsaXphdGlvbiBzY2hlbWVcbiAgLy8gYW1vbmcgb3RoZXIgcHJvdG9jb2xzLlxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gR2V0IHRoZSBhY3RpdmUgd2FsbGV0IGluIHRoZSBkZXZpY2UuIElmIHdlIGFscmVhZHkgaGF2ZSBvbmUgcmVjb3JkZWQsXG4gIC8vIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgLy8gcmV0dXJucyBjYihlcnIpIC0tIGVyciBpcyBhIHN0cmluZ1xuICBfZ2V0QWN0aXZlV2FsbGV0KGNiLCBmb3JjZVJlZnJlc2g9ZmFsc2UpIHtcbiAgICBpZiAoZm9yY2VSZWZyZXNoICE9PSB0cnVlICYmICh0aGlzLmhhc0FjdGl2ZVdhbGxldCgpID09PSB0cnVlIHx8IHRoaXMuaXNQYWlyZWQgIT09IHRydWUpKSB7XG4gICAgICAvLyBJZiB0aGUgYWN0aXZlIHdhbGxldCBhbHJlYWR5IGV4aXN0cywgb3IgaWYgd2UgYXJlIG5vdCBwYWlyZWQsIHNraXAgdGhlIHJlcXVlc3RcbiAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gYWN0aXZlIHdhbGxldD8gR2V0IGl0IGZyb20gdGhlIGRldmljZVxuICAgICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fYnVpbGRFbmNSZXF1ZXN0KGVuY1JlcUNvZGVzLkdFVF9XQUxMRVRTLCBwYXlsb2FkKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KHBhcmFtLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0QWN0aXZlV2FsbGV0cygpO1xuICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYih0aGlzLl9oYW5kbGVHZXRXYWxsZXRzKHJlcykpO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgdGhlIHNoYXJlZCBzZWNyZXQsIGRlcml2ZWQgdmlhIEVDREggZnJvbSB0aGUgbG9jYWwgcHJpdmF0ZSBrZXlcbiAgLy8gYW5kIHRoZSBlcGhlbWVyYWwgcHVibGljIGtleVxuICAvLyBAcmV0dXJucyBCdWZmZXJcbiAgX2dldFNoYXJlZFNlY3JldCgpIHtcbiAgICAvLyBPbmNlIGV2ZXJ5IH4yNTYgYXR0ZW1wdHMsIHdlIHdpbGwgZ2V0IGEga2V5IHRoYXQgc3RhcnRzIHdpdGggYSBgMDBgIGJ5dGUsIHdoaWNoXG4gICAgLy8gY2FuIGxlYWQgdG8gcHJvYmxlbXMgaW5pdGlhbGl6aW5nIEFFUyBpZiB3ZSBkb24ndCBmb3JjZSBhIDMyIGJ5dGUgQkUgYnVmZmVyLlxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmtleS5kZXJpdmUodGhpcy5lcGhlbWVyYWxQdWIuZ2V0UHVibGljKCkpLnRvQXJyYXkoJ2JlJywgMzIpKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZXBoZW1lcmFsIGlkLCB3aGljaCBpcyB0aGUgZmlyc3QgNCBieXRlcyBvZiB0aGUgc2hhcmVkIHNlY3JldFxuICAvLyBnZW5lcmF0ZWQgZnJvbSB0aGUgbG9jYWwgcHJpdmF0ZSBrZXkgYW5kIHRoZSBlcGhlbWVyYWwgcHVibGljIGtleSBmcm9tXG4gIC8vIHRoZSBkZXZpY2UuXG4gIC8vIEByZXR1cm5zIEJ1ZmZlclxuICBfZ2V0RXBoZW1JZCgpIHtcbiAgICBpZiAodGhpcy5lcGhlbWVyYWxQdWIgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIC8vIEVwaGVtSWQgaXMgdGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIGhhc2ggb2YgdGhlIHNoYXJlZCBzZWNyZXRcbiAgICBjb25zdCBzZWNyZXQgPSB0aGlzLl9nZXRTaGFyZWRTZWNyZXQoKTtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5jcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHNlY3JldCkuZGlnZXN0KCk7XG4gICAgcmV0dXJuIGhhc2guc2xpY2UoMCwgNCk7XG4gIH1cblxuICBfYnVpbGRFbmNSZXF1ZXN0KGVuY19yZXF1ZXN0X2NvZGUsIHBheWxvYWQpIHtcbiAgICAvLyBHZXQgdGhlIGVwaGVtZXJhbCBpZCAtIGFsbCBlbmNyeXB0ZWQgcmVxdWVzdHMgcmVxdWlyZSB0aGVyZSB0byBiZSBhblxuICAgIC8vIGVwZWhlbWVyYWwgcHVibGljIGtleSBpbiBvcmRlciB0byBzZW5kXG4gICAgY29uc3QgZXBoZW1JZCA9IHBhcnNlSW50KHRoaXMuX2dldEVwaGVtSWQoKS50b1N0cmluZygnaGV4JyksIDE2KVxuICAgIC8vIEJ1aWxkIHRoZSBwYXlsb2FkIGFuZCBjaGVja3N1bVxuICAgIGNvbnN0IHBheWxvYWRQcmVDcyA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFtlbmNfcmVxdWVzdF9jb2RlXSksIHBheWxvYWRdKTtcbiAgICBjb25zdCBjcyA9IGNoZWNrc3VtKHBheWxvYWRQcmVDcyk7XG4gICAgY29uc3QgcGF5bG9hZEJ1ZiA9IEJ1ZmZlci5hbGxvYyhwYXlsb2FkUHJlQ3MubGVuZ3RoICsgNCk7XG5cbiAgICAvLyBMYXR0aWNlIHZhbGlkYXRlcyBjaGVja3N1bXMgaW4gbGl0dGxlIGVuZGlhblxuICAgIHBheWxvYWRQcmVDcy5jb3B5KHBheWxvYWRCdWYsIDApO1xuICAgIHBheWxvYWRCdWYud3JpdGVVSW50MzJMRShjcywgcGF5bG9hZFByZUNzLmxlbmd0aCk7XG4gICAgLy8gRW5jcnlwdCB0aGlzIHBheWxvYWRcbiAgICBjb25zdCBzZWNyZXQgPSB0aGlzLl9nZXRTaGFyZWRTZWNyZXQoKTtcbiAgICBjb25zdCBuZXdFbmNQYXlsb2FkID0gYWVzMjU2X2VuY3J5cHQocGF5bG9hZEJ1Ziwgc2VjcmV0KTtcblxuICAgIC8vIFdyaXRlIHRvIHRoZSBvdmVyYWxsIHBheWxvYWQuIFdlIG11c3QgdXNlIHRoZSBzYW1lIGxlbmd0aFxuICAgIC8vIGZvciBldmVyeSBlbmNyeXB0ZWQgcmVxdWVzdCBhbmQgbXVzdCBpbmNsdWRlIGEgMzItYml0IGVwaGVtSWRcbiAgICAvLyBhbG9uZyB3aXRoIHRoZSBlbmNyeXB0ZWQgZGF0YVxuICAgIGNvbnN0IG5ld1BheWxvYWQgPSBCdWZmZXIuYWxsb2MoRU5DX01TR19MRU4gKyA0KTtcbiAgICAvLyBGaXJzdCA0IGJ5dGVzIGFyZSB0aGUgZXBoZW1lcmFsIGlkIChpbiBsaXR0bGUgZW5kaWFuKVxuICAgIG5ld1BheWxvYWQud3JpdGVVSW50MzJMRShlcGhlbUlkLCAwKTtcbiAgICAvLyBOZXh0IE4gYnl0ZXNcbiAgICBuZXdFbmNQYXlsb2FkLmNvcHkobmV3UGF5bG9hZCwgNCk7XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVxdWVzdChkZXZpY2VDb2Rlcy5FTkNSWVBURURfUkVRVUVTVCwgbmV3UGF5bG9hZCk7XG4gIFxuICB9XG5cbiAgLy8gQnVpbGQgYSByZXF1ZXN0IHRvIHNlbmQgdG8gdGhlIGRldmljZS5cbiAgLy8gQHBhcmFtIFtyZXF1ZXN0X2NvZGVdIHt1aW50OH0gIC0gOC1iaXQgdW5zaWduZWQgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG1lc3NhZ2UgcmVxdWVzdCBjb2RlXG4gIC8vIEBwYXJhbSBbaWRdIHtidWZmZXJ9IC0gNCBieXRlIGlkZW50aWZpZXIgKGNvbWVzIGZyb20gSFNNIGZvciBzdWJzZXF1ZW50IGVuY3J5cHRlZCByZXFzKVxuICAvLyBAcGFyYW0gW3BheWxvYWRdIHtidWZmZXJ9IC0gc2VyaWFsaXplZCBwYXlsb2FkXG4gIC8vIEByZXR1cm5zIHtidWZmZXJ9XG4gIF9idWlsZFJlcXVlc3QocmVxdWVzdF9jb2RlLCBwYXlsb2FkKSB7XG4gICAgLy8gTGVuZ3RoIG9mIHBheWxvYWQ7XG4gICAgLy8gd2UgYWRkIDEgdG8gdGhlIHBheWxvYWQgbGVuZ3RoIHRvIGFjY291bnQgZm9yIHRoZSByZXF1ZXN0X2NvZGUgYnl0ZVxuICAgIGxldCBMID0gcGF5bG9hZCAmJiBCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkgPyBwYXlsb2FkLmxlbmd0aCArIDEgOiAxO1xuICAgIGlmIChyZXF1ZXN0X2NvZGUgPT09IGRldmljZUNvZGVzLkVOQ1JZUFRFRF9SRVFVRVNUKSB7XG4gICAgICBMID0gMSArIHBheWxvYWQubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgcHJlUmVxID0gQnVmZmVyLmFsbG9jKEwgKyA4KTtcbiAgICAvLyBCdWlsZCB0aGUgaGVhZGVyXG4gICAgaSA9IHByZVJlcS53cml0ZVVJbnQ4KFZFUlNJT05fQllURSwgaSk7XG4gICAgaSA9IHByZVJlcS53cml0ZVVJbnQ4KFJFUVVFU1RfVFlQRV9CWVRFLCBpKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDQpO1xuICAgIGkgPSBwcmVSZXEud3JpdGVVSW50MzJCRShwYXJzZUludChgMHgke2lkLnRvU3RyaW5nKCdoZXgnKX1gKSwgaSk7XG4gICAgaSA9IHByZVJlcS53cml0ZVVJbnQxNkJFKEwsIGkpO1xuICAgIC8vIEJ1aWxkIHRoZSBwYXlsb2FkXG4gICAgaSA9IHByZVJlcS53cml0ZVVJbnQ4KHJlcXVlc3RfY29kZSwgaSk7XG4gICAgaWYgKEwgPiAxKSBpID0gcGF5bG9hZC5jb3B5KHByZVJlcSwgaSk7XG4gICAgLy8gQWRkIHRoZSBjaGVja3N1bVxuICAgIGNvbnN0IGNzID0gY2hlY2tzdW0ocHJlUmVxKTtcbiAgICBjb25zdCByZXEgPSBCdWZmZXIuYWxsb2MocHJlUmVxLmxlbmd0aCArIDQpOyAvLyA0LWJ5dGUgY2hlY2tzdW1cbiAgICBpID0gcHJlUmVxLmNvcHkocmVxKTtcbiAgICByZXEud3JpdGVVSW50MzJCRShjcywgaSk7XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuXG4gIF9yZXF1ZXN0KGRhdGEsIGNiLCByZXRyeUNvdW50PXRoaXMucmV0cnlDb3VudCkge1xuICAgIGlmICghdGhpcy5kZXZpY2VJZCkgcmV0dXJuIGNiKCdTZXJpYWwgaXMgbm90IHNldC4gUGxlYXNlIHNldCBpdCBhbmQgdHJ5IGFnYWluLicpO1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vJHt0aGlzLmRldmljZUlkfWA7XG4gICAgc3VwZXJhZ2VudC5wb3N0KHVybCkudGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgLnNlbmQoe2RhdGF9KVxuICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICBpZiAoIXJlcyB8fCAhcmVzLmJvZHkpIHJldHVybiBjYihgSW52YWxpZCByZXNwb25zZTogJHtyZXN9YClcbiAgICAgIGVsc2UgaWYgKHJlcy5ib2R5LnN0YXR1cyAhPT0gMjAwKSByZXR1cm4gY2IoYEVycm9yIGNvZGUgJHtyZXMuYm9keS5zdGF0dXN9OiAke3Jlcy5ib2R5Lm1lc3NhZ2V9YClcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTGF0dGljZTFSZXNwb25zZShyZXMuYm9keS5tZXNzYWdlKTtcbiAgICAgIC8vIElmIHRoZSBkZXZpY2UgaXMgYnVzeSwgcmV0cnkgaWYgd2UgY2FuXG4gICAgICBpZiAoKCBwYXJzZWQucmVzcG9uc2VDb2RlID09PSByZXNwb25zZUNvZGVzLlJFU1BfRVJSX0RFVl9CVVNZIHx8XG4gICAgICAgICAgICBwYXJzZWQucmVzcG9uc2VDb2RlID09PSByZXNwb25zZUNvZGVzLlJFU1BfRVJSX0dDRV9USU1FT1VUICkgXG4gICAgICAgICAgICAmJiAocmV0cnlDb3VudCA+IDApKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5fcmVxdWVzdChkYXRhLCBjYiwgcmV0cnlDb3VudC0xKSB9LCAzMDAwKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGNhdWdoIGEgYEVycldhbGxldE5vdFByZXNlbnRgIG1ha2Ugc3VyZSB3ZSBhcmVuJ3QgY2FjaGluZyBhbiBvbGQgYXRpdmUgd2FsbGV0VUlEXG4gICAgICBpZiAocGFyc2VkLnJlc3BvbnNlQ29kZSA9PT0gcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9XQUxMRVRfTk9UX1BSRVNFTlQpIFxuICAgICAgICB0aGlzLl9yZXNldEFjdGl2ZVdhbGxldHMoKTtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciBpbiB0aGUgcmVzcG9uc2UsIHJldHVybiBpdFxuICAgICAgaWYgKHBhcnNlZC5lcnIpIFxuICAgICAgICByZXR1cm4gY2IocGFyc2VkLmVycik7XG4gICAgICByZXR1cm4gY2IobnVsbCwgcGFyc2VkLmRhdGEsIHBhcnNlZC5yZXNwb25zZUNvZGUpOyBcbiAgICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zdCBpc1RpbWVvdXQgPSBlcnIuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcgJiYgZXJyLmVycm5vID09PSAnRVRJTUUnO1xuICAgICAgaWYgKGlzVGltZW91dClcbiAgICAgICAgcmV0dXJuIGNiKCdUaW1lb3V0IHdhaXRpbmcgZm9yIGRldmljZS4gUGxlYXNlIGVuc3VyZSBpdCBpcyBjb25uZWN0ZWQgdG8gdGhlIGludGVybmV0IGFuZCB0cnkgYWdhaW4gaW4gYSBtaW51dGUuJylcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNiKCdGYWlsZWQgdG8gbWFrZSByZXF1ZXN0IHRvIGRldmljZS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIC0tLS0tIERldmljZSByZXNwb25zZSBoYW5kbGVycyAtLS0tLVxuXG4gIC8vIENvbm5lY3Qgd2lsbCBjYWxsIGBTdGFydFBhaXJpbmdNb2RlYCBvbiB0aGUgZGV2aWNlLCB3aGljaCBnaXZlcyB0aGVcbiAgLy8gdXNlciA2MCBzZWNvbmRzIHRvIGZpbmFsaXplIHRoZSBwYWlyaW5nXG4gIC8vIFRoaXMgd2lsbCByZXR1cm4gYW4gZXBoZW1lcmFsIHB1YmxpYyBrZXksIHdoaWNoIGlzIG5lZWRlZCBmb3IgdGhlIG5leHRcbiAgLy8gcmVxdWVzdC4gSWYgdGhlIGRldmljZSBpcyBhbHJlYWR5IHBhaXJlZCwgdGhpcyBlcGhlbVB1YiBpcyBzaW1wbHkgdXNlZFxuICAvLyB0byBlbmNyeXB0IHRoZSBuZXh0IHJlcXVlc3QuIElmIHRoZSBkZXZpY2UgaXMgbm90IHBhaXJlZCwgaXQgaXMgbmVlZGVkXG4gIC8vIHRvIHBhaXIgdGhlIGRldmljZSB3aXRoaW4gNjAgc2Vjb25kcy5cbiAgLy8gQHJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcGFpcmVkIHRvIHRoZSBkZXZpY2UgYWxyZWFkeVxuICBfaGFuZGxlQ29ubmVjdChyZXMpIHtcbiAgICBsZXQgb2ZmID0gMDtcbiAgICBjb25zdCBwYWlyaW5nU3RhdHVzID0gcmVzLnJlYWRVSW50OChvZmYpOyBvZmYrKztcbiAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBwYWlyZWQsIHdlIGdldCB0aGUgbmV4dCBlcGhlbWVyYWwga2V5XG4gICAgY29uc3QgcHViID0gcmVzLnNsaWNlKG9mZiwgb2ZmICsgNjUpLnRvU3RyaW5nKCdoZXgnKTsgb2ZmICs9IDY1O1xuICAgIC8vIEdyYWIgdGhlIGZpcm13YXJlIHZlcnNpb24gKHdpbGwgYmUgMC1sZW5ndGggZm9yIG9sZGVyIGZ3IHZlcnNpb25zKVxuICAgIC8vIEl0IGlzIG9mIGZvcm1hdCB8Zml4fG1pbm9yfG1ham9yfHJlc2VydmVkfFxuICAgIHRoaXMuZndWZXJzaW9uID0gcmVzLnNsaWNlKG9mZiwgb2ZmICsgNCk7XG4gICAgLy8gU2V0IHRoZSBwdWJsaWMga2V5XG4gICAgdGhpcy5lcGhlbWVyYWxQdWIgPSBnZXRQMjU2S2V5UGFpckZyb21QdWIocHViKTtcbiAgICAvLyByZXR1cm4gdGhlIHN0YXRlIG9mIG91ciBwYWlyaW5nXG4gICAgcmV0dXJuIChwYWlyaW5nU3RhdHVzID09PSBtZXNzYWdlQ29uc3RhbnRzLlBBSVJFRCk7XG4gIH1cblxuICAvLyBBbGwgZW5jcnlwdGVkIHJlc3BvbnNlcyBtdXN0IGJlIGRlY3J5cHRlZCB3aXRoIHRoZSBwcmV2aW91cyBzaGFyZWQgc2VjcmV0LiBQZXIgc3BlY2lmaWNhdGlvbixcbiAgLy8gZGVjcnlwdGVkIHJlc3BvbnNlcyB3aWxsIGFsbCBjb250YWluIGEgNjUtYnl0ZSBwdWJsaWMga2V5IGFzIHRoZSBwcmVmaXgsIHdoaWNoIGJlY29tZXMgdGhlIFxuICAvLyBuZXcgZXBoZW1lcmFsUHViLlxuICBfaGFuZGxlRW5jUmVzcG9uc2UoZW5jUmVzLCBsZW4pIHtcbiAgICAvLyBEZWNyeXB0IHJlc3BvbnNlXG4gICAgY29uc3Qgc2VjcmV0ID0gdGhpcy5fZ2V0U2hhcmVkU2VjcmV0KCk7XG4gICAgY29uc3QgZW5jRGF0YSA9IGVuY1Jlcy5zbGljZSgwLCBFTkNfTVNHX0xFTik7XG4gICAgY29uc3QgcmVzID0gYWVzMjU2X2RlY3J5cHQoZW5jRGF0YSwgc2VjcmV0KTtcbiAgICAvLyBsZW4gZG9lcyBub3QgaW5jbHVkZSBhIDY1LWJ5dGUgcHVia2V5IHRoYXQgcHJlZmllcyBlYWNoIGVuY1Jlc3BvbnNlXG4gICAgbGVuICs9IDY1O1xuICAgIC8vIFZhbGlkYXRlIGNoZWNrc3VtLiBJdCB3aWxsIGJlIHRoZSBsYXN0IDQgYnl0ZXMgb2YgdGhlIGRlY3J5cHRlZCBwYXlsb2FkLlxuICAgIC8vIFRoZSBsZW5ndGggb2YgdGhlIGRlY3J5cHRlZCBwYXlsb2FkIHdpbGwgYmUgZml4ZWQgZm9yIGVhY2ggZ2l2ZW4gbWVzc2FnZSB0eXBlLlxuICAgIGNvbnN0IHRvQ2hlY2sgPSByZXMuc2xpY2UoMCwgbGVuKTtcbiAgICBjb25zdCBjcyA9IHBhcnNlSW50KGAweCR7cmVzLnNsaWNlKGxlbiwgbGVuKzQpLnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICBjb25zdCBjc0NoZWNrID0gY2hlY2tzdW0odG9DaGVjayk7XG4gICAgaWYgKGNzICE9PSBjc0NoZWNrKSByZXR1cm4geyBlcnI6IGBDaGVja3N1bSBtaXNtYXRjaCBpbiByZXNwb25zZSBmcm9tIExhdHRpY2UgKGNhbGN1bGF0ZWQgJHtjc0NoZWNrfSwgd2FudGVkICR7Y3N9KWAgfTtcblxuICAgIC8vIEZpcnN0IDY1IGJ5dGVzIGlzIHRoZSBuZXh0IGVwaGVtZXJhbCBwdWJrZXlcbiAgICBjb25zdCBwdWIgPSByZXMuc2xpY2UoMCwgNjUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lcGhlbWVyYWxQdWIgPSBnZXRQMjU2S2V5UGFpckZyb21QdWIocHViKTtcbiAgICAgIHJldHVybiB7IGVycjogbnVsbCwgZGF0YTogcmVzIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHsgZXJyOiBgRXJyb3IgaGFuZGxpbmcgZ2V0QWRkcmVzc2VzIHJlc3BvbnNlOiAke2UudG9TdHJpbmcoKX1gIH07XG4gICAgfVxuICB9XG5cbiAgLy8gUGFpciB3aWxsIGNyZWF0ZSBhIG5ldyBwYWlyaW5nIGlmIHRoZSB1c2VyIHN1Y2Nlc3NmdWxseSBlbnRlcnMgdGhlIHNlY3JldFxuICAvLyBpbnRvIHRoZSBkZXZpY2UgaW4gdGltZS4gSWYgc3VjY2Vzc2Z1bCAoc3RhdHVzPTApLCB0aGUgZGV2aWNlIHdpbGwgcmV0dXJuXG4gIC8vIGEgbmV3IGVwaGVtZXJhbCBwdWJsaWMga2V5LCB3aGljaCBpcyB1c2VkIHRvIGRlcml2ZSBhIHNoYXJlZCBzZWNyZXRcbiAgLy8gZm9yIHRoZSBuZXh0IHJlcXVlc3RcbiAgLy8gQHJldHVybnMgZXJyb3IgKG9yIG51bGwpXG4gIF9oYW5kbGVQYWlyKGVuY1Jlcykge1xuICAgIGNvbnN0IGQgPSB0aGlzLl9oYW5kbGVFbmNSZXNwb25zZShlbmNSZXMsIGRlY1Jlc0xlbmd0aHMuZW1wdHkpO1xuICAgIGlmIChkLmVycikgcmV0dXJuIGQuZXJyO1xuICAgIC8vIFJlbW92ZSB0aGUgcGFpcmluZyBzYWx0IC0gd2UncmUgcGFpcmVkIVxuICAgIHRoaXMucGFpcmluZ1NhbHQgPSBudWxsO1xuICAgIHRoaXMuaXNQYWlyZWQgPSB0cnVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gR2V0QWRkcmVzc2VzIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFkZHJlc3Mgc3RyaW5nc1xuICBfaGFuZGxlR2V0QWRkcmVzc2VzKGVuY1Jlcykge1xuICAgIC8vIEhhbmRsZSB0aGUgZW5jcnlwdGVkIHJlc3BvbnNlXG4gICAgY29uc3QgZGVjcnlwdGVkID0gdGhpcy5faGFuZGxlRW5jUmVzcG9uc2UoZW5jUmVzLCBkZWNSZXNMZW5ndGhzLmdldEFkZHJlc3Nlcyk7XG4gICAgaWYgKGRlY3J5cHRlZC5lcnIgIT09IG51bGwgKSByZXR1cm4gZGVjcnlwdGVkO1xuXG4gICAgY29uc3QgYWRkckRhdGEgPSBkZWNyeXB0ZWQuZGF0YTtcbiAgICBsZXQgb2ZmID0gNjU7IC8vIFNraXAgNjUgYnl0ZSBwdWJrZXkgcHJlZml4XG4gICAgLy8gTG9vayBmb3IgYWRkcmVzc2VzIHVudGlsIHdlIHJlYWNoIHRoZSBlbmQgKGEgNCBieXRlIGNoZWNrc3VtKVxuICAgIGNvbnN0IGFkZHJzID0gW107XG4gICAgd2hpbGUgKG9mZiArIDQgPCBkZWNSZXNMZW5ndGhzLmdldEFkZHJlc3Nlcykge1xuICAgICAgY29uc3QgYWRkckJ5dGVzID0gYWRkckRhdGEuc2xpY2Uob2ZmLCBvZmYrQUREUl9TVFJfTEVOKTsgb2ZmICs9IEFERFJfU1RSX0xFTjtcbiAgICAgIC8vIFJldHVybiB0aGUgVVRGLTggcmVwcmVzZW50YXRpb25cbiAgICAgIGNvbnN0IGxlbiA9IGFkZHJCeXRlcy5pbmRleE9mKDApOyAvLyBGaXJzdCAwIGlzIHRoZSBudWxsIHRlcm1pbmF0b3JcbiAgICAgIGlmIChsZW4gPiAwKVxuICAgICAgICBhZGRycy5wdXNoKGFkZHJCeXRlcy5zbGljZSgwLCBsZW4pLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBhZGRycywgZXJyOiBudWxsIH07XG4gIH1cblxuICBfaGFuZGxlR2V0V2FsbGV0cyhlbmNSZXMpIHtcbiAgICBjb25zdCBkZWNyeXB0ZWQgPSB0aGlzLl9oYW5kbGVFbmNSZXNwb25zZShlbmNSZXMsIGRlY1Jlc0xlbmd0aHMuZ2V0V2FsbGV0cyk7XG4gICAgaWYgKGRlY3J5cHRlZC5lcnIgIT09IG51bGwpIHJldHVybiBkZWNyeXB0ZWQ7XG4gICAgY29uc3QgcmVzID0gZGVjcnlwdGVkLmRhdGE7XG4gICAgbGV0IHdhbGxldFVJRDtcbiAgICAvLyBSZWFkIHRoZSBleHRlcm5hbCB3YWxsZXQgZGF0YSBmaXJzdC4gSWYgaXQgaXMgbm9uLW51bGwsIHRoZSBleHRlcm5hbCB3YWxsZXQgd2lsbFxuICAgIC8vIGJlIHRoZSBhY3RpdmUgd2FsbGV0IG9mIHRoZSBkZXZpY2UgYW5kIHdlIHNob3VsZCBzYXZlIGl0LlxuICAgIC8vIElmIHRoZSBleHRlcm5hbCB3YWxsZXQgaXMgYmxhbmssIGl0IG1lYW5zIHRoZXJlIGlzIG5vIGNhcmQgcHJlc2VudCBhbmQgd2Ugc2hvdWxkIFxuICAgIC8vIHNhdmUgYW5kIHVzZSB0aGUgaW50ZXJhbCB3YWxsZXQuXG4gICAgLy8gSWYgYm90aCB3YWxsZXRzIGFyZSBlbXB0eSwgaXQgbWVhbnMgdGhlIGRldmljZSBzdGlsbCBuZWVkcyB0byBiZSBzZXQgdXAuXG4gICAgY29uc3Qgd2FsbGV0RGVzY3JpcHRvckxlbiA9IDcxO1xuICAgIC8vIFNraXAgNjVieXRlIHB1YmtleSBwcmVmaXguIFdhbGxldERlc2NyaXB0b3IgY29udGFpbnMgMzJieXRlIGlkICsgNGJ5dGUgZmxhZyArIDM1Ynl0ZSBuYW1lXG4gICAgbGV0IG9mZiA9IDY1O1xuICAgIC8vIEludGVybmFsIGZpcnN0XG4gICAgbGV0IGhhc0FjdGl2ZVdhbGxldCA9IGZhbHNlO1xuICAgIHdhbGxldFVJRCA9IHJlcy5zbGljZShvZmYsIG9mZiszMik7XG4gICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLnVpZCA9IHdhbGxldFVJRDtcbiAgICB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwuY2FwYWJpbGl0aWVzID0gcmVzLnJlYWRVSW50MzJCRShvZmYrMzIpO1xuICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC5uYW1lID0gcmVzLnNsaWNlKG9mZiszNiwgb2ZmK3dhbGxldERlc2NyaXB0b3JMZW4pO1xuICAgIGlmICghd2FsbGV0VUlELmVxdWFscyhFTVBUWV9XQUxMRVRfVUlEKSlcbiAgICAgIGhhc0FjdGl2ZVdhbGxldCA9IHRydWU7XG5cbiAgICAvLyBPZmZzZXQgdGhlIGZpcnN0IGl0ZW1cbiAgICBvZmYgKz0gd2FsbGV0RGVzY3JpcHRvckxlbjtcbiAgICBcbiAgICAvLyBFeHRlcm5hbFxuICAgIHdhbGxldFVJRCA9IHJlcy5zbGljZShvZmYsIG9mZiszMik7XG4gICAgdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCA9IHdhbGxldFVJRDtcbiAgICB0aGlzLmFjdGl2ZVdhbGxldHMuZXh0ZXJuYWwuY2FwYWJpbGl0aWVzID0gcmVzLnJlYWRVSW50MzJCRShvZmYrMzIpO1xuICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5uYW1lID0gcmVzLnNsaWNlKG9mZiszNiwgb2ZmK3dhbGxldERlc2NyaXB0b3JMZW4pO1xuICAgIGlmICghd2FsbGV0VUlELmVxdWFscyhFTVBUWV9XQUxMRVRfVUlEKSlcbiAgICAgIGhhc0FjdGl2ZVdhbGxldCA9IHRydWU7XG4gICAgaWYgKGhhc0FjdGl2ZVdhbGxldCA9PT0gdHJ1ZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAnTm8gYWN0aXZlIHdhbGxldC4nO1xuICB9XG5cbiAgX2hhbmRsZVNpZ24oZW5jUmVzLCBjdXJyZW5jeVR5cGUsIHJlcT1udWxsKSB7XG4gICAgLy8gSGFuZGxlIHRoZSBlbmNyeXB0ZWQgcmVzcG9uc2VcbiAgICBjb25zdCBkZWNyeXB0ZWQgPSB0aGlzLl9oYW5kbGVFbmNSZXNwb25zZShlbmNSZXMsIGRlY1Jlc0xlbmd0aHMuc2lnbik7XG4gICAgaWYgKGRlY3J5cHRlZC5lcnIgIT09IG51bGwgKSByZXR1cm4geyBlcnI6IGRlY3J5cHRlZC5lcnIgfTtcbiAgICBjb25zdCBQVUJLRVlfUFJFRklYX0xFTiA9IDY1O1xuICAgIGNvbnN0IFBLSF9QUkVGSVhfTEVOID0gMjA7XG4gICAgbGV0IG9mZiA9IFBVQktFWV9QUkVGSVhfTEVOOyAvLyBTa2lwIHBhc3QgcHVia2V5IHByZWZpeFxuICAgIGNvbnN0IHJlcyA9IGRlY3J5cHRlZC5kYXRhO1xuXG4gICAgLy8gR2V0IHRoZSBjaGFuZ2UgZGF0YSBpZiB3ZSBhcmUgbWFraW5nIGEgQlRDIHRyYW5zYWN0aW9uXG4gICAgbGV0IGNoYW5nZVJlY2lwaWVudDtcbiAgICBpZiAoY3VycmVuY3lUeXBlID09PSAnQlRDJykge1xuICAgICAgY29uc3QgY2hhbmdlVmVyc2lvbiA9IGJpdGNvaW4uYWRkcmVzc1ZlcnNpb25bcmVxLmNoYW5nZURhdGEuY2hhbmdlVmVyc2lvbl07XG4gICAgICBjb25zdCBjaGFuZ2VQdWJrZXloYXNoID0gcmVzLnNsaWNlKG9mZiwgb2ZmICsgUEtIX1BSRUZJWF9MRU4pOyBvZmYgKz0gUEtIX1BSRUZJWF9MRU47XG4gICAgICBjaGFuZ2VSZWNpcGllbnQgPSBiaXRjb2luLmdldEJpdGNvaW5BZGRyZXNzKGNoYW5nZVB1YmtleWhhc2gsIGNoYW5nZVZlcnNpb24pO1xuICAgIH1cbiAgICAvLyBTdGFydCBidWlsZGluZyByZXR1cm4gZGF0YVxuICAgIGNvbnN0IHJldHVybkRhdGEgPSB7IGVycjogbnVsbCwgZGF0YTogbnVsbCB9O1xuICAgIGNvbnN0IERFUkxlbmd0aCA9IDc0OyAvLyBtYXggc2l6ZSBvZiBhIERFUiBzaWduYXR1cmUgLS0gYWxsIExhdHRpY2Ugc2lncyBhcmUgdGhpcyBsb25nXG4gICAgY29uc3QgU0lHU19PRkZTRVQgPSAxMCAqIERFUkxlbmd0aDsgLy8gMTAgc2lnbmF0dXJlIHNsb3RzIHByZWNlZGUgMTAgcHVia2V5IHNsb3RzXG4gICAgY29uc3QgUFVCS0VZU19PRkZTRVQgPSBQVUJLRVlfUFJFRklYX0xFTiArIFBLSF9QUkVGSVhfTEVOICsgU0lHU19PRkZTRVQ7XG4gICAgXG4gICAgaWYgKGN1cnJlbmN5VHlwZSA9PT0gJ0JUQycpIHtcbiAgICAgIGNvbnN0IGNvbXByZXNzZWRQdWJMZW5ndGggPSAzMzsgIC8vIFNpemUgb2YgY29tcHJlc3NlZCBwdWJsaWMga2V5XG4gICAgICBjb25zdCBwdWJrZXlzID0gW107XG4gICAgICBjb25zdCBzaWdzID0gW107XG4gICAgICBsZXQgbiA9IDA7XG4gICAgICAvLyBQYXJzZSB0aGUgc2lnbmF0dXJlIGZvciBlYWNoIG91dHB1dCAtLSB0aGV5IGFyZSByZXR1cm5lZFxuICAgICAgLy8gaW4gdGhlIHNlcmlhbGl6ZWQgcGF5bG9hZCBpbiBmb3JtIFtwdWJrZXksIHNpZ11cbiAgICAgIC8vIFRoZXJlIGlzIG9uZSBzaWduYXR1cmUgcGVyIG91dHB1dFxuICAgICAgd2hpbGUgKG9mZiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRXhpdCBvdXQgaWYgd2UgaGF2ZSBzZWVuIGFsbCB0aGUgcmV0dXJuZWQgc2lncyBhbmQgcHVia2V5c1xuICAgICAgICBpZiAocmVzW29mZl0gIT09IDB4MzApIGJyZWFrO1xuICAgICAgICAvLyBPdGhlcndpc2UgZ3JhYiBhbm90aGVyIHNldFxuICAgICAgICAvLyBOb3RlIHRoYXQgYWxsIERFUiBzaWdzIHJldHVybmVkIGZpbGwgdGhlIG1heGltdW0gNzQgYnl0ZSBidWZmZXIsIGJ1dCBhbHNvXG4gICAgICAgIC8vIGNvbnRhaW4gYSBsZW5ndGggYXQgb2ZmKzEsIHdoaWNoIHdlIHVzZSB0byBwYXJzZSB0aGUgbm9uLXplcm8gZGF0YS5cbiAgICAgICAgLy8gRmlyc3QgZ2V0IHRoZSBzaWduYXR1cmUgZnJvbSBpdHMgc2xvdFxuICAgICAgICBjb25zdCBzaWdTdGFydCA9IG9mZjtcbiAgICAgICAgY29uc3Qgc2lnRW5kID0gb2ZmICsgMiArIHJlc1tvZmYgKyAxXTtcbiAgICAgICAgc2lncy5wdXNoKHJlcy5zbGljZShzaWdTdGFydCwgc2lnRW5kKSk7XG4gICAgICAgIC8vIE5leHQsIHNoaWZ0IGJ5IHRoZSBmdWxsIHNldCBvZiBzaWduYXR1cmVzIHRvIGhpdCB0aGUgcmVzcGVjdGl2ZSBwdWJrZXlcbiAgICAgICAgLy8gTk9URTogVGhlIGRhdGEgcmV0dXJuZWQgaXM6IFs8c2lnMD4sIDxzaWcxPiwgLi4uIDxzaWc5Pl1bPHB1YmtleTA+LCA8cHVia2V5MT4sIC4uLiA8cHVia2V5OT5dXG4gICAgICAgIGNvbnN0IHB1YlN0YXJ0ID0gKG4gKiBjb21wcmVzc2VkUHViTGVuZ3RoKSArIFBVQktFWVNfT0ZGU0VUO1xuICAgICAgICBjb25zdCBwdWJFbmQgPSAoKG4rMSkgKiBjb21wcmVzc2VkUHViTGVuZ3RoKSArIFBVQktFWVNfT0ZGU0VUO1xuICAgICAgICBwdWJrZXlzLnB1c2gocmVzLnNsaWNlKHB1YlN0YXJ0LCBwdWJFbmQpKTtcbiAgICAgICAgLy8gVXBkYXRlIG9mZnNldCB0byBoaXQgdGhlIG5leHQgc2lnbmF0dXJlIHNsb3RcbiAgICAgICAgb2ZmICs9IERFUkxlbmd0aDtcbiAgICAgICAgbiArPSAxO1xuICAgICAgfVxuICAgICAgLy8gQnVpbGQgdGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgY29uc3QgcHJlU2VyaWFsaXplZERhdGEgPSB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzcGVuZGVyU2NyaXB0VHlwZTogcmVxLnNwZW5kZXJTY3JpcHRUeXBlLFxuICAgICAgICBuZXR3b3JrOiByZXEub3JpZ0RhdGEubmV0d29yayxcbiAgICAgICAgY3J5cHRvOiB0aGlzLmNyeXB0byxcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpcnN0IG91dHB1dCBjb21lcyBmcm9tIHJlcXVlc3QgZHRhXG4gICAgICBwcmVTZXJpYWxpemVkRGF0YS5vdXRwdXRzLnB1c2goe1xuICAgICAgICB2YWx1ZTogcmVxLm9yaWdEYXRhLnZhbHVlLFxuICAgICAgICByZWNpcGllbnQ6IHJlcS5vcmlnRGF0YS5yZWNpcGllbnQsXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXEuY2hhbmdlRGF0YS52YWx1ZSA+IDApIHtcbiAgICAgICAgLy8gU2Vjb25kIG91dHB1dCBjb21lcyBmcm9tIGNoYW5nZSBkYXRhXG4gICAgICAgIHByZVNlcmlhbGl6ZWREYXRhLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IHJlcS5jaGFuZ2VEYXRhLnZhbHVlLFxuICAgICAgICAgIHJlY2lwaWVudDogY2hhbmdlUmVjaXBpZW50LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIHRoZSBpbnB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVTZXJpYWxpemVkRGF0YS5pbnB1dHMucHVzaCh7XG4gICAgICAgICAgaGFzaDogcmVxLm9yaWdEYXRhLnByZXZPdXRzW2ldLnR4SGFzaCxcbiAgICAgICAgICBpbmRleDogcmVxLm9yaWdEYXRhLnByZXZPdXRzW2ldLmluZGV4LFxuICAgICAgICAgIHNpZzogc2lnc1tpXSxcbiAgICAgICAgICBwdWJrZXk6IHB1YmtleXNbaV0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbGx5LCBzZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCBzZXJpYWxpemVkVHggPSBiaXRjb2luLnNlcmlhbGl6ZVR4KHByZVNlcmlhbGl6ZWREYXRhKTtcbiAgICAgIC8vIEdlbmVyYXRlIHRoZSB0cmFuc2FjdGlvbiBoYXNoIHNvIHRoZSB1c2VyIGNhbiBsb29rIHRoaXMgdHJhbnNhY3Rpb24gdXAgbGF0ZXJcbiAgICAgIGxldCBwcmVJbWFnZVR4SGFzaCA9IHNlcmlhbGl6ZWRUeDtcbiAgICAgIGlmIChwcmVTZXJpYWxpemVkRGF0YS5pc1NlZ3dpdFNwZW5kID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFNlZ3dpdCB0cmFuc2FjdGlvbnMgbmVlZCB0byBiZSByZS1zZXJpYWxpemVkIHVzaW5nIGxlZ2FjeSBzZXJpYWxpemF0aW9uXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgdHJhbnNhY3Rpb24gaGFzaCBpcyBjYWxjdWxhdGVkLiBUaGlzIGFsbG93cyBsZWdhY3kgY2xpZW50c1xuICAgICAgICAvLyB0byB2YWxpZGF0ZSB0aGUgdHJhbnNhY3Rpb25zLlxuICAgICAgICBwcmVTZXJpYWxpemVkRGF0YS5pc1NlZ3dpdFNwZW5kID0gZmFsc2U7XG4gICAgICAgIHByZUltYWdlVHhIYXNoID0gYml0Y29pbi5zZXJpYWxpemVUeChwcmVTZXJpYWxpemVkRGF0YSk7XG4gICAgICB9ICBcbiAgICAgIGxldCB0eEhhc2ggPSB0aGlzLmNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoQnVmZmVyLmZyb20ocHJlSW1hZ2VUeEhhc2gsICdoZXgnKSkuZGlnZXN0KCk7XG4gICAgICB0eEhhc2ggPSB0aGlzLmNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUodHhIYXNoKS5kaWdlc3QoKS5yZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgXG4gICAgICAvLyBBZGQgZXh0cmEgZGF0YSBmb3IgZGVidWdnaW5nL2xvb2t1cCBwdXJwb3Nlc1xuICAgICAgcmV0dXJuRGF0YS5kYXRhID0ge1xuICAgICAgICB0eDogc2VyaWFsaXplZFR4LFxuICAgICAgICB0eEhhc2gsXG4gICAgICAgIGNoYW5nZVJlY2lwaWVudCxcbiAgICAgICAgc2lncyxcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbmN5VHlwZSA9PT0gJ0VUSCcpIHtcbiAgICAgIGNvbnN0IHNpZyA9IHBhcnNlREVSKHJlcy5zbGljZShvZmYsIChvZmYgKyAyICsgcmVzW29mZiArIDFdKSkpOyBvZmYgKz0gREVSTGVuZ3RoO1xuICAgICAgY29uc3QgZXRoQWRkciA9IHJlcy5zbGljZShvZmYsIG9mZiArIDIwKTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgYHZgIHBhcmFtIGFuZCBhZGQgaXQgdG8gdGhlIHNpZyBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICBjb25zdCByYXdUeCA9IGV0aGVyZXVtLmJ1aWxkRXRoUmF3VHgocmVxLCBzaWcsIGV0aEFkZHIpO1xuICAgICAgcmV0dXJuRGF0YS5kYXRhID0ge1xuICAgICAgICB0eDogYDB4JHtyYXdUeH1gLFxuICAgICAgICB0eEhhc2g6IGAweCR7ZXRoZXJldW0uaGFzaFRyYW5zYWN0aW9uKHJhd1R4KX1gLFxuICAgICAgICBzaWc6IHtcbiAgICAgICAgICB2OiBzaWcudixcbiAgICAgICAgICByOiBzaWcuci50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgczogc2lnLnMudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB9LFxuICAgICAgICBzaWduZXI6IGV0aEFkZHIsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY3VycmVuY3lUeXBlID09PSAnRVRIX01TRycpIHtcbiAgICAgIGNvbnN0IHNpZyA9IHBhcnNlREVSKHJlcy5zbGljZShvZmYsIChvZmYgKyAyICsgcmVzW29mZiArIDFdKSkpOyBvZmYgKz0gREVSTGVuZ3RoO1xuICAgICAgY29uc3Qgc2lnbmVyID0gcmVzLnNsaWNlKG9mZiwgb2ZmICsgMjApO1xuICAgICAgY29uc3QgdmFsaWRhdGVkU2lnID0gZXRoZXJldW0udmFsaWRhdGVFdGhlcmV1bU1zZ1Jlc3BvbnNlKHsgc2lnbmVyLCBzaWcgfSwgcmVxKTtcbiAgICAgIHJldHVybkRhdGEuZGF0YSA9IHtcbiAgICAgICAgc2lnOiB7XG4gICAgICAgICAgdjogdmFsaWRhdGVkU2lnLnYsXG4gICAgICAgICAgcjogdmFsaWRhdGVkU2lnLnIudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHM6IHZhbGlkYXRlZFNpZy5zLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmVyLFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5EYXRhO1xuICB9XG5cbiAgX3Jlc2V0QWN0aXZlV2FsbGV0cygpIHtcbiAgICB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwudWlkID0gRU1QVFlfV0FMTEVUX1VJRDtcbiAgICB0aGlzLmFjdGl2ZVdhbGxldHMuaW50ZXJuYWwubmFtZSA9IG51bGw7XG4gICAgdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsLmNhcGFiaWxpdGllcyA9IG51bGw7XG4gICAgdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLnVpZCA9IEVNUFRZX1dBTExFVF9VSUQ7XG4gICAgdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC5jYXBhYmlsaXRpZXMgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldEFjdGl2ZVdhbGxldCgpIHtcbiAgICBpZiAoIUVNUFRZX1dBTExFVF9VSUQuZXF1YWxzKHRoaXMuYWN0aXZlV2FsbGV0cy5leHRlcm5hbC51aWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVXYWxsZXRzLmV4dGVybmFsO1xuICAgIH0gZWxzZSBpZiAoIUVNUFRZX1dBTExFVF9VSUQuZXF1YWxzKHRoaXMuYWN0aXZlV2FsbGV0cy5pbnRlcm5hbC51aWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVXYWxsZXRzLmludGVybmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoYXNBY3RpdmVXYWxsZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlV2FsbGV0KCkgIT09IG51bGw7XG4gIH1cbiAgXG4gIC8vIEdldCA2NCBieXRlcyByZXByZXNlbnRpbmcgdGhlIHB1YmxpYyBrZXlcbiAgLy8gVGhpcyBpcyB0aGUgdW5jb21wcmVzc2VkIGtleSB3aXRob3V0IHRoZSBsZWFkaW5nIDA0IGJ5dGVcbiAgcHViS2V5Qnl0ZXMoTEU9ZmFsc2UpIHtcbiAgICBjb25zdCBrID0gdGhpcy5rZXkuZ2V0UHVibGljKCk7XG4gICAgY29uc3QgcCA9IGsuZW5jb2RlKCdoZXgnKTtcbiAgICBjb25zdCBwYiA9IEJ1ZmZlci5mcm9tKHAsICdoZXgnKTtcbiAgICBpZiAoTEUgPT09IHRydWUpIHtcbiAgICAgIC8vIE5lZWQgdG8gZmxpcCBYIGFuZCBZIGNvbXBvbmVudHMgdG8gbGl0dGxlIGVuZGlhblxuICAgICAgY29uc3QgeCA9IHBiLnNsaWNlKDEsIDMzKS5yZXZlcnNlKCk7XG4gICAgICBjb25zdCB5ID0gcGIuc2xpY2UoMzMsIDY1KS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcGJbMF0sIHgsIHldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBiO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGV4cG9ydCB0aGlzLlxuICBwYXJzZUFiaShzb3VyY2UsIGRhdGEsIHNraXBFcnJvcnM9ZmFsc2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgY2FzZSAnZXRoZXJzY2FuJzpcbiAgICAgICAgcmV0dXJuIGFiaVBhcnNlcnNbc291cmNlXShkYXRhLCBza2lwRXJyb3JzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGVycjogYE5vICR7c291cmNlfSBwYXJzZXIgYXZhaWxhYmxlLmAgfTtcblxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlcnNcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyJztcbmNvbnN0IHN0YXRlTWV0YWRhdGEgPSB7XG4gICAgc3ViamVjdE1ldGFkYXRhOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogZmFsc2UgfSxcbn07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgc3ViamVjdE1ldGFkYXRhOiB7fSxcbn07XG4vKipcbiAqIEEgY29udHJvbGxlciBmb3Igc3RvcmluZyBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggcGVybWlzc2lvbiBzdWJqZWN0cy4gTW9yZVxuICogb3IgbGVzcywgYSBjYWNoZS5cbiAqL1xuY2xhc3MgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlciBleHRlbmRzIGNvbnRyb2xsZXJzXzEuQmFzZUNvbnRyb2xsZXJWMiB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzZW5nZXIsIHN1YmplY3RDYWNoZUxpbWl0LCBzdGF0ZSA9IHt9LCB9KSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzdWJqZWN0Q2FjaGVMaW1pdCkgfHwgc3ViamVjdENhY2hlTGltaXQgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1YmplY3RDYWNoZUxpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke3N1YmplY3RDYWNoZUxpbWl0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzUGVybWlzc2lvbnMgPSAob3JpZ2luKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2VuZ2VyLmNhbGwoJ1Blcm1pc3Npb25Db250cm9sbGVyOmhhc1Blcm1pc3Npb25zJywgb3JpZ2luKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogY29udHJvbGxlck5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogc3RhdGVNZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKHt9LCBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmdldFRyaW1tZWRTdGF0ZShzdGF0ZSwgaGFzUGVybWlzc2lvbnMpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3ViamVjdEhhc1Blcm1pc3Npb25zID0gaGFzUGVybWlzc2lvbnM7XG4gICAgICAgIHRoaXMuc3ViamVjdENhY2hlTGltaXQgPSBzdWJqZWN0Q2FjaGVMaW1pdDtcbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3RhdGUgb2YgdGhpcyBjb250cm9sbGVyLiBBbHNvIHJlc2V0cyB0aGUgY2FjaGUgb2Ygc3ViamVjdHNcbiAgICAgKiBlbmNvdW50ZXJlZCBzaW5jZSBzdGFydHVwLCBzbyBhcyB0byBub3QgcHJlbWF0dXJlbHkgcmVhY2ggdGhlIGNhY2hlIGxpbWl0LlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKChfZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgZG9tYWluIG1ldGFkYXRhIGZvciB0aGUgZ2l2ZW4gb3JpZ2luIChzdWJqZWN0KS4gRGVsZXRlcyBtZXRhZGF0YSBmb3JcbiAgICAgKiBzdWJqZWN0cyB3aXRob3V0IHBlcm1pc3Npb25zIGluIGEgRklGTyBtYW5uZXIgb25jZSBtb3JlIHRoYW5cbiAgICAgKiB7QGxpbmsgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0Q2FjaGVMaW1pdH0gZGlzdGluY3Qgb3JpZ2lucyBoYXZlXG4gICAgICogYmVlbiBhZGRlZCBzaW5jZSBib290LlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gcHJldmVudCBhIGRlZ3JhZGVkIHVzZXIgZXhwZXJpZW5jZSxcbiAgICAgKiBtZXRhZGF0YSBpcyBuZXZlciBkZWxldGVkIGZvciBzdWJqZWN0cyB3aXRoIHBlcm1pc3Npb25zLCBzaW5jZSBtZXRhZGF0YVxuICAgICAqIGNhbm5vdCB5ZXQgYmUgcmVxdWVzdGVkIG9uIGRlbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBzdWJqZWN0IG1ldGFkYXRhIHRvIHN0b3JlLlxuICAgICAqL1xuICAgIGFkZFN1YmplY3RNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSksIHsgZXh0ZW5zaW9uSWQ6IG1ldGFkYXRhLmV4dGVuc2lvbklkIHx8IG51bGwsIGljb25Vcmw6IG1ldGFkYXRhLmljb25VcmwgfHwgbnVsbCB9KTtcbiAgICAgICAgbGV0IG9yaWdpblRvRm9yZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gV2Ugb25seSBkZWxldGUgdGhlIG9sZGVzdCBlbmNvdW50ZXJlZCBzdWJqZWN0IGZyb20gdGhlIGNhY2hlLCBhZ2FpbiB0b1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdXNlcidzIGV4cGVyaWVuY2UgaXNuJ3QgZGVncmFkZWQgYnkgbWlzc2luZyBpY29ucyBldGMuXG4gICAgICAgIGlmICh0aGlzLnN1YmplY3RzV2l0aG91dFBlcm1pc3Npb25zRWNvdW50ZXJlZFNpbmNlU3RhcnR1cC5zaXplID49XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RDYWNoZUxpbWl0KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRPcmlnaW4gPSB0aGlzLnN1YmplY3RzV2l0aG91dFBlcm1pc3Npb25zRWNvdW50ZXJlZFNpbmNlU3RhcnR1cFxuICAgICAgICAgICAgICAgIC52YWx1ZXMoKVxuICAgICAgICAgICAgICAgIC5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RzV2l0aG91dFBlcm1pc3Npb25zRWNvdW50ZXJlZFNpbmNlU3RhcnR1cC5kZWxldGUoY2FjaGVkT3JpZ2luKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdWJqZWN0SGFzUGVybWlzc2lvbnMoY2FjaGVkT3JpZ2luKSkge1xuICAgICAgICAgICAgICAgIG9yaWdpblRvRm9yZ2V0ID0gY2FjaGVkT3JpZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmFkZChvcmlnaW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IHRzKDI1ODkpXG4gICAgICAgICAgICBkcmFmdFN0YXRlLnN1YmplY3RNZXRhZGF0YVtvcmlnaW5dID0gbmV3TWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpblRvRm9yZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFN0YXRlLnN1YmplY3RNZXRhZGF0YVtvcmlnaW5Ub0ZvcmdldF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFsbCBzdWJqZWN0cyB3aXRob3V0IHBlcm1pc3Npb25zIGZyb20gdGhlIGNvbnRyb2xsZXIncyBzdGF0ZS5cbiAgICAgKi9cbiAgICB0cmltTWV0YWRhdGFTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmdldFRyaW1tZWRTdGF0ZShcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiB0cygyNTg5KVxuICAgICAgICAgICAgZHJhZnRTdGF0ZSwgdGhpcy5zdWJqZWN0SGFzUGVybWlzc2lvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzdGF0ZSBvYmplY3QgdGhhdCBvbmx5IGluY2x1ZGVzIHN1YmplY3RzIHdpdGggcGVybWlzc2lvbnMuXG4gICAgICogVGhpcyBtZXRob2QgaXMgc3RhdGljIGJlY2F1c2Ugd2Ugd2FudCB0byBjYWxsIGl0IGluIHRoZSBjb25zdHJ1Y3RvciwgYmVmb3JlXG4gICAgICogdGhlIGNvbnRyb2xsZXIncyBzdGF0ZSBpcyBpbml0aWFsaXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBzdGF0ZSBvYmplY3QgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0gaGFzUGVybWlzc2lvbnMgLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZ1xuICAgICAqIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIHN1YmplY3QgKGlkZW50aWZpZWQgYnkgaXRzIG9yaWdpbikgaGFzIGFueVxuICAgICAqIHBlcm1pc3Npb25zLlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgc3RhdGUgb2JqZWN0LiBJZiB0aGUgc3BlY2lmaWVkIGBzdGF0ZWAgb2JqZWN0IGhhcyBub1xuICAgICAqIHN1YmplY3QgbWV0YWRhdGEsIHRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBiZSBlcXVpdmFsZW50IHRvIHRoZSBkZWZhdWx0XG4gICAgICogc3RhdGUgb2YgdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUcmltbWVkU3RhdGUoc3RhdGUsIGhhc1Blcm1pc3Npb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc3ViamVjdE1ldGFkYXRhID0ge30gfSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ViamVjdE1ldGFkYXRhOiBPYmplY3Qua2V5cyhzdWJqZWN0TWV0YWRhdGEpLnJlZHVjZSgobmV3U3ViamVjdE1ldGFkYXRhLCBvcmlnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGVybWlzc2lvbnMob3JpZ2luKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdWJqZWN0TWV0YWRhdGFbb3JpZ2luXSA9IHN1YmplY3RNZXRhZGF0YVtvcmlnaW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3U3ViamVjdE1ldGFkYXRhO1xuICAgICAgICAgICAgfSwge30pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlciA9IFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TbmFwQ29udHJvbGxlciA9IGV4cG9ydHMuU25hcFN0YXR1c0V2ZW50ID0gZXhwb3J0cy5TbmFwU3RhdHVzID0gZXhwb3J0cy5TTkFQX1BSRUZJWF9SRUdFWCA9IGV4cG9ydHMuU05BUF9QUkVGSVggPSBleHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IGNvbnRyb2xsZXJzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXJzXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGlubGluZVNuYXBzXzEgPSByZXF1aXJlKFwiLi9pbmxpbmVTbmFwc1wiKTtcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnU25hcENvbnRyb2xsZXInO1xuZXhwb3J0cy5TTkFQX1BSRUZJWCA9ICd3YWxsZXRfc25hcF8nO1xuZXhwb3J0cy5TTkFQX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoYF4ke2V4cG9ydHMuU05BUF9QUkVGSVh9YCwgJ3UnKTtcbmNvbnN0IFNFUklBTElaQUJMRV9TTkFQX1BST1BFUlRJRVMgPSBuZXcgU2V0KFtcbiAgICAnaW5pdGlhbFBlcm1pc3Npb25zJyxcbiAgICAnbmFtZScsXG4gICAgJ3Blcm1pc3Npb25OYW1lJyxcbl0pO1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIHNuYXBFcnJvcnM6IHt9LFxuICAgIGlubGluZVNuYXBJc1J1bm5pbmc6IGZhbHNlLFxuICAgIHNuYXBzOiB7fSxcbiAgICBzbmFwU3RhdGVzOiB7fSxcbn07XG52YXIgU25hcFN0YXR1cztcbihmdW5jdGlvbiAoU25hcFN0YXR1cykge1xuICAgIFNuYXBTdGF0dXNbXCJpbnN0YWxsaW5nXCJdID0gXCJpbnN0YWxsaW5nXCI7XG4gICAgU25hcFN0YXR1c1tcInJ1bm5pbmdcIl0gPSBcInJ1bm5pbmdcIjtcbiAgICBTbmFwU3RhdHVzW1wic3RvcHBlZFwiXSA9IFwic3RvcHBlZFwiO1xuICAgIFNuYXBTdGF0dXNbXCJjcmFzaGVkXCJdID0gXCJjcmFzaGVkXCI7XG59KShTbmFwU3RhdHVzID0gZXhwb3J0cy5TbmFwU3RhdHVzIHx8IChleHBvcnRzLlNuYXBTdGF0dXMgPSB7fSkpO1xudmFyIFNuYXBTdGF0dXNFdmVudDtcbihmdW5jdGlvbiAoU25hcFN0YXR1c0V2ZW50KSB7XG4gICAgU25hcFN0YXR1c0V2ZW50W1wic3RhcnRcIl0gPSBcInN0YXJ0XCI7XG4gICAgU25hcFN0YXR1c0V2ZW50W1wic3RvcFwiXSA9IFwic3RvcFwiO1xuICAgIFNuYXBTdGF0dXNFdmVudFtcImNyYXNoXCJdID0gXCJjcmFzaFwiO1xufSkoU25hcFN0YXR1c0V2ZW50ID0gZXhwb3J0cy5TbmFwU3RhdHVzRXZlbnQgfHwgKGV4cG9ydHMuU25hcFN0YXR1c0V2ZW50ID0ge30pKTtcbi8qKlxuICogR3VhcmQgdHJhbnNpdGlvbmluZyB3aGVuIHRoZSBzbmFwIGlzIGRpc2FibGVkLlxuICovXG5jb25zdCBkaXNhYmxlZEd1YXJkID0gKHNlcmlhbGl6ZWRTbmFwKSA9PiB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRTbmFwLmVuYWJsZWQ7XG59O1xuLyoqXG4gKiBUaGUgc3RhdGUgbWFjaGluZSBjb25maWd1cmF0aW9uIGZvciBhIHNuYXBzIGBzdGF0dXNgIHN0YXRlLlxuICogVXNpbmcgYSBzdGF0ZSBtYWNoaW5lIGZvciBhIHNuYXBzIGBzdGF0dXNgIGVuc3VyZXMgdGhhdCB0aGUgc25hcCB0cmFuc2l0aW9ucyB0byBhIHZhbGlkIG5leHQgbGlmZWN5Y2xlIHN0YXRlLlxuICogU3VwcG9ydHMgYSB2ZXJ5IG1pbmltYWwgc3Vic2V0IG9mIFhTdGF0ZSBjb252ZW50aW9ucyBvdXRsaW5lZCBpbiBgX3RyYW5zaXRpb25TbmFwU3RhdGVgLlxuICovXG5jb25zdCBzbmFwU3RhdHVzU3RhdGVNYWNoaW5lQ29uZmlnID0ge1xuICAgIGluaXRpYWw6IFNuYXBTdGF0dXMuaW5zdGFsbGluZyxcbiAgICBzdGF0ZXM6IHtcbiAgICAgICAgW1NuYXBTdGF0dXMuaW5zdGFsbGluZ106IHtcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgW1NuYXBTdGF0dXNFdmVudC5zdGFydF06IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBTbmFwU3RhdHVzLnJ1bm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmQ6IGRpc2FibGVkR3VhcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtTbmFwU3RhdHVzLnJ1bm5pbmddOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFtTbmFwU3RhdHVzRXZlbnQuc3RvcF06IFNuYXBTdGF0dXMuc3RvcHBlZCxcbiAgICAgICAgICAgICAgICBbU25hcFN0YXR1c0V2ZW50LmNyYXNoXTogU25hcFN0YXR1cy5jcmFzaGVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW1NuYXBTdGF0dXMuc3RvcHBlZF06IHtcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgW1NuYXBTdGF0dXNFdmVudC5zdGFydF06IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBTbmFwU3RhdHVzLnJ1bm5pbmcsXG4gICAgICAgICAgICAgICAgICAgIGNvbmQ6IGRpc2FibGVkR3VhcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtTbmFwU3RhdHVzLmNyYXNoZWRdOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFtTbmFwU3RhdHVzRXZlbnQuc3RhcnRdOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogU25hcFN0YXR1cy5ydW5uaW5nLFxuICAgICAgICAgICAgICAgICAgICBjb25kOiBkaXNhYmxlZEd1YXJkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuY29uc3QgbmFtZSA9ICdTbmFwQ29udHJvbGxlcic7XG4vKlxuICogQSBzbmFwIGlzIGluaXRpYWxpemVkIGluIHRocmVlIHBoYXNlczpcbiAqIC0gQWRkOiBMb2FkcyB0aGUgc25hcCBmcm9tIGEgcmVtb3RlIHNvdXJjZSBhbmQgcGFyc2VzIGl0LlxuICogLSBBdXRob3JpemU6IFJlcXVlc3RzIHRoZSBzbmFwJ3MgcmVxdWlyZWQgcGVybWlzc2lvbnMgZnJvbSB0aGUgdXNlci5cbiAqIC0gU3RhcnQ6IEluaXRpYWxpemVzIHRoZSBzbmFwIGluIGl0cyBTRVMgcmVhbG0gd2l0aCB0aGUgYXV0aG9yaXplZCBwZXJtaXNzaW9ucy5cbiAqL1xuY2xhc3MgU25hcENvbnRyb2xsZXIgZXh0ZW5kcyBjb250cm9sbGVyc18xLkJhc2VDb250cm9sbGVyVjIge1xuICAgIGNvbnN0cnVjdG9yKHsgcmVtb3ZlQWxsUGVybWlzc2lvbnNGb3IsIGNsb3NlQWxsQ29ubmVjdGlvbnMsIHJlcXVlc3RQZXJtaXNzaW9ucywgZ2V0UGVybWlzc2lvbnMsIHRlcm1pbmF0ZVNuYXAsIHRlcm1pbmF0ZUFsbFNuYXBzLCBoYXNQZXJtaXNzaW9uLCBleGVjdXRlU25hcCwgZ2V0UnBjTWVzc2FnZUhhbmRsZXIsIG1lc3Nlbmdlciwgc3RhdGUsIG1heElkbGVUaW1lID0gMzAwMDAsIGlkbGVUaW1lQ2hlY2tJbnRlcnZhbCA9IDUwMDAsIG1heFJlcXVlc3RUaW1lID0gNjAwMDAsIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBzbmFwRXJyb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lU25hcElzUnVubmluZzoge1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNuYXBTdGF0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNuYXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3Q6IChzbmFwcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc25hcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc25hcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNuYXApLCB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGUgdGltZSBzdGF0ZSBpcyByZWh5ZHJhdGVkLCBubyBzbmFwIHdpbGwgYmUgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBTbmFwU3RhdHVzLnN0b3BwZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKG1lbW8sIHNuYXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1vW3NuYXAubmFtZV0gPSBzbmFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUFsbFBlcm1pc3Npb25zRm9yID0gcmVtb3ZlQWxsUGVybWlzc2lvbnNGb3I7XG4gICAgICAgIHRoaXMuX2Nsb3NlQWxsQ29ubmVjdGlvbnMgPSBjbG9zZUFsbENvbm5lY3Rpb25zO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0UGVybWlzc2lvbnMgPSByZXF1ZXN0UGVybWlzc2lvbnM7XG4gICAgICAgIHRoaXMuX2dldFBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnM7XG4gICAgICAgIHRoaXMuX2hhc1Blcm1pc3Npb24gPSBoYXNQZXJtaXNzaW9uO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGVTbmFwID0gdGVybWluYXRlU25hcDtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlQWxsU25hcHMgPSB0ZXJtaW5hdGVBbGxTbmFwcztcbiAgICAgICAgdGhpcy5fZXhlY3V0ZVNuYXAgPSBleGVjdXRlU25hcDtcbiAgICAgICAgdGhpcy5fZ2V0UnBjTWVzc2FnZUhhbmRsZXIgPSBnZXRScGNNZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgdGhpcy5fb25VbmhhbmRsZWRTbmFwRXJyb3IgPSB0aGlzLl9vblVuaGFuZGxlZFNuYXBFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9vblVucmVzcG9uc2l2ZVNuYXAgPSB0aGlzLl9vblVucmVzcG9uc2l2ZVNuYXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uc3Vic2NyaWJlKCdTZXJ2aWNlTWVzc2VuZ2VyOnVuaGFuZGxlZEVycm9yJywgdGhpcy5fb25VbmhhbmRsZWRTbmFwRXJyb3IpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5zdWJzY3JpYmUoJ1NlcnZpY2VNZXNzZW5nZXI6dW5yZXNwb25zaXZlJywgdGhpcy5fb25VbnJlc3BvbnNpdmVTbmFwKTtcbiAgICAgICAgdGhpcy5fc25hcHNCZWluZ0FkZGVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tYXhJZGxlVGltZSA9IG1heElkbGVUaW1lO1xuICAgICAgICB0aGlzLl9tYXhSZXF1ZXN0VGltZSA9IG1heFJlcXVlc3RUaW1lO1xuICAgICAgICB0aGlzLl9pZGxlVGltZUNoZWNrSW50ZXJ2YWwgPSBpZGxlVGltZUNoZWNrSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3BvbGxGb3JMYXN0UmVxdWVzdFN0YXR1cygpO1xuICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcnBjSGFuZGxlck1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgX3BvbGxGb3JMYXN0UmVxdWVzdFN0YXR1cygpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dEZvckxhc3RSZXF1ZXN0U3RhdHVzID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wU25hcHNMYXN0UmVxdWVzdFBhc3RNYXgoKTtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxGb3JMYXN0UmVxdWVzdFN0YXR1cygpO1xuICAgICAgICB9LCB0aGlzLl9pZGxlVGltZUNoZWNrSW50ZXJ2YWwpO1xuICAgIH1cbiAgICBfc3RvcFNuYXBzTGFzdFJlcXVlc3RQYXN0TWF4KCkge1xuICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdE1hcC5mb3JFYWNoKGFzeW5jICh0aW1lc3RhbXAsIHNuYXBOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF4SWRsZVRpbWUgJiYgdXRpbHNfMS50aW1lU2luY2UodGltZXN0YW1wKSA+IHRoaXMuX21heElkbGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wU25hcChzbmFwTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25VbnJlc3BvbnNpdmVTbmFwKHNuYXBOYW1lKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25TbmFwU3RhdGUoc25hcE5hbWUsIFNuYXBTdGF0dXNFdmVudC5jcmFzaCk7XG4gICAgICAgIHRoaXMuX3N0b3BTbmFwKHNuYXBOYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYWRkU25hcEVycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IC0zMjAwMSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdTbmFwIFVucmVzcG9uc2l2ZScsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgc25hcE5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX29uVW5oYW5kbGVkU25hcEVycm9yKHNuYXBOYW1lLCBlcnJvcikge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uU25hcFN0YXRlKHNuYXBOYW1lLCBTbmFwU3RhdHVzRXZlbnQuY3Jhc2gpO1xuICAgICAgICB0aGlzLl9zdG9wU25hcChzbmFwTmFtZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFkZFNuYXBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb25zIGJldHdlZW4gc3RhdGVzIHVzaW5nIGBzbmFwU3RhdHVzU3RhdGVNYWNoaW5lQ29uZmlnYCBhcyB0aGUgdGVtcGxhdGUgdG8gZmlndXJlIG91dCB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgKiBUaGlzIHRyYW5zaXRpb24gZnVuY3Rpb24gdXNlcyBhIHZlcnkgbWluaW1hbCBzdWJzZXQgb2YgWFN0YXRlIGNvbnZlbnRpb25zOlxuICAgICAqIC0gc3VwcG9ydHMgaW5pdGlhbCBzdGF0ZVxuICAgICAqIC0gLm9uIHN1cHBvcnRzIHJhdyBldmVudCB0YXJnZXQgc3RyaW5nXG4gICAgICogLSAub24gc3VwcG9ydHMge3RhcmdldCwgY29uZH0gb2JqZWN0XG4gICAgICogLSB0aGUgYXJndW1lbnRzIGZvciBgY29uZGAgaXMgdGhlIGBTZXJpYWxpemVkU25hcGAgaW5zdGVhZCBvZiBYc3RhdGUgY29udmVudGlvbiBvZiBgKGV2ZW50LCBjb250ZXh0KSA9PiBib29sZWFuYFxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSB0aGUgbmFtZSBvZiB0aGUgc25hcCB0byB0cmFuc2l0aW9uXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBlbnVtIHRvIHVzZSB0byB0cmFuc2l0aW9uXG4gICAgICovXG4gICAgX3RyYW5zaXRpb25TbmFwU3RhdGUoc25hcE5hbWUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc25hcFN0YXR1cyA9IHRoaXMuc3RhdGUuc25hcHNbc25hcE5hbWVdLnN0YXR1cztcbiAgICAgICAgbGV0IG5leHRTdGF0dXMgPSAoX2EgPSBzbmFwU3RhdHVzU3RhdGVNYWNoaW5lQ29uZmlnLnN0YXRlc1tzbmFwU3RhdHVzXS5vbltldmVudF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNuYXBTdGF0dXM7XG4gICAgICAgIGlmIChuZXh0U3RhdHVzLmNvbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBuZXh0U3RhdHVzLmNvbmQodGhpcy5zdGF0ZS5zbmFwc1tzbmFwTmFtZV0pO1xuICAgICAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25kaXRpb24gZmFpbGVkIGZvciBzdGF0ZSB0cmFuc2l0aW9uIFwiJHtzbmFwTmFtZX1cIiB3aXRoIGV2ZW50IFwiJHtldmVudH1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dFN0YXR1cy50YXJnZXQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0dXMgPSBuZXh0U3RhdHVzLnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dFN0YXR1cyA9PT0gc25hcFN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc25hcHNbc25hcE5hbWVdLnN0YXR1cyA9IG5leHRTdGF0dXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGV4aXN0aW5nIChpbnN0YWxsZWQpIHNuYXBzLlxuICAgICAqIERlbGV0ZXMgYW55IHNuYXBzIHRoYXQgY2Fubm90IGJlIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgcnVuRXhpc3RpbmdTbmFwcygpIHtcbiAgICAgICAgY29uc3QgeyBzbmFwcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNuYXBzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgZXhpc3Rpbmcgc25hcHMuLi4nLCBzbmFwcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gZXhpc3Rpbmcgc25hcHMgdG8gcnVuLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC52YWx1ZXMoc25hcHMpLm1hcChhc3luYyAoeyBuYW1lOiBzbmFwTmFtZSwgc291cmNlQ29kZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmc6ICR7c25hcE5hbWV9YCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0U25hcCh7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHN0YXJ0IFwiJHtzbmFwTmFtZX1cIiwgZGVsZXRpbmcgaXQuYCwgZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBmYWlsZWQgc25hcHM6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTbmFwKHNuYXBOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGdpdmVuIHNuYXAuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIHNuYXAgZXhpc3RzXG4gICAgICogb3IgaWYgaXQgaXMgYWxyZWFkeSBydW5uaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gc3RhcnQuXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRTbmFwKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IHNuYXAgPSB0aGlzLmdldChzbmFwTmFtZSk7XG4gICAgICAgIGlmICghc25hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc25hcHNbc25hcE5hbWVdLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBOYW1lfVwiIGlzIGRpc2FibGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0U25hcCh7XG4gICAgICAgICAgICBzbmFwTmFtZSxcbiAgICAgICAgICAgIHNvdXJjZUNvZGU6IHNuYXAuc291cmNlQ29kZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIGdpdmVuIHNuYXAuIEEgc25hcCBjYW4gb25seSBiZSBzdGFydGVkIGlmIGl0IGlzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcCB0byBlbmFibGUuXG4gICAgICovXG4gICAgZW5hYmxlU25hcChzbmFwTmFtZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBzW3NuYXBOYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBnaXZlbiBzbmFwLiBBIHNuYXAgY2FuIG9ubHkgYmUgc3RhcnRlZCBpZiBpdCBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gZGlzYWJsZS5cbiAgICAgKi9cbiAgICBkaXNhYmxlU25hcChzbmFwTmFtZSkge1xuICAgICAgICB0aGlzLnN0b3BTbmFwKHNuYXBOYW1lKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwc1tzbmFwTmFtZV0uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIGdpdmVuIHNuYXAuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIHNuYXAgZXhpc3RzXG4gICAgICogb3IgaWYgaXQgaXMgYWxyZWFkeSBzdG9wcGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gc3RvcC5cbiAgICAgKi9cbiAgICBzdG9wU25hcChzbmFwTmFtZSkge1xuICAgICAgICBjb25zdCBzbmFwID0gdGhpcy5nZXQoc25hcE5hbWUpO1xuICAgICAgICBpZiAoIXNuYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcE5hbWV9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcoc25hcE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBOYW1lfVwiIGFscmVhZHkgc3RvcHBlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wU25hcChzbmFwTmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBzdG9wcGVkLmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgZ2l2ZW4gc25hcCwgcmVtb3ZlcyBhbGwgaG9va3MsIGNsb3NlcyBhbGwgY29ubmVjdGlvbnMsIGFuZFxuICAgICAqIHRlcm1pbmF0ZXMgaXRzIHdvcmtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIHN0b3AuXG4gICAgICogQHBhcmFtIHNldE5vdFJ1bm5pbmcgLSBXaGV0aGVyIHRvIG1hcmsgdGhlIHNuYXAgYXMgbm90IHJ1bm5pbmcuXG4gICAgICogU2hvdWxkIG9ubHkgYmUgc2V0IHRvIGZhbHNlIGlmIHRoZSBzbmFwIGlzIGFib3V0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgX3N0b3BTbmFwKHNuYXBOYW1lLCBzZXROb3RSdW5uaW5nID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdE1hcC5kZWxldGUoc25hcE5hbWUpO1xuICAgICAgICB0aGlzLl9jbG9zZUFsbENvbm5lY3Rpb25zKHNuYXBOYW1lKTtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlU25hcChzbmFwTmFtZSk7XG4gICAgICAgIGlmIChzZXROb3RSdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU25hcFN0YXRlKHNuYXBOYW1lLCBTbmFwU3RhdHVzRXZlbnQuc3RvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzbmFwIGlzIHJ1bm5pbmcuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzbmFwIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcCB0byBjaGVjay5cbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoc25hcE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMuZ2V0KHNuYXBOYW1lKTtcbiAgICAgICAgaWYgKCFzbmFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBOYW1lfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc25hcC5zdGF0dXMgPT09IFNuYXBTdGF0dXMucnVubmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzbmFwIGhhcyBiZWVuIGFkZGVkIHRvIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gY2hlY2sgZm9yLlxuICAgICAqL1xuICAgIGhhcyhzbmFwTmFtZSkge1xuICAgICAgICByZXR1cm4gc25hcE5hbWUgaW4gdGhpcy5zdGF0ZS5zbmFwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc25hcCB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGV4aXN0cywgaW5jbHVkaW5nIGFsbCBkYXRhLlxuICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIGlmIHRoZSBzbmFwIGlzIHRvIGJlIHNlcmlhbGl6YWJsZSwgYXMgZS5nLlxuICAgICAqIHRoZSBzbmFwIHNvdXJjZUNvZGUgbWF5IGJlIHF1aXRlIGxhcmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgdG8gZ2V0LlxuICAgICAqL1xuICAgIGdldChzbmFwTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zbmFwc1tzbmFwTmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNuYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBleGlzdHMsIGV4Y2x1ZGluZyBhbnlcbiAgICAgKiBub24tc2VyaWFsaXphYmxlIG9yIGV4cGVuc2l2ZS10by1zZXJpYWxpemUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHRvIGdldC5cbiAgICAgKi9cbiAgICBnZXRTZXJpYWxpemFibGUoc25hcE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMuZ2V0KHNuYXBOYW1lKTtcbiAgICAgICAgcmV0dXJuIHNuYXBcbiAgICAgICAgICAgID8gLy8gVGhlIGNhc3QgdG8gXCJhbnlcIiBvZiB0aGUgYWNjdW11bGF0b3Igb2JqZWN0IGlzIGR1ZSB0byBhIFR5cGVTY3JpcHQgYnVnXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc25hcCkucmVkdWNlKChzZXJpYWxpemVkLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFNFUklBTElaQUJMRV9TTkFQX1BST1BFUlRJRVMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHNuYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgb3duIHN0YXRlIG9mIHRoZSBzbmFwIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICogVGhpcyBpcyBkaXN0aW5jdCBmcm9tIHRoZSBzdGF0ZSBNZXRhTWFzayB1c2VzIHRvIG1hbmFnZSBzbmFwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwIHdob3NlIHN0YXRlIHNob3VsZCBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBuZXdTbmFwU3RhdGUgLSBUaGUgbmV3IHN0YXRlIG9mIHRoZSBzbmFwLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVNuYXBTdGF0ZShzbmFwTmFtZSwgbmV3U25hcFN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc25hcFN0YXRlc1tzbmFwTmFtZV0gPSBuZXdTbmFwU3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGVycm9yIGZyb20gYSBzbmFwIHRvIHRoZSBTbmFwQ29udHJvbGxlcnMgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcEVycm9yIC0gVGhlIGVycm9yIHRvIHN0b3JlIG9uIHRoZSBTbmFwQ29udHJvbGxlclxuICAgICAqL1xuICAgIGFzeW5jIGFkZFNuYXBFcnJvcihzbmFwRXJyb3IpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IG5hbm9pZF8xLm5hbm9pZCgpO1xuICAgICAgICAgICAgc3RhdGUuc25hcEVycm9yc1tpZF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNuYXBFcnJvciksIHsgaW50ZXJuYWxJRDogaWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGVycm9yIGJ5IGludGVybmFsSUQgZnJvbSBhIHRoZSBTbmFwQ29udHJvbGxlcnMgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxJRCAtIFRoZSBpbnRlcm5hbCBlcnJvciBJRCB0byByZW1vdmUgb24gdGhlIFNuYXBDb250cm9sbGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlU25hcEVycm9yKGludGVybmFsSUQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuc25hcEVycm9yc1tpbnRlcm5hbElEXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZXJyb3JzIGZyb20gdGhlIFNuYXBDb250cm9sbGVycyBzdGF0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFyU25hcEVycm9ycygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zbmFwRXJyb3JzID0ge307XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvd24gc3RhdGUgb2YgdGhlIHNuYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKiBUaGlzIGlzIGRpc3RpbmN0IGZyb20gdGhlIHN0YXRlIE1ldGFNYXNrIHVzZXMgdG8gbWFuYWdlIHNuYXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgd2hvc2Ugc3RhdGUgdG8gZ2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNuYXBTdGF0ZShzbmFwTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zbmFwU3RhdGVzW3NuYXBOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGVseSBjbGVhciB0aGUgY29udHJvbGxlcidzIHN0YXRlOiBkZWxldGUgYWxsIGFzc29jaWF0ZWQgZGF0YSxcbiAgICAgKiBoYW5kbGVycywgZXZlbnQgbGlzdGVuZXJzLCBhbmQgcGVybWlzc2lvbnM7IHRlYXIgZG93biBhbGwgc25hcCBwcm92aWRlcnMuXG4gICAgICovXG4gICAgY2xlYXJTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc25hcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5zdGF0ZS5zbmFwcyk7XG4gICAgICAgIHNuYXBOYW1lcy5mb3JFYWNoKChzbmFwTmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VBbGxDb25uZWN0aW9ucyhzbmFwTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGVBbGxTbmFwcygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVBbGxQZXJtaXNzaW9uc0ZvcihzbmFwTmFtZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlubGluZVNuYXBJc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBzID0ge307XG4gICAgICAgICAgICBzdGF0ZS5zbmFwU3RhdGVzID0ge307XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBzbmFwIGZyb20gc3RhdGUsIGFuZCBjbGVhcnMgYWxsIGFzc29jaWF0ZWQgaGFuZGxlcnNcbiAgICAgKiBhbmQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAuXG4gICAgICovXG4gICAgcmVtb3ZlU25hcChzbmFwTmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVNuYXBzKFtzbmFwTmFtZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgZ2l2ZW4gc25hcHMsIHJlbW92ZXMgdGhlbSBmcm9tIHN0YXRlLCBhbmQgY2xlYXJzIGFsbCBhc3NvY2lhdGVkXG4gICAgICogcGVybWlzc2lvbnMsIGhhbmRsZXJzLCBhbmQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwcy5cbiAgICAgKi9cbiAgICByZW1vdmVTbmFwcyhzbmFwTmFtZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNuYXBOYW1lcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYXJyYXkgb2Ygc25hcCBuYW1lcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHNuYXBOYW1lcy5mb3JFYWNoKChzbmFwTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTbmFwKHNuYXBOYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnBjSGFuZGxlck1hcC5kZWxldGUoc25hcE5hbWUpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5zbmFwc1tzbmFwTmFtZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnNuYXBTdGF0ZXNbc25hcE5hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZW1vdmVBbGxQZXJtaXNzaW9uc0ZvcihzbmFwTmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZXJpYWxpemVkIHBlcm1pdHRlZCBzbmFwcyBvZiB0aGUgZ2l2ZW4gb3JpZ2luLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gd2hvc2UgcGVybWl0dGVkIHNuYXBzIHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIGdldFBlcm1pdHRlZFNuYXBzKG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGVybWlzc2lvbnMob3JpZ2luKS5yZWR1Y2UoKHBlcm1pdHRlZFNuYXBzLCBwZXJtKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVybS5wYXJlbnRDYXBhYmlsaXR5LnN0YXJ0c1dpdGgoZXhwb3J0cy5TTkFQX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwTmFtZSA9IHBlcm0ucGFyZW50Q2FwYWJpbGl0eS5yZXBsYWNlKGV4cG9ydHMuU05BUF9QUkVGSVhfUkVHRVgsICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwID0gdGhpcy5nZXRTZXJpYWxpemFibGUoc25hcE5hbWUpO1xuICAgICAgICAgICAgICAgIHBlcm1pdHRlZFNuYXBzW3NuYXBOYW1lXSA9IHNuYXAgfHwge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXRoX3JwY19lcnJvcnNfMS5zZXJpYWxpemVFcnJvcihuZXcgRXJyb3IoJ1NuYXAgcGVybWl0dGVkIGJ1dCBub3QgaW5zdGFsbGVkLicpKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBlcm1pdHRlZFNuYXBzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbGxzIHRoZSBzbmFwcyByZXF1ZXN0ZWQgYnkgdGhlIGdpdmVuIG9yaWdpbiwgcmV0dXJuaW5nIHRoZSBzbmFwXG4gICAgICogb2JqZWN0IGlmIHRoZSBvcmlnaW4gaXMgcGVybWl0dGVkIHRvIGluc3RhbGwgaXQsIGFuZCBhbiBhdXRob3JpemF0aW9uIGVycm9yXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gdGhhdCByZXF1ZXN0ZWQgdG8gaW5zdGFsbCB0aGUgc25hcHMuXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZFNuYXBzIC0gVGhlIHNuYXBzIHRvIGluc3RhbGwuXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IG9mIHNuYXAgbmFtZXMgYW5kIHNuYXAgb2JqZWN0cywgb3IgZXJyb3JzIGlmIGFcbiAgICAgKiBzbmFwIGNvdWxkbid0IGJlIGluc3RhbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnN0YWxsU25hcHMob3JpZ2luLCByZXF1ZXN0ZWRTbmFwcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gdXNlIGEgZm9yLWxvb3Agc28gdGhhdCB3ZSBjYW4gcmV0dXJuIGFuIG9iamVjdCBhbmQgYXdhaXQgdGhlIHJlc29sdXRpb25cbiAgICAgICAgLy8gb2YgZWFjaCBjYWxsIHRvIHByb2Nlc3NSZXF1ZXN0ZWRTbmFwXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHJlcXVlc3RlZFNuYXBzKS5tYXAoYXN5bmMgKHNuYXBOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uTmFtZSA9IGV4cG9ydHMuU05BUF9QUkVGSVggKyBzbmFwTmFtZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNQZXJtaXNzaW9uKG9yaWdpbiwgcGVybWlzc2lvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBpbnN0YWxsIGFuZCBydW4gdGhlIHNuYXAsIHN0b3JpbmcgYW55IGVycm9ycyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gb2NjdXIgZHVyaW5nIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgcmVzdWx0W3NuYXBOYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIChhd2FpdCB0aGlzLnByb2Nlc3NSZXF1ZXN0ZWRTbmFwKHNuYXBOYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyB0aGUgaW5zdGFsbGF0aW9uIG9mIHBlcm1pdHRlZCBzbmFwc1xuICAgICAgICAgICAgICAgIHJlc3VsdFtzbmFwTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoYE5vdCBhdXRob3JpemVkIHRvIGluc3RhbGwgc25hcCAnJHtzbmFwTmFtZX0nLiBSZXF1ZXN0IHRoZSBwZXJtaXNzaW9uIGZvciB0aGUgc25hcCBiZWZvcmUgYXR0ZW1wdGluZyB0byBpbnN0YWxsIGl0LmApLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcywgYXV0aG9yaXplcywgYW5kIHJ1bnMgdGhlIGdpdmVuIHNuYXAgd2l0aCBhIHNuYXAgcHJvdmlkZXIuXG4gICAgICogUmVzdWx0cyBmcm9tIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBlZmZpY2llbnRseSBzZXJpYWxpemFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gLSBzbmFwTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzbmFwLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgc25hcCBvYmplY3QsIG9yIGFuIGVycm9yIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NSZXF1ZXN0ZWRTbmFwKHNuYXBOYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSBzbmFwIGlzIGFscmVhZHkgaW5zdGFsbGVkLCBqdXN0IHJldHVybiBpdFxuICAgICAgICBjb25zdCBzbmFwID0gdGhpcy5nZXQoc25hcE5hbWUpO1xuICAgICAgICBpZiAoc25hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VyaWFsaXphYmxlKHNuYXBOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2VDb2RlIH0gPSBhd2FpdCB0aGlzLmFkZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogc25hcE5hbWUsXG4gICAgICAgICAgICAgICAgbWFuaWZlc3RVcmw6IHNuYXBOYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGhvcml6ZShzbmFwTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFNuYXAoe1xuICAgICAgICAgICAgICAgIHNuYXBOYW1lLFxuICAgICAgICAgICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlcmlhbGl6YWJsZShzbmFwTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBhZGRpbmcgc25hcC5gLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGV0aF9ycGNfZXJyb3JzXzEuc2VyaWFsaXplRXJyb3IoZXJyKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgY29tcGxldGUgaW5zdGFsbGF0aW9uIG9mIHRoZSByZXF1ZXN0ZWQgc25hcC5cbiAgICAgKiBJZiB0aGUgc25hcCBpcyBhbHJlYWR5IGJlaW5nIGluc3RhbGxlZCwgdGhlIHByZXZpb3VzbHkgcGVuZGluZyBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIE9iamVjdCBjb250YWluaW5nIGVpdGhlciB0aGUgVVJMIG9mIHRoZSBzbmFwJ3MgbWFuaWZlc3QsXG4gICAgICogb3IgdGhlIHNuYXAncyBtYW5pZmVzdCBhbmQgc291cmNlIGNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBzbmFwIG9iamVjdC5cbiAgICAgKi9cbiAgICBhZGQoYXJncykge1xuICAgICAgICBjb25zdCB7IG5hbWU6IHNuYXBOYW1lIH0gPSBhcmdzO1xuICAgICAgICBpZiAoIXNuYXBOYW1lIHx8IHR5cGVvZiBzbmFwTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzbmFwIG5hbWU6ICR7c25hcE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmdzIHx8XG4gICAgICAgICAgICAoISgnbWFuaWZlc3RVcmwnIGluIGFyZ3MpICYmXG4gICAgICAgICAgICAgICAgKCEoJ21hbmlmZXN0JyBpbiBhcmdzKSB8fCAhKCdzb3VyY2VDb2RlJyBpbiBhcmdzKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWRkIHNuYXAgYXJncyBmb3Igc25hcCBcIiR7c25hcE5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zbmFwc0JlaW5nQWRkZWQuaGFzKHNuYXBOYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBzbmFwOiAke3NuYXBOYW1lfWApO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNCZWluZ0FkZGVkLnNldChzbmFwTmFtZSwgdGhpcy5fYWRkKGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc25hcHNCZWluZ0FkZGVkLmdldChzbmFwTmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIF9zdGFydFNuYXAoc25hcERhdGEpIHtcbiAgICAgICAgY29uc3QgeyBzbmFwTmFtZSB9ID0gc25hcERhdGE7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZyhzbmFwTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBcIiR7c25hcE5hbWV9XCIgaXMgYWxyZWFkeSBzdGFydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2V4ZWN1dGVTbmFwKHNuYXBEYXRhKTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblNuYXBTdGF0ZShzbmFwTmFtZSwgU25hcFN0YXR1c0V2ZW50LnN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kLiBTZWUgdGhlIFwiYWRkXCIgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYWRkIHNuYXAgYXJncy5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIHNuYXAgb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIF9hZGQoYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgbmFtZTogc25hcE5hbWUgfSA9IGFyZ3M7XG4gICAgICAgIGxldCBtYW5pZmVzdCwgc291cmNlQ29kZTtcbiAgICAgICAgaWYgKCdtYW5pZmVzdFVybCcgaW4gYXJncykge1xuICAgICAgICAgICAgY29uc3QgX3NvdXJjZVVybCA9IGFyZ3MubWFuaWZlc3RVcmwgfHwgc25hcE5hbWU7XG4gICAgICAgICAgICBbbWFuaWZlc3QsIHNvdXJjZUNvZGVdID0gYXdhaXQgdGhpcy5fZmV0Y2hTbmFwKHNuYXBOYW1lLCBfc291cmNlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmlmZXN0ID0gYXJncy5tYW5pZmVzdDtcbiAgICAgICAgICAgIHNvdXJjZUNvZGUgPSBhcmdzLnNvdXJjZUNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VDb2RlICE9PSAnc3RyaW5nJyB8fCBzb3VyY2VDb2RlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNvdXJjZSBjb2RlIGZvciBzbmFwIFwiJHtzbmFwTmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUGVybWlzc2lvbnMgPSAoX2EgPSBtYW5pZmVzdCA9PT0gbnVsbCB8fCBtYW5pZmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFuaWZlc3Qud2ViM1dhbGxldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluaXRpYWxQZXJtaXNzaW9ucztcbiAgICAgICAgaWYgKCFpbml0aWFsUGVybWlzc2lvbnMgfHxcbiAgICAgICAgICAgIHR5cGVvZiBpbml0aWFsUGVybWlzc2lvbnMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGluaXRpYWxQZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbml0aWFsIHBlcm1pc3Npb25zIGZvciBzbmFwIFwiJHtzbmFwTmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc25hcCA9IHtcbiAgICAgICAgICAgIGluaXRpYWxQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIG5hbWU6IHNuYXBOYW1lLFxuICAgICAgICAgICAgcGVybWlzc2lvbk5hbWU6IGV4cG9ydHMuU05BUF9QUkVGSVggKyBzbmFwTmFtZSxcbiAgICAgICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiBtYW5pZmVzdC52ZXJzaW9uLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogc25hcFN0YXR1c1N0YXRlTWFjaGluZUNvbmZpZy5pbml0aWFsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzbmFwc1N0YXRlID0gdGhpcy5zdGF0ZS5zbmFwcztcbiAgICAgICAgLy8gcmVzdG9yZSByZWxldmFudCBzbmFwIHN0YXRlIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAoc25hcHNTdGF0ZVtzbmFwTmFtZV0pIHtcbiAgICAgICAgICAgIHNuYXAgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNuYXBzU3RhdGVbc25hcE5hbWVdKSwgc25hcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgdGhlIHNuYXAgYmFjayBpbiBzdGF0ZVxuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnNuYXBzW3NuYXBOYW1lXSA9IHNuYXA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc25hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbWFuaWZlc3QgYW5kIHNvdXJjZSBjb2RlIG9mIGEgc25hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAuXG4gICAgICogQHBhcmFtIG1hbmlmZXN0VXJsIC0gVGhlIFVSTCBvZiB0aGUgc25hcCdzIG1hbmlmZXN0IGZpbGUuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHNuYXAgbWFuaWZlc3Qgb2JqZWN0IGFuZCB0aGUgc25hcCBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBhc3luYyBfZmV0Y2hTbmFwKHNuYXBOYW1lLCBtYW5pZmVzdFVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIHNuYXAgbWFuaWZlc3QgZnJvbTogJHttYW5pZmVzdFVybH1gKTtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBTb3VyY2UgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IHNuYXBTb3VyY2UuanNvbigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYERlc3RydWN0dXJpbmcgc25hcDogYCwgbWFuaWZlc3QpO1xuICAgICAgICAgICAgY29uc3QgeyB3ZWIzV2FsbGV0OiB7IGJ1bmRsZSB9LCB9ID0gbWFuaWZlc3Q7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgc25hcCBzb3VyY2UgY29kZSBmcm9tOiAke2J1bmRsZS51cmx9YCk7XG4gICAgICAgICAgICBjb25zdCBzbmFwQnVuZGxlID0gYXdhaXQgZmV0Y2goYnVuZGxlLnVybCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VDb2RlID0gYXdhaXQgc25hcEJ1bmRsZS50ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gW21hbmlmZXN0LCBzb3VyY2VDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2JsZW0gZmV0Y2hpbmcgc25hcCBcIiR7c25hcE5hbWV9XCI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGVzIGEgcmVxdWVzdCBmb3IgdGhlIGdpdmVuIHNuYXAncyBpbml0aWFsIHBlcm1pc3Npb25zLlxuICAgICAqIE11c3QgYmUgY2FsbGVkIGluIG9yZGVyLiBTZWUgcHJvY2Vzc1JlcXVlc3RlZFNuYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc25hcCdzIGFwcHJvdmVkUGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgYXN5bmMgYXV0aG9yaXplKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBdXRob3JpemluZyBzbmFwOiAke3NuYXBOYW1lfWApO1xuICAgICAgICBjb25zdCBzbmFwc1N0YXRlID0gdGhpcy5zdGF0ZS5zbmFwcztcbiAgICAgICAgY29uc3Qgc25hcCA9IHNuYXBzU3RhdGVbc25hcE5hbWVdO1xuICAgICAgICBjb25zdCB7IGluaXRpYWxQZXJtaXNzaW9ucyB9ID0gc25hcDtcbiAgICAgICAgLy8gRG9uJ3QgcHJvbXB0IGlmIHRoZXJlIGFyZSBubyBwZXJtaXNzaW9ucyByZXF1ZXN0ZWQ6XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhpbml0aWFsUGVybWlzc2lvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsUGVybWlzc2lvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBwcm92ZWRQZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMuX3JlcXVlc3RQZXJtaXNzaW9ucyhzbmFwTmFtZSwgaW5pdGlhbFBlcm1pc3Npb25zKTtcbiAgICAgICAgICAgIHJldHVybiBhcHByb3ZlZFBlcm1pc3Npb25zLm1hcCgocGVybSkgPT4gcGVybS5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzQmVpbmdBZGRlZC5kZWxldGUoc25hcE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgbWV0aG9kLlxuICAgICAqL1xuICAgIHJ1bklubGluZVNuYXAoaW5saW5lU25hcE5hbWUgPSAnSURMRScpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRTbmFwKHtcbiAgICAgICAgICAgIHNuYXBOYW1lOiAnaW5saW5lU25hcCcsXG4gICAgICAgICAgICBzb3VyY2VDb2RlOiBpbmxpbmVTbmFwc18xLklOTElORV9TTkFQU1tpbmxpbmVTbmFwTmFtZV0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlubGluZVNuYXBJc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBtZXRob2QuXG4gICAgICovXG4gICAgcmVtb3ZlSW5saW5lU25hcCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5pbmxpbmVTbmFwSXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZVNuYXAoJ2lubGluZVNuYXAnKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5fdGltZW91dEZvckxhc3RSZXF1ZXN0U3RhdHVzKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEZvckxhc3RSZXF1ZXN0U3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS51bnN1YnNjcmliZSgnU2VydmljZU1lc3Nlbmdlcjp1bmhhbmRsZWRFcnJvcicsIHRoaXMuX29uVW5oYW5kbGVkU25hcEVycm9yKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0udW5zdWJzY3JpYmUoJ1NlcnZpY2VNZXNzZW5nZXI6dW5yZXNwb25zaXZlJywgdGhpcy5fb25VbnJlc3BvbnNpdmVTbmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUlBDIG1lc3NhZ2UgaGFuZGxlciBmb3IgdGhlIGdpdmVuIHNuYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc25hcE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc25hcCB3aG9zZSBtZXNzYWdlIGhhbmRsZXIgdG8gZ2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJwY01lc3NhZ2VIYW5kbGVyKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSGFuZGxlciA9IHRoaXMuX3JwY0hhbmRsZXJNYXAuZ2V0KHNuYXBOYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBycGNIYW5kbGVyID0gYXN5bmMgKG9yaWdpbiwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBhd2FpdCB0aGlzLl9nZXRScGNNZXNzYWdlSGFuZGxlcihzbmFwTmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zbmFwc1tzbmFwTmFtZV0uZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBOYW1lfVwiIGlzIGRpc2FibGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc25hcHNbc25hcE5hbWVdLnN0YXR1cyA9PT0gU25hcFN0YXR1cy5pbnN0YWxsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwIFwiJHtzbmFwTmFtZX1cIiBoYXMgbm90IGJlZW4gc3RhcnRlZCB5ZXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIgJiYgdGhpcy5pc1J1bm5pbmcoc25hcE5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbGQgc3RhcnRcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0U25hcChzbmFwTmFtZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGF3YWl0IHRoaXMuX2dldFJwY01lc3NhZ2VIYW5kbGVyKHNuYXBOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcCBleGVjdXRpb24gc2VydmljZSByZXR1cm5lZCBubyBSUEMgaGFuZGxlciBmb3IgcnVubmluZyBzbmFwIFwiJHtzbmFwTmFtZX1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY29yZFNuYXBScGNSZXF1ZXN0KHNuYXBOYW1lKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtYXggcmVxdWVzdCB0aW1lXG4gICAgICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTbmFwKHNuYXBOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIHJlcXVlc3QgdGltZWQgb3V0LicpKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLl9tYXhSZXF1ZXN0VGltZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBlaXRoZXIgZ2V0IHRoZSByZXN1bHQgb3IgcmVqZWN0IGR1ZSB0byB0aGUgdGltZW91dC5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgaGFuZGxlcihvcmlnaW4sIHJlcXVlc3QpLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9ycGNIYW5kbGVyTWFwLnNldChzbmFwTmFtZSwgcnBjSGFuZGxlcik7XG4gICAgICAgIHJldHVybiBycGNIYW5kbGVyO1xuICAgIH1cbiAgICBfcmVjb3JkU25hcFJwY1JlcXVlc3Qoc25hcE5hbWUpIHtcbiAgICAgICAgdGhpcy5fbGFzdFJlcXVlc3RNYXAuc2V0KHNuYXBOYW1lLCBEYXRlLm5vdygpKTtcbiAgICB9XG59XG5leHBvcnRzLlNuYXBDb250cm9sbGVyID0gU25hcENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TbmFwQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBvYnNfc3RvcmVfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svb2JzLXN0b3JlXCIpO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IGFsd2F5c1JlcXVpcmVkRmllbGRzID0gWydmcm9tRG9tYWluJ107XG5jb25zdCBjb21wdXRlU3RhdGUgPSAoc3RvcmFnZUtleSwgaW5pdGlhbFJlc291cmNlcykgPT4ge1xuICAgIHJldHVybiB7IFtzdG9yYWdlS2V5XTogaW5pdGlhbFJlc291cmNlcyB9O1xufTtcbmNvbnN0IGdldFVuYXV0aG9yaXplZE1lc3NhZ2UgPSAoaWQpID0+IGBOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgcmVzb3VyY2Ugd2l0aCBpZCBcIiR7aWR9XCIuYDtcbi8qKlxuICogQSBjbGFzcyBpbnRlbmRlZCB0byBkZXNjcmliZSBhIHBhcnRpY3VsYXIgcmVzb3VyY2UgdGhhdCBpcyBtYW5hZ2VkIGJ5IHNuYXBzLlxuICogRXhhbXBsZSByZXNvdXJjZXMgYXJlIGFzc2V0cy5cbiAqXG4gKiBUaGVzZSBhcmUgdGhpbmdzIHRoYXQgTWV0YU1hc2sgdHJlYXRzIGFzIGZpcnN0LWNsYXNzIG9iamVjdHMgd2l0aCBkaXN0aW5jdCBwcm9wZXJ0aWVzIHdpdGhpbiBpdHMgb3duIFVJLlxuICovXG5jbGFzcyBFeHRlcm5hbFJlc291cmNlQ29udHJvbGxlciBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKHsgc3RvcmFnZUtleSwgcmVxdWlyZWRGaWVsZHMsIGluaXRpYWxSZXNvdXJjZXMsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXF1aXJlZEZpZWxkcyA9IHJlcXVpcmVkRmllbGRzO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IG9ic19zdG9yZV8xLk9ic2VydmFibGVTdG9yZShjb21wdXRlU3RhdGUoc3RvcmFnZUtleSwgaW5pdGlhbFJlc291cmNlcykpO1xuICAgIH1cbiAgICBnZXRSZXNvdXJjZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0b3JlLmdldFN0YXRlKClbdGhpcy5zdG9yYWdlS2V5XSk7XG4gICAgfVxuICAgIHNldFJlc291cmNlcyhyZXNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5zdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgICBbdGhpcy5zdG9yYWdlS2V5XTogcmVzb3VyY2VzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJSZXNvdXJjZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0UmVzb3VyY2VzKHt9KTtcbiAgICB9XG4gICAgZGVsZXRlUmVzb3VyY2VzRm9yKGZyb21Eb21haW4pIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5nZXRSZXNvdXJjZXMoKTtcbiAgICAgICAgY29uc3QgbmV3UmVzb3VyY2VzID0gT2JqZWN0LmVudHJpZXMocmVzb3VyY2VzKS5yZWR1Y2UoKGFjYywgW2lkLCByZXNvdXJjZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5mcm9tRG9tYWluICE9PSBmcm9tRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgYWNjW2lkXSA9IHJlc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLnNldFJlc291cmNlcyhuZXdSZXNvdXJjZXMpO1xuICAgIH1cbiAgICBnZXQoZnJvbURvbWFpbiwgaWQpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLmdldFJlc291cmNlcygpW2lkXTtcbiAgICAgICAgaWYgKHJlc291cmNlICYmIHJlc291cmNlLmZyb21Eb21haW4gIT09IGZyb21Eb21haW4pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2V0VW5hdXRob3JpemVkTWVzc2FnZShpZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb3VyY2UgPyBPYmplY3QuYXNzaWduKHt9LCByZXNvdXJjZSkgOiBudWxsO1xuICAgIH1cbiAgICBnZXRBbGxSZXNvdXJjZXMoZnJvbURvbWFpbikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmdldFJlc291cmNlcygpKS5maWx0ZXIoKHJlc291cmNlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2UuZnJvbURvbWFpbiA9PT0gZnJvbURvbWFpbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZChmcm9tRG9tYWluLCByZXNvdXJjZSkge1xuICAgICAgICBjb25zdCBuZXdSZXNvdXJjZSA9IHRoaXMucHJvY2Vzc05ld1Jlc291cmNlKGZyb21Eb21haW4sIHJlc291cmNlKTtcbiAgICAgICAgY29uc3QgeyBpZCB9ID0gbmV3UmVzb3VyY2U7XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuZ2V0UmVzb3VyY2VzKCk7XG4gICAgICAgIGlmIChyZXNvdXJjZXNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIHdpdGggaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb3VyY2VzW2lkXSA9IG5ld1Jlc291cmNlO1xuICAgICAgICAgICAgdGhpcy5zZXRSZXNvdXJjZXMocmVzb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UmVzb3VyY2UuaWQ7XG4gICAgfVxuICAgIHVwZGF0ZShmcm9tRG9tYWluLCByZXNvdXJjZSkge1xuICAgICAgICBjb25zdCB7IGlkIH0gPSByZXNvdXJjZTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gdGhpcy5nZXRSZXNvdXJjZXMoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvdXJjZSA9IHJlc291cmNlc1tpZF07XG4gICAgICAgIGlmICghZXhpc3RpbmdSZXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLnJlc291cmNlTm90Rm91bmQoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXNvdXJjZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQuYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nUmVzb3VyY2UuZnJvbURvbWFpbiAhPT0gZnJvbURvbWFpbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBnZXRVbmF1dGhvcml6ZWRNZXNzYWdlKGlkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc291cmNlc1tpZF0gPSB0aGlzLnByb2Nlc3NOZXdSZXNvdXJjZShmcm9tRG9tYWluLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc291cmNlc1tpZF0pLCByZXNvdXJjZSkpO1xuICAgICAgICB0aGlzLnNldFJlc291cmNlcyhyZXNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIHByb2Nlc3NOZXdSZXNvdXJjZShmcm9tRG9tYWluLCByZXNvdXJjZSkge1xuICAgICAgICB0aGlzLnJlcXVpcmVkRmllbGRzLmZvckVhY2goKHJlcXVpcmVkRmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmICghKHJlcXVpcmVkRmllbGQgaW4gcmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFJlc291cmNlIGZyb20gXCIke2Zyb21Eb21haW59XCIgbWlzc2luZyByZXF1aXJlZCBmaWVsZDogJHtyZXF1aXJlZEZpZWxkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzb3VyY2UpLCB7IGZyb21Eb21haW4sIGlkOiByZXNvdXJjZS5pZCB8fCBuYW5vaWRfMS5uYW5vaWQoKSB9KTtcbiAgICB9XG4gICAgZGVsZXRlKGZyb21Eb21haW4sIGlkKSB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuZ2V0UmVzb3VyY2VzKCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUmVzb3VyY2UgPSByZXNvdXJjZXNbaWRdO1xuICAgICAgICBpZiAoIWV4aXN0aW5nUmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVzb3VyY2Ugd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ1Jlc291cmNlLmZyb21Eb21haW4gIT09IGZyb21Eb21haW4pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2V0VW5hdXRob3JpemVkTWVzc2FnZShpZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgcmVzb3VyY2VzW2lkXTtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZXMocmVzb3VyY2VzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGhhbmRsZVJwY1JlcXVlc3QoZnJvbURvbWFpbiwgbWV0aG9kLCBhcmcpIHtcbiAgICAgICAgaWYgKCFmcm9tRG9tYWluIHx8IHR5cGVvZiBmcm9tRG9tYWluICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZyb21Eb21haW4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGZyb21Eb21haW4sIGFyZyk7XG4gICAgICAgICAgICBjYXNlICdnZXRBbGwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbFJlc291cmNlcyhmcm9tRG9tYWluKTtcbiAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGZyb21Eb21haW4sIGFyZyk7XG4gICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShmcm9tRG9tYWluLCBhcmcpO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoZnJvbURvbWFpbiwgYXJnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vdCBhbiBhc3NldCBtZXRob2Q6ICR7bWV0aG9kfWAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsUmVzb3VyY2VDb250cm9sbGVyID0gRXh0ZXJuYWxSZXNvdXJjZUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRlcm5hbFJlc291cmNlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4ZWN1dGlvbkVudmlyb25tZW50U2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViV29ya2VyRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlID0gdm9pZCAwO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgcHVtcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwdW1wXCIpKTtcbmNvbnN0IG9ic19zdG9yZV8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9vYnMtc3RvcmVcIik7XG5jb25zdCBvYmplY3RfbXVsdGlwbGV4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9vYmplY3QtbXVsdGlwbGV4XCIpKTtcbmNvbnN0IHBvc3RfbWVzc2FnZV9zdHJlYW1fMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svcG9zdC1tZXNzYWdlLXN0cmVhbVwiKTtcbmNvbnN0IHNuYXBfd29ya2Vyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zbmFwLXdvcmtlcnNcIik7XG5jb25zdCBqc29uX3JwY19taWRkbGV3YXJlX3N0cmVhbV8xID0gcmVxdWlyZShcImpzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtXCIpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY2xhc3MgV2ViV29ya2VyRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNldHVwU25hcFByb3ZpZGVyLCB3b3JrZXJVcmwsIG1lc3NlbmdlciwgdW5yZXNwb25zaXZlUG9sbGluZ0ludGVydmFsID0gNTAwMCwgdW5yZXNwb25zaXZlVGltZW91dCA9IDMwMDAwLCB9KSB7XG4gICAgICAgIHRoaXMud29ya2VyVXJsID0gd29ya2VyVXJsO1xuICAgICAgICB0aGlzLnNldHVwU25hcFByb3ZpZGVyID0gc2V0dXBTbmFwUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBuZXcgb2JzX3N0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlKHsgd29ya2Vyczoge30gfSk7XG4gICAgICAgIHRoaXMud29ya2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zbmFwVG9Xb3JrZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMud29ya2VyVG9TbmFwTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zbmFwUnBjSG9va3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX21lc3NlbmdlciA9IG1lc3NlbmdlcjtcbiAgICAgICAgdGhpcy5fdW5yZXNwb25zaXZlUG9sbGluZ0ludGVydmFsID0gdW5yZXNwb25zaXZlUG9sbGluZ0ludGVydmFsO1xuICAgICAgICB0aGlzLl91bnJlc3BvbnNpdmVUaW1lb3V0ID0gdW5yZXNwb25zaXZlVGltZW91dDtcbiAgICAgICAgdGhpcy5fdGltZW91dEZvclVucmVzcG9uc2l2ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgX3NldFdvcmtlcih3b3JrZXJJZCwgd29ya2VyV3JhcHBlcikge1xuICAgICAgICB0aGlzLndvcmtlcnMuc2V0KHdvcmtlcklkLCB3b3JrZXJXcmFwcGVyKTtcbiAgICAgICAgY29uc3QgbmV3V29ya2VyU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS53b3JrZXJzKSwgeyBbd29ya2VySWRdOiB3b3JrZXJXcmFwcGVyIH0pO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgd29ya2VyczogbmV3V29ya2VyU3RhdGUgfSk7XG4gICAgfVxuICAgIF9kZWxldGVXb3JrZXIod29ya2VySWQpIHtcbiAgICAgICAgdGhpcy53b3JrZXJzLmRlbGV0ZSh3b3JrZXJJZCk7XG4gICAgICAgIGNvbnN0IG5ld1dvcmtlclN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLndvcmtlcnMpO1xuICAgICAgICBkZWxldGUgbmV3V29ya2VyU3RhdGVbd29ya2VySWRdO1xuICAgICAgICB0aGlzLnN0b3JlLnVwZGF0ZVN0YXRlKHsgd29ya2VyczogbmV3V29ya2VyU3RhdGUgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9jb21tYW5kKHdvcmtlcklkLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzZW5kIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JrZXJXcmFwcGVyID0gdGhpcy53b3JrZXJzLmdldCh3b3JrZXJJZCk7XG4gICAgICAgIGlmICghd29ya2VyV3JhcHBlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXb3JrZXIgd2l0aCBpZCAke3dvcmtlcklkfSBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ1BhcmVudDogU2VuZGluZyBDb21tYW5kJywgbWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd29ya2VyV3JhcHBlci5ycGNFbmdpbmUuaGFuZGxlKG1lc3NhZ2UpO1xuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyB0ZXJtaW5hdGVBbGxTbmFwcygpIHtcbiAgICAgICAgZm9yIChjb25zdCB3b3JrZXJJZCBvZiB0aGlzLndvcmtlcnMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSh3b3JrZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc25hcFJwY0hvb2tzLmNsZWFyKCk7XG4gICAgfVxuICAgIGFzeW5jIHRlcm1pbmF0ZVNuYXAoc25hcE5hbWUpIHtcbiAgICAgICAgY29uc3Qgd29ya2VySWQgPSB0aGlzLnNuYXBUb1dvcmtlck1hcC5nZXQoc25hcE5hbWUpO1xuICAgICAgICB3b3JrZXJJZCAmJiB0aGlzLnRlcm1pbmF0ZSh3b3JrZXJJZCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNuYXBIb29rcyhzbmFwTmFtZSk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSh3b3JrZXJJZCkge1xuICAgICAgICBjb25zdCB3b3JrZXJXcmFwcGVyID0gdGhpcy53b3JrZXJzLmdldCh3b3JrZXJJZCk7XG4gICAgICAgIGlmICghd29ya2VyV3JhcHBlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXb3JrZXIgd2l0aCBpZCBcIiR7d29ya2VySWR9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuYXBOYW1lID0gdGhpcy5fZ2V0U25hcEZvcldvcmtlcih3b3JrZXJJZCk7XG4gICAgICAgIGlmICghc25hcE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYSBzbmFwIGZvciB3b3JrZXIgd2l0aCBpZCBcIiR7d29ya2VySWR9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnZhbHVlcyh3b3JrZXJXcmFwcGVyLnN0cmVhbXMpLmZvckVhY2goKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAhc3RyZWFtLmRlc3Ryb3llZCAmJiBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igd2hpbGUgZGVzdHJveWluZyBzdHJlYW0nLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyV3JhcHBlci53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNuYXBBbmRXb3JrZXJNYXBwaW5nKHdvcmtlcklkKTtcbiAgICAgICAgdGhpcy5fZGVsZXRlV29ya2VyKHdvcmtlcklkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRGb3JVbnJlc3BvbnNpdmVNYXAuZ2V0KHdvcmtlcklkKSk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRGb3JVbnJlc3BvbnNpdmVNYXAuZGVsZXRlKHdvcmtlcklkKTtcbiAgICAgICAgY29uc29sZS5sb2coYHdvcmtlcjoke3dvcmtlcklkfSB0ZXJtaW5hdGVkYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJQQyBtZXNzYWdlIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBzbmFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNuYXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNuYXAgd2hvc2UgbWVzc2FnZSBoYW5kbGVyIHRvIGdldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRScGNNZXNzYWdlSGFuZGxlcihzbmFwTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc25hcFJwY0hvb2tzLmdldChzbmFwTmFtZSk7XG4gICAgfVxuICAgIF9yZW1vdmVTbmFwSG9va3Moc25hcE5hbWUpIHtcbiAgICAgICAgdGhpcy5fc25hcFJwY0hvb2tzLmRlbGV0ZShzbmFwTmFtZSk7XG4gICAgfVxuICAgIF9jcmVhdGVTbmFwSG9va3Moc25hcE5hbWUsIHdvcmtlcklkKSB7XG4gICAgICAgIGNvbnN0IHJwY0hvb2sgPSBhc3luYyAob3JpZ2luLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY29tbWFuZCh3b3JrZXJJZCwge1xuICAgICAgICAgICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdzbmFwUnBjJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNuYXBOYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc25hcFJwY0hvb2tzLnNldChzbmFwTmFtZSwgcnBjSG9vayk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGVTbmFwKHNuYXBEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLnNuYXBUb1dvcmtlck1hcC5oYXMoc25hcERhdGEuc25hcE5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXAgXCIke3NuYXBEYXRhLnNuYXBOYW1lfVwiIGlzIGFscmVhZHkgYmVpbmcgZXhlY3V0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5faW5pdFdvcmtlcigpO1xuICAgICAgICB0aGlzLl9tYXBTbmFwQW5kV29ya2VyKHNuYXBEYXRhLnNuYXBOYW1lLCB3b3JrZXIuaWQpO1xuICAgICAgICB0aGlzLnNldHVwU25hcFByb3ZpZGVyKHNuYXBEYXRhLnNuYXBOYW1lLCB3b3JrZXIuc3RyZWFtcy5ycGMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9jb21tYW5kKHdvcmtlci5pZCwge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdleGVjdXRlU25hcCcsXG4gICAgICAgICAgICBwYXJhbXM6IHNuYXBEYXRhLFxuICAgICAgICAgICAgaWQ6IG5hbm9pZF8xLm5hbm9pZCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IHVwIHBvbGwvcGluZyBmb3Igc3RhdHVzIHRvIHNlZSBpZiBpdHMgdXAsIGlmIGl0cyBub3QgdGhlbiBlbWl0IGV2ZW50IHRoYXQgaXQgY2FudCBiZSByZWFjaGVkXG4gICAgICAgIHRoaXMuX3BvbGxGb3JXb3JrZXJTdGF0dXMoc25hcERhdGEuc25hcE5hbWUpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTbmFwSG9va3Moc25hcERhdGEuc25hcE5hbWUsIHdvcmtlci5pZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wb2xsRm9yV29ya2VyU3RhdHVzKHNuYXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcklkID0gdGhpcy5fZ2V0V29ya2VyRm9yU25hcChzbmFwTmFtZSk7XG4gICAgICAgIGlmICghd29ya2VySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gd29ya2VyIGlkIGZvdW5kIGZvciBzbmFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZ2V0V29ya2VyU3RhdHVzKHdvcmtlcklkKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsRm9yV29ya2VyU3RhdHVzKHNuYXBOYW1lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZXNzZW5nZXIucHVibGlzaCgnU2VydmljZU1lc3Nlbmdlcjp1bnJlc3BvbnNpdmUnLCBzbmFwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcy5fdW5yZXNwb25zaXZlUG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgdGhpcy5fdGltZW91dEZvclVucmVzcG9uc2l2ZU1hcC5zZXQoc25hcE5hbWUsIHRpbWVvdXQpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0V29ya2VyU3RhdHVzKHdvcmtlcklkKSB7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3BpbmcgcmVxdWVzdCB0aW1lZCBvdXQnKSk7XG4gICAgICAgIH0sIHRoaXMuX3VucmVzcG9uc2l2ZVRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHRoaXMuX2NvbW1hbmQod29ya2VySWQsIHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgIGlkOiBuYW5vaWRfMS5uYW5vaWQoKSxcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgX21hcFNuYXBBbmRXb3JrZXIoc25hcE5hbWUsIHdvcmtlcklkKSB7XG4gICAgICAgIHRoaXMuc25hcFRvV29ya2VyTWFwLnNldChzbmFwTmFtZSwgd29ya2VySWQpO1xuICAgICAgICB0aGlzLndvcmtlclRvU25hcE1hcC5zZXQod29ya2VySWQsIHNuYXBOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSBzbmFwJ3Mgd29ya2VyLlxuICAgICAqL1xuICAgIF9nZXRXb3JrZXJGb3JTbmFwKHNuYXBOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNuYXBUb1dvcmtlck1hcC5nZXQoc25hcE5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgSUQgd29ya2VyJ3Mgc25hcC5cbiAgICAgKi9cbiAgICBfZ2V0U25hcEZvcldvcmtlcih3b3JrZXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53b3JrZXJUb1NuYXBNYXAuZ2V0KHdvcmtlcklkKTtcbiAgICB9XG4gICAgX3JlbW92ZVNuYXBBbmRXb3JrZXJNYXBwaW5nKHdvcmtlcklkKSB7XG4gICAgICAgIGNvbnN0IHNuYXBOYW1lID0gdGhpcy53b3JrZXJUb1NuYXBNYXAuZ2V0KHdvcmtlcklkKTtcbiAgICAgICAgaWYgKCFzbmFwTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JrZXI6JHt3b3JrZXJJZH0gaGFzIG5vIG1hcHBlZCBzbmFwLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya2VyVG9TbmFwTWFwLmRlbGV0ZSh3b3JrZXJJZCk7XG4gICAgICAgIHRoaXMuc25hcFRvV29ya2VyTWFwLmRlbGV0ZShzbmFwTmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbml0V29ya2VyKCkge1xuICAgICAgICBjb25zdCB3b3JrZXJJZCA9IG5hbm9pZF8xLm5hbm9pZCgpO1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHRoaXMud29ya2VyVXJsLCB7XG4gICAgICAgICAgICBuYW1lOiB3b3JrZXJJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhhbmRsZSBvdXQtb2YtYmFuZCBlcnJvcnMsIGkuZS4gZXJyb3JzIHRocm93biBmcm9tIHRoZSBzbmFwIG91dHNpZGUgb2YgdGhlIHJlcS9yZXMgY3ljbGUuXG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21lc3Nlbmdlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBOYW1lID0gdGhpcy53b3JrZXJUb1NuYXBNYXAuZ2V0KHdvcmtlcklkKTtcbiAgICAgICAgICAgICAgICBpZiAoc25hcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2VuZ2VyLnB1Ymxpc2goJ1NlcnZpY2VNZXNzZW5nZXI6dW5oYW5kbGVkRXJyb3InLCBzbmFwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZXYuZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGV2LmVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBldi5lcnJvci5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBzdHJlYW1zID0gdGhpcy5faW5pdFdvcmtlclN0cmVhbXMod29ya2VyLCB3b3JrZXJJZCk7XG4gICAgICAgIGNvbnN0IHJwY0VuZ2luZSA9IG5ldyBqc29uX3JwY19lbmdpbmVfMS5Kc29uUnBjRW5naW5lKCk7XG4gICAgICAgIGNvbnN0IGpzb25ScGNDb25uZWN0aW9uID0ganNvbl9ycGNfbWlkZGxld2FyZV9zdHJlYW1fMS5jcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCk7XG4gICAgICAgIHB1bXBfMS5kZWZhdWx0KGpzb25ScGNDb25uZWN0aW9uLnN0cmVhbSwgc3RyZWFtcy5jb21tYW5kLCBqc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0pO1xuICAgICAgICBycGNFbmdpbmUucHVzaChqc29uUnBjQ29ubmVjdGlvbi5taWRkbGV3YXJlKTtcbiAgICAgICAgY29uc3Qgd29ya2VyV3JhcHBlciA9IHtcbiAgICAgICAgICAgIGlkOiB3b3JrZXJJZCxcbiAgICAgICAgICAgIHN0cmVhbXMsXG4gICAgICAgICAgICBycGNFbmdpbmUsXG4gICAgICAgICAgICB3b3JrZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NldFdvcmtlcih3b3JrZXJJZCwgd29ya2VyV3JhcHBlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NvbW1hbmQod29ya2VySWQsIHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kOiAncGluZycsXG4gICAgICAgICAgICBpZDogbmFub2lkXzEubmFub2lkKCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyV3JhcHBlcjtcbiAgICB9XG4gICAgX2luaXRXb3JrZXJTdHJlYW1zKHdvcmtlciwgd29ya2VySWQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyU3RyZWFtID0gbmV3IHBvc3RfbWVzc2FnZV9zdHJlYW1fMS5Xb3JrZXJQYXJlbnRQb3N0TWVzc2FnZVN0cmVhbSh7IHdvcmtlciB9KTtcbiAgICAgICAgLy8gVHlwZWNhc3QganVzdGlmaWNhdGlvbjogc3RyZWFtIHR5cGUgbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgod29ya2VyU3RyZWFtLCBgV29ya2VyOiR7d29ya2VySWR9YCk7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKHNuYXBfd29ya2Vyc18xLlNOQVBfU1RSRUFNX05BTUVTLkNPTU1BTkQpO1xuICAgICAgICBjb25zdCBycGNTdHJlYW0gPSBtdXguY3JlYXRlU3RyZWFtKHNuYXBfd29ya2Vyc18xLlNOQVBfU1RSRUFNX05BTUVTLkpTT05fUlBDKTtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IHN0cmVhbSB0eXBlIG1pc21hdGNoXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kU3RyZWFtLFxuICAgICAgICAgICAgcnBjOiBycGNTdHJlYW0sXG4gICAgICAgICAgICBfY29ubmVjdGlvbjogd29ya2VyU3RyZWFtLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViV29ya2VyRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlID0gV2ViV29ya2VyRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlO1xuLyoqXG4gKiBTZXRzIHVwIHN0cmVhbSBtdWx0aXBsZXhpbmcgZm9yIHRoZSBnaXZlbiBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHthbnl9IGNvbm5lY3Rpb25TdHJlYW0gLSB0aGUgc3RyZWFtIHRvIG11eFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmVhbU5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtLCBmb3IgaWRlbnRpZmljYXRpb24gaW4gZXJyb3JzXG4gKiBAcmV0dXJuIHtzdHJlYW0uU3RyZWFtfSB0aGUgbXVsdGlwbGV4ZWQgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0sIHN0cmVhbU5hbWUpIHtcbiAgICBjb25zdCBtdXggPSBuZXcgb2JqZWN0X211bHRpcGxleF8xLmRlZmF1bHQoKTtcbiAgICBwdW1wXzEuZGVmYXVsdChjb25uZWN0aW9uU3RyZWFtLCBcbiAgICAvLyBUeXBlY2FzdDogc3RyZWFtIHR5cGUgbWlzbWF0Y2hcbiAgICBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgc3RyZWFtTmFtZVxuICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihgJHtzdHJlYW1OYW1lfSBzdHJlYW0gZmFpbHVyZS5gLCBlcnIpXG4gICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbXV4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViV29ya2VyRXhlY3V0aW9uRW52aXJvbm1lbnRTZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXRob2ROYW1lcyA9IHZvaWQgMDtcbnZhciBNZXRob2ROYW1lcztcbihmdW5jdGlvbiAoTWV0aG9kTmFtZXMpIHtcbiAgICBNZXRob2ROYW1lc1tcInJlcXVlc3RQZXJtaXNzaW9uc1wiXSA9IFwid2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9uc1wiO1xuICAgIE1ldGhvZE5hbWVzW1wiZ2V0UGVybWlzc2lvbnNcIl0gPSBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiO1xufSkoTWV0aG9kTmFtZXMgPSBleHBvcnRzLk1ldGhvZE5hbWVzIHx8IChleHBvcnRzLk1ldGhvZE5hbWVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maW5kQ2F2ZWF0ID0gZXhwb3J0cy5jb25zdHJ1Y3RQZXJtaXNzaW9uID0gdm9pZCAwO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBwZXJtaXNzaW9uIGZhY3RvcnkgZnVuY3Rpb24uIE5haXZlbHkgY29uc3RydWN0cyBhIHBlcm1pc3Npb24gZnJvbVxuICogdGhlIGlucHV0cy4gU2V0cyBhIGRlZmF1bHQsIHJhbmRvbSBgaWRgIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbn0gRm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAdGVtcGxhdGUgVGFyZ2V0UGVybWlzc2lvbiAtIFRoZSB7QGxpbmsgUGVybWlzc2lvbn0gdGhhdCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBlcm1pc3Npb24uXG4gKiBAcmV0dXJucyBUaGUgbmV3IHBlcm1pc3Npb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RQZXJtaXNzaW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNhdmVhdHMgPSBudWxsLCBpbnZva2VyLCB0YXJnZXQgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IG5hbm9pZF8xLm5hbm9pZCgpLFxuICAgICAgICBwYXJlbnRDYXBhYmlsaXR5OiB0YXJnZXQsXG4gICAgICAgIGludm9rZXIsXG4gICAgICAgIGNhdmVhdHMsXG4gICAgICAgIGRhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgIH07XG59XG5leHBvcnRzLmNvbnN0cnVjdFBlcm1pc3Npb24gPSBjb25zdHJ1Y3RQZXJtaXNzaW9uO1xuLyoqXG4gKiBHZXRzIHRoZSBjYXZlYXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGJlbG9uZ2luZyB0byB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uXG4gKlxuICogQHBhcmFtIHBlcm1pc3Npb24gVGhlIHBlcm1pc3Npb24gd2hvc2UgY2F2ZWF0IHRvIHJldHJpZXZlLlxuICogQHBhcmFtIGNhdmVhdFR5cGUgVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm5zIFRoZSBjYXZlYXQsIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoIGNhdmVhdCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIGZpbmRDYXZlYXQocGVybWlzc2lvbiwgY2F2ZWF0VHlwZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gcGVybWlzc2lvbi5jYXZlYXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoY2F2ZWF0KSA9PiBjYXZlYXQudHlwZSA9PT0gY2F2ZWF0VHlwZSk7XG59XG5leHBvcnRzLmZpbmRDYXZlYXQgPSBmaW5kQ2F2ZWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVybWlzc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb3JhdGVXaXRoQ2F2ZWF0cyA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBEZWNvcmF0ZSBhIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uIHdpdGggaXRzIGNhdmVhdHMuXG4gKlxuICogTm90ZSB0aGF0IGFsbCBjYXZlYXQgZnVuY3Rpb25zIChpLmUuIHRoZSBhcmd1bWVudCBhbmQgcmV0dXJuIHZhbHVlIG9mIHRoZVxuICogZGVjb3JhdG9yKSBtdXN0IGJlIGF3YWl0ZWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29yYXRlV2l0aENhdmVhdHMobWV0aG9kSW1wbGVtZW50YXRpb24sIHBlcm1pc3Npb24sIC8vIGJvdW5kIHRvIHRoZSByZXF1ZXN0aW5nIG9yaWdpblxuY2F2ZWF0U3BlY2lmaWNhdGlvbnMpIHtcbiAgICBjb25zdCB7IGNhdmVhdHMgfSA9IHBlcm1pc3Npb247XG4gICAgaWYgKCFjYXZlYXRzKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RJbXBsZW1lbnRhdGlvbjtcbiAgICB9XG4gICAgbGV0IGRlY29yYXRlZCA9IGFzeW5jIChhcmdzKSA9PiBtZXRob2RJbXBsZW1lbnRhdGlvbihhcmdzKTtcbiAgICBmb3IgKGNvbnN0IGNhdmVhdCBvZiBjYXZlYXRzKSB7XG4gICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSBjYXZlYXRTcGVjaWZpY2F0aW9uc1tjYXZlYXQudHlwZV07XG4gICAgICAgIGlmICghc3BlY2lmaWNhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvcihjYXZlYXQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb3JhdGVkID0gc3BlY2lmaWNhdGlvbi5kZWNvcmF0b3IoZGVjb3JhdGVkLCBjYXZlYXQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb3JhdGVkO1xufVxuZXhwb3J0cy5kZWNvcmF0ZVdpdGhDYXZlYXRzID0gZGVjb3JhdGVXaXRoQ2F2ZWF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdmVhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFuZGxlcnMgPSB2b2lkIDA7XG5jb25zdCByZXF1ZXN0UGVybWlzc2lvbnNfMSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RQZXJtaXNzaW9uc1wiKTtcbmNvbnN0IGdldFBlcm1pc3Npb25zXzEgPSByZXF1aXJlKFwiLi9nZXRQZXJtaXNzaW9uc1wiKTtcbmV4cG9ydHMuaGFuZGxlcnMgPSBbcmVxdWVzdFBlcm1pc3Npb25zXzEucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciwgZ2V0UGVybWlzc2lvbnNfMS5nZXRQZXJtaXNzaW9uc0hhbmRsZXJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25Db250cm9sbGVyID0gZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlcnNcIik7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuY29uc3QgZGVlcF9mcmVlemVfc3RyaWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlZXAtZnJlZXplLXN0cmljdFwiKSk7XG5jb25zdCBpbW1lcl8xID0gcmVxdWlyZShcImltbWVyXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IENhdmVhdF8xID0gcmVxdWlyZShcIi4vQ2F2ZWF0XCIpO1xuY29uc3QgUGVybWlzc2lvbl8xID0gcmVxdWlyZShcIi4vUGVybWlzc2lvblwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgcGVybWlzc2lvbl9taWRkbGV3YXJlXzEgPSByZXF1aXJlKFwiLi9wZXJtaXNzaW9uLW1pZGRsZXdhcmVcIik7XG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXJ9LlxuICovXG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdQZXJtaXNzaW9uQ29udHJvbGxlcic7XG4vKipcbiAqIEdldCB0aGUgc3RhdGUgbWV0YWRhdGEgb2YgdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uXG4gKlxuICogQHRlbXBsYXRlIFBlcm1pc3Npb24gLSBUaGUgY29udHJvbGxlcidzIHBlcm1pc3Npb24gdHlwZSB1bmlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4geyBzdWJqZWN0czogeyBhbm9ueW1vdXM6IHRydWUsIHBlcnNpc3Q6IHRydWUgfSB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uXG4gKlxuICogQHRlbXBsYXRlIFBlcm1pc3Npb24gLSBUaGUgY29udHJvbGxlcidzIHBlcm1pc3Npb24gdHlwZSB1bmlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0YXRlKCkge1xuICAgIHJldHVybiB7IHN1YmplY3RzOiB7fSB9O1xufVxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHBvc3NpYmxlIHJlc3VsdHMgb2YgYSB7QGxpbmsgQ2F2ZWF0TXV0YXRvcn0gZnVuY3Rpb24uXG4gKi9cbnZhciBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uO1xuKGZ1bmN0aW9uIChDYXZlYXRNdXRhdG9yT3BlcmF0aW9uKSB7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1wibm9vcFwiXSA9IDBdID0gXCJub29wXCI7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1widXBkYXRlVmFsdWVcIl0gPSAxXSA9IFwidXBkYXRlVmFsdWVcIjtcbiAgICBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW0NhdmVhdE11dGF0b3JPcGVyYXRpb25bXCJkZWxldGVDYXZlYXRcIl0gPSAyXSA9IFwiZGVsZXRlQ2F2ZWF0XCI7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1wicmV2b2tlUGVybWlzc2lvblwiXSA9IDNdID0gXCJyZXZva2VQZXJtaXNzaW9uXCI7XG59KShDYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0gZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uIHx8IChleHBvcnRzLkNhdmVhdE11dGF0b3JPcGVyYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgcGVybWlzc2lvbiBjb250cm9sbGVyLiBTZWUgdGhlIFJFQURNRSBmb3IgZGV0YWlscy5cbiAqXG4gKiBBc3N1bWVzIHRoZSBleGlzdGVuY2Ugb2YgYW4ge0BsaW5rIEFwcHJvdmFsQ29udHJvbGxlcn0gcmVhY2hhYmxlIHZpYSB0aGVcbiAqIHtAbGluayBDb250cm9sbGVyTWVzc2VuZ2VyfS5cbiAqXG4gKiBAdGVtcGxhdGUgQ29udHJvbGxlclBlcm1pc3Npb25TcGVjaWZpY2F0aW9uIC0gQSB1bmlvbiBvZiB0aGUgdHlwZXMgb2YgYWxsXG4gKiBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlci4gQW55IHJlZmVyZW5jZWQgY2F2ZWF0c1xuICogbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgY29udHJvbGxlcidzIGNhdmVhdCBzcGVjaWZpY2F0aW9ucy5cbiAqIEB0ZW1wbGF0ZSBDb250cm9sbGVyQ2F2ZWF0U3BlY2lmaWNhdGlvbiAtIEEgdW5pb24gb2YgdGhlIHR5cGVzIG9mIGFsbFxuICogY2F2ZWF0IHNwZWNpZmljYXRpb25zIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlci5cbiAqL1xuY2xhc3MgUGVybWlzc2lvbkNvbnRyb2xsZXIgZXh0ZW5kcyBjb250cm9sbGVyc18xLkJhc2VDb250cm9sbGVyVjIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUGVybWlzc2lvbiBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2F2ZWF0U3BlY2lmaWNhdGlvbnMgLSBUaGUgc3BlY2lmaWNhdGlvbnMgb2YgYWxsIGNhdmVhdHNcbiAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuIFNlZSB7QGxpbmsgQ2F2ZWF0U3BlY2lmaWNhdGlvbk1hcH0gYW5kIHRoZVxuICAgICAqIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMgLSBUaGUgc3BlY2lmaWNhdGlvbnMgb2YgYWxsXG4gICAgICogcGVybWlzc2lvbnMgYXZhaWxhYmxlIHRvIHRoZSBjb250cm9sbGVyLiBTZWVcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvblNwZWNpZmljYXRpb25NYXB9IGFuZCB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudW5yZXN0cmljdGVkTWV0aG9kcyAtIFRoZSBjYWxsYWJsZSBuYW1lcyBvZiBhbGwgSlNPTi1SUENcbiAgICAgKiBtZXRob2RzIGlnbm9yZWQgYnkgdGhlIG5ldyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyIG1lc3Nlbmdlci4gU2VlXG4gICAgICoge0BsaW5rIEJhc2VDb250cm9sbGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEV4aXN0aW5nIHN0YXRlIHRvIGh5ZHJhdGUgdGhlIGNvbnRyb2xsZXIgd2l0aCBhdFxuICAgICAqIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjYXZlYXRTcGVjaWZpY2F0aW9ucywgcGVybWlzc2lvblNwZWNpZmljYXRpb25zLCB1bnJlc3RyaWN0ZWRNZXRob2RzLCBtZXNzZW5nZXIsIHN0YXRlID0ge30sIH0gPSBvcHRpb25zO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBnZXRTdGF0ZU1ldGFkYXRhKCksXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXREZWZhdWx0U3RhdGUoKSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VucmVzdHJpY3RlZE1ldGhvZHMgPSBuZXcgU2V0KHVucmVzdHJpY3RlZE1ldGhvZHMpO1xuICAgICAgICB0aGlzLl9jYXZlYXRTcGVjaWZpY2F0aW9ucyA9IGRlZXBfZnJlZXplX3N0cmljdF8xLmRlZmF1bHQoT2JqZWN0LmFzc2lnbih7fSwgY2F2ZWF0U3BlY2lmaWNhdGlvbnMpKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyhwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRoaXMuX2NhdmVhdFNwZWNpZmljYXRpb25zKTtcbiAgICAgICAgdGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zID0gZGVlcF9mcmVlemVfc3RyaWN0XzEuZGVmYXVsdChPYmplY3QuYXNzaWduKHt9LCBwZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMpKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlID0gcGVybWlzc2lvbl9taWRkbGV3YXJlXzEuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5KHtcbiAgICAgICAgICAgIGV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kOiB0aGlzLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0UmVzdHJpY3RlZE1ldGhvZDogdGhpcy5nZXRSZXN0cmljdGVkTWV0aG9kLmJpbmQodGhpcyksXG4gICAgICAgICAgICBpc1VucmVzdHJpY3RlZE1ldGhvZDogdGhpcy51bnJlc3RyaWN0ZWRNZXRob2RzLmhhcy5iaW5kKHRoaXMudW5yZXN0cmljdGVkTWV0aG9kcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZXMgb2YgYWxsIEpTT04tUlBDIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgZ2V0IHVucmVzdHJpY3RlZE1ldGhvZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnJlc3RyaWN0ZWRNZXRob2RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldEtleSAtIFRoZSB0YXJnZXQga2V5IG9mIHRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHRhcmdldCBrZXkuXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnNbdGFyZ2V0S2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNhdmVhdCBzcGVjaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjYXZlYXQgc3BlY2lmaWNhdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRDYXZlYXRTcGVjaWZpY2F0aW9uKGNhdmVhdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhdmVhdFNwZWNpZmljYXRpb25zW2NhdmVhdFR5cGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgZm9yIHZhbGlkYXRpbmcgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9ucy4gVGhpcyBpc1xuICAgICAqIGludGVuZGVkIHRvIHByZXZlbnQgdGhlIHVzZSBvZiBpbnZhbGlkIHRhcmdldCBrZXlzIHdoaWNoLCB3aGlsZSBpbXBvc3NpYmxlXG4gICAgICogdG8gYWRkIGluIFR5cGVTY3JpcHQsIGNvdWxkIHJhdGhlciBlYXNpbHkgb2NjdXIgaW4gcGxhaW4gSmF2YVNjcmlwdC5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyAtIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIHBhc3NlZCB0b1xuICAgICAqIHRoaXMgY29udHJvbGxlcidzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBjYXZlYXRTcGVjaWZpY2F0aW9ucyAtIFRoZSBjYXZlYXQgc3BlY2lmaWNhdGlvbnMgcGFzc2VkIHRvIHRoaXNcbiAgICAgKiBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUGVybWlzc2lvblNwZWNpZmljYXRpb25zKHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgY2F2ZWF0U3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGVybWlzc2lvblNwZWNpZmljYXRpb25zKS5mb3JFYWNoKChbdGFyZ2V0S2V5LCB7IHRhcmdldEtleTogaW5uZXJUYXJnZXRLZXksIGFsbG93ZWRDYXZlYXRzIH1dKSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGtleSBpcyB0aGUgZW1wdHkgc3RyaW5nLCBlbmRzIHdpdGggXCJfXCIsIG9yIGVuZHNcbiAgICAgICAgICAgIC8vIHdpdGggXCIqXCIgYnV0IG5vdCBcIl8qXCJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0S2V5IHx8IC9fJC91LnRlc3QodGFyZ2V0S2V5KSB8fCAvW15fXVxcKiQvdS50ZXN0KHRhcmdldEtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVybWlzc2lvbiB0YXJnZXQga2V5OiBcIiR7dGFyZ2V0S2V5fVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0S2V5ICE9PSBpbm5lclRhcmdldEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb246IGtleSBcIiR7dGFyZ2V0S2V5fVwiIG11c3QgbWF0Y2ggc3BlY2lmaWNhdGlvbi50YXJnZXQgdmFsdWUgXCIke2lubmVyVGFyZ2V0S2V5fVwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93ZWRDYXZlYXRzKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZENhdmVhdHMuZm9yRWFjaCgoY2F2ZWF0VHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkoY2F2ZWF0U3BlY2lmaWNhdGlvbnMsIGNhdmVhdFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yKGNhdmVhdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgZm9yIHJlZ2lzdGVyaW5nIHRoZSBjb250cm9sbGVyJ3MgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIGFjdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Y2xlYXJQZXJtaXNzaW9uc2AsICgpID0+IHRoaXMuY2xlYXJTdGF0ZSgpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpnZXRTdWJqZWN0TmFtZXNgLCAoKSA9PiB0aGlzLmdldFN1YmplY3ROYW1lcygpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpoYXNQZXJtaXNzaW9uc2AsIChvcmlnaW4pID0+IHRoaXMuaGFzUGVybWlzc2lvbnMob3JpZ2luKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3RhdGUgb2YgdGhlIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY2xlYXJTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKF9kcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFN0YXRlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCByZXN0cmljdGVkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEEgSlNPTi1SUEMgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0gYW5kXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlfSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSByZXN0cmljdGVkIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QgZm9yIHRoZSByZXN0cmljdGVkXG4gICAgICogbWV0aG9kLCBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGdldFJlc3RyaWN0ZWRNZXRob2QobWV0aG9kLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkobWV0aG9kKTtcbiAgICAgICAgaWYgKCF0YXJnZXRLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JzXzEubWV0aG9kTm90Rm91bmQoeyBtZXRob2QgfSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHsgb3JpZ2luIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbih0YXJnZXRLZXkpLm1ldGhvZEltcGxlbWVudGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgb3JpZ2lucyAoaS5lLiBJRHMpIG9mIGFsbCBzdWJqZWN0cy5cbiAgICAgKi9cbiAgICBnZXRTdWJqZWN0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLnN1YmplY3RzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGVybWlzc2lvbiBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgb2YgdGhlIHN1YmplY3QgY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgb3JpZ2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbWV0aG9kIG5hbWUgYXMgaW52b2tlZCBieSBhIHRoaXJkIHBhcnR5IChpLmUuLCBub3RcbiAgICAgKiBhIG1ldGhvZCBrZXkpLlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJtaXNzaW9uIGlmIGl0IGV4aXN0cywgb3IgdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0TmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0YXRlLnN1YmplY3RzW29yaWdpbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZXJtaXNzaW9uc1t0YXJnZXROYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgcGVybWlzc2lvbnMgZm9yIHRoZSBzcGVjaWZpZWQgc3ViamVjdCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIHBlcm1pc3Npb25zIG9mIHRoZSBzdWJqZWN0LCBpZiBhbnkuXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvbnMob3JpZ2luKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc3RhdGUuc3ViamVjdHNbb3JpZ2luXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcm1pc3Npb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZ2luIGhhcyB0aGUgc3BlY2lmaWVkXG4gICAgICogcGVybWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3ViamVjdCBoYXMgdGhlIHBlcm1pc3Npb24uXG4gICAgICovXG4gICAgaGFzUGVybWlzc2lvbihvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFBlcm1pc3Npb24ob3JpZ2luLCB0YXJnZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHN1YmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG9yaWdpbiBoYXMgYW55IHBlcm1pc3Npb25zLlxuICAgICAqIFVzZSB0aGlzIGlmIHlvdSB3YW50IHRvIGtub3cgaWYgYSBzdWJqZWN0IFwiZXhpc3RzXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzdWJqZWN0IGhhcyBhbnkgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgaGFzUGVybWlzc2lvbnMob3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3RhdGUuc3ViamVjdHNbb3JpZ2luXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgYWxsIHBlcm1pc3Npb25zIGZyb20gdGhlIHNwZWNpZmllZCBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3Igb2YgdGhlIG9yaWdpbiBoYXMgbm8gcGVybWlzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB3aG9zZSBwZXJtaXNzaW9ucyB0byByZXZva2UuXG4gICAgICovXG4gICAgcmV2b2tlQWxsUGVybWlzc2lvbnMob3JpZ2luKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3Iob3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbiBmcm9tIHRoZSBzdWJqZWN0IHdpdGggdGhlIHNwZWNpZmllZFxuICAgICAqIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc3ViamVjdCBvciB0aGUgcGVybWlzc2lvbiBkb2VzIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0IHdob3NlIHBlcm1pc3Npb24gdG8gcmV2b2tlLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gcmV2b2tlLlxuICAgICAqL1xuICAgIHJldm9rZVBlcm1pc3Npb24ob3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5yZXZva2VQZXJtaXNzaW9ucyh7IFtvcmlnaW5dOiBbdGFyZ2V0XSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb25zIGZyb20gdGhlIHNwZWNpZmllZCBzdWJqZWN0cy5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIHN1YmplY3RzIG9yIHBlcm1pc3Npb25zIGRvIG5vdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJqZWN0c0FuZFBlcm1pc3Npb25zIC0gQW4gb2JqZWN0IG1hcHBpbmcgc3ViamVjdCBvcmlnaW5zXG4gICAgICogdG8gYXJyYXlzIG9mIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWVzIHRvIHJldm9rZS5cbiAgICAgKi9cbiAgICByZXZva2VQZXJtaXNzaW9ucyhzdWJqZWN0c0FuZFBlcm1pc3Npb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdWJqZWN0c0FuZFBlcm1pc3Npb25zKS5mb3JFYWNoKChvcmlnaW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkoZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YmplY3RzQW5kUGVybWlzc2lvbnNbb3JpZ2luXS5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkocGVybWlzc2lvbnMsIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlUGVybWlzc2lvbihkcmFmdFN0YXRlLnN1YmplY3RzLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgYWxsIHBlcm1pc3Npb25zIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXQgZm9yIGFsbCBzdWJqZWN0cy5cbiAgICAgKiBEb2VzIG5vdGhpbmcgaWYgbm8gc3ViamVjdHMgb3Igbm8gc3VjaCBwZXJtaXNzaW9uIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IHRvIHJldm9rZSBhbGwgcGVybWlzc2lvbnMgZm9yLlxuICAgICAqL1xuICAgIHJldm9rZVBlcm1pc3Npb25Gb3JBbGxTdWJqZWN0cyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0U3ViamVjdE5hbWVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRyYWZ0U3RhdGUuc3ViamVjdHMpLmZvckVhY2goKFtvcmlnaW4sIHN1YmplY3RdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gc3ViamVjdDtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5oYXNQcm9wZXJ0eShwZXJtaXNzaW9ucywgdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBlcm1pc3Npb24oZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgcGVybWlzc2lvbiBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBvcmlnaW4gYW5kIHRhcmdldC4gSWYgdGhlXG4gICAgICogcGVybWlzc2lvbiBpcyB0aGUgc2luZ2xlIHJlbWFpbmluZyBwZXJtaXNzaW9uIG9mIGl0cyBzdWJqZWN0LCB0aGUgc3ViamVjdFxuICAgICAqIGlzIGFsc28gZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJqZWN0cyAtIFRoZSBkcmFmdCBwZXJtaXNzaW9uIGNvbnRyb2xsZXIgc3ViamVjdHMuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBwZXJtaXNzaW9uXG4gICAgICogdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGRlbGV0ZVBlcm1pc3Npb24oc3ViamVjdHMsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHN1YmplY3RzW29yaWdpbl07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwZXJtaXNzaW9ucykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZGVsZXRlIHBlcm1pc3Npb25zW3RhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc3ViamVjdHNbb3JpZ2luXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgcGVybWlzc2lvbiBvZiB0aGUgc3ViamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICAgICAqIG9yaWdpbiBoYXMgYSBjYXZlYXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgYSBwZXJtaXNzaW9uIHdpdGggdGhlXG4gICAgICogc3BlY2lmaWVkIHRhcmdldCBuYW1lLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwZXJtaXNzaW9uIGhhcyB0aGUgc3BlY2lmaWVkIGNhdmVhdC5cbiAgICAgKi9cbiAgICBoYXNDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgaWYgYW55LCBmb3IgdGhlIHBlcm1pc3Npb24gb2ZcbiAgICAgKiB0aGUgc3ViamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN1YmplY3QgZG9lcyBub3QgaGF2ZSBhIHBlcm1pc3Npb24gd2l0aCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgdGFyZ2V0IG5hbWUuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjYXZlYXQsIG9yIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggY2F2ZWF0IGV4aXN0cy5cbiAgICAgKi9cbiAgICBnZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpIHtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IHRoaXMuZ2V0UGVybWlzc2lvbihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIGlmICghcGVybWlzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBlcm1pc3Npb25fMS5maW5kQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGNhdmVhdCB2YWx1ZSwgdG9cbiAgICAgKiB0aGUgcGVybWlzc2lvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBzdWJqZWN0IG9yaWdpbiBhbmQgcGVybWlzc2lvblxuICAgICAqIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEZvciBtb2RpZnlpbmcgZXhpc3RpbmcgY2F2ZWF0cywgdXNlXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZUNhdmVhdH0uXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBwZXJtaXNzaW9uIGV4aXN0cywgb3IgaWYgdGhlIGNhdmVhdCBhbHJlYWR5XG4gICAgICogZXhpc3RzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIGFkZC5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGNhdmVhdCB0byBhZGQuXG4gICAgICovXG4gICAgYWRkQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlLCBjYXZlYXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0QWxyZWFkeUV4aXN0c0Vycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBiZWxvbmdpbmcgdG8gdGhlXG4gICAgICogcGVybWlzc2lvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBzdWJqZWN0IG9yaWdpbiBhbmQgcGVybWlzc2lvblxuICAgICAqIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEZvciBhZGRpbmcgbmV3IGNhdmVhdHMsIHVzZVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hZGRDYXZlYXR9LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggcGVybWlzc2lvbiBvciBjYXZlYXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIFRhcmdldE5hbWUgLSBUaGUgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS4gU2hvdWxkIGJlIGluZmVycmVkLlxuICAgICAqIEB0ZW1wbGF0ZSBDYXZlYXRUeXBlIC0gVGhlIHZhbGlkIGNhdmVhdCB0eXBlcyBmb3IgdGhlIHBlcm1pc3Npb24uIFNob3VsZFxuICAgICAqIGJlIGluZmVycmVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VmFsdWUgLSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjYXZlYXQuXG4gICAgICovXG4gICAgdXBkYXRlQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlLCBjYXZlYXRWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzcGVjaWZpZWQgY2F2ZWF0IG9uIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbi4gT3ZlcndyaXRlcyBleGlzdGluZ1xuICAgICAqIGNhdmVhdHMgb2YgdGhlIHNhbWUgdHlwZSBpbi1wbGFjZSAocHJlc2VydmluZyBhcnJheSBvcmRlciksIGFuZCBhZGRzIHRoZVxuICAgICAqIGNhdmVhdCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBlcm1pc3Npb24gZG9lcyBub3QgZXhpc3Qgb3IgZmFpbHMgdG8gdmFsaWRhdGUgYWZ0ZXJcbiAgICAgKiBpdHMgY2F2ZWF0cyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hZGRDYXZlYXR9XG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlQ2F2ZWF0fVxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBzZXQuXG4gICAgICogQHBhcmFtIGNhdmVhdFZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBjYXZlYXQgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmplY3QgPSBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl07XG4gICAgICAgICAgICAvLyBVbnJlYWNoYWJsZSBiZWNhdXNlIGBoYXNDYXZlYXRgIGlzIGFsd2F5cyBjYWxsZWQgYmVmb3JlIHRoaXMsIGFuZCBpdFxuICAgICAgICAgICAgLy8gdGhyb3dzIGlmIHBlcm1pc3Npb25zIGFyZSBtaXNzaW5nLiBUeXBlU2NyaXB0IG5lZWRzIHRoaXMsIGhvd2V2ZXIuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3Iob3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSBzdWJqZWN0LnBlcm1pc3Npb25zW3RhcmdldF07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHByYWN0aWNhbGx5IGltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IHdhbnRzIGl0ICovXG4gICAgICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhdmVhdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBjYXZlYXRUeXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjYXZlYXRWYWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2F2ZWF0KGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24uY2F2ZWF0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdmVhdEluZGV4ID0gcGVybWlzc2lvbi5jYXZlYXRzLmZpbmRJbmRleCgoZXhpc3RpbmdDYXZlYXQpID0+IGV4aXN0aW5nQ2F2ZWF0LnR5cGUgPT09IGNhdmVhdC50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2F2ZWF0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24uY2F2ZWF0cy5wdXNoKGNhdmVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMuc3BsaWNlKGNhdmVhdEluZGV4LCAxLCBjYXZlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVjYXN0OiBBdCB0aGlzIHBvaW50LCB3ZSBkb24ndCBrbm93IGlmIHRoZSBzcGVjaWZpYyBwZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gaXMgYWxsb3dlZCB0byBoYXZlIGNhdmVhdHMsIGJ1dCBpdCBzaG91bGQgYmUgaW1wb3NzaWJsZSB0byBjYWxsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBtZXRob2QgZm9yIGEgcGVybWlzc2lvbiB0aGF0IG1heSBub3QgaGF2ZSBhbnkgY2F2ZWF0cy5cbiAgICAgICAgICAgICAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdGhlIHBlcm1pc3Npb24gdmFsaWRhdG9yIGlzIGFsc28gY2FsbGVkLlxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb24uY2F2ZWF0cyA9IFtjYXZlYXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGlmaWVkUGVybWlzc2lvbihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFsbCBjYXZlYXRzIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlIGZvciBhbGwgc3ViamVjdHMgYW5kXG4gICAgICogcGVybWlzc2lvbnMgYnkgYXBwbHlpbmcgdGhlIHNwZWNpZmllZCBtdXRhdG9yIGZ1bmN0aW9uIHRvIHRoZW0uXG4gICAgICpcbiAgICAgKiAqKkFUVE46KiogUGVybWlzc2lvbnMgY2FuIGJlIHJldm9rZWQgZW50aXJlbHkgYnkgdGhlIGFjdGlvbiBvZiB0aGlzIG1ldGhvZCxcbiAgICAgKiByZWFkIG9uIGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQ2F2ZWF0IG11dGF0b3JzIGFyZSBmdW5jdGlvbnMgdGhhdCByZWNlaXZlIGEgY2F2ZWF0IHZhbHVlIGFuZCByZXR1cm4gYVxuICAgICAqIHR1cGxlIGNvbnNpc3Rpbmcgb2YgYSB7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbn0gYW5kLCBvcHRpb25hbGx5LCBhIG5ld1xuICAgICAqIHZhbHVlIHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgY2F2ZWF0IHdpdGguXG4gICAgICpcbiAgICAgKiBGb3IgZWFjaCBjYXZlYXQsIGRlcGVuZGluZyBvbiB0aGUgbXV0YXRvciByZXN1bHQsIHRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogLSBEbyBub3RoaW5nICh7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5ub29wfSlcbiAgICAgKiAtIFVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIGNhdmVhdCAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24udXBkYXRlVmFsdWV9KVxuICAgICAqICAgLSBUaGUgY2F2ZWF0IHNwZWNpZmljYXRpb24gdmFsaWRhdG9yLCBpZiBhbnksIHdpbGwgYmUgY2FsbGVkIGFmdGVyXG4gICAgICogICAgIHVwZGF0aW5nIHRoZSB2YWx1ZS5cbiAgICAgKiAtIERlbGV0ZSB0aGUgY2F2ZWF0ICh7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5kZWxldGVDYXZlYXR9KVxuICAgICAqICAgLSBUaGUgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uIHZhbGlkYXRvciwgaWYgYW55LCB3aWxsIGJlIGNhbGxlZCBhZnRlclxuICAgICAqICAgICBkZWxldGluZyB0aGUgY2F2ZWF0LlxuICAgICAqIC0gUmV2b2tlIHRoZSBwYXJlbnQgcGVybWlzc2lvbiAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24ucmV2b2tlUGVybWlzc2lvbn0pXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB0aHJvd3MgaWYgdGhlIHZhbGlkYXRpb24gb2YgYW55IGNhdmVhdCBvciBwZXJtaXNzaW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldENhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0cyB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIG11dGF0b3IgLSBUaGUgbXV0YXRvciBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGNhdmVhdFxuICAgICAqIHZhbHVlcy5cbiAgICAgKi9cbiAgICB1cGRhdGVQZXJtaXNzaW9uc0J5Q2F2ZWF0KHRhcmdldENhdmVhdFR5cGUsIG11dGF0b3IpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3ViamVjdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGRyYWZ0U3RhdGUuc3ViamVjdHMpLmZvckVhY2goKHN1YmplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHN1YmplY3QucGVybWlzc2lvbnMpLmZvckVhY2goKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDYXZlYXQgPSBjYXZlYXRzID09PSBudWxsIHx8IGNhdmVhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdmVhdHMuZmluZCgoeyB0eXBlIH0pID0+IHR5cGUgPT09IHRhcmdldENhdmVhdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldENhdmVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtdXRhdG9yIG1heSBtb2RpZnkgdGhlIGNhdmVhdCB2YWx1ZSBpbiBwbGFjZSwgYW5kIG11c3QgYWx3YXlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBhIHZhbGlkIG11dGF0aW9uIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXV0YXRvclJlc3VsdCA9IG11dGF0b3IodGFyZ2V0Q2F2ZWF0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtdXRhdG9yUmVzdWx0Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLm5vb3A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhdmVhdE11dGF0b3JPcGVyYXRpb24udXBkYXRlVmFsdWU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IGBNdXRhYmxlYCBpcyB1c2VkIGhlcmUgdG8gYXNzaWduIHRvIGEgcmVhZG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eS4gYHRhcmdldENvbnN0cmFpbnRgIHNob3VsZCBhbHJlYWR5IGJlIG11dGFibGUgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcGFydCBvZiBhIGRyYWZ0LCBidXQgZm9yIHNvbWUgcmVhc29uIGl0J3Mgbm90LiBXZSBjYW4ndFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgbW9yZS1jb3JyZWN0IGBEcmFmdGAgdHlwZSBoZXJlIGVpdGhlciBiZWNhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0cyBpbiBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDYXZlYXQudmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdG9yUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYXZlYXQodGFyZ2V0Q2F2ZWF0LCBzdWJqZWN0Lm9yaWdpbiwgcGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5kZWxldGVDYXZlYXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVDYXZlYXQocGVybWlzc2lvbiwgdGFyZ2V0Q2F2ZWF0VHlwZSwgc3ViamVjdC5vcmlnaW4sIHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhdmVhdE11dGF0b3JPcGVyYXRpb24ucmV2b2tlUGVybWlzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBlcm1pc3Npb24oZHJhZnRTdGF0ZS5zdWJqZWN0cywgc3ViamVjdC5vcmlnaW4sIHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlIGNoZWNrIGVuc3VyZXMgdGhhdCB0aGUgc3dpdGNoIHN0YXRlbWVudCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aGF1c3RpdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG11dGF0b3JSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbXV0YXRpb24gcmVzdWx0OiBcIiR7X2V4aGF1c3RpdmVDaGVjay5vcGVyYXRpb259XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjYXZlYXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGZyb20gdGhlIHBlcm1pc3Npb24gY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHRoZSBnaXZlbiBzdWJqZWN0IG9yaWdpbiBhbmQgdGFyZ2V0IG5hbWUuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBwZXJtaXNzaW9uIG9yIGNhdmVhdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZUNhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IChfYSA9IGRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcm1pc3Npb25zW3RhcmdldF07XG4gICAgICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGVybWlzc2lvbi5jYXZlYXRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVsZXRlQ2F2ZWF0KHBlcm1pc3Npb24sIGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBjYXZlYXQgZnJvbSB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uIElmIG5vIGNhdmVhdHNcbiAgICAgKiByZW1haW4gYWZ0ZXIgZGVsZXRpb24sIHRoZSBwZXJtaXNzaW9uJ3MgY2F2ZWF0IHByb3BlcnR5IGlzIHNldCB0byBgbnVsbGAuXG4gICAgICogVGhlIHBlcm1pc3Npb24gaXMgdmFsaWRhdGVkIGFmdGVyIGJlaW5nIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGhhdmUgYSBjYXZlYXQgd2l0aCB0aGUgc3BlY2lmaWVkXG4gICAgICogdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9uIC0gVGhlIHBlcm1pc3Npb24gd2hvc2UgY2F2ZWF0IHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRoZSBwZXJtaXNzaW9uIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uIHRhcmdldC5cbiAgICAgKi9cbiAgICBkZWxldGVDYXZlYXQocGVybWlzc2lvbiwgY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBub3QgcG9zc2libGUgaW4gb3VyIHVzYWdlICovXG4gICAgICAgIGlmICghcGVybWlzc2lvbi5jYXZlYXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhdmVhdEluZGV4ID0gcGVybWlzc2lvbi5jYXZlYXRzLmZpbmRJbmRleCgoZXhpc3RpbmdDYXZlYXQpID0+IGV4aXN0aW5nQ2F2ZWF0LnR5cGUgPT09IGNhdmVhdFR5cGUpO1xuICAgICAgICBpZiAoY2F2ZWF0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJtaXNzaW9uLmNhdmVhdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVybWlzc2lvbi5jYXZlYXRzLnNwbGljZShjYXZlYXRJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZU1vZGlmaWVkUGVybWlzc2lvbihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIG1vZGlmaWVkIHBlcm1pc3Npb24uIFNob3VsZCAqKmFsd2F5cyoqIGJlIGludm9rZWRcbiAgICAgKiBvbiBhIHBlcm1pc3Npb24gYWZ0ZXIgaXRzIGNhdmVhdHMgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogSnVzdCBsaWtlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci52YWxpZGF0ZVBlcm1pc3Npb259LCBleGNlcHQgdGhhdCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHRhcmdldCBrZXkgYW5kIHNwZWNpZmljYXRpb24gYXJlIHJldHJpZXZlZCBmaXJzdCwgYW5kIGFuXG4gICAgICogZXJyb3IgaXMgdGhyb3duIGlmIHRoZSB0YXJnZXQga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gLSBUaGUgbW9kaWZpZWQgcGVybWlzc2lvbiB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgdGFyZ2V0IG5hbWUgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU1vZGlmaWVkUGVybWlzc2lvbihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkocGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIHNob3VsZCBiZSBpbXBvc3NpYmxlICovXG4gICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhdGFsOiBFeGlzdGluZyBwZXJtaXNzaW9uIHRhcmdldCBrZXkgXCIke3RhcmdldEtleX1cIiBoYXMgbm8gc3BlY2lmaWNhdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbih0aGlzLmdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSksIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGtleSBmb3IgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uIHRhcmdldC5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gc3VwcG9ydCBvdXIgbmFtZXNwYWNlZCBwZXJtaXNzaW9uIHRhcmdldCBmZWF0dXJlLCB3aGljaCBpcyB1c2VkXG4gICAgICogdG8gaW1wbGVtZW50IG5hbWVzcGFjZWQgcmVzdHJpY3RlZCBKU09OLVJQQyBtZXRob2RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbiB0YXJnZXQuXG4gICAgICogQHJldHVybnMgVGhlIGludGVybmFsIGtleSBvZiB0aGUgcGVybWlzc2lvbiB0YXJnZXQuXG4gICAgICovXG4gICAgZ2V0VGFyZ2V0S2V5KHRhcmdldCkge1xuICAgICAgICBpZiAodXRpbHNfMS5oYXNQcm9wZXJ0eSh0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZXNwYWNlZFRhcmdldHNXaXRob3V0V2lsZGNhcmQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRLZXkgb2YgT2JqZWN0LmtleXModGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zKSkge1xuICAgICAgICAgICAgY29uc3Qgd2lsZENhcmRNYXRjaCA9IHRhcmdldEtleS5tYXRjaCgvKC4rKVxcKiQvdSk7XG4gICAgICAgICAgICBpZiAod2lsZENhcmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZWRUYXJnZXRzV2l0aG91dFdpbGRjYXJkW3dpbGRDYXJkTWF0Y2hbMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgcG90ZW50aWFsbHkgbmVzdGVkIG5hbWVzcGFjZXM6XG4gICAgICAgIC8vIEV4OiB3aWxkem9uZV9cbiAgICAgICAgLy8gRXg6IGV0aF9wbHVnaW5fXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGFyZ2V0LnNwbGl0KCdfJyk7XG4gICAgICAgIGxldCB0YXJnZXRLZXkgPSAnJztcbiAgICAgICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICF1dGlsc18xLmhhc1Byb3BlcnR5KHRoaXMuX3Blcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgdGFyZ2V0S2V5KSAmJlxuICAgICAgICAgICAgIW5hbWVzcGFjZWRUYXJnZXRzV2l0aG91dFdpbGRjYXJkW3RhcmdldEtleV0pIHtcbiAgICAgICAgICAgIHRhcmdldEtleSArPSBgJHtzZWdtZW50cy5zaGlmdCgpfV9gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2VkVGFyZ2V0c1dpdGhvdXRXaWxkY2FyZFt0YXJnZXRLZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGFyZ2V0S2V5fSpgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBfYXBwcm92ZWRfIHBlcm1pc3Npb25zIHRvIHRoZSBzcGVjaWZpZWQgc3ViamVjdC4gRXZlcnkgcGVybWlzc2lvbiBhbmRcbiAgICAgKiBjYXZlYXQgaXMgc3RyaW5nZW50bHkgdmFsaWRhdGVkIOKAkyBpbmNsdWRpbmcgYnkgY2FsbGluZyBldmVyeSBzcGVjaWZpY2F0aW9uXG4gICAgICogdmFsaWRhdG9yIOKAkyBhbmQgYW4gZXJyb3IgaXMgdGhyb3duIGlmIGFueSB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogKipBVFROOioqIFRoaXMgbWV0aG9kIGRvZXMgKipub3QqKiBwcm9tcHQgdGhlIHVzZXIgZm9yIGFwcHJvdmFsLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zfSBGb3IgaW5pdGlhdGluZyBhXG4gICAgICogcGVybWlzc2lvbnMgcmVxdWVzdCByZXF1aXJpbmcgdXNlciBhcHByb3ZhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFwcHJvdmVkUGVybWlzc2lvbnMgLSBUaGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zIGFwcHJvdmVkIGJ5XG4gICAgICogdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVxdWVzdERhdGEgLSBQZXJtaXNzaW9uIHJlcXVlc3QgZGF0YS4gUGFzc2VkIHRvIHBlcm1pc3Npb25cbiAgICAgKiBmYWN0b3J5IGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgLSBXaGV0aGVyIHRvIHByZXNlcnZlIHRoZVxuICAgICAqIHN1YmplY3QncyBleGlzdGluZyBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWJqZWN0IC0gVGhlIHN1YmplY3QgdG8gZ3JhbnQgcGVybWlzc2lvbnMgdG8uXG4gICAgICogQHJldHVybnMgVGhlIGdyYW50ZWQgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgZ3JhbnRQZXJtaXNzaW9ucyh7IGFwcHJvdmVkUGVybWlzc2lvbnMsIHJlcXVlc3REYXRhLCBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgPSB0cnVlLCBzdWJqZWN0LCB9KSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBzdWJqZWN0O1xuICAgICAgICBpZiAoIW9yaWdpbiB8fCB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSAocHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0UGVybWlzc2lvbnMob3JpZ2luKSkgOiB7fSk7XG4gICAgICAgIGZvciAoY29uc3QgW3JlcXVlc3RlZFRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uXSBvZiBPYmplY3QuZW50cmllcyhhcHByb3ZlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkocmVxdWVzdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEubWV0aG9kTm90Rm91bmQoeyBtZXRob2Q6IHJlcXVlc3RlZFRhcmdldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHByb3ZlZFBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkVGFyZ2V0ICE9PSBhcHByb3ZlZFBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3Iob3JpZ2luLCByZXF1ZXN0ZWRUYXJnZXQsIGFwcHJvdmVkUGVybWlzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIHRhcmdldCBtdXN0IGJlIGEgdmFsaWQgdGFyZ2V0IG5hbWUgaWYgd2UgZm91bmQgaXRzIGtleS5cbiAgICAgICAgICAgIC8vIFdlIHJlYXNzaWduIGl0IHRvIGNoYW5nZSBpdHMgdHlwZS5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSByZXF1ZXN0ZWRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uID0gdGhpcy5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbih0YXJnZXRLZXkpO1xuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCBjYXZlYXRzIGFyZSB2YWxpZGF0ZWQgaGVyZS5cbiAgICAgICAgICAgIGNvbnN0IGNhdmVhdHMgPSB0aGlzLmNvbnN0cnVjdENhdmVhdHMob3JpZ2luLCB0YXJnZXROYW1lLCBhcHByb3ZlZFBlcm1pc3Npb24uY2F2ZWF0cyk7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjYXZlYXRzLFxuICAgICAgICAgICAgICAgIGludm9rZXI6IG9yaWdpbixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBlcm1pc3Npb247XG4gICAgICAgICAgICBpZiAoc3BlY2lmaWNhdGlvbi5mYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbiA9IHNwZWNpZmljYXRpb24uZmFjdG9yeShwZXJtaXNzaW9uT3B0aW9ucywgcmVxdWVzdERhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEZ1bGwgY2F2ZWF0IGFuZCBwZXJtaXNzaW9uIHZhbGlkYXRpb24gaXMgcGVyZm9ybWVkIGhlcmUgc2luY2UgdGhlXG4gICAgICAgICAgICAgICAgLy8gZmFjdG9yeSBmdW5jdGlvbiBjYW4gYXJiaXRyYXJpbHkgbW9kaWZ5IHRoZSBlbnRpcmUgcGVybWlzc2lvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkaW5nIGl0cyBjYXZlYXRzLlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uKHNwZWNpZmljYXRpb24sIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uID0gUGVybWlzc2lvbl8xLmNvbnN0cnVjdFBlcm1pc3Npb24ocGVybWlzc2lvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIHZhbGlkYXRlIGNhdmVhdHMgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHRoZSBwbGFpblxuICAgICAgICAgICAgICAgIC8vIHBlcm1pc3Npb24gY29uc3RydWN0b3IgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSBjYXZlYXRzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdlcmUgYWxyZWFkeSB2YWxpZGF0ZWQgYnkgYGNvbnN0cnVjdENhdmVhdHNgIGFib3ZlLlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uKHNwZWNpZmljYXRpb24sIHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtQ2F2ZWF0VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJtaXNzaW9uc1t0YXJnZXROYW1lXSA9IHBlcm1pc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRWYWxpZGF0ZWRQZXJtaXNzaW9ucyhvcmlnaW4sIHBlcm1pc3Npb25zKTtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uIGJ5OlxuICAgICAqIC0gRW5zdXJpbmcgdGhhdCBpdHMgYGNhdmVhdHNgIHByb3BlcnR5IGlzIGVpdGhlciBgbnVsbGAgb3IgYSBub24tZW1wdHlcbiAgICAgKiAgIGFycmF5LlxuICAgICAqIC0gRW5zdXJpbmcgdGhhdCBpdCBvbmx5IGluY2x1ZGVzIGNhdmVhdHMgYWxsb3dlZCBieSBpdHMgc3BlY2lmaWNhdGlvbi5cbiAgICAgKiAtIEVuc3VyaW5nIHRoYXQgaXQgaW5jbHVkZXMgbm8gZHVwbGljYXRlIGNhdmVhdHMgKGJ5IGNhdmVhdCB0eXBlKS5cbiAgICAgKiAtIFZhbGlkYXRpbmcgZWFjaCBjYXZlYXQgb2JqZWN0LCBpZiBgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb25gIGlzIGB0cnVlYC5cbiAgICAgKiAtIENhbGxpbmcgdGhlIHZhbGlkYXRvciBvZiBpdHMgc3BlY2lmaWNhdGlvbiwgaWYgb25lIGV4aXN0cyBhbmRcbiAgICAgKiAgIGBpbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yYCBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcGVjaWZpY2F0aW9uIC0gVGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gLSBUaGUgcGVybWlzc2lvbiB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgdGFyZ2V0IG5hbWUgb2YgdGhlIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHZhbGlkYXRpb25PcHRpb25zIC0gVmFsaWRhdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB2YWxpZGF0aW9uT3B0aW9ucy5pbnZva2VQZXJtaXNzaW9uVmFsaWRhdG9yIC0gV2hldGhlciB0byBpbnZva2UgdGhlXG4gICAgICogcGVybWlzc2lvbidzIGNvbnN1bWVyLXNwZWNpZmllZCB2YWxpZGF0b3IgZnVuY3Rpb24sIGlmIGFueS5cbiAgICAgKiBAcGFyYW0gdmFsaWRhdGlvbk9wdGlvbnMucGVyZm9ybUNhdmVhdFZhbGlkYXRpb24gLSBXaGV0aGVyIHRvIGludm9rZVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci52YWxpZGF0ZUNhdmVhdH0gb24gZWFjaCBvZiB0aGUgcGVybWlzc2lvbidzXG4gICAgICogY2F2ZWF0cy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBlcm1pc3Npb24oc3BlY2lmaWNhdGlvbiwgcGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lLCB7IGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3IsIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uIH0gPSB7XG4gICAgICAgIGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3I6IHRydWUsXG4gICAgICAgIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uOiB0cnVlLFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkQ2F2ZWF0cywgdmFsaWRhdG9yIH0gPSBzcGVjaWZpY2F0aW9uO1xuICAgICAgICBpZiAodXRpbHNfMS5oYXNQcm9wZXJ0eShwZXJtaXNzaW9uLCAnY2F2ZWF0cycpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhdmVhdHMgfSA9IHBlcm1pc3Npb247XG4gICAgICAgICAgICBpZiAoY2F2ZWF0cyAhPT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkoY2F2ZWF0cykgJiYgY2F2ZWF0cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3Iob3JpZ2luLCB0YXJnZXROYW1lLCBjYXZlYXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZW5DYXZlYXRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGNhdmVhdHMgPT09IG51bGwgfHwgY2F2ZWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F2ZWF0cy5mb3JFYWNoKChjYXZlYXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVyZm9ybUNhdmVhdFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGFsbG93ZWRDYXZlYXRzID09PSBudWxsIHx8IGFsbG93ZWRDYXZlYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkQ2F2ZWF0cy5pbmNsdWRlcyhjYXZlYXQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Gb3JiaWRkZW5DYXZlYXRFcnJvcihjYXZlYXQudHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5DYXZlYXRUeXBlcy5oYXMoY2F2ZWF0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5EdXBsaWNhdGVDYXZlYXRFcnJvcihjYXZlYXQudHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VlbkNhdmVhdFR5cGVzLmFkZChjYXZlYXQudHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2tlUGVybWlzc2lvblZhbGlkYXRvciAmJiB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9ucyB0byB0aGUgc3ViamVjdCB3aXRoIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICogT3ZlcndyaXRlcyBhbGwgZXhpc3RpbmcgcGVybWlzc2lvbnMsIGFuZCBjcmVhdGVzIGEgc3ViamVjdCBlbnRyeSBpZiBpdFxuICAgICAqIGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKlxuICAgICAqICoqQVRUTjoqKiBBc3N1bWVzIHRoYXQgdGhlIG5ldyBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gdmFsaWRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGdyYW50ZWUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnMgLSBUaGUgbmV3IHBlcm1pc3Npb25zIGZvciB0aGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqL1xuICAgIHNldFZhbGlkYXRlZFBlcm1pc3Npb25zKG9yaWdpbiwgcGVybWlzc2lvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKSB7XG4gICAgICAgICAgICAgICAgZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dID0geyBvcmlnaW4sIHBlcm1pc3Npb25zOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dLnBlcm1pc3Npb25zID0gaW1tZXJfMS5jYXN0RHJhZnQocGVybWlzc2lvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSByZXF1ZXN0ZWQgY2F2ZWF0cyBmb3IgdGhlIHBlcm1pc3Npb24gb2YgdGhlIHNwZWNpZmllZFxuICAgICAqIHN1YmplY3Qgb3JpZ2luIGFuZCB0YXJnZXQgbmFtZSBhbmQgcmV0dXJucyB0aGUgdmFsaWRhdGVkIGNhdmVhdCBhcnJheS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHBlcm1pc3Npb24gc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZENhdmVhdHMgLSBUaGUgcmVxdWVzdGVkIGNhdmVhdHMgdG8gY29uc3RydWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RlZCBjYXZlYXRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdENhdmVhdHMob3JpZ2luLCB0YXJnZXQsIHJlcXVlc3RlZENhdmVhdHMpIHtcbiAgICAgICAgY29uc3QgY2F2ZWF0QXJyYXkgPSByZXF1ZXN0ZWRDYXZlYXRzID09PSBudWxsIHx8IHJlcXVlc3RlZENhdmVhdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3RlZENhdmVhdHMubWFwKChyZXF1ZXN0ZWRDYXZlYXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDYXZlYXQocmVxdWVzdGVkQ2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbiBzbyB0aGF0IHdlIGhhdmUgYSBmcmVzaCBvYmplY3QuXG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSByZXF1ZXN0ZWRDYXZlYXQ7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlLCB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhdmVhdEFycmF5ICYmIHV0aWxzXzEuaXNOb25FbXB0eUFycmF5KGNhdmVhdEFycmF5KVxuICAgICAgICAgICAgPyBjYXZlYXRBcnJheVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kcyB2YWxpZGF0ZXMgdGhhdCB0aGUgc3BlY2lmaWVkIGNhdmVhdCBpcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBleHBlY3RlZCBwcm9wZXJ0aWVzIGFuZCB0eXBlcy4gSXQgYWxzbyBlbnN1cmVzIHRoYXQgYSBjYXZlYXQgc3BlY2lmaWNhdGlvblxuICAgICAqIGV4aXN0cyBmb3IgdGhlIHJlcXVlc3RlZCBjYXZlYXQgdHlwZSwgYW5kIGNhbGxzIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAgICogdmFsaWRhdG9yLCBpZiBpdCBleGlzdHMsIG9uIHRoZSBjYXZlYXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2F2ZWF0IC0gVGhlIGNhdmVhdCBvYmplY3QgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJqZWN0IG9mIHRoZSBwYXJlbnRcbiAgICAgKiBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXJlbnQgcGVybWlzc2lvbi5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF1dGlsc18xLmlzUGxhaW5PYmplY3QoY2F2ZWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRDYXZlYXRFcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2F2ZWF0KS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYXZlYXQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0VHlwZUVycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSB0aGlzLmdldENhdmVhdFNwZWNpZmljYXRpb24oY2F2ZWF0LnR5cGUpO1xuICAgICAgICBpZiAoIXNwZWNpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IoY2F2ZWF0LnR5cGUsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxzXzEuaGFzUHJvcGVydHkoY2F2ZWF0LCAndmFsdWUnKSB8fCBjYXZlYXQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdE1pc3NpbmdWYWx1ZUVycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1ZhbGlkSnNvbihjYXZlYXQudmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0SW52YWxpZEpzb25FcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUeXBlY2FzdDogVHlwZVNjcmlwdCBzdGlsbCBiZWxpZXZlcyB0aGF0IHRoZSBjYXZlYXQgaXMgYSBQbGFpbk9iamVjdC5cbiAgICAgICAgKF9hID0gc3BlY2lmaWNhdGlvbi52YWxpZGF0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHNwZWNpZmljYXRpb24sIGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBwZXJtaXNzaW9uIHJlcXVlc3QgdGhhdCByZXF1aXJlcyB1c2VyIGFwcHJvdmFsLiBUaGlzIHNob3VsZFxuICAgICAqIGFsd2F5cyBiZSB1c2VkIHRvIGdyYW50IGFkZGl0aW9uYWwgcGVybWlzc2lvbnMgdG8gYSBzdWJqZWN0LCB1bmxlc3MgdXNlclxuICAgICAqIGFwcHJvdmFsIGhhcyBiZWVuIG9idGFpbmVkIHRocm91Z2ggc29tZSBvdGhlciBtZWFucy5cbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb25zIGFyZSB2YWxpZGF0ZWQgYXQgZXZlcnkgc3RlcCBvZiB0aGUgYXBwcm92YWwgcHJvY2VzcywgYW5kIHRoaXNcbiAgICAgKiBtZXRob2Qgd2lsbCByZWplY3QgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFwcHJvdmFsQ29udHJvbGxlcn0gRm9yIHRoZSB1c2VyIGFwcHJvdmFsIGxvZ2ljLlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdH0gRm9yIHRoZSBtZXRob2RcbiAgICAgKiB0aGF0IF9hY2NlcHRzXyB0aGUgcmVxdWVzdCBhbmQgcmVzb2x2ZXMgdGhlIHVzZXIgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3R9IEZvciB0aGUgbWV0aG9kXG4gICAgICogdGhhdCBfcmVqZWN0c18gdGhlIHJlcXVlc3QgYW5kIHRoZSB1c2VyIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICogQHBhcmFtIHN1YmplY3QgLSBUaGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRQZXJtaXNzaW9ucyAtIFRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWQgLSBUaGUgaWQgb2YgdGhlIHBlcm1pc3Npb25zIHJlcXVlc3QuIERlZmF1bHRzIHRvIGEgdW5pcXVlXG4gICAgICogaWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zIC0gV2hldGhlciB0byBwcmVzZXJ2ZSB0aGVcbiAgICAgKiBzdWJqZWN0J3MgZXhpc3RpbmcgcGVybWlzc2lvbnMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZ3JhbnRlZCBwZXJtaXNzaW9ucyBhbmQgcmVxdWVzdCBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0UGVybWlzc2lvbnMoc3ViamVjdCwgcmVxdWVzdGVkUGVybWlzc2lvbnMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gc3ViamVjdDtcbiAgICAgICAgY29uc3QgeyBpZCA9IG5hbm9pZF8xLm5hbm9pZCgpLCBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnMob3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlcXVlc3RlZFBlcm1pc3Npb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYSA9IGF3YWl0IHRoaXMucmVxdWVzdFVzZXJBcHByb3ZhbChwZXJtaXNzaW9uc1JlcXVlc3QpLCB7IHBlcm1pc3Npb25zOiBhcHByb3ZlZFBlcm1pc3Npb25zIH0gPSBfYSwgcmVxdWVzdERhdGEgPSBfX3Jlc3QoX2EsIFtcInBlcm1pc3Npb25zXCJdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuZ3JhbnRQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZFBlcm1pc3Npb25zLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlRXhpc3RpbmdQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuIFRocm93cyBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMgYXJlIGEgcHJvcGVybHlcbiAgICAgKiBmb3JtYXR0ZWQge0BsaW5rIFJlcXVlc3RlZFBlcm1pc3Npb25zfSBvYmplY3QsIGFuZCBwZXJmb3JtcyB0aGUgc2FtZVxuICAgICAqIHZhbGlkYXRpb24gYXMge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmdyYW50UGVybWlzc2lvbnN9LCBleGNlcHQgdGhhdFxuICAgICAqIGNvbnN1bWVyLXNwZWNpZmllZCBwZXJtaXNzaW9uIHZhbGlkYXRvciBmdW5jdGlvbnMgYXJlIG5vdCBjYWxsZWQsIHNpbmNlXG4gICAgICogdGhleSBhcmUgb25seSBjYWxsZWQgb24gZnVsbHkgY29uc3RydWN0ZWQsIGFwcHJvdmVkIHBlcm1pc3Npb25zIHRoYXQgYXJlXG4gICAgICogb3RoZXJ3aXNlIGNvbXBsZXRlbHkgdmFsaWQuXG4gICAgICpcbiAgICAgKiBVbnJlY29nbnppZWQgcHJvcGVydGllcyBvbiByZXF1ZXN0ZWQgcGVybWlzc2lvbnMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRQZXJtaXNzaW9ucyAtIFRoZSByZXF1ZXN0ZWQgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgdmFsaWRhdGVSZXF1ZXN0ZWRQZXJtaXNzaW9ucyhvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zKSB7XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KHJlcXVlc3RlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlcXVlc3RlZCBwZXJtaXNzaW9ucyBmb3Igb3JpZ2luIFwiJHtvcmlnaW59XCIgaXMgbm90IGEgcGxhaW4gb2JqZWN0LmAsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVxdWVzdGVkUGVybWlzc2lvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGNvbnRhaW5zIG5vIHBlcm1pc3Npb25zLmAsXG4gICAgICAgICAgICAgICAgZGF0YTogeyByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXROYW1lIG9mIE9iamVjdC5rZXlzKHJlcXVlc3RlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbiA9IHJlcXVlc3RlZFBlcm1pc3Npb25zW3RhcmdldE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkodGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IG9yaWdpbiwgcmVxdWVzdGVkUGVybWlzc2lvbnMgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KHBlcm1pc3Npb24pIHx8XG4gICAgICAgICAgICAgICAgKHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5hbWUgIT09IHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGNvbnRhaW5zIGludmFsaWQgcmVxdWVzdGVkIHBlcm1pc3Npb24ocykuYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIZXJlIHdlIHZhbGlkYXRlIHRoZSBwZXJtaXNzaW9uIHdpdGhvdXQgaW52b2tpbmcgaXRzIHZhbGlkYXRvciwgaWYgYW55LlxuICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRvciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHBlcm1pc3Npb24gaGFzIGJlZW4gYXBwcm92ZWQuXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbih0aGlzLmdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSksIFxuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IFRoZSBwZXJtaXNzaW9uIGlzIHN0aWxsIGEgXCJQbGFpbk9iamVjdFwiIGhlcmUuXG4gICAgICAgICAgICBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUsIHsgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcjogZmFsc2UsIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZXF1ZXN0IHRvIHRoZSB7QGxpbmsgQXBwcm92YWxDb250cm9sbGVyfSB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgQWRkQXBwcm92YWxSZXF1ZXN0fSBhY3Rpb24uIEFsc28gdmFsaWRhdGVzIHRoZSByZXN1bHRpbmcgYXBwcm92ZWRcbiAgICAgKiBwZXJtaXNzaW9ucyByZXF1ZXN0LCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnNSZXF1ZXN0IC0gVGhlIHBlcm1pc3Npb25zIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0VXNlckFwcHJvdmFsKHBlcm1pc3Npb25zUmVxdWVzdCkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiwgaWQgfSA9IHBlcm1pc3Npb25zUmVxdWVzdC5tZXRhZGF0YTtcbiAgICAgICAgY29uc3QgYXBwcm92ZWRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOmFkZFJlcXVlc3QnLCB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiBwZXJtaXNzaW9uc1JlcXVlc3QsXG4gICAgICAgICAgICB0eXBlOiB1dGlsc18yLk1ldGhvZE5hbWVzLnJlcXVlc3RQZXJtaXNzaW9ucyxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVBcHByb3ZlZFBlcm1pc3Npb25zKGFwcHJvdmVkUmVxdWVzdCwgeyBpZCwgb3JpZ2luIH0pO1xuICAgICAgICByZXR1cm4gYXBwcm92ZWRSZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgYW4gYXBwcm92ZWQge0BsaW5rIFBlcm1pc3Npb25zUmVxdWVzdH0gb2JqZWN0LiBUaGUgYXBwcm92ZWRcbiAgICAgKiByZXF1ZXN0IG11c3QgaGF2ZSB0aGUgcmVxdWlyZWQgYG1ldGFkYXRhYCBhbmQgYHBlcm1pc3Npb25zYCBwcm9wZXJ0aWVzLFxuICAgICAqIHRoZSBgaWRgIGFuZCBgb3JpZ2luYCBvZiB0aGUgYG1ldGFkYXRhYCBtdXN0IG1hdGNoIHRoZSBvcmlnaW5hbCByZXF1ZXN0XG4gICAgICogbWV0YWRhdGEsIGFuZCB0aGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zIG11c3QgYmUgdmFsaWQgcGVyXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnN9LiBBbnkgZXh0cmFcbiAgICAgKiBtZXRhZGF0YSBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQW4gZXJyb3IgaXMgdGhyb3duIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBwcm92ZWRSZXF1ZXN0IC0gVGhlIGFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbE1ldGFkYXRhIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3QgbWV0YWRhdGEuXG4gICAgICovXG4gICAgdmFsaWRhdGVBcHByb3ZlZFBlcm1pc3Npb25zKGFwcHJvdmVkUmVxdWVzdCwgb3JpZ2luYWxNZXRhZGF0YSkge1xuICAgICAgICBjb25zdCB7IGlkLCBvcmlnaW4gfSA9IG9yaWdpbmFsTWV0YWRhdGE7XG4gICAgICAgIGlmICghdXRpbHNfMS5pc1BsYWluT2JqZWN0KGFwcHJvdmVkUmVxdWVzdCkgfHxcbiAgICAgICAgICAgICF1dGlsc18xLmlzUGxhaW5PYmplY3QoYXBwcm92ZWRSZXF1ZXN0Lm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgQXBwcm92ZWQgcGVybWlzc2lvbnMgcmVxdWVzdCBmb3Igc3ViamVjdCBcIiR7b3JpZ2lufVwiIGlzIGludmFsaWQuYCwgeyBkYXRhOiB7IGFwcHJvdmVkUmVxdWVzdCB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGE6IHsgaWQ6IG5ld0lkLCBvcmlnaW46IG5ld09yaWdpbiB9LCBwZXJtaXNzaW9ucywgfSA9IGFwcHJvdmVkUmVxdWVzdDtcbiAgICAgICAgaWYgKG5ld0lkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgQXBwcm92ZWQgcGVybWlzc2lvbnMgcmVxdWVzdCBmb3Igc3ViamVjdCBcIiR7b3JpZ2lufVwiIG11dGF0ZWQgaXRzIGlkLmAsIHsgb3JpZ2luYWxJZDogaWQsIG11dGF0ZWRJZDogbmV3SWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld09yaWdpbiAhPT0gb3JpZ2luKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5pbnRlcm5hbEVycm9yKGBBcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBzdWJqZWN0IFwiJHtvcmlnaW59XCIgbXV0YXRlZCBpdHMgb3JpZ2luLmAsIHsgb3JpZ2luYWxPcmlnaW46IG9yaWdpbiwgbXV0YXRlZE9yaWdpbjogbmV3T3JpZ2luIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZS10aHJvdyBhcyBhbiBpbnRlcm5hbCBlcnJvcjsgd2Ugc2hvdWxkIG5ldmVyIHJlY2VpdmUgaW52YWxpZCBhcHByb3ZlZFxuICAgICAgICAgICAgLy8gcGVybWlzc2lvbnMuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNfMS5pbnRlcm5hbEVycm9yKGBJbnZhbGlkIGFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3Q6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvci5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgcGVybWlzc2lvbnMgcmVxdWVzdCBjcmVhdGVkIGJ5XG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9uc30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHJlcXVlc3QubWV0YWRhdGE7XG4gICAgICAgIGlmICghdGhpcy5oYXNBcHByb3ZhbFJlcXVlc3QoeyBpZCB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0LnBlcm1pc3Npb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgcmVxdWVzdCBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbi4nLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdBcHByb3ZhbENvbnRyb2xsZXI6YWNjZXB0UmVxdWVzdCcsIGlkLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElmIGFjY2VwdGluZyB1bmV4cGVjdGVkbHkgZmFpbHMsIHJlamVjdCB0aGUgcmVxdWVzdCBhbmQgcmUtdGhyb3cgdGhlXG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGEgcGVybWlzc2lvbnMgcmVxdWVzdCBjcmVhdGVkIGJ5XG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9uc30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIHJlcXVlc3QgdG8gYmUgcmVqZWN0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBcHByb3ZhbFJlcXVlc3QoeyBpZCB9KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3JzXzEudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHtAbGluayBBcHByb3ZhbENvbnRyb2xsZXJ9IGhhcyBhIHBhcnRpY3VsYXIgcGVybWlzc2lvbnNcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0fSBhbmRcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0fSBmb3IgdXNhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUge0BsaW5rIEhhc0FwcHJvdmFsUmVxdWVzdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdCB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHJlcXVlc3QgZXhpc3RzLlxuICAgICAqL1xuICAgIGhhc0FwcHJvdmFsUmVxdWVzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdBcHByb3ZhbENvbnRyb2xsZXI6aGFzUmVxdWVzdCcsIFxuICAgICAgICAvLyBUeXBlY2FzdDogRm9yIHNvbWUgcmVhc29uLCB0aGUgdHlwZSBoZXJlIGV4cGVjdHMgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgICAgICAvLyBIYXNBcHByb3ZhbFJlcXVlc3Qgb3B0aW9ucyB0byBiZSBzcGVjaWZpZWQsIHdoZW4gdGhleSdyZSBhY3R1YWxseSBhbGxcbiAgICAgICAgLy8gb3B0aW9uYWwuIFBhc3NpbmcganVzdCB0aGUgaWQgaXMgZGVmaW5pdGVseSB2YWxpZCwgc28gd2UganVzdCBjYXN0IGl0LlxuICAgICAgICBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyB0aGUgcGVybWlzc2lvbnMgcmVxdWVzdCB3aXRoIHRoZSBzcGVjaWZpZWQgaWQsIHdpdGggdGhlIHNwZWNpZmllZFxuICAgICAqIGVycm9yIGFzIHRoZSByZWFzb24uIFRoaXMgbWV0aG9kIGlzIGVmZmVjdGl2ZWx5IGEgd3JhcHBlciBhcm91bmQgYVxuICAgICAqIG1lc3NlbmdlciBjYWxsIGZvciB0aGUgYEFwcHJvdmFsQ29udHJvbGxlcjpyZWplY3RSZXF1ZXN0YCBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3R9IGFuZFxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3R9IGZvciB1c2FnZS5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIHJlcXVlc3QgdG8gcmVqZWN0LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhlIHJlamVjdGlvbi5cbiAgICAgKi9cbiAgICBfcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOnJlamVjdFJlcXVlc3QnLCBpZCwgZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIHJlc3RyaWN0ZWQgbWV0aG9kIGFzIHRoZSBzdWJqZWN0IHdpdGggdGhlIGdpdmVuIG9yaWdpbi5cbiAgICAgKiBUaGUgc3BlY2lmaWVkIHBhcmFtcywgaWYgYW55LCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogKipBVFROOioqIEdyZWF0IGNhdXRpb24gc2hvdWxkIGJlIGV4ZXJjaXNlZCBpbiB0aGUgdXNlIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqIE1ldGhvZHMgdGhhdCBjYXVzZSBzaWRlIGVmZmVjdHMgb3IgYWZmZWN0IGFwcGxpY2F0aW9uIHN0YXRlIHNob3VsZFxuICAgICAqIGJlIGF2b2lkZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGZpcnN0IGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIHJlcXVlc3RlZCByZXN0cmljdGVkIG1ldGhvZFxuICAgICAqIGltcGxlbWVudGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2VzIG5vdCBleGlzdC4gVGhlIG1ldGhvZCB3aWxsIHRoZW4gYmVcbiAgICAgKiBpbnZva2VkIGFzIHRob3VnaCB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZ2luIGhhZCBpbnZva2VkIGl0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuIFRoaXMgbWVhbnMgdGhhdCBhbnkgZXhpc3RpbmcgY2F2ZWF0cyB3aWxsIGJlXG4gICAgICogYXBwbGllZCB0byB0aGUgcmVzdHJpY3RlZCBtZXRob2QsIGFuZCB0aGlzIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZVxuICAgICAqIHJlc3RyaWN0ZWQgbWV0aG9kIG9yIGl0cyBjYXZlYXQgZGVjb3JhdG9ycyB0aHJvdy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgYVxuICAgICAqIHBlcm1pc3Npb24gZm9yIHRoZSBzcGVjaWZpZWQgcmVzdHJpY3RlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCB0byBleGVjdXRlIHRoZSBtZXRob2Qgb24gYmVoYWxmXG4gICAgICogb2YuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGV4ZWN1dGUuIFRoaXMgbXVzdCBiZSBhIHZhbGlkXG4gICAgICogcGVybWlzc2lvbiB0YXJnZXQgbmFtZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGV4ZWN1dGVkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZChvcmlnaW4sIHRhcmdldE5hbWUsIHBhcmFtcykge1xuICAgICAgICAvLyBUaHJvd3MgaWYgdGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBjb25zdCBtZXRob2RJbXBsZW1lbnRhdGlvbiA9IHRoaXMuZ2V0UmVzdHJpY3RlZE1ldGhvZCh0YXJnZXROYW1lLCBvcmlnaW4pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZChtZXRob2RJbXBsZW1lbnRhdGlvbiwgeyBvcmlnaW4gfSwgdGFyZ2V0TmFtZSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIHJlcXVlc3QgZm9yIG1ldGhvZCBcIiR7dGFyZ2V0TmFtZX1cIiBhcyBvcmlnaW4gXCIke29yaWdpbn1cIiByZXR1cm5lZCBubyByZXN1bHQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJuYWwgbWV0aG9kIHVzZWQgaW4gdGhlIGNvbnRyb2xsZXIncyBganNvbi1ycGMtZW5naW5lYCBtaWRkbGV3YXJlXG4gICAgICogYW5kIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0uIENhbGxzIHRoZVxuICAgICAqIHNwZWNpZmllZCByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBhZnRlciBkZWNvcmF0aW5nIGl0IHdpdGggdGhlXG4gICAgICogY2F2ZWF0cyBvZiBpdHMgcGVybWlzc2lvbi4gVGhyb3dzIGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgdGhlXG4gICAgICogcmVxdWlzaXRlIHBlcm1pc3Npb24uXG4gICAgICpcbiAgICAgKiAqKkFUVE46KiogUGFyYW1ldGVyIHZhbGlkYXRpb24gaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIsIG9yXG4gICAgICogdGhlIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uIGluIHRoZSBjYXNlIG9mIGBwYXJhbXNgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2R9IGFuZFxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5jcmVhdGVQZXJtaXNzaW9uTWlkZGxld2FyZX0gZm9yIHVzYWdlLlxuICAgICAqIEBwYXJhbSBtZXRob2RJbXBsZW1lbnRhdGlvbiAtIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbWV0aG9kIHRvIGNhbGwuXG4gICAgICogQHBhcmFtIHN1YmplY3QgLSBNZXRhZGF0YSBhYm91dCB0aGUgc3ViamVjdCB0aGF0IG1hZGUgdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBfZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QobWV0aG9kSW1wbGVtZW50YXRpb24sIHN1YmplY3QsIG1ldGhvZCwgcGFyYW1zID0gW10pIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW4gfSA9IHN1YmplY3Q7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSB0aGlzLmdldFBlcm1pc3Npb24ob3JpZ2luLCBtZXRob2QpO1xuICAgICAgICBpZiAoIXBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc18xLnVuYXV0aG9yaXplZCh7IGRhdGE6IHsgb3JpZ2luLCBtZXRob2QgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2F2ZWF0XzEuZGVjb3JhdGVXaXRoQ2F2ZWF0cyhtZXRob2RJbXBsZW1lbnRhdGlvbiwgcGVybWlzc2lvbiwgdGhpcy5fY2F2ZWF0U3BlY2lmaWNhdGlvbnMpKHsgbWV0aG9kLCBwYXJhbXMsIGNvbnRleHQ6IHsgb3JpZ2luIH0gfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJtaXNzaW9uQ29udHJvbGxlciA9IFBlcm1pc3Npb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVybWlzc2lvbkNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc1N0cmVhbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVyZ2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChcImRldmVsb3BtZW50XCIgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmMtdXItcmVnaXN0cnktZXRoLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYXNlLWV0aC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVBc3luY01pZGRsZXdhcmUgfSBmcm9tICdqc29uLXJwYy1lbmdpbmUnO1xuaW1wb3J0IHsgZm9ybWF0VHhNZXRhRm9yUnBjUmVzdWx0IH0gZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nTm9uY2VNaWRkbGV3YXJlKHsgZ2V0UGVuZGluZ05vbmNlIH0pIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSByZXE7XG4gICAgaWYgKG1ldGhvZCAhPT0gJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50Jykge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyYW0sIGJsb2NrUmVmXSA9IHBhcmFtcztcbiAgICBpZiAoYmxvY2tSZWYgIT09ICdwZW5kaW5nJykge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXMucmVzdWx0ID0gYXdhaXQgZ2V0UGVuZGluZ05vbmNlKHBhcmFtKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nVHhNaWRkbGV3YXJlKHsgZ2V0UGVuZGluZ1RyYW5zYWN0aW9uQnlIYXNoIH0pIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSByZXE7XG4gICAgaWYgKG1ldGhvZCAhPT0gJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2hhc2hdID0gcGFyYW1zO1xuICAgIGNvbnN0IHR4TWV0YSA9IGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaChoYXNoKTtcbiAgICBpZiAoIXR4TWV0YSkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXMucmVzdWx0ID0gZm9ybWF0VHhNZXRhRm9yUnBjUmVzdWx0KHR4TWV0YSk7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZ2V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBLZXlWYWx1ZVN0b3JlID0gcmVxdWlyZSgnLi9rZXlWYWx1ZVN0b3JlJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXgnKTtcblxudmFyIEVOQ19CTE9DS19TSVpFID0gMjQ7XG5cbnZhciBQcml2YXRlU3RvcmUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LZXlWYWx1ZVN0b3JlKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlLCBfS2V5VmFsdWVTdG9yZSk7XG5cbiAgZnVuY3Rpb24gUHJpdmF0ZVN0b3JlKG9yYml0ZGIsIG5hbWUsIGVuc3VyZUNvbm5lY3RlZCwgXzNpZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgUHJpdmF0ZVN0b3JlKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByaXZhdGVTdG9yZSkuY2FsbCh0aGlzLCBvcmJpdGRiLCBuYW1lLCBlbnN1cmVDb25uZWN0ZWQsIF8zaWQpKTtcbiAgICBfdGhpcy5rZXlyaW5nID0gXzNpZC5nZXRLZXlyaW5nQnlTcGFjZU5hbWUobmFtZSk7XG4gICAgX3RoaXMuX3NhbHQgPSBfdGhpcy5rZXlyaW5nLmdldERCU2FsdCgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5KSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9nZXQzW1wiZGVmYXVsdFwiXSkoKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShQcml2YXRlU3RvcmUucHJvdG90eXBlKSwgXCJnZXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLl9nZW5EYktleShrZXkpLCBvcHRzKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZW50cnkgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGlmICghb3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9vYmplY3RTcHJlYWQoe30sIGVudHJ5LCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fZGVjcnlwdEVudHJ5KGVudHJ5LnZhbHVlKVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kZWNyeXB0RW50cnkoZW50cnkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldChfeCkge1xuICAgICAgICByZXR1cm4gX2dldDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRNZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1ldGFkYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCAoMCwgX2dldDNbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByaXZhdGVTdG9yZS5wcm90b3R5cGUpLCBcImdldE1ldGFkYXRhXCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcy5fZ2VuRGJLZXkoa2V5KSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRNZXRhZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0TWV0YWRhdGE7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9lbmNyeXB0RW50cnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuX2dlbkRiS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9nZXQzW1wiZGVmYXVsdFwiXSkoKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShQcml2YXRlU3RvcmUucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBrZXksIHZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldChfeDMsIF94NCkge1xuICAgICAgICByZXR1cm4gX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNldE11bHRpcGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0TXVsdGlwbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoa2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYktleXMsIGVuY3J5cHRlZFZhbHVlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXRpbHMudGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGtleXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZGJLZXlzID0ga2V5cy5tYXAodGhpcy5fZ2VuRGJLZXksIHRoaXMpO1xuICAgICAgICAgICAgICAgIGVuY3J5cHRlZFZhbHVlcyA9IHZhbHVlcy5tYXAodGhpcy5fZW5jcnlwdEVudHJ5LCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCAoMCwgX2dldDNbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByaXZhdGVTdG9yZS5wcm90b3R5cGUpLCBcInNldE11bHRpcGxlXCIsIHRoaXMpLmNhbGwodGhpcywgZGJLZXlzLCBlbmNyeXB0ZWRWYWx1ZXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0TXVsdGlwbGUoX3g1LCBfeDYpIHtcbiAgICAgICAgcmV0dXJuIF9zZXRNdWx0aXBsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0TXVsdGlwbGU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVtb3ZlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLl9nZW5EYktleShrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfZ2V0M1tcImRlZmF1bHRcIl0pKCgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoUHJpdmF0ZVN0b3JlLnByb3RvdHlwZSksIFwicmVtb3ZlXCIsIHRoaXMpLmNhbGwodGhpcywga2V5KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZShfeDcpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIHVuZGVybHlpbmcgbG9nIGVudHJpZXMuIEluIGxpbmVhcml6ZWQgb3JkZXIgYWNjb3JkaW5nIHRvIHRoZWlyIExhbXBvcnQgY2xvY2tzLlxuICAgICAqIFVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBhIGNvbXBsZXRlIGhpc3Rvcnkgb2YgYWxsIG9wZXJhdGlvbnMgb24gc3RvcmUuIEtleSBpcyBoYXNoZWQsIHNvIGtleSBpc1xuICAgICAqIG5vdCBhdmFpbGFibGUgZnJvbSB0aGUgcHJpdmF0ZSBzdG9yZS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZVxuICAgICAqICBjb25zdCBsb2cgPSBzdG9yZS5sb2dcbiAgICAgKiAgY29uc3QgZW50cnkgPSBsb2dbMF1cbiAgICAgKiAgY29uc29sZS5sb2coZW50cnkpXG4gICAgICogIC8vIHsgb3A6ICdQVVQnLCBrZXk6IC4uLi4sIHZhbHVlOiAnQm90Ym90JywgdGltZVN0YW1wOiAnMTUzODU3NTQxNjA2OCcgfVxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7QXJyYXk8T2JqZWN0Pn0gICAgIEFycmF5IG9mIG9yZGVyZWQgbG9nIGVudHJ5IG9iamVjdHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZW5EYktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuRGJLZXkoa2V5KSB7XG4gICAgICB1dGlscy50aHJvd0lmVW5kZWZpbmVkKGtleSwgJ2tleScpO1xuICAgICAgcmV0dXJuIHV0aWxzLnNoYTI1Nk11bHRpaGFzaCh0aGlzLl9zYWx0ICsga2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VuY3J5cHRFbnRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5jcnlwdEVudHJ5KGVudHJ5KSB7XG4gICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdFbnRyeSB0byBlbmNyeXB0IGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICAgIHJldHVybiB0aGlzLmtleXJpbmcuc3ltRW5jcnlwdCh0aGlzLl9wYWQoSlNPTi5zdHJpbmdpZnkoZW50cnkpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWNyeXB0RW50cnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY3J5cHRFbnRyeShfcmVmKSB7XG4gICAgICB2YXIgY2lwaGVydGV4dCA9IF9yZWYuY2lwaGVydGV4dCxcbiAgICAgICAgICBub25jZSA9IF9yZWYubm9uY2U7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLl91bnBhZCh0aGlzLmtleXJpbmcuc3ltRGVjcnlwdChjaXBoZXJ0ZXh0LCBub25jZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFkKHZhbCkge1xuICAgICAgdmFyIGJsb2NrU2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRU5DX0JMT0NLX1NJWkU7XG4gICAgICB2YXIgYmxvY2tEaWZmID0gKGJsb2NrU2l6ZSAtIHZhbC5sZW5ndGggJSBibG9ja1NpemUpICUgYmxvY2tTaXplO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbCkuY29uY2F0KCdcXDAnLnJlcGVhdChibG9ja0RpZmYpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VucGFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bnBhZChwYWRkZWQpIHtcbiAgICAgIHJldHVybiBwYWRkZWQucmVwbGFjZSgvXFwwKyQvLCAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiAoMCwgX2dldDNbXCJkZWZhdWx0XCJdKSgoMCwgX2dldFByb3RvdHlwZU9mMltcImRlZmF1bHRcIl0pKFByaXZhdGVTdG9yZS5wcm90b3R5cGUpLCBcImxvZ1wiLCB0aGlzKS5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIHtcbiAgICAgICAgICB2YWx1ZTogb2JqLnZhbHVlID8gX3RoaXMyLl9kZWNyeXB0RW50cnkob2JqLnZhbHVlKSA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFByaXZhdGVTdG9yZTtcbn0oS2V5VmFsdWVTdG9yZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpdmF0ZVN0b3JlOyIsInZhciBlbmdpbmUgPSByZXF1aXJlKCcuLi9zcmMvc3RvcmUtZW5naW5lJylcblxudmFyIHN0b3JhZ2VzID0gcmVxdWlyZSgnLi4vc3RvcmFnZXMvYWxsJylcbnZhciBwbHVnaW5zID0gW3JlcXVpcmUoJy4uL3BsdWdpbnMvanNvbjInKV1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmdpbmUuY3JlYXRlU3RvcmUoc3RvcmFnZXMsIHBsdWdpbnMpXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIEtleVZhbHVlU3RvcmUgPSByZXF1aXJlKCcuL2tleVZhbHVlU3RvcmUnKTtcblxudmFyIFRocmVhZCA9IHJlcXVpcmUoJy4vdGhyZWFkJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMnKSxcbiAgICBzaGEyNTZNdWx0aWhhc2ggPSBfcmVxdWlyZS5zaGEyNTZNdWx0aWhhc2gsXG4gICAgdGhyb3dJZlVuZGVmaW5lZCA9IF9yZXF1aXJlLnRocm93SWZVbmRlZmluZWQsXG4gICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzID0gX3JlcXVpcmUudGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzO1xuXG52YXIgT3JiaXREQkFkZHJlc3MgPSByZXF1aXJlKCdvcmJpdC1kYi9zcmMvb3JiaXQtZGItYWRkcmVzcycpO1xuXG52YXIgRU5DX0JMT0NLX1NJWkUgPSAyNDtcblxudmFyIG5hbWVUb1NwYWNlTmFtZSA9IGZ1bmN0aW9uIG5hbWVUb1NwYWNlTmFtZShuYW1lKSB7XG4gIHJldHVybiBcIjNib3guc3BhY2UuXCIuY29uY2F0KG5hbWUsIFwiLmtleXZhbHVlXCIpO1xufTtcblxudmFyIG5hbWVzVG90aHJlYWROYW1lID0gZnVuY3Rpb24gbmFtZXNUb3RocmVhZE5hbWUoc3BhY2VOYW1lLCB0aHJlYWROYW1lKSB7XG4gIHJldHVybiBcIjNib3gudGhyZWFkLlwiLmNvbmNhdChzcGFjZU5hbWUsIFwiLlwiKS5jb25jYXQodGhyZWFkTmFtZSk7XG59O1xuXG52YXIgU3BhY2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUGxlYXNlIHVzZSAqKmJveC5vcGVuU3BhY2UqKiB0byBnZXQgdGhlIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIFNwYWNlKG5hbWUsIHRocmVlSWQsIG9yYml0ZGIsIHJvb3RTdG9yZSwgZW5zdXJlQ29ubmVjdGVkKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBTcGFjZSk7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fM2lkID0gdGhyZWVJZDtcbiAgICB0aGlzLl9lbnN1cmVDb25uZWN0ZWQgPSBlbnN1cmVDb25uZWN0ZWQ7XG4gICAgdGhpcy5fc3RvcmUgPSBuZXcgS2V5VmFsdWVTdG9yZShvcmJpdGRiLCBuYW1lVG9TcGFjZU5hbWUodGhpcy5fbmFtZSksIHRoaXMuX2Vuc3VyZUNvbm5lY3RlZCwgdGhpcy5fM2lkKTtcbiAgICB0aGlzLl9vcmJpdGRiID0gb3JiaXRkYjtcbiAgICB0aGlzLl9hY3RpdmVUaHJlYWRzID0ge307XG4gICAgdGhpcy5fcm9vdFN0b3JlID0gcm9vdFN0b3JlO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7S2V5VmFsdWVTdG9yZX0gcHVibGljICAgICAgICAgYWNjZXNzIHRoZSBwcm9maWxlIHN0b3JlIG9mIHRoZSBzcGFjZVxuICAgICAqL1xuXG4gICAgdGhpc1tcInB1YmxpY1wiXSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtLZXlWYWx1ZVN0b3JlfSBwcml2YXRlICAgICAgICBhY2Nlc3MgdGhlIHByaXZhdGUgc3RvcmUgb2YgdGhlIHNwYWNlXG4gICAgICovXG5cbiAgICB0aGlzW1wicHJpdmF0ZVwiXSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBESUQgICAgICAgIHRoZSBkaWQgb2YgdGhlIHVzZXIgaW4gdGhpcyBzcGFjZVxuICAgKi9cblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoU3BhY2UsIFt7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgY29uc2VudE5lZWRlZCxcbiAgICAgICAgICAgIHNwYWNlQWRkcmVzcyxcbiAgICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgIGhhc051bUVudHJpZXMsXG4gICAgICAgICAgICBudW1FbnRyaWVzLFxuICAgICAgICAgICAgc3luY1NwYWNlLFxuICAgICAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MyLmxlbmd0aCA+IDAgJiYgX2FyZ3MyWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9yZS5fZGIpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5pbml0S2V5cmluZ0J5TmFtZSh0aGlzLl9uYW1lKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY29uc2VudE5lZWRlZCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNvbnNlbnRDYWxsYmFjaykgb3B0cy5jb25zZW50Q2FsbGJhY2soY29uc2VudE5lZWRlZCwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5fbG9hZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzcGFjZUFkZHJlc3MgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuaXRlcmF0b3Ioe1xuICAgICAgICAgICAgICAgICAgbGltaXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkuY29sbGVjdCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgZW50cmllcyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gZW50cmllcy5maW5kKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnBheWxvYWQudmFsdWUub2RiQWRkcmVzcyAmJiBlbnRyeS5wYXlsb2FkLnZhbHVlLm9kYkFkZHJlc3MuaW5kZXhPZihuYW1lVG9TcGFjZU5hbWUoX3RoaXMuX25hbWUpKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgICAgICAgICAgICBESUQ6IHRoaXMuRElELFxuICAgICAgICAgICAgICAgICAgb2RiQWRkcmVzczogc3BhY2VBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnBheWxvYWQudmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RTdG9yZS5kZWwoZW50cnkuaGFzaCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290U3RvcmUuYWRkKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgICAgICAgICAgICBESUQ6IHRoaXMuRElELFxuICAgICAgICAgICAgICAgICAgb2RiQWRkcmVzczogc3BhY2VBZGRyZXNzXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICBoYXNOdW1FbnRyaWVzID0gb3B0cy5udW1FbnRyaWVzTWVzc2FnZXMgJiYgb3B0cy5udW1FbnRyaWVzTWVzc2FnZXNbc3BhY2VBZGRyZXNzXTtcbiAgICAgICAgICAgICAgICBudW1FbnRyaWVzID0gaGFzTnVtRW50cmllcyA/IG9wdHMubnVtRW50cmllc01lc3NhZ2VzW3NwYWNlQWRkcmVzc10ubnVtRW50cmllcyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHN5bmNTcGFjZSA9XG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zdG9yZS5fc3luYyhudW1FbnRyaWVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMub25TeW5jRG9uZSkgb3B0cy5vblN5bmNEb25lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3luY1NwYWNlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zeW5jU3BhY2VQcm9taXNlID0gc3luY1NwYWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpc1tcInB1YmxpY1wiXSA9IHB1YmxpY1N0b3JlUmVkdWNlcih0aGlzLl9zdG9yZSk7XG4gICAgICAgICAgICAgICAgdGhpc1tcInByaXZhdGVcIl0gPSBwcml2YXRlU3RvcmVSZWR1Y2VyKHRoaXMuX3N0b3JlLCB0aGlzLl8zaWQuZ2V0S2V5cmluZ0J5U3BhY2VOYW1lKG5hbWVUb1NwYWNlTmFtZSh0aGlzLl9uYW1lKSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIF9vcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcGVuO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEpvaW4gYSB0aHJlYWQuIFVzZSB0aGlzIHRvIHN0YXJ0IHJlY2VpdmluZyB1cGRhdGVzIGZyb20sIGFuZCB0byBwb3N0IGluIHRocmVhZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgbmFtZSAgICAgICAgICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHRocmVhZFxuICAgICAqIEBwYXJhbSAgICAge09iamVjdH0gICAgb3B0cyAgICAgICAgICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5maXJzdE1vZGVyYXRvciAgICAgRElEIG9mIGZpcnN0IG1vZGVyYXRvciBvZiBhIHRocmVhZCwgYnkgZGVmYXVsdCwgdXNlciBpcyBmaXJzdCBtb2RlcmF0b3JcbiAgICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMubWVtYmVycyAgICAgICAgICAgIGpvaW4gYSBtZW1iZXJzIG9ubHkgdGhyZWFkLCB3aGljaCBvbmx5IG1lbWJlcnMgY2FuIHBvc3QgaW4sIGRlZmF1bHRzIHRvIG9wZW4gdGhyZWFkXG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLm5vQXV0b1N1YiAgICAgICAgICBEaXNhYmxlIGF1dG8gc3Vic2NyaXB0aW9uIHRvIHRoZSB0aHJlYWQgd2hlbiBwb3N0aW5nIHRvIGl0IChkZWZhdWx0IGZhbHNlKVxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7VGhyZWFkfSAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgdGhyZWFkIGNsYXNzIGZvciB0aGUgam9pbmVkIHRocmVhZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblRocmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2pvaW5UaHJlYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMobmFtZSkge1xuICAgICAgICB2YXIgb3B0cyxcbiAgICAgICAgICAgIHN1YnNjcmliZUZuLFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzMy5sZW5ndGggPiAxICYmIF9hcmdzM1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzFdIDoge307XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlRm4gPSBvcHRzLm5vQXV0b1N1YiA/IGZ1bmN0aW9uICgpIHt9IDogdGhpcy5zdWJzY3JpYmVUaHJlYWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMuZmlyc3RNb2RlcmF0b3IpIG9wdHMuZmlyc3RNb2RlcmF0b3IgPSB0aGlzLl8zaWQuZ2V0U3ViRElEKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgICAgIHRocmVhZCA9IG5ldyBUaHJlYWQodGhpcy5fb3JiaXRkYiwgbmFtZXNUb3RocmVhZE5hbWUodGhpcy5fbmFtZSwgbmFtZSksIHRoaXMuXzNpZCwgb3B0cy5tZW1iZXJzLCBvcHRzLmZpcnN0TW9kZXJhdG9yLCBzdWJzY3JpYmVGbiwgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocmVhZC5fZ2V0VGhyZWFkQWRkcmVzcygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10pO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJlYWQuX2xvYWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10gPSB0aHJlYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhyZWFkKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGpvaW5UaHJlYWQoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9qb2luVGhyZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqb2luVGhyZWFkO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEpvaW4gYSB0aHJlYWQgYnkgZnVsbCB0aHJlYWQgYWRkcmVzcy4gVXNlIHRoaXMgdG8gc3RhcnQgcmVjZWl2aW5nIHVwZGF0ZXMgZnJvbSwgYW5kIHRvIHBvc3QgaW4gdGhyZWFkc1xuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgICBUaGUgZnVsbCBhZGRyZXNzIG9mIHRoZSB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMubm9BdXRvU3ViICAgICAgICAgIERpc2FibGUgYXV0byBzdWJzY3JpcHRpb24gdG8gdGhlIHRocmVhZCB3aGVuIHBvc3RpbmcgdG8gaXQgKGRlZmF1bHQgZmFsc2UpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtUaHJlYWR9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGluc3RhbmNlIG9mIHRoZSB0aHJlYWQgY2xhc3MgZm9yIHRoZSBqb2luZWQgdGhyZWFkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJqb2luVGhyZWFkQnlBZGRyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfam9pblRocmVhZEJ5QWRkcmVzcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgdGhyZWFkU3BhY2UsXG4gICAgICAgICAgICB0aHJlYWROYW1lLFxuICAgICAgICAgICAgc3Vic2NyaWJlRm4sXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBfYXJnczQgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczQubGVuZ3RoID4gMSAmJiBfYXJnczRbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNFsxXSA6IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKE9yYml0REJBZGRyZXNzLmlzVmFsaWQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pblRocmVhZEJ5QWRkcmVzczogdmFsaWQgb3JiaXRkYiBhZGRyZXNzIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRocmVhZFNwYWNlID0gYWRkcmVzcy5zcGxpdCgnLicpWzJdO1xuICAgICAgICAgICAgICAgIHRocmVhZE5hbWUgPSBhZGRyZXNzLnNwbGl0KCcuJylbM107XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aHJlYWRTcGFjZSAhPT0gdGhpcy5fbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pblRocmVhZEJ5QWRkcmVzczogYXR0ZW1wdGluZyB0byBvcGVuIHRocmVhZCBmcm9tIGRpZmZlcmVudCBzcGFjZSwgbXVzdCBvcGVuIHdpdGhpbiBzYW1lIHNwYWNlJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlVGhyZWFkc1thZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fYWN0aXZlVGhyZWFkc1thZGRyZXNzXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHN1YnNjcmliZUZuID0gb3B0cy5ub0F1dG9TdWIgPyBmdW5jdGlvbiAoKSB7fSA6IHRoaXMuc3Vic2NyaWJlVGhyZWFkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhyZWFkID0gbmV3IFRocmVhZCh0aGlzLl9vcmJpdGRiLCBuYW1lc1RvdGhyZWFkTmFtZSh0aGlzLl9uYW1lLCB0aHJlYWROYW1lKSwgdGhpcy5fM2lkLCBvcHRzLm1lbWJlcnMsIG9wdHMuZmlyc3RNb2RlcmF0b3IsIHN1YnNjcmliZUZuLCB0aGlzLl9lbnN1cmVDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocmVhZC5fbG9hZChhZGRyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVRocmVhZHNbYWRkcmVzc10gPSB0aHJlYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhyZWFkKTtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGpvaW5UaHJlYWRCeUFkZHJlc3MoX3gyKSB7XG4gICAgICAgIHJldHVybiBfam9pblRocmVhZEJ5QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gam9pblRocmVhZEJ5QWRkcmVzcztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGdpdmVuIHRocmVhZCwgaWYgbm90IGFscmVhZHkgc3Vic2NyaWJlZFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICAgICAgICAgICAgIFRoZSBhZGRyZXNzIG9mIHRoZSB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIGNvbmZpZyAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uIGFuZCB0aHJlYWQgbWV0YSBkYXRhXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBvcHRzLm5hbWUgICAgICAgICAgICAgTmFtZSBvZiB0aHJlYWRcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMuZmlyc3RNb2RlcmF0b3IgICBESUQgb2YgdGhlIGZpcnN0IG1vZGVyYXRvclxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5tZW1iZXJzICAgICAgICAgIEJvb2xlYW4gc3RyaW5nLCB0cnVlIGlmIGEgbWVtYmVycyBvbmx5IHRocmVhZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3Vic2NyaWJlVGhyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3Vic2NyaWJlVGhyZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIGNvbmZpZyxcbiAgICAgICAgICAgIHRocmVhZEtleSxcbiAgICAgICAgICAgIF9hcmdzNSA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uZmlnID0gX2FyZ3M1Lmxlbmd0aCA+IDEgJiYgX2FyZ3M1WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczVbMV0gOiB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChPcmJpdERCQWRkcmVzcy5pc1ZhbGlkKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZVRocmVhZDogbXVzdCBzdWJzY3JpYmUgdG8gdmFsaWQgdGhyZWFkL29yYml0ZGIgYWRkcmVzcycpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aHJlYWRLZXkgPSBcInRocmVhZC1cIi5jb25jYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zeW5jU3BhY2VQcm9taXNlO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJwdWJsaWNcIl0uZ2V0KHRocmVhZEtleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dDUuc2VudCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJwdWJsaWNcIl0uc2V0KHRocmVhZEtleSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlVGhyZWFkKF94Mykge1xuICAgICAgICByZXR1cm4gX3N1YnNjcmliZVRocmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaWJlVGhyZWFkO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGdpdmVuIHRocmVhZCwgaWYgc3Vic2NyaWJlZFxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBhZGRyZXNzICAgICBUaGUgYWRkcmVzcyBvZiB0aGUgdGhyZWFkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bnN1YnNjcmliZVRocmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3Vuc3Vic2NyaWJlVGhyZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGFkZHJlc3MpIHtcbiAgICAgICAgdmFyIHRocmVhZEtleTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyZWFkS2V5ID0gXCJ0aHJlYWQtXCIuY29uY2F0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tcInB1YmxpY1wiXS5nZXQodGhyZWFkS2V5KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCFfY29udGV4dDYuc2VudCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1wicHVibGljXCJdLnJlbW92ZSh0aHJlYWRLZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZVRocmVhZChfeDQpIHtcbiAgICAgICAgcmV0dXJuIF91bnN1YnNjcmliZVRocmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmVUaHJlYWQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhbGwgdGhlIHRocmVhZHMgc3Vic2NyaWJlZCB0byBpbiB0aGlzIHNwYWNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtBcnJheTxPYmplY3RzPn0gICAgQSBsaXN0IG9mIHRocmVhZCBvYmplY3RzIGFzIHsgYWRkcmVzcywgZmlyc3RNb2RlcmF0b3IsIG1lbWJlcnMsIG5hbWV9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVkVGhyZWFkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N1YnNjcmliZWRUaHJlYWRzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KCkge1xuICAgICAgICB2YXIgYWxsRW50cmllcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1wicHVibGljXCJdLmFsbCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhbGxFbnRyaWVzID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgT2JqZWN0LmtleXMoYWxsRW50cmllcykucmVkdWNlKGZ1bmN0aW9uICh0aHJlYWRzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgndGhyZWFkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlcyBleHBlcmltZW50YWwgdGhyZWFkcyAodjEpXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzID0ga2V5LnNwbGl0KCd0aHJlYWQtJylbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKE9yYml0REJBZGRyZXNzLmlzVmFsaWQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRzLnB1c2goYWxsRW50cmllc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhyZWFkcztcbiAgICAgICAgICAgICAgICB9LCBbXSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdWJzY3JpYmVkVGhyZWFkcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdWJzY3JpYmVkVGhyZWFkcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaWJlZFRocmVhZHM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiRElEXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fM2lkLmdldFN1YkRJRCh0aGlzLl9uYW1lKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNwYWNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlO1xuXG52YXIgcHVibGljU3RvcmVSZWR1Y2VyID0gZnVuY3Rpb24gcHVibGljU3RvcmVSZWR1Y2VyKHN0b3JlKSB7XG4gIHZhciBQUkVGSVggPSAncHViXyc7XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChrZXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJnczggPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBfYXJnczgubGVuZ3RoID4gMSAmJiBfYXJnczhbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFsxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIHN0b3JlLmdldChQUkVGSVggKyBrZXksIG9wdHMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0KF94NSkge1xuICAgICAgICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0O1xuICAgIH0oKSxcbiAgICBnZXRNZXRhZGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRNZXRhZGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ5LnByZXYgPSBfY29udGV4dDkubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuZ2V0TWV0YWRhdGEoUFJFRklYICsga2V5KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKF94Nikge1xuICAgICAgICByZXR1cm4gX2dldE1ldGFkYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRNZXRhZGF0YTtcbiAgICB9KCksXG4gICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZlVuZGVmaW5lZChrZXksICdrZXknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuc2V0KFBSRUZJWCArIGtleSwgdmFsdWUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTApO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXQoX3g3LCBfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9KCksXG4gICAgc2V0TXVsdGlwbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0TXVsdGlwbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgcHJlZml4ZWRLZXlzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGtleXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcHJlZml4ZWRLZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFBSRUZJWCArIGtleTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuc2V0TXVsdGlwbGUocHJlZml4ZWRLZXlzLCB2YWx1ZXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRNdWx0aXBsZShfeDksIF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9zZXRNdWx0aXBsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0TXVsdGlwbGU7XG4gICAgfSgpLFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZlVuZGVmaW5lZChrZXksICdrZXknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUucmVtb3ZlKFBSRUZJWCArIGtleSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZShfeDExKSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfSgpLFxuXG4gICAgZ2V0IGxvZygpIHtcbiAgICAgIHJldHVybiBzdG9yZS5sb2cucmVkdWNlKGZ1bmN0aW9uIChuZXdMb2csIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgZW50cnkua2V5ID0gZW50cnkua2V5LnNsaWNlKDQpO1xuICAgICAgICAgIG5ld0xvZy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdMb2c7XG4gICAgICB9LCBbXSk7XG4gICAgfSxcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hbGwgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEzKG9wdHMpIHtcbiAgICAgICAgdmFyIGVudHJpZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5hbGwob3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDEzLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIE9iamVjdC5rZXlzKGVudHJpZXMpLnJlZHVjZShmdW5jdGlvbiAobmV3QWxsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0FsbFtrZXkuc2xpY2UoNCldID0gZW50cmllc1trZXldO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3QWxsO1xuICAgICAgICAgICAgICAgIH0sIHt9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWxsKF94MTIpIHtcbiAgICAgICAgcmV0dXJuIF9hbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9KClcbiAgfTtcbn07XG5cbnZhciBwcml2YXRlU3RvcmVSZWR1Y2VyID0gZnVuY3Rpb24gcHJpdmF0ZVN0b3JlUmVkdWNlcihzdG9yZSwga2V5cmluZykge1xuICB2YXIgUFJFRklYID0gJ3ByaXZfJztcbiAgdmFyIFNBTFQgPSBrZXlyaW5nLmdldERCU2FsdCgpO1xuXG4gIHZhciBkYktleSA9IGZ1bmN0aW9uIGRiS2V5KGtleSkge1xuICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG4gICAgcmV0dXJuIFBSRUZJWCArIHNoYTI1Nk11bHRpaGFzaChTQUxUICsga2V5KTtcbiAgfTtcblxuICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKHZhbCkge1xuICAgIHZhciBibG9ja1NpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEVOQ19CTE9DS19TSVpFO1xuICAgIHZhciBibG9ja0RpZmYgPSAoYmxvY2tTaXplIC0gdmFsLmxlbmd0aCAlIGJsb2NrU2l6ZSkgJSBibG9ja1NpemU7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbCkuY29uY2F0KCdcXDAnLnJlcGVhdChibG9ja0RpZmYpKTtcbiAgfTtcblxuICB2YXIgdW5wYWQgPSBmdW5jdGlvbiB1bnBhZChwYWRkZWQpIHtcbiAgICByZXR1cm4gcGFkZGVkLnJlcGxhY2UoL1xcMCskLywgJycpO1xuICB9O1xuXG4gIHZhciBlbmNyeXB0RW50cnkgPSBmdW5jdGlvbiBlbmNyeXB0RW50cnkoZW50cnkpIHtcbiAgICByZXR1cm4ga2V5cmluZy5zeW1FbmNyeXB0KHBhZChKU09OLnN0cmluZ2lmeShlbnRyeSkpKTtcbiAgfTtcblxuICB2YXIgZGVjcnlwdEVudHJ5ID0gZnVuY3Rpb24gZGVjcnlwdEVudHJ5KF9yZWYyKSB7XG4gICAgdmFyIGNpcGhlcnRleHQgPSBfcmVmMi5jaXBoZXJ0ZXh0LFxuICAgICAgICBub25jZSA9IF9yZWYyLm5vbmNlO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHVucGFkKGtleXJpbmcuc3ltRGVjcnlwdChjaXBoZXJ0ZXh0LCBub25jZSkpKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChrZXkpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgIF9hcmdzMTQgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE0JChfY29udGV4dDE0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNC5wcmV2ID0gX2NvbnRleHQxNC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MxNC5sZW5ndGggPiAxICYmIF9hcmdzMTRbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTRbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5nZXQoZGJLZXkoa2V5KSwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVudHJ5ID0gX2NvbnRleHQxNC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgX29iamVjdFNwcmVhZCh7fSwgZW50cnksIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNyeXB0RW50cnkoZW50cnkudmFsdWUpLnZhbHVlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGVjcnlwdEVudHJ5KGVudHJ5KS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE0KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0KF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSgpLFxuICAgIGdldE1ldGFkYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1ldGFkYXRhMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUoa2V5KSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNS5wcmV2ID0gX2NvbnRleHQxNS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RvcmUuZ2V0TWV0YWRhdGEoZGJLZXkoa2V5KSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKF94MTQpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRNZXRhZGF0YTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldE1ldGFkYXRhO1xuICAgIH0oKSxcbiAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNiQoX2NvbnRleHQxNikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTYucHJldiA9IF9jb250ZXh0MTYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuYWJydXB0KFwicmV0dXJuXCIsIHN0b3JlLnNldChkYktleShrZXkpLCBlbmNyeXB0RW50cnkoe1xuICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldChfeDE1LCBfeDE2KSB7XG4gICAgICAgIHJldHVybiBfc2V0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0oKSxcbiAgICBzZXRNdWx0aXBsZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXRNdWx0aXBsZTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE3KGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgZGJLZXlzLCBlbmNyeXB0ZWRFbnRyaWVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGtleXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgZGJLZXlzID0ga2V5cy5tYXAoZGJLZXkpO1xuICAgICAgICAgICAgICAgIGVuY3J5cHRlZEVudHJpZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNyeXB0RW50cnkoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCBzdG9yZS5zZXRNdWx0aXBsZShkYktleXMsIGVuY3J5cHRlZEVudHJpZXMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTcpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRNdWx0aXBsZShfeDE3LCBfeDE4KSB7XG4gICAgICAgIHJldHVybiBfc2V0TXVsdGlwbGUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRNdWx0aXBsZTtcbiAgICB9KCksXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbW92ZTIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE4KGtleSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTgucHJldiA9IF9jb250ZXh0MTgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguYWJydXB0KFwicmV0dXJuXCIsIHN0b3JlLnJlbW92ZShkYktleShrZXkpKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE4KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlKF94MTkpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfSgpLFxuXG4gICAgZ2V0IGxvZygpIHtcbiAgICAgIHJldHVybiBzdG9yZS5sb2cucmVkdWNlKGZ1bmN0aW9uIChuZXdMb2csIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgdmFyIGRlY0VudHJ5ID0gZGVjcnlwdEVudHJ5KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICBlbnRyeS5rZXkgPSBkZWNFbnRyeS5rZXk7XG4gICAgICAgICAgZW50cnkudmFsdWUgPSBkZWNFbnRyeS52YWx1ZTtcbiAgICAgICAgICBuZXdMb2cucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3TG9nO1xuICAgICAgfSwgW10pO1xuICAgIH0sXG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWxsMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkoKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIF9hcmdzMTkgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE5JChfY29udGV4dDE5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOS5wcmV2ID0gX2NvbnRleHQxOS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MxOS5sZW5ndGggPiAwICYmIF9hcmdzMTlbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTlbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE5Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5hbGwob3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVudHJpZXMgPSBfY29udGV4dDE5LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuYWJydXB0KFwicmV0dXJuXCIsIE9iamVjdC5rZXlzKGVudHJpZXMpLnJlZHVjZShmdW5jdGlvbiAobmV3QWxsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChQUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNba2V5XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNFbnRyeSA9IGRlY3J5cHRFbnRyeShlbnRyeS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3QWxsW2RlY0VudHJ5LmtleV0gPSBfb2JqZWN0U3ByZWFkKHt9LCBlbnRyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlY0VudHJ5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9kZWNFbnRyeSA9IGRlY3J5cHRFbnRyeShlbnRyeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBuZXdBbGxbX2RlY0VudHJ5LmtleV0gPSBfZGVjRW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FsbDtcbiAgICAgICAgICAgICAgICB9LCB7fSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9hbGwyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSgpXG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBncmFwaFFMUmVxdWVzdCA9IHJlcXVpcmUoJ2dyYXBocWwtcmVxdWVzdCcpLnJlcXVlc3Q7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXgnKTtcblxudmFyIHZlcmlmaWVyID0gcmVxdWlyZSgnLi91dGlscy92ZXJpZmllcicpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2lkJyksXG4gICAgaXNNdXBvcnRESUQgPSBfcmVxdWlyZS5pc011cG9ydERJRDtcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLmpzJyk7XG5cbnZhciBHUkFQSFFMX1NFUlZFUl9VUkwgPSBjb25maWcuZ3JhcGhxbF9zZXJ2ZXJfdXJsO1xudmFyIFBST0ZJTEVfU0VSVkVSX1VSTCA9IGNvbmZpZy5wcm9maWxlX3NlcnZlcl91cmw7XG52YXIgQUREUkVTU19TRVJWRVJfVVJMID0gY29uZmlnLmFkZHJlc3Nfc2VydmVyX3VybDtcblxuZnVuY3Rpb24gZ2V0Um9vdFN0b3JlQWRkcmVzcyhfeCkge1xuICByZXR1cm4gX2dldFJvb3RTdG9yZUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJvb3RTdG9yZUFkZHJlc3MoKSB7XG4gIF9nZXRSb290U3RvcmVBZGRyZXNzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGlkZW50aWZpZXIpIHtcbiAgICB2YXIgc2VydmVyVXJsLFxuICAgICAgICByZXMsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzZXJ2ZXJVcmwgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IEFERFJFU1NfU0VSVkVSX1VSTDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbihzZXJ2ZXJVcmwgKyAnL29kYkFkZHJlc3MvJyArIGlkZW50aWZpZXIpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLmRhdGEucm9vdFN0b3JlQWRkcmVzcyk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Um9vdFN0b3JlQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBsaXN0U3BhY2VzKF94Mikge1xuICByZXR1cm4gX2xpc3RTcGFjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xpc3RTcGFjZXMoKSB7XG4gIF9saXN0U3BhY2VzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhZGRyZXNzKSB7XG4gICAgdmFyIHNlcnZlclVybCxcbiAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgc2VydmVyVXJsID0gX2FyZ3MyLmxlbmd0aCA+IDEgJiYgX2FyZ3MyWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbMV0gOiBQUk9GSUxFX1NFUlZFUl9VUkw7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE7XG5cbiAgICAgICAgICAgIGlmICghaXNNdXBvcnRESUQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbihzZXJ2ZXJVcmwgKyAnL2xpc3Qtc3BhY2VzP2RpZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuZmV0Y2hKc29uKHNlcnZlclVybCArICcvbGlzdC1zcGFjZXM/YWRkcmVzcz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIFtdKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1sxLCAxM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2xpc3RTcGFjZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BhY2UoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9nZXRTcGFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSAvLyBUT0RPIGNvbnN1bWVzIGFkZHJlc3Mgbm93LCBjb3VsZCBhbHNvIGdpdmUgcm9vdCBESUQgdG8gZ2V0IHNwYWNlIERJRFxuXG5cbmZ1bmN0aW9uIF9nZXRTcGFjZSgpIHtcbiAgX2dldFNwYWNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhZGRyZXNzLCBuYW1lKSB7XG4gICAgdmFyIHNlcnZlclVybCxcbiAgICAgICAgX3JlZixcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGJsb2NrbGlzdCxcbiAgICAgICAgdXJsLFxuICAgICAgICBfYXJnczMgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHNlcnZlclVybCA9IF9hcmdzMy5sZW5ndGggPiAyICYmIF9hcmdzM1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzJdIDogUFJPRklMRV9TRVJWRVJfVVJMO1xuICAgICAgICAgICAgX3JlZiA9IF9hcmdzMy5sZW5ndGggPiAzICYmIF9hcmdzM1szXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MzWzNdIDoge30sIG1ldGFkYXRhID0gX3JlZi5tZXRhZGF0YSwgYmxvY2tsaXN0ID0gX3JlZi5ibG9ja2xpc3Q7XG5cbiAgICAgICAgICAgIGlmICghKGJsb2NrbGlzdCAmJiBibG9ja2xpc3QoYWRkcmVzcykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVzZXIgd2l0aCBcIi5jb25jYXQoYWRkcmVzcywgXCIgaXMgYmxvY2tlZFwiKSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwsIFwiL3NwYWNlXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSA1O1xuXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFyYW1ldGVyOiBhZGRyZXNzIG9yIGRpZFxuICAgICAgICAgICAgaWYgKGlzTXVwb3J0RElEKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/ZGlkPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/YWRkcmVzcz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH0gLy8gQWRkIG5hbWU6XG5cblxuICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQodXJsLCBcIiZuYW1lPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpKTsgLy8gQWRkIG1ldGFkYXRhOlxuXG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQodXJsLCBcIiZtZXRhZGF0YT1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfSAvLyBRdWVyeTpcbiAgICAgICAgICAgIC8vIHdlIGF3YWl0IGV4cGxpY2l0bHkgdG8gbWFrZSBzdXJlIHRoZSBlcnJvciBpcyBjYXRjaCdkIGluIHRoZSBjb3JyZWN0IHNjb3BlXG5cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5mZXRjaEpzb24odXJsKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNDtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDUpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwge30pO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzUsIDE0XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U3BhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3BhY2VESUQoX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9nZXRTcGFjZURJRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0U3BhY2VESUQoKSB7XG4gIF9nZXRTcGFjZURJRCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoYWRkcmVzcywgc3BhY2UpIHtcbiAgICB2YXIgb3B0cyxcbiAgICAgICAgY29uZixcbiAgICAgICAgX2FyZ3M0ID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0cyA9IF9hcmdzNC5sZW5ndGggPiAyICYmIF9hcmdzNFsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M0WzJdIDoge307XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uZmlnKGFkZHJlc3MsIG9wdHMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY29uZiA9IF9jb250ZXh0NC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoISghY29uZi5zcGFjZXNbc3BhY2VdIHx8ICFjb25mLnNwYWNlc1tzcGFjZV0uRElEKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhcHByb3ByaWF0ZSBESUQgZm9yIGFkZHJlc3MgXCIuY29uY2F0KGFkZHJlc3MpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGNvbmYuc3BhY2VzW3NwYWNlXS5ESUQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0U3BhY2VESUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhyZWFkKF94NywgX3g4LCBfeDksIF94MTApIHtcbiAgcmV0dXJuIF9nZXRUaHJlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFRocmVhZCgpIHtcbiAgX2dldFRocmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoc3BhY2UsIG5hbWUsIGZpcnN0TW9kZXJhdG9yLCBtZW1iZXJzKSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHNlcnZlclVybCxcbiAgICAgICAgdXJsLFxuICAgICAgICBfYXJnczUgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRzID0gX2FyZ3M1Lmxlbmd0aCA+IDQgJiYgX2FyZ3M1WzRdICE9PSB1bmRlZmluZWQgPyBfYXJnczVbNF0gOiB7fTtcbiAgICAgICAgICAgIHNlcnZlclVybCA9IG9wdHMucHJvZmlsZVNlcnZlciB8fCBQUk9GSUxFX1NFUlZFUl9VUkw7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3RNb2RlcmF0b3Iuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3BhY2VESUQoZmlyc3RNb2RlcmF0b3IsIHNwYWNlLCBvcHRzKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGZpcnN0TW9kZXJhdG9yID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDY7XG4gICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwsIFwiL3RocmVhZD9zcGFjZT1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChzcGFjZSksIFwiJm5hbWU9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQobmFtZSkpO1xuICAgICAgICAgICAgdXJsICs9IFwiJm1vZD1cIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGZpcnN0TW9kZXJhdG9yKSwgXCImbWVtYmVycz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChtZW1iZXJzKSk7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih1cmwpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NS5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dDUucHJldiA9IDE0O1xuICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oNik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQ1LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgbnVsbCwgW1s2LCAxNF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFRocmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRUaHJlYWRCeUFkZHJlc3MoX3gxMSkge1xuICByZXR1cm4gX2dldFRocmVhZEJ5QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VGhyZWFkQnlBZGRyZXNzKCkge1xuICBfZ2V0VGhyZWFkQnlBZGRyZXNzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNihhZGRyZXNzKSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHNlcnZlclVybCxcbiAgICAgICAgX2FyZ3M2ID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0cyA9IF9hcmdzNi5sZW5ndGggPiAxICYmIF9hcmdzNlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzFdIDoge307XG4gICAgICAgICAgICBzZXJ2ZXJVcmwgPSBvcHRzLnByb2ZpbGVTZXJ2ZXIgfHwgUFJPRklMRV9TRVJWRVJfVVJMO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAyO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbihcIlwiLmNvbmNhdChzZXJ2ZXJVcmwsIFwiL3RocmVhZD9hZGRyZXNzPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDYuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfY29udGV4dDYudDApO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU2LCBudWxsLCBbWzIsIDhdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRUaHJlYWRCeUFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29uZmlnKF94MTIpIHtcbiAgcmV0dXJuIF9nZXRDb25maWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldENvbmZpZygpIHtcbiAgX2dldENvbmZpZyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoYWRkcmVzcykge1xuICAgIHZhciBvcHRzLFxuICAgICAgICBzZXJ2ZXJVcmwsXG4gICAgICAgIF9hcmdzNyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG9wdHMgPSBfYXJnczcubGVuZ3RoID4gMSAmJiBfYXJnczdbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzN1sxXSA6IHt9O1xuICAgICAgICAgICAgc2VydmVyVXJsID0gb3B0cy5wcm9maWxlU2VydmVyIHx8IFBST0ZJTEVfU0VSVkVSX1VSTDtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5mZXRjaEpzb24oXCJcIi5jb25jYXQoc2VydmVyVXJsLCBcIi9jb25maWc/YWRkcmVzcz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzKSkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQ3LnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gX2NvbnRleHQ3W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX2NvbnRleHQ3LnQwKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNywgbnVsbCwgW1syLCA4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0Q29uZmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb2ZpbGUoX3gxMykge1xuICByZXR1cm4gX2dldFByb2ZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb2ZpbGUoKSB7XG4gIF9nZXRQcm9maWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOChhZGRyZXNzKSB7XG4gICAgdmFyIHNlcnZlclVybCxcbiAgICAgICAgX3JlZjIsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBibG9ja2xpc3QsXG4gICAgICAgIHVybCxcbiAgICAgICAgX2FyZ3M4ID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzZXJ2ZXJVcmwgPSBfYXJnczgubGVuZ3RoID4gMSAmJiBfYXJnczhbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzOFsxXSA6IFBST0ZJTEVfU0VSVkVSX1VSTDtcbiAgICAgICAgICAgIF9yZWYyID0gX2FyZ3M4Lmxlbmd0aCA+IDIgJiYgX2FyZ3M4WzJdICE9PSB1bmRlZmluZWQgPyBfYXJnczhbMl0gOiB7fSwgbWV0YWRhdGEgPSBfcmVmMi5tZXRhZGF0YSwgYmxvY2tsaXN0ID0gX3JlZjIuYmxvY2tsaXN0O1xuXG4gICAgICAgICAgICBpZiAoIShibG9ja2xpc3QgJiYgYmxvY2tsaXN0KGFkZHJlc3MpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VyIHdpdGggXCIuY29uY2F0KGFkZHJlc3MsIFwiIGlzIGJsb2NrZWRcIikpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQoc2VydmVyVXJsLCBcIi9wcm9maWxlXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSA1O1xuXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFyYW1ldGVyOiBhZGRyZXNzIG9yIGRpZFxuICAgICAgICAgICAgaWYgKGlzTXVwb3J0RElEKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/ZGlkPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCwgXCI/YWRkcmVzcz1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH0gLy8gQWRkIG1ldGFkYXRhOlxuXG5cbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdCh1cmwsIFwiJm1ldGFkYXRhPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG1ldGFkYXRhKSk7XG4gICAgICAgICAgICB9IC8vIFF1ZXJ5OlxuICAgICAgICAgICAgLy8gd2UgYXdhaXQgZXhwbGljaXRseSB0byBtYWtlIHN1cmUgdGhlIGVycm9yIGlzIGNhdGNoJ2QgaW4gdGhlIGNvcnJlY3Qgc2NvcGVcblxuXG4gICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmZldGNoSnNvbih1cmwpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0OC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dDgucHJldiA9IDEzO1xuICAgICAgICAgICAgX2NvbnRleHQ4LnQwID0gX2NvbnRleHQ4W1wiY2F0Y2hcIl0oNSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB7fSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTgsIG51bGwsIFtbNSwgMTNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRQcm9maWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFByb2ZpbGVzKF94MTQpIHtcbiAgcmV0dXJuIF9nZXRQcm9maWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvZmlsZXMoKSB7XG4gIF9nZXRQcm9maWxlcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoYWRkcmVzc0FycmF5KSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIHJlcSxcbiAgICAgICAgdXJsLFxuICAgICAgICBfYXJnczkgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRzID0gX2FyZ3M5Lmxlbmd0aCA+IDEgJiYgX2FyZ3M5WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczlbMV0gOiB7fTtcbiAgICAgICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgcHJvZmlsZVNlcnZlcjogUFJPRklMRV9TRVJWRVJfVVJMXG4gICAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgICAgYWRkcmVzc0xpc3Q6IFtdLFxuICAgICAgICAgICAgICBkaWRMaXN0OiBbXSAvLyBTcGxpdCBhZGRyZXNzZXMgb24gZXRoZXJldW0gLyBkaWRzXG5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGRyZXNzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICBpZiAoaXNNdXBvcnRESUQoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXEuZGlkTGlzdC5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcS5hZGRyZXNzTGlzdC5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KG9wdHMucHJvZmlsZVNlcnZlciwgXCIvcHJvZmlsZUxpc3RcIik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCB1dGlscy5mZXRjaEpzb24odXJsLCByZXEpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU5KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFByb2ZpbGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHByb2ZpbGVHcmFwaFFMKF94MTUpIHtcbiAgcmV0dXJuIF9wcm9maWxlR3JhcGhRTC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcHJvZmlsZUdyYXBoUUwoKSB7XG4gIF9wcm9maWxlR3JhcGhRTCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHF1ZXJ5KSB7XG4gICAgdmFyIG9wdHMsXG4gICAgICAgIF9hcmdzMTAgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0cyA9IF9hcmdzMTAubGVuZ3RoID4gMSAmJiBfYXJnczEwWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczEwWzFdIDoge307XG4gICAgICAgICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgIGdyYXBocWxTZXJ2ZXI6IEdSQVBIUUxfU0VSVkVSX1VSTFxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgZ3JhcGhRTFJlcXVlc3Qob3B0cy5ncmFwaHFsU2VydmVyLCBxdWVyeSkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUxMCk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wcm9maWxlR3JhcGhRTC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJpZmllZEFjY291bnRzKF94MTYpIHtcbiAgcmV0dXJuIF9nZXRWZXJpZmllZEFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRWZXJpZmllZEFjY291bnRzKCkge1xuICBfZ2V0VmVyaWZpZWRBY2NvdW50cyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgLyojX19QVVJFX18qL1xuICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHByb2ZpbGUpIHtcbiAgICB2YXIgdmVyaWZzLCBkaWQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdmVyaWZzID0ge307XG4gICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAxO1xuICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnlESUQocHJvZmlsZS5wcm9vZl9kaWQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGlkID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgdmVyaWZzLmRpZCA9IGRpZDtcblxuICAgICAgICAgICAgaWYgKCFwcm9maWxlLnByb29mX2dpdGh1Yikge1xuICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0MTEucHJldiA9IDc7XG4gICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnlHaXRodWIoZGlkLCBwcm9maWxlLnByb29mX2dpdGh1Yik7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgdmVyaWZzLmdpdGh1YiA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTM7XG4gICAgICAgICAgICBfY29udGV4dDExLnQwID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDcpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGlmICghcHJvZmlsZS5wcm9vZl90d2l0dGVyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxOTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllci52ZXJpZnlUd2l0dGVyKGRpZCwgcHJvZmlsZS5wcm9vZl90d2l0dGVyKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICB2ZXJpZnMudHdpdHRlciA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMjI7XG4gICAgICAgICAgICBfY29udGV4dDExLnQxID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDE2KTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBpZiAoIXByb2ZpbGUuZXRoZXJldW1fcHJvb2YpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAyNTtcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDI4O1xuICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWVyLnZlcmlmeUV0aGVyZXVtKHByb2ZpbGUuZXRoZXJldW1fcHJvb2YsIGRpZCk7XG5cbiAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgdmVyaWZzLmV0aGVyZXVtID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMzM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBfY29udGV4dDExLnByZXYgPSAzMTtcbiAgICAgICAgICAgIF9jb250ZXh0MTEudDIgPSBfY29udGV4dDExW1wiY2F0Y2hcIl0oMjUpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMzU7XG4gICAgICAgICAgICBfY29udGV4dDExLnQzID0gX2NvbnRleHQxMVtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCB2ZXJpZnMpO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTEsIG51bGwsIFtbMSwgMzVdLCBbNywgMTNdLCBbMTYsIDIyXSwgWzI1LCAzMV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFZlcmlmaWVkQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByb2ZpbGVHcmFwaFFMOiBwcm9maWxlR3JhcGhRTCxcbiAgZ2V0UHJvZmlsZTogZ2V0UHJvZmlsZSxcbiAgZ2V0U3BhY2U6IGdldFNwYWNlLFxuICBsaXN0U3BhY2VzOiBsaXN0U3BhY2VzLFxuICBnZXRUaHJlYWQ6IGdldFRocmVhZCxcbiAgZ2V0VGhyZWFkQnlBZGRyZXNzOiBnZXRUaHJlYWRCeUFkZHJlc3MsXG4gIGdldENvbmZpZzogZ2V0Q29uZmlnLFxuICBnZXRSb290U3RvcmVBZGRyZXNzOiBnZXRSb290U3RvcmVBZGRyZXNzLFxuICBnZXRQcm9maWxlczogZ2V0UHJvZmlsZXMsXG4gIGdldFZlcmlmaWVkQWNjb3VudHM6IGdldFZlcmlmaWVkQWNjb3VudHMsXG4gIGdldFNwYWNlRElEOiBnZXRTcGFjZURJRFxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgZmV0Y2ggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5mZXRjaCA6IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcblxudmFyIE11bHRpaGFzaCA9IHJlcXVpcmUoJ211bHRpaGFzaGVzJyk7XG5cbnZhciBzaGEyNTYgPSByZXF1aXJlKCdqcy1zaGEyNTYnKS5zaGEyNTY7XG5cbnZhciBldGhlcnMgPSByZXF1aXJlKCdldGhlcnMnKTtcblxudmFyIEhUVFBFcnJvciA9IGZ1bmN0aW9uIEhUVFBFcnJvcihzdGF0dXMsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGUuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgcmV0dXJuIGU7XG59O1xuXG52YXIgZ2V0TWVzc2FnZUNvbnNlbnQgPSBmdW5jdGlvbiBnZXRNZXNzYWdlQ29uc2VudChkaWQsIHRpbWVzdGFtcCkge1xuICB2YXIgbXNnID0gJ0NyZWF0ZSBhIG5ldyAzQm94IHByb2ZpbGUnICsgJ1xcblxcbicgKyAnLSBcXG4nICsgJ1lvdXIgdW5pcXVlIHByb2ZpbGUgSUQgaXMgJyArIGRpZDtcbiAgaWYgKHRpbWVzdGFtcCkgbXNnICs9ICcgXFxuJyArICdUaW1lc3RhbXA6ICcgKyB0aW1lc3RhbXA7XG4gIHJldHVybiBtc2c7XG59O1xuXG52YXIgc2FmZUV0aFNlbmQgPSBmdW5jdGlvbiBzYWZlRXRoU2VuZChldGhlcmV1bSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgdmFyIHNlbmQgPSAoQm9vbGVhbihldGhlcmV1bS5zZW5kQXN5bmMpID8gZXRoZXJldW0uc2VuZEFzeW5jIDogZXRoZXJldW0uc2VuZCkuYmluZChldGhlcmV1bSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgc2VuZChkYXRhLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC5lcnJvcik7XG4gICAgICByZXNvbHZlKHJlc3VsdC5yZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRNZXNzYWdlQ29uc2VudDogZ2V0TWVzc2FnZUNvbnNlbnQsXG4gIHJlY292ZXJQZXJzb25hbFNpZ246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlY292ZXJQZXJzb25hbFNpZ24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKG1zZywgcGVyc29uYWxTaWcpIHtcbiAgICAgIHZhciBtc2dQYXJhbXM7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISghbXNnIHx8ICFwZXJzb25hbFNpZykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlclBlcnNvbmFsU2lnbjogbWlzc2luZyBhcmd1bWVudHMsIG1zZyBhbmQvb3IgcGVyc29uYWxTaWcnKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogbXNnLFxuICAgICAgICAgICAgICAgIHNpZzogcGVyc29uYWxTaWdcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBldGhlcnMudXRpbHMudmVyaWZ5TWVzc2FnZShtc2csIHBlcnNvbmFsU2lnKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHJlY292ZXJQZXJzb25hbFNpZ24oX3gsIF94Mikge1xuICAgICAgcmV0dXJuIF9yZWNvdmVyUGVyc29uYWxTaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY292ZXJQZXJzb25hbFNpZ247XG4gIH0oKSxcbiAgb3BlbkJveENvbnNlbnQ6IGZ1bmN0aW9uIG9wZW5Cb3hDb25zZW50KGZyb21BZGRyZXNzLCBldGhlcmV1bSkge1xuICAgIHZhciB0ZXh0ID0gJ1RoaXMgYXBwIHdhbnRzIHRvIHZpZXcgYW5kIHVwZGF0ZSB5b3VyIDNCb3ggcHJvZmlsZS4nO1xuICAgIHZhciBtc2cgPSAnMHgnICsgQnVmZmVyLmZyb20odGV4dCwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHBhcmFtcyA9IFttc2csIGZyb21BZGRyZXNzXTtcbiAgICB2YXIgbWV0aG9kID0gJ3BlcnNvbmFsX3NpZ24nO1xuICAgIHJldHVybiBzYWZlRXRoU2VuZChldGhlcmV1bSwge1xuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBpZDogMCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBmcm9tQWRkcmVzczogZnJvbUFkZHJlc3NcbiAgICB9KTtcbiAgfSxcbiAgb3BlblNwYWNlQ29uc2VudDogZnVuY3Rpb24gb3BlblNwYWNlQ29uc2VudChmcm9tQWRkcmVzcywgZXRoZXJldW0sIG5hbWUpIHtcbiAgICB2YXIgdGV4dCA9IFwiQWxsb3cgdGhpcyBhcHAgdG8gb3BlbiB5b3VyIFwiLmNvbmNhdChuYW1lLCBcIiBzcGFjZS5cIik7XG4gICAgdmFyIG1zZyA9ICcweCcgKyBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgcGFyYW1zID0gW21zZywgZnJvbUFkZHJlc3NdO1xuICAgIHZhciBtZXRob2QgPSAncGVyc29uYWxfc2lnbic7XG4gICAgcmV0dXJuIHNhZmVFdGhTZW5kKGV0aGVyZXVtLCB7XG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIGlkOiAwLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGZyb21BZGRyZXNzOiBmcm9tQWRkcmVzc1xuICAgIH0pO1xuICB9LFxuICBnZXRMaW5rQ29uc2VudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZ2V0TGlua0NvbnNlbnQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihmcm9tQWRkcmVzcywgdG9ESUQsIGV0aGVyZXVtKSB7XG4gICAgICB2YXIgdGltZXN0YW1wLCB0ZXh0LCBtc2csIHBhcmFtcywgbWV0aG9kLCBzaWc7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGltZXN0YW1wID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgICAgICAgICAgICB0ZXh0ID0gZ2V0TWVzc2FnZUNvbnNlbnQodG9ESUQsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgIG1zZyA9ICcweCcgKyBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgICAgcGFyYW1zID0gW21zZywgZnJvbUFkZHJlc3NdO1xuICAgICAgICAgICAgICBtZXRob2QgPSAncGVyc29uYWxfc2lnbic7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHNhZmVFdGhTZW5kKGV0aGVyZXVtLCB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgZnJvbUFkZHJlc3M6IGZyb21BZGRyZXNzXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHNpZyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgbXNnOiB0ZXh0LFxuICAgICAgICAgICAgICAgIHNpZzogc2lnLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGdldExpbmtDb25zZW50KF94MywgX3g0LCBfeDUpIHtcbiAgICAgIHJldHVybiBfZ2V0TGlua0NvbnNlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0TGlua0NvbnNlbnQ7XG4gIH0oKSxcbiAgZmV0Y2hKc29uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9mZXRjaEpzb24gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyh1cmwsIGJvZHkpIHtcbiAgICAgIHZhciBvcHRzLCByO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRzKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFyLm9rKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgci5qc29uKCkpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHRocm93IEhUVFBFcnJvcihyLnN0YXR1cywgXCJJbnZhbGlkIHJlc3BvbnNlIChcIi5jb25jYXQoci5zdGF0dXMsIFwiKSBmb3IgcXVlcnkgYXQgXCIpLmNvbmNhdCh1cmwpKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBmZXRjaEpzb24oX3g2LCBfeDcpIHtcbiAgICAgIHJldHVybiBfZmV0Y2hKc29uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoSnNvbjtcbiAgfSgpLFxuICBmZXRjaFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2ZldGNoVGV4dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHVybCwgb3B0cykge1xuICAgICAgdmFyIHI7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRzKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByID0gX2NvbnRleHQ0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFyLm9rKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgci50ZXh0KCkpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHRocm93IEhUVFBFcnJvcihyLnN0YXR1cywgXCJJbnZhbGlkIHJlc3BvbnNlIChcIi5jb25jYXQoci5zdGF0dXMsIFwiKSBmb3IgcXVlcnkgYXQgXCIpLmNvbmNhdCh1cmwpKTtcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU0KTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBmZXRjaFRleHQoX3g4LCBfeDkpIHtcbiAgICAgIHJldHVybiBfZmV0Y2hUZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoVGV4dDtcbiAgfSgpLFxuICB0aHJvd0lmVW5kZWZpbmVkOiBmdW5jdGlvbiB0aHJvd0lmVW5kZWZpbmVkKGFyZywgbmFtZSkge1xuICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChuYW1lLCBcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50XCIpKTtcbiAgICB9XG4gIH0sXG4gIHRocm93SWZOb3RFcXVhbExlbkFycmF5czogZnVuY3Rpb24gdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzKGFycjEsIGFycjIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyMSkgfHwgIUFycmF5LmlzQXJyYXkoYXJyMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9yIG1vcmUgYXJndW1lbnRzIGFyZSBub3QgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5cyBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgfSxcbiAgc2hhMjU2TXVsdGloYXNoOiBmdW5jdGlvbiBzaGEyNTZNdWx0aWhhc2goc3RyKSB7XG4gICAgdmFyIGRpZ2VzdCA9IEJ1ZmZlci5mcm9tKHNoYTI1Ni5kaWdlc3Qoc3RyKSk7XG4gICAgcmV0dXJuIE11bHRpaGFzaC5lbmNvZGUoZGlnZXN0LCAnc2hhMi0yNTYnKS50b1N0cmluZygnaGV4Jyk7XG4gIH0sXG4gIHNoYTI1Njogc2hhMjU2XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvaXBmcy1wdWJzdWInKVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBMb2cgPSByZXF1aXJlKCdpcGZzLWxvZycpO1xuXG52YXIgSUZSQU1FX1NUT1JFX1ZFUlNJT04gPSAnMC4wLjMnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZHJlc3Nfc2VydmVyX3VybDogcHJvY2Vzcy5lbnYuQUREUkVTU19TRVJWRVJfVVJMIHx8ICdodHRwczovL2JldGEuM2JveC5pby9hZGRyZXNzLXNlcnZlcicsXG4gIHBpbm5pbmdfbm9kZTogcHJvY2Vzcy5lbnYuUElOTklOR19OT0RFIHx8ICcvZG5zYWRkci9pcGZzLjNib3guaW8vdGNwLzQ0My93c3MvaXBmcy9RbVp2eEVwaVZOam1OYkVLeVFHdkZ6QVkxQndtR3V1dmRVVG1jVHN0UVBoeVZDJyxcbiAgcGlubmluZ19yb29tOiBwcm9jZXNzLmVudi5QSU5OSU5HX1JPT00gfHwgJzNib3gtcGlubmluZycsXG4gIGlmcmFtZV9zdG9yZV92ZXJzaW9uOiBwcm9jZXNzLmVudi5JRlJBTUVfU1RPUkVfVkVSU0lPTiB8fCBJRlJBTUVfU1RPUkVfVkVSU0lPTixcbiAgaWZyYW1lX3N0b3JlX3VybDogcHJvY2Vzcy5lbnYuSUZSQU1FX1NUT1JFX1VSTCB8fCBcImh0dHBzOi8vaWZyYW1lLjNib3guaW8vXCIuY29uY2F0KElGUkFNRV9TVE9SRV9WRVJTSU9OLCBcIi9pZnJhbWUuaHRtbFwiKSxcbiAgaXBmc19vcHRpb25zOiB7XG4gICAgRVhQRVJJTUVOVEFMOiB7XG4gICAgICBwdWJzdWI6IHRydWVcbiAgICB9LFxuICAgIHByZWxvYWQ6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfSxcbiAgICBjb25maWc6IHtcbiAgICAgIEJvb3RzdHJhcDogW11cbiAgICB9XG4gIH0sXG4gIG9yYml0ZGJfb3B0aW9uczoge1xuICAgIHN5bmNMb2NhbDogdHJ1ZSxcbiAgICBzb3J0Rm46IExvZy5Tb3J0aW5nLlNvcnRCeUVudHJ5SGFzaCAvLyB0aGlzIG9wdGlvbiBpcyByZXF1aXJlZCBub3cgYnV0IHdpbGwgbGlrZWx5IG5vdCBiZSBpbiB0aGUgZnV0dXJlLlxuXG4gIH0sXG4gIGdyYXBocWxfc2VydmVyX3VybDogcHJvY2Vzcy5lbnYuR1JBUEhRTF9TRVJWRVJfVVJMIHx8ICdodHRwczovL2FwaS4zYm94LmlvL2dyYXBoLycsXG4gIHByb2ZpbGVfc2VydmVyX3VybDogcHJvY2Vzcy5lbnYuUFJPRklMRV9TRVJWRVJfVVJMIHx8ICdodHRwczovL2lwZnMuM2JveC5pbycsXG4gIG11cG9ydF9pcGZzX2hvc3Q6IHByb2Nlc3MuZW52Lk1VUE9SVF9JUEZTX0hPU1QgfHwgJ2lwZnMuaW5mdXJhLmlvJyxcbiAgbXVwb3J0X2lwZnNfcG9ydDogcHJvY2Vzcy5lbnYuTVVQT1JUX0lQRlNfUE9SVCB8fCA1MDAxLFxuICBtdXBvcnRfaXBmc19wcm90b2NvbDogcHJvY2Vzcy5lbnYuTVVQT1JUX0lQRlNfUFJPVE9DT0wgfHwgJ2h0dHBzJ1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgSEROb2RlID0gcmVxdWlyZSgnZXRoZXJzJykudXRpbHMuSEROb2RlO1xuXG52YXIgZGlkSldUID0gcmVxdWlyZSgnZGlkLWp3dCcpO1xuXG52YXIgRGlkRG9jdW1lbnQgPSByZXF1aXJlKCdpcGZzLWRpZC1kb2N1bWVudCcpO1xuXG52YXIgSXBmc01pbmkgPSByZXF1aXJlKCdpcGZzLW1pbmknKTtcblxudmFyIGxvY2Fsc3RvcmFnZSA9IHJlcXVpcmUoJ3N0b3JlJyk7XG5cbnZhciBJZGVudGl0aWVzID0gcmVxdWlyZSgnb3JiaXQtZGItaWRlbnRpdHktcHJvdmlkZXInKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnM2JveC1vcmJpdGRiLXBsdWdpbnMnKSxcbiAgICBPZGJJZGVudGl0eVByb3ZpZGVyID0gX3JlcXVpcmUuT2RiSWRlbnRpdHlQcm92aWRlcjtcblxuSWRlbnRpdGllcy5hZGRJZGVudGl0eVByb3ZpZGVyKE9kYklkZW50aXR5UHJvdmlkZXIpO1xuXG52YXIgcmVnaXN0ZXJSZXNvbHZlciA9IHJlcXVpcmUoJzNpZC1yZXNvbHZlcicpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pbmRleCcpO1xuXG52YXIgS2V5cmluZyA9IHJlcXVpcmUoJy4va2V5cmluZycpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnLmpzJyk7XG5cbnZhciBESURfTUVUSE9EX05BTUUgPSAnMyc7XG52YXIgU1RPUkFHRV9LRVkgPSAnc2VyaWFsaXplZDNpZF8nO1xudmFyIE1VUE9SVF9JUEZTID0ge1xuICBob3N0OiBjb25maWcubXVwb3J0X2lwZnNfaG9zdCxcbiAgcG9ydDogY29uZmlnLm11cG9ydF9pcGZzX3BvcnQsXG4gIHByb3RvY29sOiBjb25maWcubXVwb3J0X2lwZnNfcHJvdG9jb2xcbn07XG5cbnZhciBUaHJlZUlkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGhyZWVJZChzZXJpYWxpemVTdGF0ZSwgZXRoZXJldW0sIGlwZnMsIG9wdHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFRocmVlSWQpO1xuICAgIHRoaXMuX2V0aGVyZXVtID0gZXRoZXJldW07XG4gICAgdGhpcy5faXBmcyA9IGlwZnM7XG4gICAgdGhpcy5fa2V5cmluZ3MgPSB7fTtcblxuICAgIHRoaXMuX2luaXRLZXlzKHNlcmlhbGl6ZVN0YXRlLCBvcHRzKTtcblxuICAgIHJlZ2lzdGVyUmVzb2x2ZXIoaXBmcyk7XG4gICAgbG9jYWxzdG9yYWdlLnNldChTVE9SQUdFX0tFWSArIHRoaXMubWFuYWdlbWVudEFkZHJlc3MsIHRoaXMuc2VyaWFsaXplU3RhdGUoKSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMltcImRlZmF1bHRcIl0pKFRocmVlSWQsIFt7XG4gICAga2V5OiBcInNpZ25KV1RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zaWduSldUID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocGF5bG9hZCkge1xuICAgICAgICB2YXIgX3JlZixcbiAgICAgICAgICAgIHVzZTNJRCxcbiAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgZXhwaXJlc0luLFxuICAgICAgICAgICAga2V5cmluZyxcbiAgICAgICAgICAgIGlzc3VlcixcbiAgICAgICAgICAgIHNldHRpbmdzLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfcmVmID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiB7fSwgdXNlM0lEID0gX3JlZi51c2UzSUQsIHNwYWNlID0gX3JlZi5zcGFjZSwgZXhwaXJlc0luID0gX3JlZi5leHBpcmVzSW47XG4gICAgICAgICAgICAgICAga2V5cmluZyA9IHNwYWNlID8gdGhpcy5fa2V5cmluZ3Nbc3BhY2VdIDogdGhpcy5fbWFpbktleXJpbmc7XG4gICAgICAgICAgICAgICAgaXNzdWVyID0gdGhpcy5tdXBvcnRESUQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlM0lEKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZXIgPSB0aGlzLkRJRDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZXIgPSB0aGlzLl9zdWJESURzW3NwYWNlXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICAgIHNpZ25lcjoga2V5cmluZy5nZXRKV1RTaWduZXIoKSxcbiAgICAgICAgICAgICAgICAgIGlzc3VlcjogaXNzdWVyLFxuICAgICAgICAgICAgICAgICAgZXhwaXJlc0luOiBleHBpcmVzSW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGlkSldULmNyZWF0ZUpXVChwYXlsb2FkLCBzZXR0aW5ncykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2lnbkpXVChfeCkge1xuICAgICAgICByZXR1cm4gX3NpZ25KV1QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpZ25KV1Q7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3ViRElEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN1YkRJRChzcGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YkRJRHNbc3BhY2VdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPZGJJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE9kYklkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHNwYWNlKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIElkZW50aXRpZXMuY3JlYXRlSWRlbnRpdHkoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJzNJRCcsXG4gICAgICAgICAgICAgICAgICB0aHJlZUlkOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgc3BhY2U6IHNwYWNlXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRPZGJJZChfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRPZGJJZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0T2RiSWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplU3RhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhdGVPYmogPSB7XG4gICAgICAgIG1hbmFnZW1lbnRBZGRyZXNzOiB0aGlzLm1hbmFnZW1lbnRBZGRyZXNzLFxuICAgICAgICBzZWVkOiB0aGlzLl9tYWluS2V5cmluZy5zZXJpYWxpemUoKSxcbiAgICAgICAgc3BhY2VTZWVkczoge31cbiAgICAgIH07XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9rZXlyaW5ncykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHN0YXRlT2JqLnNwYWNlU2VlZHNbbmFtZV0gPSBfdGhpcy5fa2V5cmluZ3NbbmFtZV0uc2VyaWFsaXplKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0ZU9iaik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0S2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdEtleXMoc2VyaWFsaXplU3RhdGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhdGUgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZVN0YXRlKTsgLy8gVE9ETyByZW1vdmUgdG9Mb3dlckNhc2UoKSBpbiBmdXR1cmUsIHNob3VsZCBiZSBzYW5pdGl6ZWQgZWxzZXdoZXJlXG4gICAgICAvLyAgICAgIHRoaXMgZm9yY2VzIGV4aXN0aW5nIHN0YXRlIHRvIGNvcnJlY3Qgc3RhdGUgc28gdGhhdCBhZGRyZXNzIDwtPlxuICAgICAgLy8gICAgICByb290c3RvcmUgcmVsYXRpb24gaG9sZHNcblxuICAgICAgdGhpcy5tYW5hZ2VtZW50QWRkcmVzcyA9IHN0YXRlLm1hbmFnZW1lbnRBZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLl9tYWluS2V5cmluZyA9IG5ldyBLZXlyaW5nKHN0YXRlLnNlZWQpO1xuICAgICAgT2JqZWN0LmtleXMoc3RhdGUuc3BhY2VTZWVkcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIF90aGlzMi5fa2V5cmluZ3NbbmFtZV0gPSBuZXcgS2V5cmluZyhzdGF0ZS5zcGFjZVNlZWRzW25hbWVdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdERJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2luaXRESUQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG11cG9ydElwZnMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG11cG9ydFByb21pc2UsIHNwYWNlcywgc3ViRElEcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbXVwb3J0UHJvbWlzZSA9IHRoaXMuX2luaXRNdXBvcnQobXVwb3J0SXBmcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0M0lEKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RESUQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICBzcGFjZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9rZXlyaW5ncyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzcGFjZXMubWFwKGZ1bmN0aW9uIChzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5faW5pdDNJRChzcGFjZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBzdWJESURzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViRElEcyA9IHt9O1xuICAgICAgICAgICAgICAgIHNwYWNlcy5tYXAoZnVuY3Rpb24gKHNwYWNlLCBpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX3N1YkRJRHNbc3BhY2VdID0gc3ViRElEc1tpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIHJldHVybiBtdXBvcnRQcm9taXNlO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2luaXRESUQoX3gzKSB7XG4gICAgICAgIHJldHVybiBfaW5pdERJRDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9pbml0RElEO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0M0lEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaW5pdDNJRDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoc3BhY2VOYW1lKSB7XG4gICAgICAgIHZhciBkb2MsIHB1YmtleXMsIF9wdWJrZXlzLCBwYXlsb2FkLCBzaWduYXR1cmU7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZG9jID0gbmV3IERpZERvY3VtZW50KHRoaXMuX2lwZnMsIERJRF9NRVRIT0RfTkFNRSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwdWJrZXlzID0gdGhpcy5fbWFpbktleXJpbmcuZ2V0UHVibGljS2V5cyh0cnVlKTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkUHVibGljS2V5KCdzaWduaW5nS2V5JywgJ1NlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTgnLCAncHVibGljS2V5SGV4JywgcHVia2V5cy5zaWduaW5nS2V5KTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkUHVibGljS2V5KCdlbmNyeXB0aW9uS2V5JywgJ0N1cnZlMjU1MTlFbmNyeXB0aW9uUHVibGljS2V5JywgJ3B1YmxpY0tleUJhc2U2NCcsIHB1YmtleXMuYXN5bUVuY3J5cHRpb25LZXkpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRQdWJsaWNLZXkoJ21hbmFnZW1lbnRLZXknLCAnU2VjcDI1NmsxVmVyaWZpY2F0aW9uS2V5MjAxOCcsICdldGhlcmV1bUFkZHJlc3MnLCB0aGlzLm1hbmFnZW1lbnRBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkQXV0aGVudGljYXRpb24oJ1NlY3AyNTZrMVNpZ25hdHVyZUF1dGhlbnRpY2F0aW9uMjAxOCcsICdzaWduaW5nS2V5Jyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX3B1YmtleXMgPSB0aGlzLl9rZXlyaW5nc1tzcGFjZU5hbWVdLmdldFB1YmxpY0tleXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jLmFkZFB1YmxpY0tleSgnc3ViU2lnbmluZ0tleScsICdTZWNwMjU2azFWZXJpZmljYXRpb25LZXkyMDE4JywgJ3B1YmxpY0tleUhleCcsIF9wdWJrZXlzLnNpZ25pbmdLZXkpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRQdWJsaWNLZXkoJ3N1YkVuY3J5cHRpb25LZXknLCAnQ3VydmUyNTUxOUVuY3J5cHRpb25QdWJsaWNLZXknLCAncHVibGljS2V5QmFzZTY0JywgX3B1YmtleXMuYXN5bUVuY3J5cHRpb25LZXkpO1xuICAgICAgICAgICAgICAgIGRvYy5hZGRBdXRoZW50aWNhdGlvbignU2VjcDI1NmsxU2lnbmF0dXJlQXV0aGVudGljYXRpb24yMDE4JywgJ3N1YlNpZ25pbmdLZXknKTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkQ3VzdG9tUHJvcGVydHkoJ3NwYWNlJywgc3BhY2VOYW1lKTtcbiAgICAgICAgICAgICAgICBkb2MuYWRkQ3VzdG9tUHJvcGVydHkoJ3Jvb3QnLCB0aGlzLkRJRCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgIHN1YlNpZ25pbmdLZXk6IF9wdWJrZXlzLnNpZ25pbmdLZXksXG4gICAgICAgICAgICAgICAgICBzdWJFbmNyeXB0aW9uS2V5OiBfcHVia2V5cy5hc3ltRW5jcnlwdGlvbktleSxcbiAgICAgICAgICAgICAgICAgIHNwYWNlOiBzcGFjZU5hbWUsXG4gICAgICAgICAgICAgICAgICBpYXQ6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkpXVChwYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICB1c2UzSUQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IF9jb250ZXh0NC5zZW50LnNwbGl0KCcuJylbMl07XG4gICAgICAgICAgICAgICAgZG9jLmFkZEN1c3RvbVByb3BlcnR5KCdwcm9vZicsIHtcbiAgICAgICAgICAgICAgICAgIGFsZzogJ0VTMjU2SycsXG4gICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmNvbW1pdCh7XG4gICAgICAgICAgICAgICAgICBub1RpbWVzdGFtcDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgZG9jLkRJRCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfaW5pdDNJRChfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9pbml0M0lEMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2luaXQzSUQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRNdXBvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9pbml0TXVwb3J0MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNihtdXBvcnRJcGZzKSB7XG4gICAgICAgIHZhciBrZXlzLCBkb2MsIGRvY0hhc2gsIHB1Ymxpc2hUb0luZnVyYTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAga2V5cyA9IHRoaXMuX21haW5LZXlyaW5nLmdldFB1YmxpY0tleXMoKTtcbiAgICAgICAgICAgICAgICBkb2MgPSBjcmVhdGVNdXBvcnREb2N1bWVudChrZXlzLnNpZ25pbmdLZXksIHRoaXMubWFuYWdlbWVudEFkZHJlc3MsIGtleXMuYXN5bUVuY3J5cHRpb25LZXkpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXBmcy5hZGQoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZG9jKSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBkb2NIYXNoID0gX2NvbnRleHQ2LnNlbnRbMF0uaGFzaDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tdXBvcnRESUQgPSAnZGlkOm11cG9ydDonICsgZG9jSGFzaDtcbiAgICAgICAgICAgICAgICB0aGlzLm11cG9ydEZpbmdlcnByaW50ID0gdXRpbHMuc2hhMjU2TXVsdGloYXNoKHRoaXMubXVwb3J0RElEKTtcblxuICAgICAgICAgICAgICAgIHB1Ymxpc2hUb0luZnVyYSA9XG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgICAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlwZnNNaW5pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGZzTWluaSA9IG5ldyBJcGZzTWluaShtdXBvcnRJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcGZzTWluaS5hZGRKU09OKGRvYywgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNSk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBwdWJsaXNoVG9JbmZ1cmEoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgICAgICBwdWJsaXNoVG9JbmZ1cmEoKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2luaXRNdXBvcnQoX3g1KSB7XG4gICAgICAgIHJldHVybiBfaW5pdE11cG9ydDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9pbml0TXVwb3J0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldEtleXJpbmdCeVNwYWNlTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRLZXlyaW5nQnlTcGFjZU5hbWUobmFtZSkge1xuICAgICAgdmFyIHNwbGl0ID0gbmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICBpZiAoc3BsaXRbMF0gPT09IHRoaXMubXVwb3J0RmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5LZXlyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXJpbmdzW3NwbGl0WzJdXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdEtleXJpbmdCeU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9pbml0S2V5cmluZ0J5TmFtZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhuYW1lKSB7XG4gICAgICAgIHZhciBzaWcsIGVudHJvcHksIHNlZWQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZXlyaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMub3BlblNwYWNlQ29uc2VudCh0aGlzLm1hbmFnZW1lbnRBZGRyZXNzLCB0aGlzLl9ldGhlcmV1bSwgbmFtZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHNpZyA9IF9jb250ZXh0Ny5zZW50O1xuICAgICAgICAgICAgICAgIGVudHJvcHkgPSAnMHgnICsgdXRpbHMuc2hhMjU2KHNpZy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgc2VlZCA9IEhETm9kZS5tbmVtb25pY1RvU2VlZChIRE5vZGUuZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2tleXJpbmdzW25hbWVdID0gbmV3IEtleXJpbmcoc2VlZCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0M0lEKG5hbWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJESURzW25hbWVdID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxzdG9yYWdlLnNldChTVE9SQUdFX0tFWSArIHRoaXMubWFuYWdlbWVudEFkZHJlc3MsIHRoaXMuc2VyaWFsaXplU3RhdGUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpbml0S2V5cmluZ0J5TmFtZShfeDYpIHtcbiAgICAgICAgcmV0dXJuIF9pbml0S2V5cmluZ0J5TmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5pdEtleXJpbmdCeU5hbWU7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibG9nb3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICAgIGxvY2Fsc3RvcmFnZS5yZW1vdmUoU1RPUkFHRV9LRVkgKyB0aGlzLm1hbmFnZW1lbnRBZGRyZXNzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiRElEXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdERJRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVwb3J0RElEXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbXVwb3J0RElEO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzTG9nZ2VkSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMb2dnZWRJbihhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihsb2NhbHN0b3JhZ2UuZ2V0KFNUT1JBR0VfS0VZICsgYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElkRnJvbUV0aEFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRJZEZyb21FdGhBZGRyZXNzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGFkZHJlc3MsIGV0aGVyZXVtLCBpcGZzKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgbm9ybWFsaXplZEFkZHJlc3MsXG4gICAgICAgICAgICBzZXJpYWxpemVkM2lkLFxuICAgICAgICAgICAgc2lnLFxuICAgICAgICAgICAgZW50cm9weSxcbiAgICAgICAgICAgIG1uZW1vbmljLFxuICAgICAgICAgICAgc2VlZCxcbiAgICAgICAgICAgIF8zaWQsXG4gICAgICAgICAgICBfYXJnczggPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzOC5sZW5ndGggPiAzICYmIF9hcmdzOFszXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M4WzNdIDoge307XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZDNpZCA9IGxvY2Fsc3RvcmFnZS5nZXQoU1RPUkFHRV9LRVkgKyBub3JtYWxpemVkQWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlcmlhbGl6ZWQzaWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNvbnNlbnRDYWxsYmFjaykgb3B0cy5jb25zZW50Q2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGlmICghb3B0cy5jb250ZW50U2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2lnID0gb3B0cy5jb250ZW50U2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlscy5vcGVuQm94Q29uc2VudChub3JtYWxpemVkQWRkcmVzcywgZXRoZXJldW0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgc2lnID0gX2NvbnRleHQ4LnNlbnQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5jb25zZW50Q2FsbGJhY2spIG9wdHMuY29uc2VudENhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIGVudHJvcHkgPSAnMHgnICsgdXRpbHMuc2hhMjU2KHNpZy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgbW5lbW9uaWMgPSBIRE5vZGUuZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSk7XG4gICAgICAgICAgICAgICAgc2VlZCA9IEhETm9kZS5tbmVtb25pY1RvU2VlZChtbmVtb25pYyk7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZDNpZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgIG1hbmFnZW1lbnRBZGRyZXNzOiBub3JtYWxpemVkQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgIHNlZWQ6IHNlZWQsXG4gICAgICAgICAgICAgICAgICBzcGFjZVNlZWRzOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgXzNpZCA9IG5ldyBUaHJlZUlkKHNlcmlhbGl6ZWQzaWQsIGV0aGVyZXVtLCBpcGZzLCBvcHRzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfM2lkLl9pbml0RElEKG9wdHMubXVwb3J0SXBmcyB8fCBNVVBPUlRfSVBGUyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBfM2lkKTtcblxuICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOCk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldElkRnJvbUV0aEFkZHJlc3MoX3g3LCBfeDgsIF94OSkge1xuICAgICAgICByZXR1cm4gX2dldElkRnJvbUV0aEFkZHJlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldElkRnJvbUV0aEFkZHJlc3M7XG4gICAgfSgpXG4gIH1dKTtcbiAgcmV0dXJuIFRocmVlSWQ7XG59KCk7XG5cbnZhciBjcmVhdGVNdXBvcnREb2N1bWVudCA9IGZ1bmN0aW9uIGNyZWF0ZU11cG9ydERvY3VtZW50KHNpZ25pbmdLZXksIG1hbmFnZW1lbnRLZXksIGFzeW1FbmNyeXB0aW9uS2V5KSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogMSxcbiAgICBzaWduaW5nS2V5OiBzaWduaW5nS2V5LFxuICAgIG1hbmFnZW1lbnRLZXk6IG1hbmFnZW1lbnRLZXksXG4gICAgYXN5bUVuY3J5cHRpb25LZXk6IGFzeW1FbmNyeXB0aW9uS2V5XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRocmVlSWQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIHZlcmlmaWVyID0gcmVxdWlyZSgnLi91dGlscy92ZXJpZmllcicpO1xuXG52YXIgVmVyaWZpZWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUGxlYXNlIHVzZSAqKmJveC52ZXJpZmllZCoqIHRvIGdldCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKi9cbiAgZnVuY3Rpb24gVmVyaWZpZWQoYm94KSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBWZXJpZmllZCk7XG4gICAgdGhpcy5fYm94ID0gYm94O1xuICAgIHRoaXMuX2RpZCA9IGJveC5fM2lkLm11cG9ydERJRDtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyW1wiZGVmYXVsdFwiXSkoVmVyaWZpZWQsIFt7XG4gICAga2V5OiBcIl9hZGRWZXJpZmllZFB1YmxpY0FjY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRWZXJpZmllZFB1YmxpY0FjY291bnQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5LCBwcm9vZiwgdmVyaWZpY2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGFjY291bnQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWNhdGlvbkZ1bmN0aW9uKHRoaXMuX2RpZCwgcHJvb2YpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm94W1wicHVibGljXCJdLnNldCgncHJvb2ZfJyArIGtleSwgcHJvb2YpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2FkZFZlcmlmaWVkUHVibGljQWNjb3VudChfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9hZGRWZXJpZmllZFB1YmxpY0FjY291bnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfYWRkVmVyaWZpZWRQdWJsaWNBY2NvdW50O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWZXJpZmllZFB1YmxpY0FjY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRWZXJpZmllZFB1YmxpY0FjY291bnQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGtleSwgdmVyaWZpY2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb29mO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JveFtcInB1YmxpY1wiXS5nZXQoJ3Byb29mXycgKyBrZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBwcm9vZiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHZlcmlmaWNhdGlvbkZ1bmN0aW9uKHRoaXMuX2RpZCwgcHJvb2YpKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2dldFZlcmlmaWVkUHVibGljQWNjb3VudChfeDQsIF94NSkge1xuICAgICAgICByZXR1cm4gX2dldFZlcmlmaWVkUHVibGljQWNjb3VudDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRWZXJpZmllZFB1YmxpY0FjY291bnQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFZlcmlmaWVkUHJpdmF0ZUFjY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRWZXJpZmllZFByaXZhdGVBY2NvdW50MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhrZXksIHByb29mLCB2ZXJpZmljYXRpb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgYWNjb3VudDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJpZmljYXRpb25GdW5jdGlvbih0aGlzLl9kaWQsIHByb29mKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYWNjb3VudCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm94W1wicHJpdmF0ZVwiXS5zZXQoJ3Byb29mXycgKyBrZXksIHByb29mKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgYWNjb3VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9hZGRWZXJpZmllZFByaXZhdGVBY2NvdW50KF94NiwgX3g3LCBfeDgpIHtcbiAgICAgICAgcmV0dXJuIF9hZGRWZXJpZmllZFByaXZhdGVBY2NvdW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2FkZFZlcmlmaWVkUHJpdmF0ZUFjY291bnQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZlcmlmaWVkUHJpdmF0ZUFjY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRWZXJpZmllZFByaXZhdGVBY2NvdW50MiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNChrZXksIHZlcmlmaWNhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBwcm9vZjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3hbXCJwcml2YXRlXCJdLmdldCgncHJvb2ZfJyArIGtleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHByb29mID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgdmVyaWZpY2F0aW9uRnVuY3Rpb24odGhpcy5fZGlkLCBwcm9vZikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZ2V0VmVyaWZpZWRQcml2YXRlQWNjb3VudChfeDksIF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9nZXRWZXJpZmllZFByaXZhdGVBY2NvdW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldFZlcmlmaWVkUHJpdmF0ZUFjY291bnQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmVyaWZpZWQgRElEIG9mIHRoZSB1c2VyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICAgIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBESUQgb2YgdGhlIHVzZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIkRJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX0RJRCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZGlkKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gRElEKCkge1xuICAgICAgICByZXR1cm4gX0RJRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gRElEO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIHVzZXIgaGFzIGEgdmFsaWQgZ2l0aHViIGFjY291bnRcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgYW5kIHByb29mXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnaXRodWJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9naXRodWIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2dldFZlcmlmaWVkUHVibGljQWNjb3VudCgnZ2l0aHViJywgdmVyaWZpZXIudmVyaWZ5R2l0aHViKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdpdGh1YigpIHtcbiAgICAgICAgcmV0dXJuIF9naXRodWIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdpdGh1YjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZ2l0aHViIHZlcmlmaWNhdGlvbiB0byB0aGUgdXNlcnMgcHJvZmlsZVxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmVyaWZpY2F0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICAgICAgICAgIGdpc3RVcmwgICAgICAgICBVUkwgb2YgdGhlIHByb29mXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgYW5kIHByb29mXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRHaXRodWJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRHaXRodWIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoZ2lzdFVybCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9hZGRWZXJpZmllZFB1YmxpY0FjY291bnQoJ2dpdGh1YicsIGdpc3RVcmwsIHZlcmlmaWVyLnZlcmlmeUdpdGh1YikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBhZGRHaXRodWIoX3gxMSkge1xuICAgICAgICByZXR1cm4gX2FkZEdpdGh1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkR2l0aHViO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIHVzZXIgaGFzIGEgdmFsaWQgdHdpdHRlciBhY2NvdW50XG4gICAgICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdXNlcm5hbWUsIHByb29mLCBhbmQgdGhlIHZlcmlmaWVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0d2l0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdHdpdHRlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZ2V0VmVyaWZpZWRQdWJsaWNBY2NvdW50KCd0d2l0dGVyJywgdmVyaWZpZXIudmVyaWZ5VHdpdHRlcikpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB0d2l0dGVyKCkge1xuICAgICAgICByZXR1cm4gX3R3aXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR3aXR0ZXI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHR3aXR0ZXIgdmVyaWZpY2F0aW9uIHRvIHRoZSB1c2VycyBwcm9maWxlXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2ZXJpZmljYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgY2xhaW0gICAgICAgICAgIEEgZGlkLUpXVCBjbGFpbSBvd25lcnNoaXAgb2YgYSB0d2l0dGVyIHVzZXJuYW1lXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgcHJvb2YsIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZFR3aXR0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hZGRUd2l0dGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KGNsYWltKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2FkZFZlcmlmaWVkUHVibGljQWNjb3VudCgndHdpdHRlcicsIGNsYWltLCB2ZXJpZmllci52ZXJpZnlUd2l0dGVyKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFR3aXR0ZXIoX3gxMikge1xuICAgICAgICByZXR1cm4gX2FkZFR3aXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZFR3aXR0ZXI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgKiBWZXJpZmllcyB0aGF0IHRoZSB1c2VyIGhhcyBhIHZlcmlmaWVkIGVtYWlsIGFjY291bnRcbiAgICAqIFRocm93cyBhbiBlcnJvciBvdGhlcndpc2UuXG4gICAgKlxuICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgcHJvb2YsIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1haWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9lbWFpbCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZ2V0VmVyaWZpZWRQcml2YXRlQWNjb3VudCgnZW1haWwnLCB2ZXJpZmllci52ZXJpZnlFbWFpbCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGVtYWlsKCkge1xuICAgICAgICByZXR1cm4gX2VtYWlsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbWFpbDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGVtYWlsIHZlcmlmaWNhdGlvbiB0byB0aGUgdXNlcnMgcHJvZmlsZVxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmVyaWZpY2F0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIGNsYWltICAgICAgICAgICBBIGRpZC1KV1QgY2xhaW0gb3duZXJzaGlwIG9mIGFuIGVtYWlsIHVzZXJuYW1lXG4gICAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgcHJvb2YsIGFuZCB0aGUgdmVyaWZpZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEVtYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWRkRW1haWwgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGNsYWltKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fYWRkVmVyaWZpZWRQcml2YXRlQWNjb3VudCgnZW1haWwnLCBjbGFpbSwgdmVyaWZpZXIudmVyaWZ5RW1haWwpKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBhZGRFbWFpbChfeDEzKSB7XG4gICAgICAgIHJldHVybiBfYWRkRW1haWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZEVtYWlsO1xuICAgIH0oKVxuICB9XSk7XG4gIHJldHVybiBWZXJpZmllZDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZXJpZmllZDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG4vKipcbiAqIEEgbW9kdWxlIHRvIHZlcmlmeSAmIHZhbGlkYXRlIGNsYWltc1xuICpcbiAqIEBuYW1lIGlkVXRpbHNcbiAqIEBtZW1iZXJvZiBCb3hcbiAqL1xudmFyIGRpZEpXVCA9IHJlcXVpcmUoJ2RpZC1qd3QnKTtcblxudmFyIERJRF9NVVBPUlRfUFJFRklYID0gJ2RpZDptdXBvcnQ6Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIHN0cmluZyBpcyBhIG11cG9ydCBkaWQgb3Igbm90XG4gICAqXG4gICAqIEBtZW1iZXJPZiBCb3guaWRVdGlsc1xuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgYWRkcmVzcyAgQSBzdHJpbmcgY29udGFpbmluZyBhIHVzZXIgcHJvZmlsZSBhZGRyZXNzXG4gICAqIEByZXR1cm4gIHsqfGJvb2xlYW59ICAgICAgICAgICBXaGV0aGVyIHRoZSBhZGRyZXNzIGlzIGEgbXVwb3J0IGRpZCBvciBub3RcbiAgICovXG4gIGlzTXVwb3J0RElEOiBmdW5jdGlvbiBpc011cG9ydERJRChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGFkZHJlc3Muc3RhcnRzV2l0aChESURfTVVQT1JUX1BSRUZJWCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBzdHJpbmcgaXMgYSB2YWxpZCBjbGFpbSBvciBub3RcbiAgICpcbiAgICogQG1lbWJlck9mIEJveC5pZFV0aWxzXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICAgICAgY2xhaW1cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgICBvcHRzICAgICAgICAgICAgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIG9wdHMuYXVkaWVuY2UgICBUaGUgRElEIG9mIHRoZSBhdWRpZW5jZSBvZiB0aGUgSldUXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59ICAgICAgICAgICAgICAgICAgIHdoZXRoZXIgdGhlIHBhcmFtZXRlciBpcyBhbiBhY3R1YWwgY2xhaW1cbiAgICovXG4gIGlzQ2xhaW06IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2lzQ2xhaW0gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNsYWltKSB7XG4gICAgICB2YXIgb3B0cyxcbiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG9wdHMgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IHt9O1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiBkaWRKV1QuZGVjb2RlSldUKGNsYWltLCBvcHRzKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCA3XV0pO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGlzQ2xhaW0oX3gpIHtcbiAgICAgIHJldHVybiBfaXNDbGFpbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBpc0NsYWltO1xuICB9KCksXG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhIGNsYWltIGFuZCByZXR1cm4gaXRzIGNvbnRlbnQuXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXBvcnQtcHJvamVjdC9kaWQtand0LyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgQm94LmlkVXRpbHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICBjbGFpbVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgIG9wdHMgICAgICAgICAgICBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgb3B0cy5hdWRpZW5jZSAgIFRoZSBESUQgb2YgdGhlIEpXVCdzIGF1ZGllbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB2YWxpZGF0ZWQgY2xhaW1cbiAgICovXG4gIHZlcmlmeUNsYWltOiBkaWRKV1QudmVyaWZ5SldUXG59OyIsImNvbnN0IEFjY2Vzc0NvbnRyb2xsZXJzID0gcmVxdWlyZSgnLi9zcmMvYWNjZXNzLWNvbnRyb2xsZXJzJylcbm1vZHVsZS5leHBvcnRzID0gQWNjZXNzQ29udHJvbGxlcnNcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBLZXlWYWx1ZVN0b3JlID0gcmVxdWlyZSgnLi9rZXlWYWx1ZVN0b3JlJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMvaW5kZXgnKSxcbiAgICB0aHJvd0lmVW5kZWZpbmVkID0gX3JlcXVpcmUudGhyb3dJZlVuZGVmaW5lZCxcbiAgICB0aHJvd0lmTm90RXF1YWxMZW5BcnJheXMgPSBfcmVxdWlyZS50aHJvd0lmTm90RXF1YWxMZW5BcnJheXM7XG5cbnZhciBQcm9maWxlU3RvcmUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LZXlWYWx1ZVN0b3JlKSB7XG4gICgwLCBfaW5oZXJpdHMyW1wiZGVmYXVsdFwiXSkoUHJvZmlsZVN0b3JlLCBfS2V5VmFsdWVTdG9yZSk7XG5cbiAgZnVuY3Rpb24gUHJvZmlsZVN0b3JlKG9yYml0ZGIsIG5hbWUsIGxpbmtQcm9maWxlLCBlbnN1cmVDb25uZWN0ZWQsIF8zaWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIFByb2ZpbGVTdG9yZSk7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yW1wiZGVmYXVsdFwiXSkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShQcm9maWxlU3RvcmUpLmNhbGwodGhpcywgb3JiaXRkYiwgbmFtZSwgZW5zdXJlQ29ubmVjdGVkLCBfM2lkKSk7XG4gICAgX3RoaXMuX2xpbmtQcm9maWxlID0gbGlua1Byb2ZpbGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShQcm9maWxlU3RvcmUsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9wdHMsXG4gICAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MubGVuZ3RoID4gMiAmJiBfYXJnc1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICB0aHJvd0lmVW5kZWZpbmVkKGtleSwgJ2tleScpOyAvLyBpZiB0aGlzIGlzIHRoZSBub0xpbmsgY2FsbCB3ZSBzaG91bGRuJ3QgY2FsbCBfbGlua1Byb2ZpbGUuXG5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5ub0xpbmspIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmtQcm9maWxlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9nZXQyW1wiZGVmYXVsdFwiXSkoKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShQcm9maWxlU3RvcmUucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBrZXksIHZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXQoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNldE11bHRpcGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0TXVsdGlwbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoa2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZOb3RFcXVhbExlbkFycmF5cyhrZXlzLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlua1Byb2ZpbGUoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9nZXQyW1wiZGVmYXVsdFwiXSkoKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShQcm9maWxlU3RvcmUucHJvdG90eXBlKSwgXCJzZXRNdWx0aXBsZVwiLCB0aGlzKS5jYWxsKHRoaXMsIGtleXMsIHZhbHVlcykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRNdWx0aXBsZShfeDMsIF94NCkge1xuICAgICAgICByZXR1cm4gX3NldE11bHRpcGxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRNdWx0aXBsZTtcbiAgICB9KClcbiAgfV0pO1xuICByZXR1cm4gUHJvZmlsZVN0b3JlO1xufShLZXlWYWx1ZVN0b3JlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9maWxlU3RvcmU7IiwiY29uc3QgT2RiSWRlbnRpdHlQcm92aWRlciA9IHJlcXVpcmUoJy4vb2RiSWRlbnRpdHlQcm92aWRlcicpXG5jb25zdCBNb2RlcmF0b3JBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9tb2RlcmF0b3JBY2Nlc3NDb250cm9sbGVyJylcbmNvbnN0IFRocmVhZEFjY2Vzc0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL3RocmVhZEFjY2Vzc0NvbnRyb2xsZXInKVxuY29uc3QgTGVnYWN5SVBGUzNCb3hBY2Nlc3NDb250cm9sbGVyID0gcmVxdWlyZSgnLi9sZWdhY3lJcGZzM2JveEFjY2Vzc0NvbnRyb2xsZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgT2RiSWRlbnRpdHlQcm92aWRlciwgTW9kZXJhdG9yQWNjZXNzQ29udHJvbGxlciwgVGhyZWFkQWNjZXNzQ29udHJvbGxlciwgTGVnYWN5SVBGUzNCb3hBY2Nlc3NDb250cm9sbGVyICB9XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgRXZlbnRTdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWV2ZW50c3RvcmUnKVxuY29uc3QgRmVlZFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItZmVlZHN0b3JlJylcbmNvbnN0IEtleVZhbHVlU3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1rdnN0b3JlJylcbmNvbnN0IENvdW50ZXJTdG9yZSA9IHJlcXVpcmUoJ29yYml0LWRiLWNvdW50ZXJzdG9yZScpXG5jb25zdCBEb2N1bWVudFN0b3JlID0gcmVxdWlyZSgnb3JiaXQtZGItZG9jc3RvcmUnKVxuY29uc3QgUHVic3ViID0gcmVxdWlyZSgnb3JiaXQtZGItcHVic3ViJylcbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnb3JiaXQtZGItY2FjaGUnKVxuY29uc3QgS2V5c3RvcmUgPSByZXF1aXJlKCdvcmJpdC1kYi1rZXlzdG9yZScpXG5jb25zdCBJZGVudGl0aWVzID0gcmVxdWlyZSgnb3JiaXQtZGItaWRlbnRpdHktcHJvdmlkZXInKVxubGV0IEFjY2Vzc0NvbnRyb2xsZXJzID0gcmVxdWlyZSgnb3JiaXQtZGItYWNjZXNzLWNvbnRyb2xsZXJzJylcbmNvbnN0IE9yYml0REJBZGRyZXNzID0gcmVxdWlyZSgnLi9vcmJpdC1kYi1hZGRyZXNzJylcbmNvbnN0IGNyZWF0ZURCTWFuaWZlc3QgPSByZXF1aXJlKCcuL2RiLW1hbmlmZXN0JylcbmNvbnN0IGV4Y2hhbmdlSGVhZHMgPSByZXF1aXJlKCcuL2V4Y2hhbmdlLWhlYWRzJylcbmNvbnN0IHsgaXNEZWZpbmVkLCBpbyB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJ2xvZ3BsZWFzZScpXG5jb25zdCBsb2dnZXIgPSBMb2dnZXIuY3JlYXRlKFwib3JiaXQtZGJcIilcbkxvZ2dlci5zZXRMb2dMZXZlbCgnRVJST1InKVxuXG4vLyBNYXBwaW5nIGZvciAnZGF0YWJhc2UgdHlwZScgLT4gQ2xhc3NcbmxldCBkYXRhYmFzZVR5cGVzID0ge1xuICAnY291bnRlcic6IENvdW50ZXJTdG9yZSxcbiAgJ2V2ZW50bG9nJzogRXZlbnRTdG9yZSxcbiAgJ2ZlZWQnOiBGZWVkU3RvcmUsXG4gICdkb2NzdG9yZSc6IERvY3VtZW50U3RvcmUsXG4gICdrZXl2YWx1ZSc6IEtleVZhbHVlU3RvcmUsXG59XG5cbiAgY2xhc3MgT3JiaXREQiB7XG4gIGNvbnN0cnVjdG9yKGlwZnMsIGlkZW50aXR5LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzRGVmaW5lZChpcGZzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignSVBGUyBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29yYml0ZGIvb3JiaXQtZGIvYmxvYi9tYXN0ZXIvQVBJLm1kI2NyZWF0ZWluc3RhbmNlJylcblxuICAgIGlmICghaXNEZWZpbmVkKGlkZW50aXR5KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignaWRlbnRpdHkgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmJpdGRiL29yYml0LWRiL2Jsb2IvbWFzdGVyL0FQSS5tZCNjcmVhdGVpbnN0YW5jZScpXG5cbiAgICB0aGlzLl9pcGZzID0gaXBmc1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eVxuICAgIHRoaXMuaWQgPSBvcHRpb25zLnBlZXJJZFxuICAgIHRoaXMuX3B1YnN1YiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5icm9rZXJcbiAgICAgID8gbmV3IG9wdGlvbnMuYnJva2VyKHRoaXMuX2lwZnMpXG4gICAgICA6IG5ldyBQdWJzdWIodGhpcy5faXBmcywgdGhpcy5pZClcbiAgICB0aGlzLmRpcmVjdG9yeSA9IG9wdGlvbnMuZGlyZWN0b3J5IHx8ICcuL29yYml0ZGInXG4gICAgdGhpcy5rZXlzdG9yZSA9IG9wdGlvbnMua2V5c3RvcmVcbiAgICB0aGlzLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBDYWNoZVxuICAgIHRoaXMuc3RvcmVzID0ge31cbiAgICB0aGlzLl9kaXJlY3RDb25uZWN0aW9ucyA9IHt9XG4gICAgLy8gQWNjZXNzQ29udHJvbGxlcnMgbW9kdWxlIGNhbiBiZSBwYXNzZWQgaW4gdG8gZW5hYmxlXG4gICAgLy8gdGVzdGluZyB3aXRoIG9yYml0LWRiLWFjY2Vzcy1jb250cm9sbGVyXG4gICAgQWNjZXNzQ29udHJvbGxlcnMgPSBvcHRpb25zLkFjY2Vzc0NvbnRyb2xsZXJzIHx8IEFjY2Vzc0NvbnRyb2xsZXJzXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgY3JlYXRlSW5zdGFuY2UgKGlwZnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNEZWZpbmVkKGlwZnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJUEZTIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3JiaXRkYi9vcmJpdC1kYi9ibG9iL21hc3Rlci9BUEkubWQjY3JlYXRlaW5zdGFuY2UnKVxuXG4gICAgY29uc3QgeyBpZCB9ID0gYXdhaXQgaXBmcy5pZCgpXG4gICAgY29uc3QgZGlyZWN0b3J5ID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgJy4vb3JiaXRkYidcbiAgICBjb25zdCBrZXlzdG9yZSA9IG9wdGlvbnMua2V5c3RvcmUgfHwgS2V5c3RvcmUuY3JlYXRlKHBhdGguam9pbihkaXJlY3RvcnksIGlkLCAnL2tleXN0b3JlJykpXG5cbiAgICBjb25zdCBpZGVudGl0eSA9IG9wdGlvbnMuaWRlbnRpdHkgfHwgYXdhaXQgSWRlbnRpdGllcy5jcmVhdGVJZGVudGl0eSh7XG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCBpZCxcbiAgICAgIGtleXN0b3JlOiBrZXlzdG9yZSxcbiAgICB9KVxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBwZWVySWQ6IGlkICxcbiAgICAgIGRpcmVjdG9yeTogZGlyZWN0b3J5LFxuICAgICAga2V5c3RvcmU6IGtleXN0b3JlXG4gICAgfSlcbiAgICBjb25zdCBvcmJpdGRiID0gbmV3IE9yYml0REIoaXBmcywgaWRlbnRpdHksIG9wdGlvbnMpXG4gICAgcmV0dXJuIG9yYml0ZGJcbiAgfVxuXG4gIC8qIERhdGFiYXNlcyAqL1xuICBhc3luYyBmZWVkIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNyZWF0ZTogdHJ1ZSwgdHlwZTogJ2ZlZWQnIH0sIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMub3BlbihhZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgbG9nIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNyZWF0ZTogdHJ1ZSwgdHlwZTogJ2V2ZW50bG9nJyB9LCBvcHRpb25zKVxuICAgIHJldHVybiB0aGlzLm9wZW4oYWRkcmVzcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGV2ZW50bG9nIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5sb2coYWRkcmVzcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGtleXZhbHVlIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNyZWF0ZTogdHJ1ZSwgdHlwZTogJ2tleXZhbHVlJyB9LCBvcHRpb25zKVxuICAgIHJldHVybiB0aGlzLm9wZW4oYWRkcmVzcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGt2c3RvcmUgKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmtleXZhbHVlKGFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBjb3VudGVyIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNyZWF0ZTogdHJ1ZSwgdHlwZTogJ2NvdW50ZXInIH0sIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMub3BlbihhZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgZG9jcyAoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjcmVhdGU6IHRydWUsIHR5cGU6ICdkb2NzdG9yZScgfSwgb3B0aW9ucylcbiAgICByZXR1cm4gdGhpcy5vcGVuKGFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBkb2NzdG9yZSAoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jcyhhZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgZGlzY29ubmVjdCAoKSB7XG4gICAgLy9jbG9zZSBLZXlzdG9yZVxuICAgIGlmICh0aGlzLmtleXN0b3JlLmNsb3NlKVxuICAgICAgYXdhaXQgdGhpcy5rZXlzdG9yZS5jbG9zZSgpXG5cbiAgICAvLyBDbG9zZSBhbGwgb3BlbiBkYXRhYmFzZXNcbiAgICBjb25zdCBkYXRhYmFzZXMgPSBPYmplY3QudmFsdWVzKHRoaXMuc3RvcmVzKVxuICAgIGZvciAobGV0IGRiIG9mIGRhdGFiYXNlcykge1xuICAgICAgYXdhaXQgZGIuY2xvc2UoKVxuICAgICAgZGVsZXRlIHRoaXMuc3RvcmVzW2RiLmFkZHJlc3MudG9TdHJpbmcoKV1cbiAgICB9XG5cbiAgICAvLyBDbG9zZSBhIGRpcmVjdCBjb25uZWN0aW9uIGFuZCByZW1vdmUgaXQgZnJvbSBpbnRlcm5hbCBzdGF0ZVxuICAgIGNvbnN0IHJlbW92ZURpcmVjdENvbm5lY3QgPSBlID0+IHtcbiAgICAgIHRoaXMuX2RpcmVjdENvbm5lY3Rpb25zW2VdLmNsb3NlKClcbiAgICAgIGRlbGV0ZSB0aGlzLl9kaXJlY3RDb25uZWN0aW9uc1tlXVxuICAgIH1cblxuICAgIC8vIENsb3NlIGFsbCBkaXJlY3QgY29ubmVjdGlvbnMgdG8gcGVlcnNcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9kaXJlY3RDb25uZWN0aW9ucykuZm9yRWFjaChyZW1vdmVEaXJlY3RDb25uZWN0KVxuXG4gICAgLy8gRGlzY29ubmVjdCBmcm9tIHB1YnN1YlxuICAgIGlmICh0aGlzLl9wdWJzdWIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3B1YnN1Yi5kaXNjb25uZWN0KClcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGRhdGFiYXNlcyBmcm9tIHRoZSBzdGF0ZVxuICAgIHRoaXMuc3RvcmVzID0ge31cbiAgfVxuXG4gIC8vIEFsaWFzIGZvciBkaXNjb25uZWN0KClcbiAgYXN5bmMgc3RvcCAoKSB7XG4gICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0KClcbiAgfVxuXG4gIC8qIFByaXZhdGUgbWV0aG9kcyAqL1xuICBhc3luYyBfY3JlYXRlU3RvcmUgKHR5cGUsIGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICAvLyBHZXQgdGhlIHR5cGUgLT4gY2xhc3MgbWFwcGluZ1xuICAgIGNvbnN0IFN0b3JlID0gZGF0YWJhc2VUeXBlc1t0eXBlXVxuXG4gICAgaWYgKCFTdG9yZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhYmFzZSB0eXBlICcke3R5cGV9J2ApXG5cbiAgICBsZXQgYWNjZXNzQ29udHJvbGxlclxuICAgIGlmIChvcHRpb25zLmFjY2Vzc0NvbnRyb2xsZXJBZGRyZXNzKSB7XG4gICAgICBhY2Nlc3NDb250cm9sbGVyID0gYXdhaXQgQWNjZXNzQ29udHJvbGxlcnMucmVzb2x2ZSh0aGlzLCBvcHRpb25zLmFjY2Vzc0NvbnRyb2xsZXJBZGRyZXNzLCBvcHRpb25zLmFjY2Vzc0NvbnRyb2xsZXIpXG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCB0aGlzLl9sb2FkQ2FjaGUodGhpcy5kaXJlY3RvcnksIGFkZHJlc3MpXG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHJlcGxpY2F0ZTogdHJ1ZSB9LCBvcHRpb25zLCB7XG4gICAgICBhY2Nlc3NDb250cm9sbGVyOiBhY2Nlc3NDb250cm9sbGVyLFxuICAgICAga2V5c3RvcmU6IHRoaXMua2V5c3RvcmUsXG4gICAgICBjYWNoZTogY2FjaGUsXG4gICAgICBvbkNsb3NlOiB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcyksXG4gICAgfSlcbiAgICBjb25zdCBpZGVudGl0eSA9IG9wdGlvbnMuaWRlbnRpdHkgfHwgdGhpcy5pZGVudGl0eVxuXG4gICAgY29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUodGhpcy5faXBmcywgaWRlbnRpdHksIGFkZHJlc3MsIG9wdHMpXG4gICAgc3RvcmUuZXZlbnRzLm9uKCd3cml0ZScsIHRoaXMuX29uV3JpdGUuYmluZCh0aGlzKSlcbiAgICAvLyBJRCBvZiB0aGUgc3RvcmUgaXMgdGhlIGFkZHJlc3MgYXMgYSBzdHJpbmdcbiAgICBjb25zdCBhZGRyID0gYWRkcmVzcy50b1N0cmluZygpXG4gICAgdGhpcy5zdG9yZXNbYWRkcl0gPSBzdG9yZVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIHB1YnN1YiB0byBnZXQgdXBkYXRlcyBmcm9tIHBlZXJzLFxuICAgIC8vIHRoaXMgaXMgd2hhdCBob29rcyB1cyBpbnRvIHRoZSBtZXNzYWdlIHByb3BhZ2F0aW9uIGxheWVyXG4gICAgLy8gYW5kIHRoZSBwMnAgbmV0d29ya1xuICAgIGlmKG9wdHMucmVwbGljYXRlICYmIHRoaXMuX3B1YnN1YilcbiAgICAgIHRoaXMuX3B1YnN1Yi5zdWJzY3JpYmUoYWRkciwgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyksIHRoaXMuX29uUGVlckNvbm5lY3RlZC5iaW5kKHRoaXMpKVxuXG4gICAgcmV0dXJuIHN0b3JlXG4gIH1cblxuICAvLyBDYWxsYmFjayBmb3IgbG9jYWwgd3JpdGVzIHRvIHRoZSBkYXRhYmFzZS4gV2UgdGhlIHVwZGF0ZSB0byBwdWJzdWIuXG4gIF9vbldyaXRlIChhZGRyZXNzLCBlbnRyeSwgaGVhZHMpIHtcbiAgICBpZighaGVhZHMpIHRocm93IG5ldyBFcnJvcihcIidoZWFkcycgbm90IGRlZmluZWRcIilcbiAgICBpZih0aGlzLl9wdWJzdWIpIHRoaXMuX3B1YnN1Yi5wdWJsaXNoKGFkZHJlc3MsIGhlYWRzKVxuICB9XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIHJlY2VpdmluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgbmV0d29ya1xuICBhc3luYyBfb25NZXNzYWdlIChhZGRyZXNzLCBoZWFkcykge1xuICAgIGNvbnN0IHN0b3JlID0gdGhpcy5zdG9yZXNbYWRkcmVzc11cbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBSZWNlaXZlZCAke2hlYWRzLmxlbmd0aH0gaGVhZHMgZm9yICcke2FkZHJlc3N9JzpcXG5gLCBKU09OLnN0cmluZ2lmeShoZWFkcy5tYXAoZSA9PiBlLmhhc2gpLCBudWxsLCAyKSlcbiAgICAgIGlmIChzdG9yZSAmJiBoZWFkcyAmJiBoZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGF3YWl0IHN0b3JlLnN5bmMoaGVhZHMpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gYSBwZWVyIGNvbm5lY3RlZCB0byBhIGRhdGFiYXNlXG4gIGFzeW5jIF9vblBlZXJDb25uZWN0ZWQgKGFkZHJlc3MsIHBlZXIpIHtcbiAgICBsb2dnZXIuZGVidWcoYE5ldyBwZWVyICcke3BlZXJ9JyBjb25uZWN0ZWQgdG8gJyR7YWRkcmVzc30nYClcblxuICAgIGNvbnN0IGdldFN0b3JlID0gYWRkcmVzcyA9PiB0aGlzLnN0b3Jlc1thZGRyZXNzXVxuICAgIGNvbnN0IGdldERpcmVjdENvbm5lY3Rpb24gPSBwZWVyID0+IHRoaXMuX2RpcmVjdENvbm5lY3Rpb25zW3BlZXJdXG4gICAgY29uc3Qgb25DaGFubmVsQ3JlYXRlZCA9IGNoYW5uZWwgPT4gdGhpcy5fZGlyZWN0Q29ubmVjdGlvbnNbY2hhbm5lbC5fcmVjZWl2ZXJJRF0gPSBjaGFubmVsXG4gICAgY29uc3Qgb25NZXNzYWdlID0gKGFkZHJlc3MsIGhlYWRzKSA9PiB0aGlzLl9vbk1lc3NhZ2UoYWRkcmVzcywgaGVhZHMpXG5cbiAgICBjb25zdCBjaGFubmVsID0gYXdhaXQgZXhjaGFuZ2VIZWFkcyhcbiAgICAgIHRoaXMuX2lwZnMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgcGVlcixcbiAgICAgIGdldFN0b3JlLFxuICAgICAgZ2V0RGlyZWN0Q29ubmVjdGlvbixcbiAgICAgIG9uTWVzc2FnZSxcbiAgICAgIG9uQ2hhbm5lbENyZWF0ZWRcbiAgICApXG5cbiAgICBpZiAoZ2V0U3RvcmUoYWRkcmVzcykpXG4gICAgICBnZXRTdG9yZShhZGRyZXNzKS5ldmVudHMuZW1pdCgncGVlcicsIHBlZXIpXG4gIH1cblxuICAvLyBDYWxsYmFjayB3aGVuIGRhdGFiYXNlIHdhcyBjbG9zZWRcbiAgYXN5bmMgX29uQ2xvc2UgKGFkZHJlc3MpIHtcbiAgICBsb2dnZXIuZGVidWcoYENsb3NlICR7YWRkcmVzc31gKVxuXG4gICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBwdWJzdWJcbiAgICBpZiAodGhpcy5fcHVic3ViKSB7XG4gICAgICBhd2FpdCB0aGlzLl9wdWJzdWIudW5zdWJzY3JpYmUoYWRkcmVzcylcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5zdG9yZXNbYWRkcmVzc11cbiAgfVxuXG4gIGFzeW5jIF9kZXRlcm1pbmVBZGRyZXNzKG5hbWUsIHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghT3JiaXREQi5pc1ZhbGlkVHlwZSh0eXBlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhYmFzZSB0eXBlICcke3R5cGV9J2ApXG5cbiAgICBpZiAoT3JiaXREQkFkZHJlc3MuaXNWYWxpZChuYW1lKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR2l2ZW4gZGF0YWJhc2UgbmFtZSBpcyBhbiBhZGRyZXNzLiBQbGVhc2UgZ2l2ZSBvbmx5IHRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSFgKVxuXG4gICAgLy8gQ3JlYXRlIGFuIEFjY2Vzc0NvbnRyb2xsZXIsIHVzZSBJUEZTIEFDIGFzIHRoZSBkZWZhdWx0XG4gICAgb3B0aW9ucy5hY2Nlc3NDb250cm9sbGVyID0gT2JqZWN0LmFzc2lnbih7fSwgeyBuYW1lOiBuYW1lICwgdHlwZTogJ2lwZnMnIH0sIG9wdGlvbnMuYWNjZXNzQ29udHJvbGxlcilcbiAgICBjb25zdCBhY2Nlc3NDb250cm9sbGVyQWRkcmVzcyA9IGF3YWl0IEFjY2Vzc0NvbnRyb2xsZXJzLmNyZWF0ZSh0aGlzLCBvcHRpb25zLmFjY2Vzc0NvbnRyb2xsZXIudHlwZSwgb3B0aW9ucy5hY2Nlc3NDb250cm9sbGVyICB8fCB7fSlcblxuICAgIC8vIFNhdmUgdGhlIG1hbmlmZXN0IHRvIElQRlNcbiAgICBjb25zdCBtYW5pZmVzdEhhc2ggPSBhd2FpdCBjcmVhdGVEQk1hbmlmZXN0KHRoaXMuX2lwZnMsIG5hbWUsIHR5cGUsIGFjY2Vzc0NvbnRyb2xsZXJBZGRyZXNzLCBvcHRpb25zKVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBkYXRhYmFzZSBhZGRyZXNzXG4gICAgcmV0dXJuIE9yYml0REJBZGRyZXNzLnBhcnNlKHBhdGguam9pbignL29yYml0ZGInLCBtYW5pZmVzdEhhc2gsIG5hbWUpKVxuICB9XG5cbiAgLyogQ3JlYXRlIGFuZCBPcGVuIGRhdGFiYXNlcyAqL1xuXG4gIC8qXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGFjY2Vzc0NvbnRyb2xsZXI6IHsgd3JpdGU6IFtdIH0gLy8gYXJyYXkgb2Yga2V5cyB0aGF0IGNhbiB3cml0ZSB0byB0aGlzIGRhdGFiYXNlXG4gICAgICBkaXJlY3Rvcnk6ICcuL29yYml0ZGInLCAvLyBkaXJlY3RvcnkgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIGRhdGFiYXNlIGZpbGVzXG4gICAgICBvdmVyd3JpdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHdlIHNob3VsZCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGRhdGFiYXNlIGlmIGl0IGV4aXN0c1xuICAgIH1cbiAgKi9cbiAgYXN5bmMgY3JlYXRlIChuYW1lLCB0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBsb2dnZXIuZGVidWcoYGNyZWF0ZSgpYClcblxuICAgIC8vIFRoZSBkaXJlY3RvcnkgdG8gbG9vayBkYXRhYmFzZXMgZnJvbSBjYW4gYmUgcGFzc2VkIGluIGFzIGFuIG9wdGlvblxuICAgIGNvbnN0IGRpcmVjdG9yeSA9IG9wdGlvbnMuZGlyZWN0b3J5IHx8IHRoaXMuZGlyZWN0b3J5XG4gICAgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyBkYXRhYmFzZSAnJHtuYW1lfScgYXMgJHt0eXBlfSBpbiAnJHtkaXJlY3Rvcnl9J2ApXG5cbiAgICAvLyBDcmVhdGUgdGhlIGRhdGFiYXNlIGFkZHJlc3NcbiAgICBjb25zdCBkYkFkZHJlc3MgPSBhd2FpdCB0aGlzLl9kZXRlcm1pbmVBZGRyZXNzKG5hbWUsIHR5cGUsIG9wdGlvbnMpXG5cbiAgICAvLyBMb2FkIHRoZSBsb2NhbGx5IHNhdmVkIGRhdGFiYXNlIGluZm9ybWF0aW9uXG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCB0aGlzLl9sb2FkQ2FjaGUoZGlyZWN0b3J5LCBkYkFkZHJlc3MpXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBkYXRhYmFzZSBsb2NhbGx5XG4gICAgY29uc3QgaGF2ZURCID0gYXdhaXQgdGhpcy5faGF2ZUxvY2FsRGF0YShjYWNoZSwgZGJBZGRyZXNzKVxuXG4gICAgaWYgKGhhdmVEQiAmJiAhb3B0aW9ucy5vdmVyd3JpdGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFiYXNlICcke2RiQWRkcmVzc30nIGFscmVhZHkgZXhpc3RzIWApXG5cbiAgICAvLyBTYXZlIHRoZSBkYXRhYmFzZSBsb2NhbGx5XG4gICAgYXdhaXQgdGhpcy5fYWRkTWFuaWZlc3RUb0NhY2hlKGRpcmVjdG9yeSwgZGJBZGRyZXNzKVxuXG4gICAgbG9nZ2VyLmRlYnVnKGBDcmVhdGVkIGRhdGFiYXNlICcke2RiQWRkcmVzc30nYClcblxuICAgIC8vIE9wZW4gdGhlIGRhdGFiYXNlXG4gICAgcmV0dXJuIHRoaXMub3BlbihkYkFkZHJlc3MsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBkZXRlcm1pbmVBZGRyZXNzKG5hbWUsIHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB7IG9ubHlIYXNoOiB0cnVlIH0sIG9wdGlvbnMpXG4gICAgcmV0dXJuIHRoaXMuX2RldGVybWluZUFkZHJlc3MobmFtZSwgdHlwZSwgb3B0cylcbiAgfVxuXG4gIC8qXG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBsb2NhbE9ubHk6IGZhbHNlIC8vIGlmIHNldCB0byB0cnVlLCB0aHJvd3MgYW4gZXJyb3IgaWYgZGF0YWJhc2UgY2FuJ3QgYmUgZm91bmQgbG9jYWxseVxuICAgICAgICBjcmVhdGU6IGZhbHNlIC8vIHdoZXRoZXIgdG8gY3JlYXRlIHRoZSBkYXRhYmFzZVxuICAgICAgICB0eXBlOiBUT0RPXG4gICAgICAgIG92ZXJ3cml0ZTogVE9ET1xuXG4gICAgICB9XG4gICAqL1xuICBhc3luYyBvcGVuIChhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBsb2dnZXIuZGVidWcoYG9wZW4oKWApXG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGxvY2FsT25seTogZmFsc2UsIGNyZWF0ZTogZmFsc2UgfSwgb3B0aW9ucylcbiAgICBsb2dnZXIuZGVidWcoYE9wZW4gZGF0YWJhc2UgJyR7YWRkcmVzc30nYClcblxuICAgIC8vIFRoZSBkaXJlY3RvcnkgdG8gbG9vayBkYXRhYmFzZXMgZnJvbSBjYW4gYmUgcGFzc2VkIGluIGFzIGFuIG9wdGlvblxuICAgIGNvbnN0IGRpcmVjdG9yeSA9IG9wdGlvbnMuZGlyZWN0b3J5IHx8IHRoaXMuZGlyZWN0b3J5XG4gICAgbG9nZ2VyLmRlYnVnKGBMb29rIGZyb20gJyR7ZGlyZWN0b3J5fSdgKVxuXG4gICAgLy8gSWYgYWRkcmVzcyBpcyBqdXN0IHRoZSBuYW1lIG9mIGRhdGFiYXNlLCBjaGVjayB0aGUgb3B0aW9ucyB0byBjcmF0ZSB0aGUgZGF0YWJhc2VcbiAgICBpZiAoIU9yYml0REJBZGRyZXNzLmlzVmFsaWQoYWRkcmVzcykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5jcmVhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnb3B0aW9ucy5jcmVhdGUnIHNldCB0byAnZmFsc2UnLiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBkYXRhYmFzZSwgc2V0ICdvcHRpb25zLmNyZWF0ZScgdG8gJ3RydWUnLmApXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3JlYXRlICYmICFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSB0eXBlIG5vdCBwcm92aWRlZCEgUHJvdmlkZSBhIHR5cGUgd2l0aCAnb3B0aW9ucy50eXBlJyAoJHtPcmJpdERCLmRhdGFiYXNlVHlwZXMuam9pbignfCcpfSlgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYE5vdCBhIHZhbGlkIE9yYml0REIgYWRkcmVzcyAnJHthZGRyZXNzfScsIGNyZWF0aW5nIHRoZSBkYXRhYmFzZWApXG4gICAgICAgIG9wdGlvbnMub3ZlcndyaXRlID0gb3B0aW9ucy5vdmVyd3JpdGUgPyBvcHRpb25zLm92ZXJ3cml0ZSA6IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKGFkZHJlc3MsIG9wdGlvbnMudHlwZSwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSB0aGUgZGF0YWJhc2UgYWRkcmVzc1xuICAgIGNvbnN0IGRiQWRkcmVzcyA9IE9yYml0REJBZGRyZXNzLnBhcnNlKGFkZHJlc3MpXG5cbiAgICAvLyBMb2FkIHRoZSBsb2NhbGx5IHNhdmVkIGRiIGluZm9ybWF0aW9uXG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCB0aGlzLl9sb2FkQ2FjaGUoZGlyZWN0b3J5LCBkYkFkZHJlc3MpXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBkYXRhYmFzZVxuICAgIGNvbnN0IGhhdmVEQiA9IGF3YWl0IHRoaXMuX2hhdmVMb2NhbERhdGEoY2FjaGUsIGRiQWRkcmVzcylcblxuICAgIGxvZ2dlci5kZWJ1ZygoaGF2ZURCID8gJ0ZvdW5kJyA6ICdEaWRuXFwndCBmaW5kJykgKyBgIGRhdGFiYXNlICcke2RiQWRkcmVzc30nYClcblxuICAgIC8vIElmIHdlIHdhbnQgdG8gdHJ5IGFuZCBvcGVuIHRoZSBkYXRhYmFzZSBsb2NhbC1vbmx5LCB0aHJvdyBhbiBlcnJvclxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdGhlIGRhdGFiYXNlIGxvY2FsbHlcbiAgICBpZiAob3B0aW9ucy5sb2NhbE9ubHkgJiYgIWhhdmVEQikge1xuICAgICAgbG9nZ2VyLndhcm4oYERhdGFiYXNlICcke2RiQWRkcmVzc30nIGRvZXNuJ3QgZXhpc3QhYClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgJyR7ZGJBZGRyZXNzfScgZG9lc24ndCBleGlzdCFgKVxuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhgTG9hZGluZyBNYW5pZmVzdCBmb3IgJyR7ZGJBZGRyZXNzfSdgKVxuXG4gICAgLy8gR2V0IHRoZSBkYXRhYmFzZSBtYW5pZmVzdCBmcm9tIElQRlNcbiAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGlvLnJlYWQodGhpcy5faXBmcywgZGJBZGRyZXNzLnJvb3QpXG4gICAgbG9nZ2VyLmRlYnVnKGBNYW5pZmVzdCBmb3IgJyR7ZGJBZGRyZXNzfSc6XFxuJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdCwgbnVsbCwgMil9YClcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgdHlwZSBmcm9tIHRoZSBtYW5pZmVzdCBtYXRjaGVzIHRoZSB0eXBlIHRoYXQgd2FzIGdpdmVuIGFzIGFuIG9wdGlvblxuICAgIGlmIChvcHRpb25zLnR5cGUgJiYgbWFuaWZlc3QudHlwZSAhPT0gb3B0aW9ucy50eXBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSAnJHtkYkFkZHJlc3N9JyBpcyB0eXBlICcke21hbmlmZXN0LnR5cGV9JyBidXQgd2FzIG9wZW5lZCBhcyAnJHtvcHRpb25zLnR5cGV9J2ApXG5cbiAgICAvLyBTYXZlIHRoZSBkYXRhYmFzZSBsb2NhbGx5XG4gICAgYXdhaXQgdGhpcy5fYWRkTWFuaWZlc3RUb0NhY2hlKGRpcmVjdG9yeSwgZGJBZGRyZXNzKVxuXG4gICAgLy8gT3BlbiB0aGUgdGhlIGRhdGFiYXNlXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgYWNjZXNzQ29udHJvbGxlckFkZHJlc3M6IG1hbmlmZXN0LmFjY2Vzc0NvbnRyb2xsZXIgfSlcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlU3RvcmUobWFuaWZlc3QudHlwZSwgZGJBZGRyZXNzLCBvcHRpb25zKVxuICB9XG5cbiAgLy8gU2F2ZSB0aGUgZGF0YWJhc2UgbG9jYWxseVxuICBhc3luYyBfYWRkTWFuaWZlc3RUb0NhY2hlIChkaXJlY3RvcnksIGRiQWRkcmVzcykge1xuICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgdGhpcy5fbG9hZENhY2hlKGRpcmVjdG9yeSwgZGJBZGRyZXNzKVxuICAgIGF3YWl0IGNhY2hlLnNldChwYXRoLmpvaW4oZGJBZGRyZXNzLnRvU3RyaW5nKCksICdfbWFuaWZlc3QnKSwgZGJBZGRyZXNzLnJvb3QpXG4gICAgbG9nZ2VyLmRlYnVnKGBTYXZlZCBtYW5pZmVzdCB0byBJUEZTIGFzICcke2RiQWRkcmVzcy5yb290fSdgKVxuICB9XG5cbiAgYXN5bmMgX2xvYWRDYWNoZSAoZGlyZWN0b3J5LCBkYkFkZHJlc3MpIHtcbiAgICBsZXQgY2FjaGVcbiAgICB0cnkge1xuICAgICAgY2FjaGUgPSBhd2FpdCB0aGlzLmNhY2hlLmxvYWQoZGlyZWN0b3J5LCBkYkFkZHJlc3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgIGxvZ2dlci5lcnJvcihcIkNvdWxkbid0IGxvYWQgQ2FjaGU6XCIsIGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgZGF0YWJhc2UsIG9yIHBhcnQgb2YgaXQsIHNhdmVkIGxvY2FsbHlcbiAgICogQHBhcmFtICB7W0NhY2hlXX0gY2FjaGUgW1RoZSBPcmJpdERCQ2FjaGUgaW5zdGFuY2UgY29udGFpbmluZyB0aGUgbG9jYWwgZGF0YV1cbiAgICogQHBhcmFtICB7W09yYml0REJBZGRyZXNzXX0gZGJBZGRyZXNzIFtBZGRyZXNzIG9mIHRoZSBkYXRhYmFzZSB0byBjaGVja11cbiAgICogQHJldHVybiB7W0Jvb2xlYW5dfSBbUmV0dXJucyB0cnVlIGlmIHdlIGhhdmUgY2FjaGVkIHRoZSBkYiBsb2NhbGx5LCBmYWxzZSBpZiBub3RdXG4gICAqL1xuICBhc3luYyBfaGF2ZUxvY2FsRGF0YSAoY2FjaGUsIGRiQWRkcmVzcykge1xuICAgIGlmICghY2FjaGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgY2FjaGUuZ2V0KHBhdGguam9pbihkYkFkZHJlc3MudG9TdHJpbmcoKSwgJ19tYW5pZmVzdCcpKVxuICAgIHJldHVybiBkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3VwcG9ydGVkIGRhdGFiYXNlIHR5cGVzIGFzIGFuIEFycmF5IG9mIHN0cmluZ3NcbiAgICogRWcuIFsgJ2NvdW50ZXInLCAnZXZlbnRsb2cnLCAnZmVlZCcsICdkb2NzdG9yZScsICdrZXl2YWx1ZSddXG4gICAqIEByZXR1cm4ge1tBcnJheV19IFtTdXBwb3J0ZWQgZGF0YWJhc2UgdHlwZXNdXG4gICAqL1xuICBzdGF0aWMgZ2V0IGRhdGFiYXNlVHlwZXMgKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhkYXRhYmFzZVR5cGVzKVxuICB9XG5cbiAgc3RhdGljIGlzVmFsaWRUeXBlICh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGFiYXNlVHlwZXMpLmluY2x1ZGVzKHR5cGUpXG4gIH1cblxuICBzdGF0aWMgYWRkRGF0YWJhc2VUeXBlICh0eXBlLCBzdG9yZSkge1xuICAgIGlmIChkYXRhYmFzZVR5cGVzW3R5cGVdKSB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgYWxyZWFkeSBleGlzdHM6ICR7dHlwZX1gKVxuICAgIGRhdGFiYXNlVHlwZXNbdHlwZV0gPSBzdG9yZVxuICB9XG5cbiAgc3RhdGljIGdldERhdGFiYXNlVHlwZXMgKCkge1xuICAgIHJldHVybiBkYXRhYmFzZVR5cGVzXG4gIH1cblxuICBzdGF0aWMgaXNWYWxpZEFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gT3JiaXREQkFkZHJlc3MuaXNWYWxpZChhZGRyZXNzKVxuICB9XG5cbiAgc3RhdGljIHBhcnNlQWRkcmVzcyAoYWRkcmVzcykge1xuICAgIHJldHVybiBPcmJpdERCQWRkcmVzcy5wYXJzZShhZGRyZXNzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT3JiaXREQlxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJsb2NrU2VydmljZSA9IHJlcXVpcmUoJ2lwZnMtYmxvY2stc2VydmljZScpXG5jb25zdCBJcGxkID0gcmVxdWlyZSgnaXBsZCcpXG5jb25zdCBQZWVySWQgPSByZXF1aXJlKCdwZWVyLWlkJylcbmNvbnN0IFBlZXJJbmZvID0gcmVxdWlyZSgncGVlci1pbmZvJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2xpYnAycC1jcnlwdG8nKVxuY29uc3QgaXNJUEZTID0gcmVxdWlyZSgnaXMtaXBmcycpXG5jb25zdCBtdWx0aWFkZHIgPSByZXF1aXJlKCdtdWx0aWFkZHInKVxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgUGVlckJvb2sgPSByZXF1aXJlKCdwZWVyLWJvb2snKVxuY29uc3QgbXVsdGliYXNlID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IG11bHRpY29kZWMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJylcbmNvbnN0IG11bHRpaGFzaGluZyA9IHJlcXVpcmUoJ211bHRpaGFzaGluZy1hc3luYycpXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKVxuY29uc3QgbWVyZ2VPcHRpb25zID0gcmVxdWlyZSgnbWVyZ2Utb3B0aW9ucycpXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKVxuXG5jb25zdCBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG5jb25zdCBib290ID0gcmVxdWlyZSgnLi9ib290JylcbmNvbnN0IGNvbXBvbmVudHMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMnKVxuXG4vLyByZXBsYWNlZCBieSByZXBvLWJyb3dzZXIgd2hlbiBydW5uaW5nIGluIHRoZSBicm93c2VyXG5jb25zdCBkZWZhdWx0UmVwbyA9IHJlcXVpcmUoJy4vcnVudGltZS9yZXBvLW5vZGVqcycpXG5jb25zdCBwcmVsb2FkID0gcmVxdWlyZSgnLi9wcmVsb2FkJylcbmNvbnN0IG1mc1ByZWxvYWQgPSByZXF1aXJlKCcuL21mcy1wcmVsb2FkJylcbmNvbnN0IGlwbGRPcHRpb25zID0gcmVxdWlyZSgnLi9ydW50aW1lL2lwbGQtbm9kZWpzJylcblxuY2xhc3MgSVBGUyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBpbml0OiB0cnVlLFxuICAgICAgc3RhcnQ6IHRydWUsXG4gICAgICBFWFBFUklNRU5UQUw6IHt9LFxuICAgICAgcHJlbG9hZDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBhZGRyZXNzZXM6IFtcbiAgICAgICAgICAnL2Ruc2FkZHIvbm9kZTAucHJlbG9hZC5pcGZzLmlvL2h0dHBzJyxcbiAgICAgICAgICAnL2Ruc2FkZHIvbm9kZTEucHJlbG9hZC5pcGZzLmlvL2h0dHBzJ1xuICAgICAgICBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IGNvbmZpZy52YWxpZGF0ZShvcHRpb25zIHx8IHt9KVxuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLmluaXQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmluaXQgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMuc3RhcnQgPT09IGZhbHNlKSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5zdGFydCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVwbyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgb3B0aW9ucy5yZXBvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JlcG8gPSBkZWZhdWx0UmVwbyhvcHRpb25zLnJlcG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcG8gPSBvcHRpb25zLnJlcG9cbiAgICB9XG5cbiAgICAvLyBJUEZTIHV0aWxzXG4gICAgdGhpcy5sb2cgPSBkZWJ1ZygnaXBmcycpXG4gICAgdGhpcy5sb2cuZXJyID0gZGVidWcoJ2lwZnM6ZXJyJylcblxuICAgIC8vIElQRlMgQ29yZSBJbnRlcm5hbHNcbiAgICAvLyB0aGlzLl9yZXBvIC0gYXNzaWduZWQgYWJvdmVcbiAgICB0aGlzLl9wZWVySW5mb0Jvb2sgPSBuZXcgUGVlckJvb2soKVxuICAgIHRoaXMuX3BlZXJJbmZvID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYml0c3dhcCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Jsb2NrU2VydmljZSA9IG5ldyBCbG9ja1NlcnZpY2UodGhpcy5fcmVwbylcbiAgICB0aGlzLl9pcGxkID0gbmV3IElwbGQoaXBsZE9wdGlvbnModGhpcy5fYmxvY2tTZXJ2aWNlLCB0aGlzLl9vcHRpb25zLmlwbGQsIHRoaXMubG9nKSlcbiAgICB0aGlzLl9wcmVsb2FkID0gcHJlbG9hZCh0aGlzKVxuICAgIHRoaXMuX21mc1ByZWxvYWQgPSBtZnNQcmVsb2FkKHRoaXMpXG4gICAgdGhpcy5faXBucyA9IHVuZGVmaW5lZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgdGhpcy5fcHJpbnQgPSB0aGlzLl9vcHRpb25zLnNpbGVudCA/IHRoaXMubG9nIDogY29uc29sZS5sb2dcblxuICAgIC8vIElQRlMgQ29yZSBleHBvc2VkIGNvbXBvbmVudHNcbiAgICAvLyAgIC0gZm9yIGJvb3RpbmcgdXAgYSBub2RlXG4gICAgdGhpcy5pbml0ID0gY29tcG9uZW50cy5pbml0KHRoaXMpXG4gICAgdGhpcy5wcmVTdGFydCA9IGNvbXBvbmVudHMucHJlU3RhcnQodGhpcylcbiAgICB0aGlzLnN0YXJ0ID0gY29tcG9uZW50cy5zdGFydCh0aGlzKVxuICAgIHRoaXMuc3RvcCA9IGNvbXBvbmVudHMuc3RvcCh0aGlzKVxuICAgIHRoaXMuc2h1dGRvd24gPSB0aGlzLnN0b3BcbiAgICB0aGlzLmlzT25saW5lID0gY29tcG9uZW50cy5pc09ubGluZSh0aGlzKVxuICAgIC8vICAgLSBpbnRlcmZhY2UtaXBmcy1jb3JlIGRlZmluZWQgQVBJXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb21wb25lbnRzLmZpbGVzUmVndWxhcih0aGlzKSlcbiAgICB0aGlzLnZlcnNpb24gPSBjb21wb25lbnRzLnZlcnNpb24odGhpcylcbiAgICB0aGlzLmlkID0gY29tcG9uZW50cy5pZCh0aGlzKVxuICAgIHRoaXMucmVwbyA9IGNvbXBvbmVudHMucmVwbyh0aGlzKVxuICAgIHRoaXMuYm9vdHN0cmFwID0gY29tcG9uZW50cy5ib290c3RyYXAodGhpcylcbiAgICB0aGlzLmNvbmZpZyA9IGNvbXBvbmVudHMuY29uZmlnKHRoaXMpXG4gICAgdGhpcy5ibG9jayA9IGNvbXBvbmVudHMuYmxvY2sodGhpcylcbiAgICB0aGlzLm9iamVjdCA9IGNvbXBvbmVudHMub2JqZWN0KHRoaXMpXG4gICAgdGhpcy5kYWcgPSBjb21wb25lbnRzLmRhZyh0aGlzKVxuICAgIHRoaXMuZmlsZXMgPSBjb21wb25lbnRzLmZpbGVzTUZTKHRoaXMpXG4gICAgdGhpcy5saWJwMnAgPSBudWxsIC8vIGFzc2lnbmVkIG9uIHN0YXJ0XG4gICAgdGhpcy5zd2FybSA9IGNvbXBvbmVudHMuc3dhcm0odGhpcylcbiAgICB0aGlzLm5hbWUgPSBjb21wb25lbnRzLm5hbWUodGhpcylcbiAgICB0aGlzLmJpdHN3YXAgPSBjb21wb25lbnRzLmJpdHN3YXAodGhpcylcbiAgICB0aGlzLnBpbiA9IGNvbXBvbmVudHMucGluKHRoaXMpXG4gICAgdGhpcy5waW5nID0gY29tcG9uZW50cy5waW5nKHRoaXMpXG4gICAgdGhpcy5waW5nUHVsbFN0cmVhbSA9IGNvbXBvbmVudHMucGluZ1B1bGxTdHJlYW0odGhpcylcbiAgICB0aGlzLnBpbmdSZWFkYWJsZVN0cmVhbSA9IGNvbXBvbmVudHMucGluZ1JlYWRhYmxlU3RyZWFtKHRoaXMpXG4gICAgdGhpcy5wdWJzdWIgPSBjb21wb25lbnRzLnB1YnN1Yih0aGlzKVxuICAgIHRoaXMuZGh0ID0gY29tcG9uZW50cy5kaHQodGhpcylcbiAgICB0aGlzLmRucyA9IGNvbXBvbmVudHMuZG5zKHRoaXMpXG4gICAgdGhpcy5rZXkgPSBjb21wb25lbnRzLmtleSh0aGlzKVxuICAgIHRoaXMuc3RhdHMgPSBjb21wb25lbnRzLnN0YXRzKHRoaXMpXG4gICAgdGhpcy5yZXNvbHZlID0gY29tcG9uZW50cy5yZXNvbHZlKHRoaXMpXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViKSB7XG4gICAgICB0aGlzLmxvZygnRVhQRVJJTUVOVEFMIHB1YnN1YiBpcyBlbmFibGVkJylcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuRVhQRVJJTUVOVEFMLmlwbnNQdWJzdWIpIHtcbiAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViKSB7XG4gICAgICAgIHRoaXMubG9nKCdFWFBFUklNRU5UQUwgcHVic3ViIGlzIGVuYWJsZWQgdG8gdXNlIElQTlMgcHVic3ViJylcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5FWFBFUklNRU5UQUwucHVic3ViID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZygnRVhQRVJJTUVOVEFMIElQTlMgcHVic3ViIGlzIGVuYWJsZWQnKVxuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5FWFBFUklNRU5UQUwuc2hhcmRpbmcpIHtcbiAgICAgIHRoaXMubG9nKCdFWFBFUklNRU5UQUwgc2hhcmRpbmcgaXMgZW5hYmxlZCcpXG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKSh0aGlzKVxuXG4gICAgYm9vdCh0aGlzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSVBGU1xuXG4vLyBOb3RlOiBXZSBuZWVkIHRvIGRvIHRoaXMgdG8gZm9yY2UgYnJvd3NlcmlmeSB0byBsb2FkIHRoZSBCdWZmZXIgbW9kdWxlXG5jb25zdCBCdWZmZXJJbXBsID0gQnVmZmVyXG5PYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCB7IGNyeXB0bywgaXNJUEZTLCBCdWZmZXI6IEJ1ZmZlckltcGwsIENJRCwgbXVsdGlhZGRyLCBtdWx0aWJhc2UsIG11bHRpaGFzaCwgbXVsdGloYXNoaW5nLCBtdWx0aWNvZGVjLCBQZWVySWQsIFBlZXJJbmZvIH0pXG5cbm1vZHVsZS5leHBvcnRzLmNyZWF0ZU5vZGUgPSAob3B0aW9ucykgPT4ge1xuICByZXR1cm4gbmV3IElQRlMob3B0aW9ucylcbn1cbiIsImltcG9ydCBhZGRFdGhlcmV1bUNoYWluIGZyb20gJy4vYWRkLWV0aGVyZXVtLWNoYWluJztcbmltcG9ydCBldGhBY2NvdW50cyBmcm9tICcuL2V0aC1hY2NvdW50cyc7XG5pbXBvcnQgZ2V0UHJvdmlkZXJTdGF0ZSBmcm9tICcuL2dldC1wcm92aWRlci1zdGF0ZSc7XG5pbXBvcnQgbG9nV2ViM1NoaW1Vc2FnZSBmcm9tICcuL2xvZy13ZWIzLXNoaW0tdXNhZ2UnO1xuaW1wb3J0IHJlcXVlc3RBY2NvdW50cyBmcm9tICcuL3JlcXVlc3QtYWNjb3VudHMnO1xuaW1wb3J0IHNlbmRNZXRhZGF0YSBmcm9tICcuL3NlbmQtbWV0YWRhdGEnO1xuaW1wb3J0IHN3aXRjaEV0aGVyZXVtQ2hhaW4gZnJvbSAnLi9zd2l0Y2gtZXRoZXJldW0tY2hhaW4nO1xuaW1wb3J0IHdhdGNoQXNzZXQgZnJvbSAnLi93YXRjaC1hc3NldCc7XG5cbmNvbnN0IGhhbmRsZXJzID0gW1xuICBhZGRFdGhlcmV1bUNoYWluLFxuICBldGhBY2NvdW50cyxcbiAgZ2V0UHJvdmlkZXJTdGF0ZSxcbiAgbG9nV2ViM1NoaW1Vc2FnZSxcbiAgcmVxdWVzdEFjY291bnRzLFxuICBzZW5kTWV0YWRhdGEsXG4gIHN3aXRjaEV0aGVyZXVtQ2hhaW4sXG4gIHdhdGNoQXNzZXQsXG5dO1xuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VsZWN0SG9va3MgPSBleHBvcnRzLnJlc3RyaWN0ZWRNZXRob2RCdWlsZGVycyA9IGV4cG9ydHMucGVybWl0dGVkTWV0aG9kcyA9IHZvaWQgMDtcbnZhciBwZXJtaXR0ZWRfMSA9IHJlcXVpcmUoXCIuL3Blcm1pdHRlZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBlcm1pdHRlZE1ldGhvZHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcm1pdHRlZF8xLmhhbmRsZXJzOyB9IH0pO1xudmFyIHJlc3RyaWN0ZWRfMSA9IHJlcXVpcmUoXCIuL3Jlc3RyaWN0ZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXN0cmljdGVkTWV0aG9kQnVpbGRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3RyaWN0ZWRfMS5idWlsZGVyczsgfSB9KTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxlY3RIb29rc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5zZWxlY3RIb29rczsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTcgSm9hY2hpbSBXZXN0ZXJcbiAqIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNPd25Qcm9wZXJ0eVwiLCB7IHZhbHVlOiBoYXNPd25Qcm9wZXJ0eSB9KTtcbmZ1bmN0aW9uIF9vYmplY3RLZXlzKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGtleXMgPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAga2V5c1trXSA9IFwiXCIgKyBrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgaSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmV4cG9ydHMuX29iamVjdEtleXMgPSBfb2JqZWN0S2V5cztcbjtcbi8qKlxuKiBEZWVwbHkgY2xvbmUgdGhlIG9iamVjdC5cbiogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiogQHBhcmFtICB7YW55fSBvYmogdmFsdWUgdG8gY2xvbmVcbiogQHJldHVybiB7YW55fSBjbG9uZWQgb2JqXG4qL1xuZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7IC8vRmFzdGVyIHRoYW4gRVM1IGNsb25lIC0gaHR0cDovL2pzcGVyZi5jb20vZGVlcC1jbG9uaW5nLW9mLW9iamVjdHMvNVxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy90aGlzIGlzIGhvdyBKU09OLnN0cmluZ2lmeSBiZWhhdmVzIGZvciBhcnJheSBpdGVtc1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iajsgLy9ubyBuZWVkIHRvIGNsb25lIHByaW1pdGl2ZXNcbiAgICB9XG59XG5leHBvcnRzLl9kZWVwQ2xvbmUgPSBfZGVlcENsb25lO1xuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5mdW5jdGlvbiBpc0ludGVnZXIoc3RyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbi8qKlxuKiBFc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcbiogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4qIEByZXR1cm4gdGhlIEVzY2FwZWQgcGF0aFxuKi9cbmZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKCd+JykgPT09IC0xKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbmV4cG9ydHMuZXNjYXBlUGF0aENvbXBvbmVudCA9IGVzY2FwZVBhdGhDb21wb25lbnQ7XG4vKipcbiAqIFVuZXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXG4gKiBAcGFyYW0gcGF0aCBUaGUgZXNjYXBlZCBwb2ludGVyXG4gKiBAcmV0dXJuIFRoZSB1bmVzY2FwZWQgcGF0aFxuICovXG5mdW5jdGlvbiB1bmVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gdW5lc2NhcGVQYXRoQ29tcG9uZW50O1xuZnVuY3Rpb24gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKSB7XG4gICAgdmFyIGZvdW5kO1xuICAgIGZvciAodmFyIGtleSBpbiByb290KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShyb290LCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAocm9vdFtrZXldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJvb3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArICcvJyArIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5leHBvcnRzLl9nZXRQYXRoUmVjdXJzaXZlID0gX2dldFBhdGhSZWN1cnNpdmU7XG5mdW5jdGlvbiBnZXRQYXRoKHJvb3QsIG9iaikge1xuICAgIGlmIChyb290ID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9XG4gICAgdmFyIHBhdGggPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopO1xuICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3Qgbm90IGZvdW5kIGluIHJvb3RcIik7XG4gICAgfVxuICAgIHJldHVybiAnLycgKyBwYXRoO1xufVxuZXhwb3J0cy5nZXRQYXRoID0gZ2V0UGF0aDtcbi8qKlxuKiBSZWN1cnNpdmVseSBjaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaGFzIGFueSB1bmRlZmluZWQgdmFsdWVzIGluc2lkZS5cbiovXG5mdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcbiAgICAgICAgICAgIHZhciBvYmpLZXlzTGVuZ3RoID0gb2JqS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW29iaktleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNVbmRlZmluZWQgPSBoYXNVbmRlZmluZWQ7XG5mdW5jdGlvbiBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCBhcmdzKSB7XG4gICAgdmFyIG1lc3NhZ2VQYXJ0cyA9IFttZXNzYWdlXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXJncykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYXJnc1trZXldID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGFyZ3Nba2V5XSwgbnVsbCwgMikgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goa2V5ICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbignXFxuJyk7XG59XG52YXIgUGF0Y2hFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGF0Y2hFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXRjaEVycm9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXRjaEVycm9yTWVzc2FnZUZvcm1hdHRlcihtZXNzYWdlLCB7IG5hbWU6IG5hbWUsIGluZGV4OiBpbmRleCwgb3BlcmF0aW9uOiBvcGVyYXRpb24sIHRyZWU6IHRyZWUgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBvcGVyYXRpb246IG9wZXJhdGlvbiwgdHJlZTogdHJlZSB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGF0Y2hFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG4iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJlRXF1YWxzID0gcmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyk7XG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzXzEuUGF0Y2hFcnJvcjtcbmV4cG9ydHMuZGVlcENsb25lID0gaGVscGVyc18xLl9kZWVwQ2xvbmU7XG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxuIGZ1bmN0aW9uLiBFYWNoIGhhc2ggZW50cnkgKHByb3BlcnR5KSB1c2VzXG4gdGhlIG9wZXJhdGlvbiBpZGVudGlmaWVycyBzcGVjaWZpZWQgaW4gcmZjNjkwMi5cbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxuIHRvIGl0cyBkZWRpY2F0ZWQgZnVuY3Rpb24gaW4gZWZmaWNpZW50IHdheS5cbiAqL1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cbnZhciBvYmpPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICB9LFxuICAgIG1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgLyogaW4gY2FzZSBtb3ZlIHRhcmdldCBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHZhbHVlLFxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxuICAgICAgICBhbmQgaXMgcG90ZW50aWFsbHkgdW5uZWVkZWQgKi9cbiAgICAgICAgdmFyIHJlbW92ZWQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiB0aGlzLmZyb20gfSkucmVtb3ZlZDtcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHRoaXMucGF0aCwgdmFsdWU6IG9yaWdpbmFsVmFsdWUgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgdmFsdWVUb0NvcHkgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgdGhpcy5mcm9tKTtcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcbiAgICAgICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHRoaXMucGF0aCwgdmFsdWU6IGhlbHBlcnNfMS5fZGVlcENsb25lKHZhbHVlVG9Db3B5KSB9KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgdGVzdDogYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH1cbn07XG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIGFycmF5LiBNYW55IGFyZSB0aGUgc2FtZSBhcyBmb3IgdGhlIG9iamVjdCAqL1xudmFyIGFyck9wcyA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChoZWxwZXJzXzEuaXNJbnRlZ2VyKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBhcnJheSBwcm9wc1xuICAgICAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIG1heSBiZSBuZWVkZWQgd2hlbiB1c2luZyAnLScgaW4gYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCBpbmRleDogaSB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZExpc3QgPSBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWRMaXN0WzBdIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGFycltpXTtcbiAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBvYmpPcHMubW92ZSxcbiAgICBjb3B5OiBvYmpPcHMuY29weSxcbiAgICB0ZXN0OiBvYmpPcHMudGVzdCxcbiAgICBfZ2V0OiBvYmpPcHMuX2dldFxufTtcbi8qKlxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxuICogQHBhcmFtIHBvaW50ZXIgYW4gZXNjYXBlZCBKU09OIHBvaW50ZXJcbiAqIEByZXR1cm4gVGhlIHJldHJpZXZlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09ICcnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgdmFyIGdldE9yaWdpbmFsRGVzdGluYXRpb24gPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogcG9pbnRlciB9O1xuICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBnZXRPcmlnaW5hbERlc3RpbmF0aW9uKTtcbiAgICByZXR1cm4gZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbi52YWx1ZTtcbn1cbmV4cG9ydHMuZ2V0VmFsdWVCeVBvaW50ZXIgPSBnZXRWYWx1ZUJ5UG9pbnRlcjtcbi8qKlxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBvcGVyYXRpb24uXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBhbmQgYG9wZXJhdGlvbmAgb2JqZWN0cyAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKG9wZXJhdGlvbikpYC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHBhdGNoXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50LCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zLCBpbmRleCkge1xuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiA9PT0gdm9pZCAwKSB7IHZhbGlkYXRlT3BlcmF0aW9uID0gZmFsc2U7IH1cbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cbiAgICBpZiAoYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9PT0gdm9pZCAwKSB7IGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPSB0cnVlOyB9XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAwOyB9XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgb3BlcmF0aW9uLnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdG9yKG9wZXJhdGlvbiwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogUk9PVCBPUEVSQVRJT05TICovXG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoID09PSBcIlwiKSB7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50IH07XG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG9wZXJhdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSB7IC8vIGl0J3MgYSBtb3ZlIG9yIGNvcHkgdG8gcm9vdFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgb3BlcmF0aW9uLmZyb20pOyAvLyBnZXQgdGhlIHZhbHVlIGJ5IGpzb24tcG9pbnRlciBpbiBgZnJvbWAgZmllbGRcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJykgeyAvLyByZXBvcnQgcmVtb3ZlZCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS50ZXN0ID0gYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVtb3ZlJykgeyAvLyBhIHJlbW92ZSBvbiByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvKiBiYWQgb3BlcmF0aW9uICovXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBvcGAgcHJvcGVydHkgaXMgbm90IG9uZSBvZiBvcGVyYXRpb25zIGRlZmluZWQgaW4gUkZDLTY5MDInLCAnT1BFUkFUSU9OX09QX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8qIEVORCBST09UIE9QRVJBVElPTlMgKi9cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFtdXRhdGVEb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSBoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50O1xuICAgICAgICB2YXIgdCA9IDE7IC8vc2tpcCBlbXB0eSBlbGVtZW50IC0gaHR0cDovL2pzcGVyZi5jb20vdG8tc2hpZnQtb3Itbm90LXRvLXNoaWZ0XG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgICB2YXIgdmFsaWRhdGVGdW5jdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgJiYga2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSlNPTi1QYXRjaDogbW9kaWZ5aW5nIGBfX3Byb3RvX19gIHByb3AgaXMgYmFubmVkIGZvciBzZWN1cml0eSByZWFzb25zLCBpZiB0aGlzIHdhcyBvbiBwdXJwb3NlLCBwbGVhc2Ugc2V0IGBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zYCBmbGFnIGZhbHNlIGFuZCBwYXNzIGl0IHRvIHRoaXMgZnVuY3Rpb24uIE1vcmUgaW5mbyBpbiBmYXN0LWpzb24tcGF0Y2ggUkVBRE1FJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gb3BlcmF0aW9uLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgZXhpc3RpbmdQYXRoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCsrO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uICYmICFoZWxwZXJzXzEuaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBvbmx5IHBhcnNlIGtleSB3aGVuIGl0J3MgYW4gaW50ZWdlciBmb3IgYGFyci5wcm9wYCB0byB3b3JrXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlbHBlcnNfMS5pc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gfn5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUaGUgc3BlY2lmaWVkIGluZGV4IE1VU1QgTk9UIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVwiLCBcIk9QRVJBVElPTl9WQUxVRV9PVVRfT0ZfQk9VTkRTXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCd+JykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaGVscGVyc18xLnVuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gb2JqT3BzW29wZXJhdGlvbi5vcF0uY2FsbChvcGVyYXRpb24sIG9iaiwga2V5LCBkb2N1bWVudCk7IC8vIEFwcGx5IHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZS50ZXN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFwcGx5T3BlcmF0aW9uID0gYXBwbHlPcGVyYXRpb247XG4vKipcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHtuZXdEb2N1bWVudCwgcmVzdWx0fSBvZiB0aGUgcGF0Y2guXG4gKiBJdCBtb2RpZmllcyB0aGUgYGRvY3VtZW50YCBvYmplY3QgYW5kIGBwYXRjaGAgLSBpdCBnZXRzIHRoZSB2YWx1ZXMgYnkgcmVmZXJlbmNlLlxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XG4gKiBganNvbnBhdGNoLmFwcGx5UGF0Y2goZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKHBhdGNoKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBwYXRjaCBUaGUgcGF0Y2ggdG8gYXBwbHlcbiAqIEBwYXJhbSB2YWxpZGF0ZU9wZXJhdGlvbiBgZmFsc2VgIGlzIHdpdGhvdXQgdmFsaWRhdGlvbiwgYHRydWVgIHRvIHVzZSBkZWZhdWx0IGpzb25wYXRjaCdzIHZhbGlkYXRpb24sIG9yIHlvdSBjYW4gcGFzcyBhIGB2YWxpZGF0ZU9wZXJhdGlvbmAgY2FsbGJhY2sgdG8gYmUgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXG4gKiBAcGFyYW0gYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyBXaGV0aGVyIHRvIGJhbiBtb2RpZmljYXRpb25zIHRvIGBfX3Byb3RvX19gLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBwYXRjaFxuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50LCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zKSB7XG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XG4gICAgaWYgKGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnMgPT09IHZvaWQgMCkgeyBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZTsgfVxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gaGVscGVyc18xLl9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwYXRjaC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxuICogU3VpdGFibGUgYXMgYSByZWR1Y2VyLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHJldHVybiBUaGUgdXBkYXRlZCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICB2YXIgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XG4gICAgaWYgKG9wZXJhdGlvblJlc3VsdC50ZXN0ID09PSBmYWxzZSkgeyAvLyBmYWlsZWQgdGVzdFxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0Lm5ld0RvY3VtZW50O1xufVxuZXhwb3J0cy5hcHBseVJlZHVjZXIgPSBhcHBseVJlZHVjZXI7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gIT09ICdvYmplY3QnIHx8IG9wZXJhdGlvbiA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBpcyBub3QgYW4gb2JqZWN0JywgJ09QRVJBVElPTl9OT1RfQU5fT0JKRUNUJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqT3BzW29wZXJhdGlvbi5vcF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgb3BgIHByb3BlcnR5IGlzIG5vdCBvbmUgb2Ygb3BlcmF0aW9ucyBkZWZpbmVkIGluIFJGQy02OTAyJywgJ09QRVJBVElPTl9PUF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3BlcmF0aW9uLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHBhdGhgIHByb3BlcnR5IGlzIG5vdCBhIHN0cmluZycsICdPUEVSQVRJT05fUEFUSF9JTlZBTElEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5pbmRleE9mKCcvJykgIT09IDAgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYXRocyB0aGF0IGFyZW4ndCBlbXB0eSBzdHJpbmcgc2hvdWxkIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdjb3B5JykgJiYgdHlwZW9mIG9wZXJhdGlvbi5mcm9tICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fRlJPTV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnYWRkJyB8fCBvcGVyYXRpb24ub3AgPT09ICdyZXBsYWNlJyB8fCBvcGVyYXRpb24ub3AgPT09ICd0ZXN0JykgJiYgaGVscGVyc18xLmhhc1VuZGVmaW5lZChvcGVyYXRpb24udmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSBhbiBgYWRkYCBvcGVyYXRpb24gYXQgdGhlIGRlc2lyZWQgcGF0aCcsICdPUEVSQVRJT05fUEFUSF9DQU5OT1RfQUREJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnX2dldCcpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucGF0aCAhPT0gZXhpc3RpbmdQYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IG9wZXJhdGlvbi5mcm9tLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdDYW5ub3QgcGVyZm9ybSB0aGUgb3BlcmF0aW9uIGZyb20gYSBwYXRoIHRoYXQgZG9lcyBub3QgZXhpc3QnLCAnT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNlcXVlbmNlIG9mIG9wZXJhdGlvbnMuIElmIGBkb2N1bWVudGAgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGUgc2VxdWVuY2UgaXMgYWRkaXRpb25hbGx5IHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBvYmplY3QgZG9jdW1lbnQuXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxuICogQHBhcmFtIHNlcXVlbmNlXG4gKiBAcGFyYW0gZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheScsICdTRVFVRU5DRV9OT1RfQU5fQVJSQVknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vY2xvbmUgZG9jdW1lbnQgYW5kIHNlcXVlbmNlIHNvIHRoYXQgd2UgY2FuIHNhZmVseSB0cnkgYXBwbHlpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgYXBwbHlQYXRjaChoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCksIGhlbHBlcnNfMS5fZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBleHBvcnRzLkpzb25QYXRjaEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBKc29uUGF0Y2hFcnJvcjogZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcixcbiAgICBkZWVwQ2xvbmU6IGV4cG9ydHMuZGVlcENsb25lLFxuICAgIGdldFZhbHVlQnlQb2ludGVyOiBnZXRWYWx1ZUJ5UG9pbnRlcixcbiAgICBhcHBseU9wZXJhdGlvbjogYXBwbHlPcGVyYXRpb24sXG4gICAgYXBwbHlQYXRjaDogYXBwbHlQYXRjaCxcbiAgICBhcHBseVJlZHVjZXI6IGFwcGx5UmVkdWNlcixcbiAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgbWggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpXG5jb25zdCBtdWx0aWJhc2UgPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuY29uc3QgQ0lEVXRpbCA9IHJlcXVpcmUoJy4vY2lkLXV0aWwnKVxuY29uc3QgdWludDhBcnJheUNvbmNhdCA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5jb25zdCB1aW50OEFycmF5VG9TdHJpbmcgPSByZXF1aXJlKCd1aW50OGFycmF5cy90by1zdHJpbmcnKVxuY29uc3QgdWludDhBcnJheUVxdWFscyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2VxdWFscycpXG5cbmNvbnN0IGNvZGVjcyA9IG11bHRpY29kZWMubmFtZVRvQ29kZVxuY29uc3QgY29kZWNJbnRzID0gLyoqIEB0eXBlIHtDb2RlY05hbWVbXX0gKi8oT2JqZWN0LmtleXMoY29kZWNzKSkucmVkdWNlKChwLCBuYW1lKSA9PiB7XG4gIHBbY29kZWNzW25hbWVdXSA9IG5hbWVcbiAgcmV0dXJuIHBcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPENvZGVjQ29kZSwgQ29kZWNOYW1lPn0gKi8oe30pKVxuXG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKCdAaXBsZC9qcy1jaWQvQ0lEJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZXJpYWxpemVkQ0lEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29kZWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGhhc2hcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiB7MHwxfSBDSURWZXJzaW9uXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnbXVsdGliYXNlJykuQmFzZU5hbWVPckNvZGV9IEJhc2VOYW1lT3JDb2RlXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnbXVsdGljb2RlYycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnbXVsdGljb2RlYycpLkNvZGVjQ29kZX0gQ29kZWNDb2RlXG4gKi9cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBDSUQgYDxtYmFzZT48dmVyc2lvbj48bWNvZGVjPjxtaGFzaD5gXG4gKiAsIGFzIGRlZmluZWQgaW4gW2lwbGQvY2lkXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL2NpZCkuXG4gKlxuICogQGNsYXNzIENJRFxuICovXG5jbGFzcyBDSUQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IENJRC5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBmb3IgYXJndW1lbnQgaW5wdXQgaXMgcm91Z2hseTpcbiAgICogYGBgXG4gICAqIGlmIChjaWQpXG4gICAqICAgLT4gY3JlYXRlIGEgY29weVxuICAgKiBlbHNlIGlmIChzdHIpXG4gICAqICAgaWYgKDFzdCBjaGFyIGlzIG9uIG11bHRpYmFzZSB0YWJsZSkgLT4gQ0lEIFN0cmluZ1xuICAgKiAgIGVsc2UgLT4gYnM1OCBlbmNvZGVkIG11bHRpaGFzaFxuICAgKiBlbHNlIGlmIChVaW50OEFycmF5KVxuICAgKiAgIGlmICgxc3QgYnl0ZSBpcyAwIG9yIDEpIC0+IENJRFxuICAgKiAgIGVsc2UgLT4gbXVsdGloYXNoXG4gICAqIGVsc2UgaWYgKE51bWJlcilcbiAgICogICAtPiBjb25zdHJ1Y3QgQ0lEIGJ5IHBhcnRzXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0NJRFZlcnNpb24gfCBzdHJpbmcgfCBVaW50OEFycmF5IHwgQ0lEfSB2ZXJzaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2NvZGVjXVxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFttdWx0aWhhc2hdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbXVsdGliYXNlTmFtZV1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IENJRCg8dmVyc2lvbj4sIDxjb2RlYz4sIDxtdWx0aWhhc2g+LCA8bXVsdGliYXNlTmFtZT4pXG4gICAqIG5ldyBDSUQoPGNpZFN0cj4pXG4gICAqIG5ldyBDSUQoPGNpZC5ieXRlcz4pXG4gICAqIG5ldyBDSUQoPG11bHRpaGFzaD4pXG4gICAqIG5ldyBDSUQoPGJzNTggZW5jb2RlZCBtdWx0aWhhc2g+KVxuICAgKiBuZXcgQ0lEKDxjaWQ+KVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHZlcnNpb24sIGNvZGVjLCBtdWx0aWhhc2gsIG11bHRpYmFzZU5hbWUpIHtcbiAgICAvLyBXZSBoYXZlIGJlbG93IHRocmVlIGJsYW5rIGZpZWxkIGFjY2Vzc29ycyBvbmx5IGJlY2F1c2VcbiAgICAvLyBvdGhlcndpc2UgVFMgd2lsbCBub3QgcGljayB0aGVtIHVwIGlmIGRvbmUgYWZ0ZXIgYXNzaWduZW1udHNcblxuICAgIC8qKlxuICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBDSUQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q0lEVmVyc2lvbn1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgdGhpcy52ZXJzaW9uXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZWMgb2YgdGhlIENJRC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHR5cGUge0NvZGVjTmFtZX1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgdGhpcy5jb2RlY1xuXG4gICAgLyoqXG4gICAgICogVGhlIG11bHRpaGFzaCBvZiB0aGUgQ0lELlxuICAgICAqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgIHRoaXMubXVsdGloYXNoXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sLCB7IHZhbHVlOiB0cnVlIH0pXG4gICAgaWYgKENJRC5pc0NJRCh2ZXJzaW9uKSkge1xuICAgICAgLy8gdmVyc2lvbiBpcyBhbiBleGlzaW5nIENJRCBpbnN0YW5jZVxuICAgICAgY29uc3QgY2lkID0gLyoqIEB0eXBlIHtDSUR9ICovKHZlcnNpb24pXG4gICAgICB0aGlzLnZlcnNpb24gPSBjaWQudmVyc2lvblxuICAgICAgdGhpcy5jb2RlYyA9IGNpZC5jb2RlY1xuICAgICAgdGhpcy5tdWx0aWhhc2ggPSBjaWQubXVsdGloYXNoXG4gICAgICAvLyBEZWZhdWx0IGd1YXJkIGZvciB3aGVuIGEgQ0lEIDwgMC43IGlzIHBhc3NlZCB3aXRoIG5vIG11bHRpYmFzZU5hbWVcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9IGNpZC5tdWx0aWJhc2VOYW1lIHx8IChjaWQudmVyc2lvbiA9PT0gMCA/ICdiYXNlNThidGMnIDogJ2Jhc2UzMicpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlLmcuICdiYXNlMzInIG9yIGZhbHNlXG4gICAgICBjb25zdCBiYXNlTmFtZSA9IG11bHRpYmFzZS5pc0VuY29kZWQodmVyc2lvbilcbiAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgQ0lEIFN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlLCBzbyB2MVxuICAgICAgICBjb25zdCBjaWQgPSBtdWx0aWJhc2UuZGVjb2RlKHZlcnNpb24pXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IC8qKiBAdHlwZSB7Q0lEVmVyc2lvbn0gKi8ocGFyc2VJbnQoY2lkWzBdLnRvU3RyaW5nKCksIDE2KSlcbiAgICAgICAgdGhpcy5jb2RlYyA9IG11bHRpY29kZWMuZ2V0Q29kZWMoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG11bHRpY29kZWMucm1QcmVmaXgoY2lkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLm11bHRpYmFzZU5hbWUgPSBiYXNlTmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIGJhc2U1OGJ0YyBzdHJpbmcgbXVsdGloYXNoLCBzbyB2MFxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXG4gICAgICAgIHRoaXMuY29kZWMgPSAnZGFnLXBiJ1xuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IG1oLmZyb21CNThTdHJpbmcodmVyc2lvbilcbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2U1OGJ0YydcbiAgICAgIH1cbiAgICAgIENJRC52YWxpZGF0ZUNJRCh0aGlzKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdHJpbmcnLCB7IHZhbHVlOiB2ZXJzaW9uIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUludCh2ZXJzaW9uWzBdLnRvU3RyaW5nKCksIDE2KVxuICAgICAgaWYgKHYgPT09IDEpIHtcbiAgICAgICAgLy8gdmVyc2lvbiBpcyBhIENJRCBVaW50OEFycmF5XG4gICAgICAgIGNvbnN0IGNpZCA9IHZlcnNpb25cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdlxuICAgICAgICB0aGlzLmNvZGVjID0gbXVsdGljb2RlYy5nZXRDb2RlYyhjaWQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMubXVsdGloYXNoID0gbXVsdGljb2RlYy5ybVByZWZpeChjaWQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMubXVsdGliYXNlTmFtZSA9ICdiYXNlMzInXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2ZXJzaW9uIGlzIGEgcmF3IG11bHRpaGFzaCBVaW50OEFycmF5LCBzbyB2MFxuICAgICAgICB0aGlzLnZlcnNpb24gPSAwXG4gICAgICAgIHRoaXMuY29kZWMgPSAnZGFnLXBiJ1xuICAgICAgICB0aGlzLm11bHRpaGFzaCA9IHZlcnNpb25cbiAgICAgICAgdGhpcy5tdWx0aWJhc2VOYW1lID0gJ2Jhc2U1OGJ0YydcbiAgICAgIH1cbiAgICAgIENJRC52YWxpZGF0ZUNJRCh0aGlzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBhc3NlbWJsZSB0aGUgQ0lEIGZyb20gdGhlIHBhcmFtZXRlcnNcblxuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb25cblxuICAgIGlmICh0eXBlb2YgY29kZWMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb2RlYyA9IGNvZGVjSW50c1tjb2RlY11cbiAgICB9XG5cbiAgICB0aGlzLmNvZGVjID0gLyoqIEB0eXBlIHtDb2RlY05hbWV9ICovIChjb2RlYylcblxuICAgIHRoaXMubXVsdGloYXNoID0gLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAobXVsdGloYXNoKVxuXG4gICAgLyoqXG4gICAgICogTXVsdGliYXNlIG5hbWUgYXMgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubXVsdGliYXNlTmFtZSA9IG11bHRpYmFzZU5hbWUgfHwgKHZlcnNpb24gPT09IDAgPyAnYmFzZTU4YnRjJyA6ICdiYXNlMzInKVxuXG4gICAgQ0lELnZhbGlkYXRlQ0lEKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVGhlIENJRCBhcyBhIGBVaW50OEFycmF5YFxuICAgKlxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICpcbiAgICovXG4gIGdldCBieXRlcyAoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGxldCBieXRlcyA9IHRoaXMuX2J5dGVzXG5cbiAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG4gICAgICAgIGJ5dGVzID0gdGhpcy5tdWx0aWhhc2hcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52ZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gbXVsdGljb2RlYy5nZXRDb2RlVmFyaW50KHRoaXMuY29kZWMpXG4gICAgICAgIGJ5dGVzID0gdWludDhBcnJheUNvbmNhdChbXG4gICAgICAgICAgWzFdLCBjb2RlYywgdGhpcy5tdWx0aWhhc2hcbiAgICAgICAgXSwgMSArIGNvZGVjLmJ5dGVMZW5ndGggKyB0aGlzLm11bHRpaGFzaC5ieXRlTGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCB2ZXJzaW9uJylcbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgdGhpcyBVaW50OEFycmF5IHNvIGl0IGRvZXNuJ3QgaGF2ZSB0byBiZSByZWNyZWF0ZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2J5dGVzJywgeyB2YWx1ZTogYnl0ZXMgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IG9mIHRoZSBDSUQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZ2V0IHByZWZpeCAoKSB7XG4gICAgY29uc3QgY29kZWMgPSBtdWx0aWNvZGVjLmdldENvZGVWYXJpbnQodGhpcy5jb2RlYylcbiAgICBjb25zdCBtdWx0aWhhc2ggPSBtaC5wcmVmaXgodGhpcy5tdWx0aWhhc2gpXG4gICAgY29uc3QgcHJlZml4ID0gdWludDhBcnJheUNvbmNhdChbXG4gICAgICBbdGhpcy52ZXJzaW9uXSwgY29kZWMsIG11bHRpaGFzaFxuICAgIF0sIDEgKyBjb2RlYy5ieXRlTGVuZ3RoICsgbXVsdGloYXNoLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gcHJlZml4XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvZGVjIG9mIHRoZSBDSUQgaW4gaXRzIG51bWJlciBmb3JtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29kZWNDb2RlfVxuICAgKi9cbiAgZ2V0IGNvZGUgKCkge1xuICAgIHJldHVybiBjb2RlY3NbdGhpcy5jb2RlY11cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgQ0lEIG9mIHZlcnNpb24gYDBgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q0lEfVxuICAgKi9cbiAgdG9WMCAoKSB7XG4gICAgaWYgKHRoaXMuY29kZWMgIT09ICdkYWctcGInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgbm9uIGRhZy1wYiBDSUQgdG8gQ0lEdjAnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgbmFtZSwgbGVuZ3RoIH0gPSBtaC5kZWNvZGUodGhpcy5tdWx0aWhhc2gpXG5cbiAgICBpZiAobmFtZSAhPT0gJ3NoYTItMjU2Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCBub24gc2hhMi0yNTYgbXVsdGloYXNoIENJRCB0byBDSUR2MCcpXG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCAhPT0gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgbm9uIDMyIGJ5dGUgbXVsdGloYXNoIENJRCB0byBDSUR2MCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDSUQoMCwgdGhpcy5jb2RlYywgdGhpcy5tdWx0aWhhc2gpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIENJRCBvZiB2ZXJzaW9uIGAxYC5cbiAgICpcbiAgICogQHJldHVybnMge0NJRH1cbiAgICovXG4gIHRvVjEgKCkge1xuICAgIHJldHVybiBuZXcgQ0lEKDEsIHRoaXMuY29kZWMsIHRoaXMubXVsdGloYXNoLCB0aGlzLm11bHRpYmFzZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIHRoZSBDSUQgaW50byBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gW2Jhc2U9dGhpcy5tdWx0aWJhc2VOYW1lXSAtIEJhc2UgZW5jb2RpbmcgdG8gdXNlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9CYXNlRW5jb2RlZFN0cmluZyAoYmFzZSA9IHRoaXMubXVsdGliYXNlTmFtZSkge1xuICAgIC8vIEB0cy1pZ25vcmUgbm9uIGVudW1lcmFibGUgY2FjaGUgcHJvcGVydHlcbiAgICBpZiAodGhpcy5zdHJpbmcgJiYgdGhpcy5zdHJpbmcubGVuZ3RoICE9PSAwICYmIGJhc2UgPT09IHRoaXMubXVsdGliYXNlTmFtZSkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBub24gZW51bWVyYWJsZSBjYWNoZSBwcm9wZXJ0eVxuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nXG4gICAgfVxuICAgIGxldCBzdHJcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAwKSB7XG4gICAgICBpZiAoYmFzZSAhPT0gJ2Jhc2U1OGJ0YycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIHdpdGggQ0lEdjAsIHRvIHN1cHBvcnQgZGlmZmVyZW50IGJhc2VzLCBwbGVhc2UgbWlncmF0ZSB0aGUgaW5zdGFuY2UgZG8gQ0lEdjEsIHlvdSBjYW4gZG8gdGhhdCB0aHJvdWdoIGNpZC50b1YxKCknKVxuICAgICAgfVxuICAgICAgc3RyID0gbWgudG9CNThTdHJpbmcodGhpcy5tdWx0aWhhc2gpXG4gICAgfSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPT09IDEpIHtcbiAgICAgIHN0ciA9IHVpbnQ4QXJyYXlUb1N0cmluZyhtdWx0aWJhc2UuZW5jb2RlKGJhc2UsIHRoaXMuYnl0ZXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHZlcnNpb24nKVxuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdGhpcy5tdWx0aWJhc2VOYW1lKSB7XG4gICAgICAvLyBjYWNoZSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0cmluZycsIHsgdmFsdWU6IHN0ciB9KVxuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogQ0lEKFFtZGZUYkJxQlBRN1ZOeFpFWUVqMTRWbVJ1WkJrcUZiaXdSZW9nSmdTMXpSMW4pXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gKCkge1xuICAgIHJldHVybiAnQ0lEKCcgKyB0aGlzLnRvU3RyaW5nKCkgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIENJRCBpbnRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBbYmFzZT10aGlzLm11bHRpYmFzZU5hbWVdIC0gQmFzZSBlbmNvZGluZyB0byB1c2UuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoYmFzZSkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZUVuY29kZWRTdHJpbmcoYmFzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdG8gYSBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXJpYWxpemVkQ0lEfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZWM6IHRoaXMuY29kZWMsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICBoYXNoOiB0aGlzLm11bHRpaGFzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIGVxdWFsaXR5IHdpdGggYW5vdGhlciBDSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q0lEfSBvdGhlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlYyA9PT0gb3RoZXIuY29kZWMgJiZcbiAgICAgIHRoaXMudmVyc2lvbiA9PT0gb3RoZXIudmVyc2lvbiAmJlxuICAgICAgdWludDhBcnJheUVxdWFscyh0aGlzLm11bHRpaGFzaCwgb3RoZXIubXVsdGloYXNoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdpdmVuIGlucHV0IGlzIGEgdmFsaWQgQ0lEIG9iamVjdC5cbiAgICogVGhyb3dzIGlmIGl0IGlzIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG90aGVyIC0gVGhlIG90aGVyIENJRC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVDSUQgKG90aGVyKSB7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBDSURVdGlsLmNoZWNrQ0lEQ29tcG9uZW50cyhvdGhlcilcbiAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqZWN0IGlzIGEgQ0lEIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7dmFsdWUgaXMgQ0lEfVxuICAgKi9cbiAgc3RhdGljIGlzQ0lEICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENJRCB8fCBCb29sZWFuKHZhbHVlICYmIHZhbHVlW3N5bWJvbF0pXG4gIH1cbn1cblxuQ0lELmNvZGVjcyA9IGNvZGVjc1xuXG5tb2R1bGUuZXhwb3J0cyA9IENJRFxuIiwiLyogZXNsaW50IHF1b3RlLXByb3BzOiBvZmYgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuYW1lcyA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnc2hhMSc6IDB4MTEsXG4gICdzaGEyLTI1Nic6IDB4MTIsXG4gICdzaGEyLTUxMic6IDB4MTMsXG4gICdzaGEzLTUxMic6IDB4MTQsXG4gICdzaGEzLTM4NCc6IDB4MTUsXG4gICdzaGEzLTI1Nic6IDB4MTYsXG4gICdzaGEzLTIyNCc6IDB4MTcsXG4gICdzaGFrZS0xMjgnOiAweDE4LFxuICAnc2hha2UtMjU2JzogMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFhLFxuICAna2VjY2FrLTI1Nic6IDB4MWIsXG4gICdrZWNjYWstMzg0JzogMHgxYyxcbiAgJ2tlY2Nhay01MTInOiAweDFkLFxuICAnYmxha2UzJzogMHgxZSxcbiAgJ211cm11cjMtMTI4JzogMHgyMixcbiAgJ211cm11cjMtMzInOiAweDIzLFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ21kNCc6IDB4ZDQsXG4gICdtZDUnOiAweGQ1LFxuICAnYm10JzogMHhkNixcbiAgJ3NoYTItMjU2LXRydW5jMjU0LXBhZGRlZCc6IDB4MTAxMixcbiAgJ3JpcGVtZC0xMjgnOiAweDEwNTIsXG4gICdyaXBlbWQtMTYwJzogMHgxMDUzLFxuICAncmlwZW1kLTI1Nic6IDB4MTA1NCxcbiAgJ3JpcGVtZC0zMjAnOiAweDEwNTUsXG4gICd4MTEnOiAweDExMDAsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbmFtZXMgfVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmV4cG9ydHMuVGV4dEVuY29kZXIgPVxuICB0eXBlb2YgVGV4dEVuY29kZXIgIT09IFwidW5kZWZpbmVkXCIgPyBUZXh0RW5jb2RlciA6IHJlcXVpcmUoXCJ1dGlsXCIpLlRleHRFbmNvZGVyXG5cbmV4cG9ydHMuVGV4dERlY29kZXIgPVxuICB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwidW5kZWZpbmVkXCIgPyBUZXh0RGVjb2RlciA6IHJlcXVpcmUoXCJ1dGlsXCIpLlRleHREZWNvZGVyXG4iLCIvLyBAdHMtY2hlY2tcbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFttdWx0aWJhc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGliYXNlKSBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBtb2R1bGUgTXVsdGliYXNlXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgZGVjb2RlVGV4dCwgYXNCdWZmZXIgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vYmFzZVwiKX0gQmFzZSAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBidWZmZXIgd2l0aCB0aGUgbXVsdGliYXNlIHZhcmludCtjb2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgcHJlZml4ZWQgd2l0aCBtdWx0aWJhc2UuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gbXVsdGliYXNlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgaWYgKCFidWYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGFuIGVuY29kZWQgYnVmZmVyJylcbiAgfVxuICBjb25zdCB7IG5hbWUsIGNvZGVCdWYgfSA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG4gIHZhbGlkRW5jb2RlKG5hbWUsIGJ1ZilcblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoY29kZUJ1Zi5sZW5ndGggKyBidWYubGVuZ3RoKVxuICBidWZmZXIuc2V0KGNvZGVCdWYsIDApXG4gIGJ1ZmZlci5zZXQoYnVmLCBjb2RlQnVmLmxlbmd0aClcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCB0aGUgc3BlY2lmaWVkIGJhc2UgYW5kIGFkZCB0aGUgbXVsdGliYXNlIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuYy5jb2RlQnVmLCBCdWZmZXIuZnJvbShlbmMuZW5jb2RlKGJ1ZikpXSlcbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVpbnQ4QXJyYXkgb3Igc3RyaW5nIGVuY29kZWQgd2l0aCBtdWx0aWJhc2UgaGVhZGVyLCBkZWNvZGVzIGl0IGFuZFxuICogcmV0dXJucyB0aGUgZGVjb2RlZCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSAoZGF0YSkge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuICBjb25zdCBwcmVmaXggPSBkYXRhWzBdXG5cbiAgLy8gTWFrZSBhbGwgZW5jb2RpbmdzIGNhc2UtaW5zZW5zaXRpdmUgZXhjZXB0IHRoZSBvbmVzIHRoYXQgaW5jbHVkZSB1cHBlciBhbmQgbG93ZXIgY2hhcnMgaW4gdGhlIGFscGhhYmV0XG4gIGlmIChbJ2YnLCAnRicsICd2JywgJ1YnLCAndCcsICdUJywgJ2InLCAnQicsICdjJywgJ0MnLCAnaCcsICdrJywgJ0snXS5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKVxuICB9XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKGRhdGFbMF0pXG4gIHJldHVybiBhc0J1ZmZlcihlbmMuZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEpKSlcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0YSBtdWx0aWJhc2UgZW5jb2RlZD9cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7ZmFsc2V8c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpc0VuY29kZWQgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIC8vIEVuc3VyZSBidWZPclN0cmluZyBpcyBhIHN0cmluZ1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlbmMgPSBlbmNvZGluZyhkYXRhWzBdKVxuICAgIHJldHVybiBlbmMubmFtZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiB2YWxpZEVuY29kZSAobmFtZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWUpXG4gIGVuYy5kZWNvZGUoZGVjb2RlVGV4dChidWYpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgZW5jb2RpbmcgYnkgbmFtZSBvciBjb2RlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlXG4gKiBAcmV0dXJucyB7QmFzZX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nIChuYW1lT3JDb2RlKSB7XG4gIGlmIChjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV0pIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLm5hbWVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSBpZiAoY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5jb2Rlc1tuYW1lT3JDb2RlXVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7bmFtZU9yQ29kZX1gKVxuICB9XG59XG5cbi8qKlxuICogR2V0IGVuY29kaW5nIGZyb20gZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmdGcm9tRGF0YSAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5nKGRhdGFbMF0pXG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG11bHRpYmFzZVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGVcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlXG5leHBvcnRzLmlzRW5jb2RlZCA9IGlzRW5jb2RlZFxuZXhwb3J0cy5lbmNvZGluZyA9IGVuY29kaW5nXG5leHBvcnRzLmVuY29kaW5nRnJvbURhdGEgPSBlbmNvZGluZ0Zyb21EYXRhXG5leHBvcnRzLm5hbWVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMubmFtZXMpXG5leHBvcnRzLmNvZGVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMuY29kZXMpXG4iLCJcblxuLy9cbi8vIFRISVMgRklMRSBJUyBBVVRPTUFUSUNBTExZIEdFTkVSQVRFRCEgRE8gTk9UIEVESVQgQlkgSEFORCFcbi8vXG47KGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgICAgID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzExOVxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICAgICAgICAgIGNvbnN0IF9CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICAgICAgY29uc3QgZ0Jhc2U2NCA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgIGdCYXNlNjQubm9Db25mbGljdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ0Jhc2U2NDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLk1ldGVvcikgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgICAgICAgICBCYXNlNjQgPSBnQmFzZTY0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IGdCYXNlNjQ7XG4gICAgICAgIH0pKCk7XG59KCh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFxuICAgICAgICA6IHRoaXNcbiksIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiAgYmFzZTY0LnRzXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbiAqICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiAgUmVmZXJlbmNlczpcbiAqICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0XG4gKlxuICogQGF1dGhvciBEYW4gS29nYWkgKGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaSlcbiAqL1xuY29uc3QgdmVyc2lvbiA9ICczLjYuMSc7XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBsb3dlcmNhc2UgYHZlcnNpb25gLlxuICovXG5jb25zdCBWRVJTSU9OID0gdmVyc2lvbjtcbmNvbnN0IF9oYXNhdG9iID0gdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfaGFzYnRvYSA9IHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nO1xuY29uc3QgX2hhc0J1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbic7XG5jb25zdCBfVEQgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcbmNvbnN0IF9URSA9IHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogdW5kZWZpbmVkO1xuY29uc3QgYjY0Y2ggPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuY29uc3QgYjY0Y2hzID0gWy4uLmI2NGNoXTtcbmNvbnN0IGI2NHRhYiA9ICgoYSkgPT4ge1xuICAgIGxldCB0YWIgPSB7fTtcbiAgICBhLmZvckVhY2goKGMsIGkpID0+IHRhYltjXSA9IGkpO1xuICAgIHJldHVybiB0YWI7XG59KShiNjRjaHMpO1xuY29uc3QgYjY0cmUgPSAvXig/OltBLVphLXpcXGQrXFwvXXs0fSkqPyg/OltBLVphLXpcXGQrXFwvXXsyfSg/Oj09KT98W0EtWmEtelxcZCtcXC9dezN9PT8pPyQvO1xuY29uc3QgX2Zyb21DQyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYmluZChTdHJpbmcpO1xuY29uc3QgX1U4QWZyb20gPSB0eXBlb2YgVWludDhBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgPyBVaW50OEFycmF5LmZyb20uYmluZChVaW50OEFycmF5KVxuICAgIDogKGl0LCBmbiA9ICh4KSA9PiB4KSA9PiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpdCwgMCkubWFwKGZuKSk7XG5jb25zdCBfbWtVcmlTYWZlID0gKHNyYykgPT4gc3JjXG4gICAgLnJlcGxhY2UoL1srXFwvXS9nLCAobTApID0+IG0wID09ICcrJyA/ICctJyA6ICdfJylcbiAgICAucmVwbGFjZSgvPSskL20sICcnKTtcbmNvbnN0IF90aWR5QjY0ID0gKHMpID0+IHMucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTtcbi8qKlxuICogcG9seWZpbGwgdmVyc2lvbiBvZiBgYnRvYWBcbiAqL1xuY29uc3QgYnRvYVBvbHlmaWxsID0gKGJpbikgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgbGV0IHUzMiwgYzAsIGMxLCBjMiwgYXNjID0gJyc7XG4gICAgY29uc3QgcGFkID0gYmluLmxlbmd0aCAlIDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOykge1xuICAgICAgICBpZiAoKGMwID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUgfHxcbiAgICAgICAgICAgIChjMSA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAoYzIgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgICAgIHUzMiA9IChjMCA8PCAxNikgfCAoYzEgPDwgOCkgfCBjMjtcbiAgICAgICAgYXNjICs9IGI2NGNoc1t1MzIgPj4gMTggJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiA+PiAxMiAmIDYzXVxuICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDYgJiA2M11cbiAgICAgICAgICAgICsgYjY0Y2hzW3UzMiAmIDYzXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZCA/IGFzYy5zbGljZSgwLCBwYWQgLSAzKSArIFwiPT09XCIuc3Vic3RyaW5nKHBhZCkgOiBhc2M7XG59O1xuLyoqXG4gKiBkb2VzIHdoYXQgYHdpbmRvdy5idG9hYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gYmluIGJpbmFyeSBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICovXG5jb25zdCBfYnRvYSA9IF9oYXNidG9hID8gKGJpbikgPT4gYnRvYShiaW4pXG4gICAgOiBfaGFzQnVmZmVyID8gKGJpbikgPT4gQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIDogYnRvYVBvbHlmaWxsO1xuY29uc3QgX2Zyb21VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgID8gKHU4YSkgPT4gQnVmZmVyLmZyb20odThhKS50b1N0cmluZygnYmFzZTY0JylcbiAgICA6ICh1OGEpID0+IHtcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNzEwMDAxL2hvdy10by1jb252ZXJ0LXVpbnQ4LWFycmF5LXRvLWJhc2U2NC1lbmNvZGVkLXN0cmluZy8xMjcxMzMyNiMxMjcxMzMyNlxuICAgICAgICBjb25zdCBtYXhhcmdzID0gMHgxMDAwO1xuICAgICAgICBsZXQgc3RycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHU4YS5sZW5ndGg7IGkgPCBsOyBpICs9IG1heGFyZ3MpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaChfZnJvbUNDLmFwcGx5KG51bGwsIHU4YS5zdWJhcnJheShpLCBpICsgbWF4YXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2J0b2Eoc3Rycy5qb2luKCcnKSk7XG4gICAgfTtcbi8qKlxuICogY29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIFVSTC1hbmQtZmlsZW5hbWUtc2FmZSBhIGxhIFJGQzQ2NDggwqc1XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGZyb21VaW50OEFycmF5ID0gKHU4YSwgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlID8gX21rVXJpU2FmZShfZnJvbVVpbnQ4QXJyYXkodThhKSkgOiBfZnJvbVVpbnQ4QXJyYXkodThhKTtcbi8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuLy8gY29uc3QgdXRvYiA9IChzcmM6IHN0cmluZykgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgY2JfdXRvYiA9IChjKSA9PiB7XG4gICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoX2Zyb21DQygweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICA6IChfZnJvbUNDKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8IChjYyAmIDB4M2YpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2MgPSAweDEwMDAwXG4gICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgIHJldHVybiAoX2Zyb21DQygweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICArIF9mcm9tQ0MoMHg4MCB8ICgoY2MgPj4+IDEyKSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgIH1cbn07XG5jb25zdCByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4vKipcbiAqIEBkZXByZWNhdGVkIHNob3VsZCBoYXZlIGJlZW4gaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFVURi04IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTE2IHN0cmluZ1xuICovXG5jb25zdCB1dG9iID0gKHUpID0+IHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbi8vXG5jb25zdCBfZW5jb2RlID0gX2hhc0J1ZmZlclxuICAgID8gKHMpID0+IEJ1ZmZlci5mcm9tKHMsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgOiBfVEVcbiAgICAgICAgPyAocykgPT4gX2Zyb21VaW50OEFycmF5KF9URS5lbmNvZGUocykpXG4gICAgICAgIDogKHMpID0+IF9idG9hKHV0b2IocykpO1xuLyoqXG4gKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIGEgQmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VybHNhZmVdIGlmIGB0cnVlYCBtYWtlIHRoZSByZXN1bHQgVVJMLXNhZmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBzdHJpbmdcbiAqL1xuY29uc3QgZW5jb2RlID0gKHNyYywgdXJsc2FmZSA9IGZhbHNlKSA9PiB1cmxzYWZlXG4gICAgPyBfbWtVcmlTYWZlKF9lbmNvZGUoc3JjKSlcbiAgICA6IF9lbmNvZGUoc3JjKTtcbi8qKlxuICogY29udmVydHMgYSBVVEYtOC1lbmNvZGVkIHN0cmluZyB0byBVUkwtc2FmZSBCYXNlNjQgUkZDNDY0OCDCpzUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gKi9cbmNvbnN0IGVuY29kZVVSSSA9IChzcmMpID0+IGVuY29kZShzcmMsIHRydWUpO1xuLy8gVGhpcyB0cmljayBpcyBmb3VuZCBicm9rZW4gaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWJhc2U2NC9pc3N1ZXMvMTMwXG4vLyBjb25zdCBidG91ID0gKHNyYzogc3RyaW5nKSA9PiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHNyYykpO1xuLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuY29uc3QgcmVfYnRvdSA9IC9bXFx4QzAtXFx4REZdW1xceDgwLVxceEJGXXxbXFx4RTAtXFx4RUZdW1xceDgwLVxceEJGXXsyfXxbXFx4RjAtXFx4RjddW1xceDgwLVxceEJGXXszfS9nO1xuY29uc3QgY2JfYnRvdSA9IChjY2NjKSA9PiB7XG4gICAgc3dpdGNoIChjY2NjLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgY3AgPSAoKDB4MDcgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDE4KVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCAxMilcbiAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSwgb2Zmc2V0ID0gY3AgLSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIChfZnJvbUNDKChvZmZzZXQgPj4+IDEwKSArIDB4RDgwMClcbiAgICAgICAgICAgICAgICArIF9mcm9tQ0MoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2Zyb21DQygoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgIHwgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSk7XG4gICAgfVxufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgc2hvdWxkIGhhdmUgYmVlbiBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTE2IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gVVRGLTggc3RyaW5nXG4gKi9cbmNvbnN0IGJ0b3UgPSAoYikgPT4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuLyoqXG4gKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBhdG9iYFxuICovXG5jb25zdCBhdG9iUG9seWZpbGwgPSAoYXNjKSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coJ3BvbHlmaWxsZWQnKTtcbiAgICBhc2MgPSBhc2MucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgaWYgKCFiNjRyZS50ZXN0KGFzYykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBiYXNlNjQuJyk7XG4gICAgYXNjICs9ICc9PScuc2xpY2UoMiAtIChhc2MubGVuZ3RoICYgMykpO1xuICAgIGxldCB1MjQsIGJpbiA9ICcnLCByMSwgcjI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc2MubGVuZ3RoOykge1xuICAgICAgICB1MjQgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxOFxuICAgICAgICAgICAgfCBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxMlxuICAgICAgICAgICAgfCAocjEgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSkgPDwgNlxuICAgICAgICAgICAgfCAocjIgPSBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSk7XG4gICAgICAgIGJpbiArPSByMSA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSlcbiAgICAgICAgICAgIDogcjIgPT09IDY0ID8gX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1KVxuICAgICAgICAgICAgICAgIDogX2Zyb21DQyh1MjQgPj4gMTYgJiAyNTUsIHUyNCA+PiA4ICYgMjU1LCB1MjQgJiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gYmluO1xufTtcbi8qKlxuICogZG9lcyB3aGF0IGB3aW5kb3cuYXRvYmAgb2Ygd2ViIGJyb3dzZXJzIGRvLlxuICogQHBhcmFtIHtTdHJpbmd9IGFzYyBCYXNlNjQtZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSBzdHJpbmdcbiAqL1xuY29uc3QgX2F0b2IgPSBfaGFzYXRvYiA/IChhc2MpID0+IGF0b2IoX3RpZHlCNjQoYXNjKSlcbiAgICA6IF9oYXNCdWZmZXIgPyAoYXNjKSA9PiBCdWZmZXIuZnJvbShhc2MsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5JylcbiAgICAgICAgOiBhdG9iUG9seWZpbGw7XG4vL1xuY29uc3QgX3RvVWludDhBcnJheSA9IF9oYXNCdWZmZXJcbiAgICA/IChhKSA9PiBfVThBZnJvbShCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykpXG4gICAgOiAoYSkgPT4gX1U4QWZyb20oX2F0b2IoYSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbi8qKlxuICogY29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqL1xuY29uc3QgdG9VaW50OEFycmF5ID0gKGEpID0+IF90b1VpbnQ4QXJyYXkoX3VuVVJJKGEpKTtcbi8vXG5jb25zdCBfZGVjb2RlID0gX2hhc0J1ZmZlclxuICAgID8gKGEpID0+IEJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKS50b1N0cmluZygndXRmOCcpXG4gICAgOiBfVERcbiAgICAgICAgPyAoYSkgPT4gX1RELmRlY29kZShfdG9VaW50OEFycmF5KGEpKVxuICAgICAgICA6IChhKSA9PiBidG91KF9hdG9iKGEpKTtcbmNvbnN0IF91blVSSSA9IChhKSA9PiBfdGlkeUI2NChhLnJlcGxhY2UoL1stX10vZywgKG0wKSA9PiBtMCA9PSAnLScgPyAnKycgOiAnLycpKTtcbi8qKlxuICogY29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgVVRGLTggc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHNyYyBCYXNlNjQgc3RyaW5nLiAgQm90aCBub3JtYWwgYW5kIFVSTC1zYWZlIGFyZSBzdXBwb3J0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICovXG5jb25zdCBkZWNvZGUgPSAoc3JjKSA9PiBfZGVjb2RlKF91blVSSShzcmMpKTtcbi8qKlxuICogY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIEJhc2U2NCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgYSB2YWx1ZSB0byBjaGVja1xuICAqL1xuY29uc3QgaXNWYWxpZCA9IChzcmMpID0+IHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzID0gc3JjLnJlcGxhY2UoL1xccysvZywgJycpLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICByZXR1cm4gIS9bXlxcczAtOWEtekEtWlxcKy9dLy50ZXN0KHMpIHx8ICEvW15cXHMwLTlhLXpBLVpcXC1fXS8udGVzdChzKTtcbn07XG4vL1xuY29uc3QgX25vRW51bSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHYsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfTtcbn07XG4vKipcbiAqIGV4dGVuZCBTdHJpbmcucHJvdG90eXBlIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICovXG5jb25zdCBleHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7XG4gICAgX2FkZCgnZnJvbUJhc2U2NCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZSh0aGlzKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSk7IH0pO1xuICAgIF9hZGQoJ3RvVWludDhBcnJheScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzKTsgfSk7XG59O1xuLyoqXG4gKiBleHRlbmQgVWludDhBcnJheS5wcm90b3R5cGUgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZFVpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgX2FkZCA9IChuYW1lLCBib2R5KSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoVWludDhBcnJheS5wcm90b3R5cGUsIG5hbWUsIF9ub0VudW0oYm9keSkpO1xuICAgIF9hZGQoJ3RvQmFzZTY0JywgZnVuY3Rpb24gKHVybHNhZmUpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHVybHNhZmUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICBfYWRkKCd0b0Jhc2U2NFVSTCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbn07XG4vKipcbiAqIGV4dGVuZCBCdWlsdGluIHByb3RvdHlwZXMgd2l0aCByZWxldmFudCBtZXRob2RzXG4gKi9cbmNvbnN0IGV4dGVuZEJ1aWx0aW5zID0gKCkgPT4ge1xuICAgIGV4dGVuZFN0cmluZygpO1xuICAgIGV4dGVuZFVpbnQ4QXJyYXkoKTtcbn07XG5jb25zdCBnQmFzZTY0ID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgVkVSU0lPTjogVkVSU0lPTixcbiAgICBhdG9iOiBfYXRvYixcbiAgICBhdG9iUG9seWZpbGw6IGF0b2JQb2x5ZmlsbCxcbiAgICBidG9hOiBfYnRvYSxcbiAgICBidG9hUG9seWZpbGw6IGJ0b2FQb2x5ZmlsbCxcbiAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICBlbmNvZGVVUkw6IGVuY29kZVVSSSxcbiAgICB1dG9iOiB1dG9iLFxuICAgIGJ0b3U6IGJ0b3UsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBmcm9tVWludDhBcnJheTogZnJvbVVpbnQ4QXJyYXksXG4gICAgdG9VaW50OEFycmF5OiB0b1VpbnQ4QXJyYXksXG4gICAgZXh0ZW5kU3RyaW5nOiBleHRlbmRTdHJpbmcsXG4gICAgZXh0ZW5kVWludDhBcnJheTogZXh0ZW5kVWludDhBcnJheSxcbiAgICBleHRlbmRCdWlsdGluczogZXh0ZW5kQnVpbHRpbnMsXG59O1xuXG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIC8vIEVTNSBpcyB5ZXQgdG8gaGF2ZSBPYmplY3QuYXNzaWduKCkgdGhhdCBtYXkgbWFrZSB0cmFuc3BpbGVycyB1bmhhcHB5LlxuICAgIC8vIGdCYXNlNjQuQmFzZTY0ID0gT2JqZWN0LmFzc2lnbih7fSwgZ0Jhc2U2NCk7XG4gICAgZ0Jhc2U2NC5CYXNlNjQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhnQmFzZTY0KS5mb3JFYWNoKGsgPT4gZ0Jhc2U2NC5CYXNlNjRba10gPSBnQmFzZTY0W2tdKTtcbiAgICByZXR1cm4gZ0Jhc2U2NDtcbn0pKTtcblxuXG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOdW1iZXJ9IENvZGVjTnVtYmVyICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG4vKipcbiAqIEB0eXBlIHtNYXA8Q29kZWNOdW1iZXIsQ29kZWNOYW1lPn1cbiAqL1xuY29uc3QgbmFtZVRhYmxlID0gbmV3IE1hcCgpXG5cbmZvciAoY29uc3QgZW5jb2RpbmdOYW1lIGluIGJhc2VUYWJsZSkge1xuICBjb25zdCBjb2RlID0gYmFzZVRhYmxlW2VuY29kaW5nTmFtZV1cbiAgbmFtZVRhYmxlLnNldChjb2RlLCAvKiogQHR5cGUge0NvZGVjTmFtZX0gKi8oZW5jb2RpbmdOYW1lKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKG5hbWVUYWJsZSlcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29uc3RhbnROdW1iZXJNYXB9IENvbnN0YW50TnVtYmVyTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCBjb25zdGFudHMgPSAvKiogQHR5cGUge0NvbnN0YW50TnVtYmVyTWFwfSAqLyh7fSlcblxuZm9yIChjb25zdCBbbmFtZSwgY29kZV0gb2YgT2JqZWN0LmVudHJpZXMoYmFzZVRhYmxlKSkge1xuICBjb25zdCBjb25zdGFudCA9IG5hbWUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJylcbiAgY29uc3RhbnRzW2NvbnN0YW50XSA9IGNvZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cylcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OdW1iZXJOYW1lTWFwfSBOdW1iZXJOYW1lTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCB0YWJsZUJ5Q29kZSA9IC8qKiBAdHlwZSB7TnVtYmVyTmFtZU1hcH0gKi8oe30pXG5cbmZvciAoY29uc3QgW25hbWUsIGNvZGVdIG9mIE9iamVjdC5lbnRyaWVzKGJhc2VUYWJsZSkpIHtcbiAgaWYgKHRhYmxlQnlDb2RlW2NvZGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0YWJsZUJ5Q29kZVtjb2RlXSA9IC8qKiBAdHlwZSB7Q29kZWNOYW1lfSAqKi8obmFtZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IC8qKiBAdHlwZSB7TnVtYmVyTmFtZU1hcH0gKi8oT2JqZWN0LmZyZWV6ZSh0YWJsZUJ5Q29kZSkpXG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk5hbWVVaW50OEFycmF5TWFwfSBOYW1lVWludDhBcnJheU1hcCAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcbmNvbnN0IHZhcmludEVuY29kZSA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhcmludEVuY29kZVxuXG5jb25zdCB2YXJpbnRUYWJsZSA9IC8qKiBAdHlwZSB7TmFtZVVpbnQ4QXJyYXlNYXB9ICovICh7fSlcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICB2YXJpbnRUYWJsZVtlbmNvZGluZ05hbWVdID0gdmFyaW50RW5jb2RlKGNvZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh2YXJpbnRUYWJsZSlcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgVWludDhBcnJheSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhc3NlZCBBcnJheUxpa2VzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycmF5c1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAoYXJyYXlzLCBsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIGZvciAoY29uc3QgYXJyIG9mIGFycmF5cykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25jYXRcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZTogcmVxdWlyZSgnLi9lbmNvZGUuanMnKVxuICAsIGRlY29kZTogcmVxdWlyZSgnLi9kZWNvZGUuanMnKVxuICAsIGVuY29kaW5nTGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aC5qcycpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHVpbnQ4QXJyYXlUb1N0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpXG5jb25zdCB1aW50OEFycmF5RnJvbVN0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG51bWJlclRvVWludDhBcnJheSxcbiAgdWludDhBcnJheVRvTnVtYmVyLFxuICB2YXJpbnRVaW50OEFycmF5RW5jb2RlLFxuICB2YXJpbnRFbmNvZGVcbn1cblxuZnVuY3Rpb24gdWludDhBcnJheVRvTnVtYmVyIChidWYpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHVpbnQ4QXJyYXlUb1N0cmluZyhidWYsICdiYXNlMTYnKSwgMTYpXG59XG5cbmZ1bmN0aW9uIG51bWJlclRvVWludDhBcnJheSAobnVtKSB7XG4gIGxldCBoZXhTdHJpbmcgPSBudW0udG9TdHJpbmcoMTYpXG4gIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgIGhleFN0cmluZyA9ICcwJyArIGhleFN0cmluZ1xuICB9XG4gIHJldHVybiB1aW50OEFycmF5RnJvbVN0cmluZyhoZXhTdHJpbmcsICdiYXNlMTYnKVxufVxuXG5mdW5jdGlvbiB2YXJpbnRVaW50OEFycmF5RW5jb2RlIChpbnB1dCkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUodWludDhBcnJheVRvTnVtYmVyKGlucHV0KSkpXG59XG5cbmZ1bmN0aW9uIHZhcmludEVuY29kZSAobnVtKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZShudW0pKVxufVxuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBiYXNlNjRtYXBcbiAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLFxuXG4gIGNyeXB0ID0ge1xuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIGxlZnRcbiAgICByb3RsOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgYikgfCAobiA+Pj4gKDMyIC0gYikpO1xuICAgIH0sXG5cbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiByaWdodFxuICAgIHJvdHI6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCAoMzIgLSBiKSkgfCAobiA+Pj4gYik7XG4gICAgfSxcblxuICAgIC8vIFN3YXAgYmlnLWVuZGlhbiB0byBsaXR0bGUtZW5kaWFuIGFuZCB2aWNlIHZlcnNhXG4gICAgZW5kaWFuOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBJZiBudW1iZXIgZ2l2ZW4sIHN3YXAgZW5kaWFuXG4gICAgICBpZiAobi5jb25zdHJ1Y3RvciA9PSBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0LnJvdGwobiwgOCkgJiAweDAwRkYwMEZGIHwgY3J5cHQucm90bChuLCAyNCkgJiAweEZGMDBGRjAwO1xuICAgICAgfVxuXG4gICAgICAvLyBFbHNlLCBhc3N1bWUgYXJyYXkgYW5kIHN3YXAgYWxsIGl0ZW1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspXG4gICAgICAgIG5baV0gPSBjcnlwdC5lbmRpYW4obltpXSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuXG4gICAgLy8gR2VuZXJhdGUgYW4gYXJyYXkgb2YgYW55IGxlbmd0aCBvZiByYW5kb20gYnl0ZXNcbiAgICByYW5kb21CeXRlczogZnVuY3Rpb24obikge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXTsgbiA+IDA7IG4tLSlcbiAgICAgICAgYnl0ZXMucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYmlnLWVuZGlhbiAzMi1iaXQgd29yZHNcbiAgICBieXRlc1RvV29yZHM6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciB3b3JkcyA9IFtdLCBpID0gMCwgYiA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKywgYiArPSA4KVxuICAgICAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpO1xuICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGJpZy1lbmRpYW4gMzItYml0IHdvcmRzIHRvIGEgYnl0ZSBhcnJheVxuICAgIHdvcmRzVG9CeXRlczogZnVuY3Rpb24od29yZHMpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGIgPSAwOyBiIDwgd29yZHMubGVuZ3RoICogMzI7IGIgKz0gOClcbiAgICAgICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZ1xuICAgIGJ5dGVzVG9IZXg6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBoZXggPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSAmIDB4RikudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZXguam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGhleFRvQnl0ZXM6IGZ1bmN0aW9uKGhleCkge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYyA9IDA7IGMgPCBoZXgubGVuZ3RoOyBjICs9IDIpXG4gICAgICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cihjLCAyKSwgMTYpKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICAgIGJ5dGVzVG9CYXNlNjQ6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBiYXNlNjQgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgICBpZiAoaSAqIDggKyBqICogNiA8PSBieXRlcy5sZW5ndGggKiA4KVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goYmFzZTY0bWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gNiAqICgzIC0gaikpICYgMHgzRikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKCc9Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTY0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYmFzZS02NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgYmFzZTY0VG9CeXRlczogZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgICAvLyBSZW1vdmUgbm9uLWJhc2UtNjQgY2hhcmFjdGVyc1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnJlcGxhY2UoL1teQS1aMC05K1xcL10vaWcsICcnKTtcblxuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgaSA9IDAsIGltb2Q0ID0gMDsgaSA8IGJhc2U2NC5sZW5ndGg7XG4gICAgICAgICAgaW1vZDQgPSArK2kgJSA0KSB7XG4gICAgICAgIGlmIChpbW9kNCA9PSAwKSBjb250aW51ZTtcbiAgICAgICAgYnl0ZXMucHVzaCgoKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSAtIDEpKVxuICAgICAgICAgICAgJiAoTWF0aC5wb3coMiwgLTIgKiBpbW9kNCArIDgpIC0gMSkpIDw8IChpbW9kNCAqIDIpKVxuICAgICAgICAgICAgfCAoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpKSkgPj4+ICg2IC0gaW1vZDQgKiAyKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGNyeXB0O1xufSkoKTtcbiIsInZhciBjaGFyZW5jID0ge1xuICAvLyBVVEYtOCBlbmNvZGluZ1xuICB1dGY4OiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBjaGFyZW5jLmJpbi5zdHJpbmdUb0J5dGVzKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGNoYXJlbmMuYmluLmJ5dGVzVG9TdHJpbmcoYnl0ZXMpKSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEJpbmFyeSBlbmNvZGluZ1xuICBiaW46IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgc3RyID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0ci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pKTtcbiAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYXJlbmM7XG4iLCIvKipcbiAqIHRvU3RyaW5nIHJlZi5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpe1xuICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgICBjYXNlICdbb2JqZWN0IEVycm9yXSc6IHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgIT09IHZhbCkgcmV0dXJuICduYW4nO1xuICBpZiAodmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSkgcmV0dXJuICdlbGVtZW50JztcblxuICBpZiAoaXNCdWZmZXIodmFsKSkgcmV0dXJuICdidWZmZXInO1xuXG4gIHZhbCA9IHZhbC52YWx1ZU9mXG4gICAgPyB2YWwudmFsdWVPZigpXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YuYXBwbHkodmFsKTtcblxuICByZXR1cm4gdHlwZW9mIHZhbDtcbn07XG5cbi8vIGNvZGUgYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2lzLWJ1ZmZlci9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gIHJldHVybiAhIShvYmogIT0gbnVsbCAmJlxuICAgIChvYmouX2lzQnVmZmVyIHx8IC8vIEZvciBTYWZhcmkgNS03IChtaXNzaW5nIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSlcbiAgICApKVxufVxuIiwiXG4vKipcbiAqIEpvaW4gYGFycmAgd2l0aCB0aGUgdHJhaWxpbmcgYHN0cmAgZGVmYXVsdGluZyB0byBcImFuZFwiLFxuICogYW5kIGBzZXBgIHN0cmluZyBkZWZhdWx0aW5nIHRvIFwiLCBcIi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZXBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIHN0ciwgc2VwKXtcbiAgc3RyID0gc3RyIHx8ICdhbmQnO1xuICBzZXAgPSBzZXAgfHwgJywgJztcblxuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHJldHVybiBhcnJbMF0gfHwgJyc7XG5cbiAgdmFyIG94Zm9yZCA9IHN0ci5zbGljZSgwLCAyKSA9PT0gc2VwO1xuXG4gIGlmICghb3hmb3JkKSB7XG4gICAgc3RyID0gJyAnICsgc3RyO1xuICB9IGVsc2UgaWYgKGFyci5sZW5ndGggPT0gMikge1xuICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhcnIuc2xpY2UoMCwgLTEpLmpvaW4oc2VwKSArIHN0ciArICcgJyArIGFyclthcnIubGVuZ3RoIC0gMV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc05ldHdvcmtFcnJvciA9IGlzTmV0d29ya0Vycm9yO1xuZXhwb3J0cy5pc1JldHJ5YWJsZUVycm9yID0gaXNSZXRyeWFibGVFcnJvcjtcbmV4cG9ydHMuaXNTYWZlUmVxdWVzdEVycm9yID0gaXNTYWZlUmVxdWVzdEVycm9yO1xuZXhwb3J0cy5pc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3IgPSBpc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3I7XG5leHBvcnRzLmlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvciA9IGlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvcjtcbmV4cG9ydHMuZXhwb25lbnRpYWxEZWxheSA9IGV4cG9uZW50aWFsRGVsYXk7XG5leHBvcnRzLmRlZmF1bHQgPSBheGlvc1JldHJ5O1xuXG52YXIgX2lzUmV0cnlBbGxvd2VkID0gcmVxdWlyZSgnaXMtcmV0cnktYWxsb3dlZCcpO1xuXG52YXIgX2lzUmV0cnlBbGxvd2VkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUmV0cnlBbGxvd2VkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG5hbWVzcGFjZSA9ICdheGlvcy1yZXRyeSc7XG5cbi8qKlxuICogQHBhcmFtICB7RXJyb3J9ICBlcnJvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuICFlcnJvci5yZXNwb25zZSAmJiBCb29sZWFuKGVycm9yLmNvZGUpICYmIC8vIFByZXZlbnRzIHJldHJ5aW5nIGNhbmNlbGxlZCByZXF1ZXN0c1xuICBlcnJvci5jb2RlICE9PSAnRUNPTk5BQk9SVEVEJyAmJiAvLyBQcmV2ZW50cyByZXRyeWluZyB0aW1lZCBvdXQgcmVxdWVzdHNcbiAgKDAsIF9pc1JldHJ5QWxsb3dlZDIuZGVmYXVsdCkoZXJyb3IpOyAvLyBQcmV2ZW50cyByZXRyeWluZyB1bnNhZmUgZXJyb3JzXG59XG5cbnZhciBTQUZFX0hUVFBfTUVUSE9EUyA9IFsnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddO1xudmFyIElERU1QT1RFTlRfSFRUUF9NRVRIT0RTID0gU0FGRV9IVFRQX01FVEhPRFMuY29uY2F0KFsncHV0JywgJ2RlbGV0ZSddKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtFcnJvcn0gIGVycm9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JldHJ5YWJsZUVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvci5jb2RlICE9PSAnRUNPTk5BQk9SVEVEJyAmJiAoIWVycm9yLnJlc3BvbnNlIHx8IGVycm9yLnJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgJiYgZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDw9IDU5OSk7XG59XG5cbi8qKlxuICogQHBhcmFtICB7RXJyb3J9ICBlcnJvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTYWZlUmVxdWVzdEVycm9yKGVycm9yKSB7XG4gIGlmICghZXJyb3IuY29uZmlnKSB7XG4gICAgLy8gQ2Fubm90IGRldGVybWluZSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgcmV0cmllZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1JldHJ5YWJsZUVycm9yKGVycm9yKSAmJiBTQUZFX0hUVFBfTUVUSE9EUy5pbmRleE9mKGVycm9yLmNvbmZpZy5tZXRob2QpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtFcnJvcn0gIGVycm9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3IoZXJyb3IpIHtcbiAgaWYgKCFlcnJvci5jb25maWcpIHtcbiAgICAvLyBDYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSByZXF1ZXN0IGNhbiBiZSByZXRyaWVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzUmV0cnlhYmxlRXJyb3IoZXJyb3IpICYmIElERU1QT1RFTlRfSFRUUF9NRVRIT0RTLmluZGV4T2YoZXJyb3IuY29uZmlnLm1ldGhvZCkgIT09IC0xO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge0Vycm9yfSAgZXJyb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvcihlcnJvcikge1xuICByZXR1cm4gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHx8IGlzSWRlbXBvdGVudFJlcXVlc3RFcnJvcihlcnJvcik7XG59XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kcywgYWx3YXlzIDBcbiAqL1xuZnVuY3Rpb24gbm9EZWxheSgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBbcmV0cnlOdW1iZXI9MF1cbiAqIEByZXR1cm4ge251bWJlcn0gLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZnVuY3Rpb24gZXhwb25lbnRpYWxEZWxheSgpIHtcbiAgdmFyIHJldHJ5TnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gIHZhciBkZWxheSA9IE1hdGgucG93KDIsIHJldHJ5TnVtYmVyKSAqIDEwMDtcbiAgdmFyIHJhbmRvbVN1bSA9IGRlbGF5ICogMC4yICogTWF0aC5yYW5kb20oKTsgLy8gMC0yMCUgb2YgdGhlIGRlbGF5XG4gIHJldHVybiBkZWxheSArIHJhbmRvbVN1bTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbmQgcmV0dXJucyB0aGUgcmV0cnkgc3RhdGUgZm9yIHRoZSBnaXZlbiByZXF1ZXN0L2NvbmZpZ1xuICogQHBhcmFtICB7QXhpb3NSZXF1ZXN0Q29uZmlnfSBjb25maWdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFN0YXRlKGNvbmZpZykge1xuICB2YXIgY3VycmVudFN0YXRlID0gY29uZmlnW25hbWVzcGFjZV0gfHwge307XG4gIGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50ID0gY3VycmVudFN0YXRlLnJldHJ5Q291bnQgfHwgMDtcbiAgY29uZmlnW25hbWVzcGFjZV0gPSBjdXJyZW50U3RhdGU7XG4gIHJldHVybiBjdXJyZW50U3RhdGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXhpb3MtcmV0cnkgb3B0aW9ucyBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdFxuICogQHBhcmFtICB7QXhpb3NSZXF1ZXN0Q29uZmlnfSBjb25maWdcbiAqIEBwYXJhbSAge0F4aW9zUmV0cnlDb25maWd9IGRlZmF1bHRPcHRpb25zXG4gKiBAcmV0dXJuIHtBeGlvc1JldHJ5Q29uZmlnfVxuICovXG5mdW5jdGlvbiBnZXRSZXF1ZXN0T3B0aW9ucyhjb25maWcsIGRlZmF1bHRPcHRpb25zKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgY29uZmlnW25hbWVzcGFjZV0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge0F4aW9zfSBheGlvc1xuICogQHBhcmFtICB7QXhpb3NSZXF1ZXN0Q29uZmlnfSBjb25maWdcbiAqL1xuZnVuY3Rpb24gZml4Q29uZmlnKGF4aW9zLCBjb25maWcpIHtcbiAgaWYgKGF4aW9zLmRlZmF1bHRzLmFnZW50ID09PSBjb25maWcuYWdlbnQpIHtcbiAgICBkZWxldGUgY29uZmlnLmFnZW50O1xuICB9XG4gIGlmIChheGlvcy5kZWZhdWx0cy5odHRwQWdlbnQgPT09IGNvbmZpZy5odHRwQWdlbnQpIHtcbiAgICBkZWxldGUgY29uZmlnLmh0dHBBZ2VudDtcbiAgfVxuICBpZiAoYXhpb3MuZGVmYXVsdHMuaHR0cHNBZ2VudCA9PT0gY29uZmlnLmh0dHBzQWdlbnQpIHtcbiAgICBkZWxldGUgY29uZmlnLmh0dHBzQWdlbnQ7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIHJlc3BvbnNlIGludGVyY2VwdG9ycyB0byBhbiBheGlvcyBpbnN0YW5jZSB0byByZXRyeSByZXF1ZXN0cyBmYWlsZWQgZHVlIHRvIG5ldHdvcmsgaXNzdWVzXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuICpcbiAqIGF4aW9zUmV0cnkoYXhpb3MsIHsgcmV0cmllczogMyB9KTtcbiAqXG4gKiBheGlvcy5nZXQoJ2h0dHA6Ly9leGFtcGxlLmNvbS90ZXN0JykgLy8gVGhlIGZpcnN0IHJlcXVlc3QgZmFpbHMgYW5kIHRoZSBzZWNvbmQgcmV0dXJucyAnb2snXG4gKiAgIC50aGVuKHJlc3VsdCA9PiB7XG4gKiAgICAgcmVzdWx0LmRhdGE7IC8vICdvaydcbiAqICAgfSk7XG4gKlxuICogLy8gRXhwb25lbnRpYWwgYmFjay1vZmYgcmV0cnkgZGVsYXkgYmV0d2VlbiByZXF1ZXN0c1xuICogYXhpb3NSZXRyeShheGlvcywgeyByZXRyeURlbGF5IDogYXhpb3NSZXRyeS5leHBvbmVudGlhbERlbGF5fSk7XG4gKlxuICogLy8gQ3VzdG9tIHJldHJ5IGRlbGF5XG4gKiBheGlvc1JldHJ5KGF4aW9zLCB7IHJldHJ5RGVsYXkgOiAocmV0cnlDb3VudCkgPT4ge1xuICogICByZXR1cm4gcmV0cnlDb3VudCAqIDEwMDA7XG4gKiB9fSk7XG4gKlxuICogLy8gQWxzbyB3b3JrcyB3aXRoIGN1c3RvbSBheGlvcyBpbnN0YW5jZXNcbiAqIGNvbnN0IGNsaWVudCA9IGF4aW9zLmNyZWF0ZSh7IGJhc2VVUkw6ICdodHRwOi8vZXhhbXBsZS5jb20nIH0pO1xuICogYXhpb3NSZXRyeShjbGllbnQsIHsgcmV0cmllczogMyB9KTtcbiAqXG4gKiBjbGllbnQuZ2V0KCcvdGVzdCcpIC8vIFRoZSBmaXJzdCByZXF1ZXN0IGZhaWxzIGFuZCB0aGUgc2Vjb25kIHJldHVybnMgJ29rJ1xuICogICAudGhlbihyZXN1bHQgPT4ge1xuICogICAgIHJlc3VsdC5kYXRhOyAvLyAnb2snXG4gKiAgIH0pO1xuICpcbiAqIC8vIEFsbG93cyByZXF1ZXN0LXNwZWNpZmljIGNvbmZpZ3VyYXRpb25cbiAqIGNsaWVudFxuICogICAuZ2V0KCcvdGVzdCcsIHtcbiAqICAgICAnYXhpb3MtcmV0cnknOiB7XG4gKiAgICAgICByZXRyaWVzOiAwXG4gKiAgICAgfVxuICogICB9KVxuICogICAuY2F0Y2goZXJyb3IgPT4geyAvLyBUaGUgZmlyc3QgcmVxdWVzdCBmYWlsc1xuICogICAgIGVycm9yICE9PSB1bmRlZmluZWRcbiAqICAgfSk7XG4gKlxuICogQHBhcmFtIHtBeGlvc30gYXhpb3MgQW4gYXhpb3MgaW5zdGFuY2UgKHRoZSBheGlvcyBvYmplY3Qgb3Igb25lIGNyZWF0ZWQgZnJvbSBheGlvcy5jcmVhdGUpXG4gKiBAcGFyYW0ge09iamVjdH0gW2RlZmF1bHRPcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0T3B0aW9ucy5yZXRyaWVzPTNdIE51bWJlciBvZiByZXRyaWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0T3B0aW9ucy5zaG91bGRSZXNldFRpbWVvdXQ9ZmFsc2VdXG4gKiAgICAgICAgRGVmaW5lcyBpZiB0aGUgdGltZW91dCBzaG91bGQgYmUgcmVzZXQgYmV0d2VlbiByZXRyaWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZGVmYXVsdE9wdGlvbnMucmV0cnlDb25kaXRpb249aXNOZXR3b3JrT3JJZGVtcG90ZW50UmVxdWVzdEVycm9yXVxuICogICAgICAgIEEgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvciBjYW4gYmUgcmV0cmllZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2RlZmF1bHRPcHRpb25zLnJldHJ5RGVsYXk9bm9EZWxheV1cbiAqICAgICAgICBBIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgZGVsYXkgYmV0d2VlbiByZXRyeSByZXF1ZXN0c1xuICovXG5mdW5jdGlvbiBheGlvc1JldHJ5KGF4aW9zLCBkZWZhdWx0T3B0aW9ucykge1xuICBheGlvcy5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSBnZXRDdXJyZW50U3RhdGUoY29uZmlnKTtcbiAgICBjdXJyZW50U3RhdGUubGFzdFJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9KTtcblxuICBheGlvcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciBjb25maWcgPSBlcnJvci5jb25maWc7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIG5vIGluZm9ybWF0aW9uIHRvIHJldHJ5IHRoZSByZXF1ZXN0XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIF9nZXRSZXF1ZXN0T3B0aW9ucyA9IGdldFJlcXVlc3RPcHRpb25zKGNvbmZpZywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgICBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUgPSBfZ2V0UmVxdWVzdE9wdGlvbnMucmV0cmllcyxcbiAgICAgICAgcmV0cmllcyA9IF9nZXRSZXF1ZXN0T3B0aW9ucyRyZSA9PT0gdW5kZWZpbmVkID8gMyA6IF9nZXRSZXF1ZXN0T3B0aW9ucyRyZSxcbiAgICAgICAgX2dldFJlcXVlc3RPcHRpb25zJHJlMiA9IF9nZXRSZXF1ZXN0T3B0aW9ucy5yZXRyeUNvbmRpdGlvbixcbiAgICAgICAgcmV0cnlDb25kaXRpb24gPSBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUyID09PSB1bmRlZmluZWQgPyBpc05ldHdvcmtPcklkZW1wb3RlbnRSZXF1ZXN0RXJyb3IgOiBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUyLFxuICAgICAgICBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUzID0gX2dldFJlcXVlc3RPcHRpb25zLnJldHJ5RGVsYXksXG4gICAgICAgIHJldHJ5RGVsYXkgPSBfZ2V0UmVxdWVzdE9wdGlvbnMkcmUzID09PSB1bmRlZmluZWQgPyBub0RlbGF5IDogX2dldFJlcXVlc3RPcHRpb25zJHJlMyxcbiAgICAgICAgX2dldFJlcXVlc3RPcHRpb25zJHNoID0gX2dldFJlcXVlc3RPcHRpb25zLnNob3VsZFJlc2V0VGltZW91dCxcbiAgICAgICAgc2hvdWxkUmVzZXRUaW1lb3V0ID0gX2dldFJlcXVlc3RPcHRpb25zJHNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9nZXRSZXF1ZXN0T3B0aW9ucyRzaDtcblxuICAgIHZhciBjdXJyZW50U3RhdGUgPSBnZXRDdXJyZW50U3RhdGUoY29uZmlnKTtcblxuICAgIHZhciBzaG91bGRSZXRyeSA9IHJldHJ5Q29uZGl0aW9uKGVycm9yKSAmJiBjdXJyZW50U3RhdGUucmV0cnlDb3VudCA8IHJldHJpZXM7XG5cbiAgICBpZiAoc2hvdWxkUmV0cnkpIHtcbiAgICAgIGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50ICs9IDE7XG4gICAgICB2YXIgZGVsYXkgPSByZXRyeURlbGF5KGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50LCBlcnJvcik7XG5cbiAgICAgIC8vIEF4aW9zIGZhaWxzIG1lcmdpbmcgdGhpcyBjb25maWd1cmF0aW9uIHRvIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYmVjYXVzZSBpdCBoYXMgYW4gaXNzdWVcbiAgICAgIC8vIHdpdGggY2lyY3VsYXIgc3RydWN0dXJlczogaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvYXhpb3MvaXNzdWVzLzM3MFxuICAgICAgZml4Q29uZmlnKGF4aW9zLCBjb25maWcpO1xuXG4gICAgICBpZiAoIXNob3VsZFJlc2V0VGltZW91dCAmJiBjb25maWcudGltZW91dCAmJiBjdXJyZW50U3RhdGUubGFzdFJlcXVlc3RUaW1lKSB7XG4gICAgICAgIHZhciBsYXN0UmVxdWVzdER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIGN1cnJlbnRTdGF0ZS5sYXN0UmVxdWVzdFRpbWU7XG4gICAgICAgIC8vIE1pbmltdW0gMW1zIHRpbWVvdXQgKHBhc3NpbmcgMCBvciBsZXNzIHRvIFhIUiBtZWFucyBubyB0aW1lb3V0KVxuICAgICAgICBjb25maWcudGltZW91dCA9IE1hdGgubWF4KGNvbmZpZy50aW1lb3V0IC0gbGFzdFJlcXVlc3REdXJhdGlvbiAtIGRlbGF5LCAxKTtcbiAgICAgIH1cblxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3QgPSBbZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShheGlvcyhjb25maWcpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfSk7XG59XG5cbi8vIENvbXBhdGliaWxpdHkgd2l0aCBDb21tb25KU1xuYXhpb3NSZXRyeS5pc05ldHdvcmtFcnJvciA9IGlzTmV0d29ya0Vycm9yO1xuYXhpb3NSZXRyeS5pc1NhZmVSZXF1ZXN0RXJyb3IgPSBpc1NhZmVSZXF1ZXN0RXJyb3I7XG5heGlvc1JldHJ5LmlzSWRlbXBvdGVudFJlcXVlc3RFcnJvciA9IGlzSWRlbXBvdGVudFJlcXVlc3RFcnJvcjtcbmF4aW9zUmV0cnkuaXNOZXR3b3JrT3JJZGVtcG90ZW50UmVxdWVzdEVycm9yID0gaXNOZXR3b3JrT3JJZGVtcG90ZW50UmVxdWVzdEVycm9yO1xuYXhpb3NSZXRyeS5leHBvbmVudGlhbERlbGF5ID0gZXhwb25lbnRpYWxEZWxheTtcbmF4aW9zUmV0cnkuaXNSZXRyeWFibGVFcnJvciA9IGlzUmV0cnlhYmxlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gdm9pZCAwO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuLyoqXG4gKiBUaGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGVcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5XG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBleHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBleHBvcnRzLmlzUHJlY29tcGlsZWQgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZXhwb3J0cy56ZXJvQWRkcmVzcyA9IHZvaWQgMDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1hZGFwdGVyJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG4vKipcbiAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3MuXG4gKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgICB2YXIgYWRkciA9IGJ5dGVzXzEuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gICAgcmV0dXJuIGJ5dGVzXzEuYnVmZmVyVG9IZXgoYWRkcik7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vLlxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcyk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBhZGRyZXNzIGlzIGEgemVybyBhZGRyZXNzLlxuICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHZhciB6ZXJvQWRkciA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgICByZXR1cm4gemVyb0FkZHIgPT09IGJ5dGVzXzEuYWRkSGV4UHJlZml4KGFkZHJlc3MpO1xufTtcbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogSWYgYSBlaXAxMTkxQ2hhaW5JZCBpcyBwcm92aWRlZCwgdGhlIGNoYWluSWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY2hlY2tzdW0gY2FsY3VsYXRpb24uIFRoaXNcbiAqIGhhcyB0aGUgZWZmZWN0IG9mIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyBmb3Igb25lIGNoYWluIGhhdmluZyBpbnZhbGlkIGNoZWNrc3VtcyBmb3Igb3RoZXJzLlxuICogRm9yIG1vcmUgZGV0YWlscywgY29uc3VsdCBFSVAtMTE5MS5cbiAqXG4gKiBXQVJOSU5HOiBDaGVja3N1bXMgd2l0aCBhbmQgd2l0aG91dCB0aGUgY2hhaW5JZCB3aWxsIGRpZmZlci4gQXMgb2YgMjAxOS0wNi0yNiwgdGhlIG1vc3QgY29tbW9ubHlcbiAqIHVzZWQgdmFyaWF0aW9uIGluIEV0aGVyZXVtIHdhcyB3aXRob3V0IHRoZSBjaGFpbklkLiBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqL1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xuICAgIGFkZHJlc3MgPSBldGhqc1V0aWwuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcHJlZml4ID0gZWlwMTE5MUNoYWluSWQgIT09IHVuZGVmaW5lZCA/IGVpcDExOTFDaGFpbklkLnRvU3RyaW5nKCkgKyAnMHgnIDogJyc7XG4gICAgdmFyIGhhc2ggPSBoYXNoXzEua2VjY2FrKHByZWZpeCArIGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgcmV0ID0gJzB4JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogU2VlIHRvQ2hlY2tzdW1BZGRyZXNzJyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzIGFib3V0IHRoZSBlaXAxMTkxQ2hhaW5JZCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkge1xuICAgIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpID09PSBhZGRyZXNzO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gICAgZnJvbSA9IGJ5dGVzXzEudG9CdWZmZXIoZnJvbSk7XG4gICAgdmFyIG5vbmNlQk4gPSBuZXcgQk4obm9uY2UpO1xuICAgIGlmIChub25jZUJOLmlzWmVybygpKSB7XG4gICAgICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAgICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgICAgICByZXR1cm4gaGFzaF8xLnJscGhhc2goW2Zyb20sIG51bGxdKS5zbGljZSgtMjApO1xuICAgIH1cbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gaGFzaF8xLnJscGhhc2goW2Zyb20sIEJ1ZmZlci5mcm9tKG5vbmNlQk4udG9BcnJheSgpKV0pLnNsaWNlKC0yMCk7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBjb250cmFjdCBjcmVhdGVkIHVzaW5nIENSRUFURTIuXG4gKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0gc2FsdCBBIHNhbHRcbiAqIEBwYXJhbSBpbml0Q29kZSBUaGUgaW5pdCBjb2RlIG9mIHRoZSBjb250cmFjdCBiZWluZyBjcmVhdGVkXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzMiA9IGZ1bmN0aW9uIChmcm9tLCBzYWx0LCBpbml0Q29kZSkge1xuICAgIHZhciBmcm9tQnVmID0gYnl0ZXNfMS50b0J1ZmZlcihmcm9tKTtcbiAgICB2YXIgc2FsdEJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoc2FsdCk7XG4gICAgdmFyIGluaXRDb2RlQnVmID0gYnl0ZXNfMS50b0J1ZmZlcihpbml0Q29kZSk7XG4gICAgYXNzZXJ0KGZyb21CdWYubGVuZ3RoID09PSAyMCk7XG4gICAgYXNzZXJ0KHNhbHRCdWYubGVuZ3RoID09PSAzMik7XG4gICAgdmFyIGFkZHJlc3MgPSBoYXNoXzEua2VjY2FrMjU2KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCdmZicsICdoZXgnKSwgZnJvbUJ1Ziwgc2FsdEJ1ZiwgaGFzaF8xLmtlY2NhazI1Nihpbml0Q29kZUJ1ZildKSk7XG4gICAgcmV0dXJuIGFkZHJlc3Muc2xpY2UoLTIwKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3VwcGxpZWQgYWRkcmVzcyBiZWxvbmdzIHRvIGEgcHJlY29tcGlsZWQgYWNjb3VudCAoQnl6YW50aXVtKS5cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgYSA9IGJ5dGVzXzEudW5wYWQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgc2FuaXRpemUpIHtcbiAgICBpZiAoc2FuaXRpemUgPT09IHZvaWQgMCkgeyBzYW5pdGl6ZSA9IGZhbHNlOyB9XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgICB9XG4gICAgaWYgKCFzYW5pdGl6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplKSB7XG4gICAgaWYgKHNhbml0aXplID09PSB2b2lkIDApIHsgc2FuaXRpemUgPSBmYWxzZTsgfVxuICAgIHB1YktleSA9IGJ5dGVzXzEudG9CdWZmZXIocHViS2V5KTtcbiAgICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgcHViS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIGhhc2hfMS5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcbmV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3M7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKGV4cG9ydHMucHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICBwcml2YXRlS2V5ID0gYnl0ZXNfMS50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAgcHVibGljS2V5ID0gYnl0ZXNfMS50b0J1ZmZlcihwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICBwdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZXhwb3J0cy5mcm9tUnBjU2lnID0gZXhwb3J0cy50b1JwY1NpZyA9IGV4cG9ydHMuZWNyZWNvdmVyID0gZXhwb3J0cy5lY3NpZ24gPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1hZGFwdGVyJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG4vKipcbiAqIFJldHVybnMgdGhlIEVDRFNBIHNpZ25hdHVyZSBvZiBhIG1lc3NhZ2UgaGFzaC5cbiAqL1xuZXhwb3J0cy5lY3NpZ24gPSBmdW5jdGlvbiAobXNnSGFzaCwgcHJpdmF0ZUtleSwgY2hhaW5JZCkge1xuICAgIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICB2YXIgcmVjb3ZlcnkgPSBzaWcucmVjb3Zlcnk7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgcjogc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMiksXG4gICAgICAgIHM6IHNpZy5zaWduYXR1cmUuc2xpY2UoMzIsIDY0KSxcbiAgICAgICAgdjogY2hhaW5JZCA/IHJlY292ZXJ5ICsgKGNoYWluSWQgKiAyICsgMzUpIDogcmVjb3ZlcnkgKyAyNyxcbiAgICB9O1xuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlLlxuICogQHJldHVybnMgUmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcywgY2hhaW5JZCkge1xuICAgIHZhciBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFtieXRlc18xLnNldExlbmd0aChyLCAzMiksIGJ5dGVzXzEuc2V0TGVuZ3RoKHMsIDMyKV0sIDY0KTtcbiAgICB2YXIgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2QuXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgdmFyIHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAgIHJldHVybiBieXRlc18xLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2J5dGVzXzEuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGJ5dGVzXzEudG9CdWZmZXIodildKSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgYnVmID0gYnl0ZXNfMS50b0J1ZmZlcihzaWcpO1xuICAgIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAgaWYgKGJ1Zi5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgfVxuICAgIHZhciB2ID0gYnVmWzY0XTtcbiAgICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgICBpZiAodiA8IDI3KSB7XG4gICAgICAgIHYgKz0gMjc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHY6IHYsXG4gICAgICAgIHI6IGJ1Zi5zbGljZSgwLCAzMiksXG4gICAgICAgIHM6IGJ1Zi5zbGljZSgzMiwgNjQpLFxuICAgIH07XG59O1xuLyoqXG4gKiBWYWxpZGF0ZSBhIEVDRFNBIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBob21lc3RlYWRPckxhdGVyIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYmVpbmcgdXNlZCBvbiBlaXRoZXIgdGhlIGhvbWVzdGVhZCBoYXJkZm9yayBvciBhIGxhdGVyIG9uZVxuICovXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkT3JMYXRlciwgY2hhaW5JZCkge1xuICAgIGlmIChob21lc3RlYWRPckxhdGVyID09PSB2b2lkIDApIHsgaG9tZXN0ZWFkT3JMYXRlciA9IHRydWU7IH1cbiAgICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gICAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkoY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHJCTiA9IG5ldyBCTihyKTtcbiAgICB2YXIgc0JOID0gbmV3IEJOKHMpO1xuICAgIGlmIChyQk4uaXNaZXJvKCkgfHwgckJOLmd0KFNFQ1AyNTZLMV9OKSB8fCBzQk4uaXNaZXJvKCkgfHwgc0JOLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChob21lc3RlYWRPckxhdGVyICYmIHNCTi5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB2YXIgcHJlZml4ID0gQnVmZmVyLmZyb20oXCJcXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCIgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpLCAndXRmLTgnKTtcbiAgICByZXR1cm4gaGFzaF8xLmtlY2NhayhCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSk7XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkge1xuICAgIHJldHVybiBjaGFpbklkID8gdiAtICgyICogY2hhaW5JZCArIDM1KSA6IHYgLSAyNztcbn1cbmZ1bmN0aW9uIGlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkge1xuICAgIHJldHVybiByZWNvdmVyeSA9PT0gMCB8fCByZWNvdmVyeSA9PT0gMTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLmFkZEhleFByZWZpeCA9IGV4cG9ydHMudG9VbnNpZ25lZCA9IGV4cG9ydHMuZnJvbVNpZ25lZCA9IGV4cG9ydHMuYnVmZmVyVG9IZXggPSBleHBvcnRzLmJ1ZmZlclRvSW50ID0gZXhwb3J0cy50b0J1ZmZlciA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGV4cG9ydHMudW5wYWQgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGggPSBleHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnplcm9zID0gdm9pZCAwO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyfEFycmF5KVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0gcmlnaHQgd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheSlcbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIGlmIChyaWdodCA9PT0gdm9pZCAwKSB7IHJpZ2h0ID0gZmFsc2U7IH1cbiAgICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICAgIG1zZyA9IGV4cG9ydHMudG9CdWZmZXIobXNnKTtcbiAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICAgIH1cbn07XG5leHBvcnRzLnNldExlbmd0aCA9IGV4cG9ydHMuc2V0TGVuZ3RoTGVmdDtcbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcnxBcnJheSlcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyfEFycmF5KVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmV4cG9ydHMudW5wYWQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEgPSBldGhqc1V0aWwuc3RyaXBIZXhQcmVmaXgoYSk7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5leHBvcnRzLnN0cmlwWmVyb3MgPSBleHBvcnRzLnVucGFkO1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZXRoanNVdGlsLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV0aGpzVXRpbC5wYWRUb0V2ZW4oZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiBcIiArIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdiA9IGV0aGpzVXRpbC5pbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICAgICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmAuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiBuZXcgQk4oZXhwb3J0cy50b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgYDB4YC1wcmVmaXhlZCBoZXggYFN0cmluZ2AuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgYnVmID0gZXhwb3J0cy50b0J1ZmZlcihidWYpO1xuICAgIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0gbnVtIFNpZ25lZCBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gbmV3IEJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiLlxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGpzVXRpbC5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT04uXG4gKiBAcGFyYW0gYmEgKEJ1ZmZlcnxBcnJheSlcbiAqIEByZXR1cm4gKEFycmF5fFN0cmluZ3xudWxsKVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IHZvaWQgMDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIERlZmluZXMgcHJvcGVydGllcyBvbiBhIGBPYmplY3RgLiBJdCBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgdW5kZXJseWluZyBkYXRhIGlzIGJpbmFyeS5cbiAqIEBwYXJhbSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxuICogQHBhcmFtIGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgICBzZWxmLnJhdyA9IFtdO1xuICAgIHNlbGYuX2ZpZWxkcyA9IFtdO1xuICAgIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICBpZiAobGFiZWwgPT09IHZvaWQgMCkgeyBsYWJlbCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgdmFyIG9ial8xID0ge307XG4gICAgICAgICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBvYmpfMVtmaWVsZF0gPSBcIjB4XCIgKyBzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmpfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXNfMS5iYVRvSlNPTihzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBzZWxmLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICAgIH07XG4gICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpKSB7XG4gICAgICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgICAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgICAgICAgIHYgPSBieXRlc18xLnRvQnVmZmVyKHYpO1xuICAgICAgICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2ID0gYnl0ZXNfMS5zdHJpcFplcm9zKHYpO1xuICAgICAgICAgICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiICsgZmllbGQubmFtZSArIFwiIG11c3Qgbm90IGhhdmUgbW9yZSBcIiArIGZpZWxkLmxlbmd0aCArIFwiIGJ5dGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCBcIlRoZSBmaWVsZCBcIiArIGZpZWxkLm5hbWUgKyBcIiBtdXN0IGhhdmUgYnl0ZSBsZW5ndGggb2YgXCIgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICAgICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV0aGpzVXRpbC5zdHJpcEhleFByZWZpeChkYXRhKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBybHAuZGVjb2RlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBieXRlc18xLnRvQnVmZmVyKGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIga2V5c18xID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5c18xLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5c18xLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscGhhc2ggPSBleHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5rZWNjYWsyNTYgPSBleHBvcnRzLmtlY2NhayA9IHZvaWQgMDtcbnZhciBfYSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnKSwga2VjY2FrMjI0ID0gX2Eua2VjY2FrMjI0LCBrZWNjYWszODQgPSBfYS5rZWNjYWszODQsIGsyNTYgPSBfYS5rZWNjYWsyNTYsIGtlY2NhazUxMiA9IF9hLmtlY2NhazUxMjtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgcmxwID0gcmVxdWlyZShcInJscFwiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpIElmIHRoZSBzdHJpbmcgaXMgYSAweC1wcmVmaXhlZCBoZXggdmFsdWVcbiAqIGl0J3MgaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWwsIG90aGVyd2lzZSBhcyB1dGY4LlxuICogQHBhcmFtIGJpdHMgVGhlIEtlY2NhayB3aWR0aFxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gICAgaWYgKGJpdHMgPT09IHZvaWQgMCkgeyBiaXRzID0gMjU2OyB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiAhZXRoanNVdGlsLmlzSGV4U3RyaW5nKGEpKSB7XG4gICAgICAgIGEgPSBCdWZmZXIuZnJvbShhLCAndXRmOCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYSA9IGJ5dGVzXzEudG9CdWZmZXIoYSk7XG4gICAgfVxuICAgIGlmICghYml0cylcbiAgICAgICAgYml0cyA9IDI1NjtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAyMjQ6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNTY6IHtcbiAgICAgICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzg0OiB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTEyOiB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsZCBhbGdvcml0aG06IGtlY2Nha1wiICsgYml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KS5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcilcbiAqL1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgYSA9IGJ5dGVzXzEudG9CdWZmZXIoYSk7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUoYSlcbiAgICAgICAgLmRpZ2VzdCgpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXG4gKiBAcGFyYW0gcGFkZGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgYSA9IGJ5dGVzXzEudG9CdWZmZXIoYSk7XG4gICAgdmFyIGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKVxuICAgICAgICAudXBkYXRlKGEpXG4gICAgICAgIC5kaWdlc3QoKTtcbiAgICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBieXRlc18xLnNldExlbmd0aChoYXNoLCAzMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGFcbiAqL1xuZXhwb3J0cy5ybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lY2RoVW5zYWZlID0gZXhwb3J0cy5lY2RoID0gZXhwb3J0cy5yZWNvdmVyID0gZXhwb3J0cy52ZXJpZnkgPSBleHBvcnRzLnNpZ24gPSBleHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZXhwb3J0cy5zaWduYXR1cmVFeHBvcnQgPSBleHBvcnRzLnNpZ25hdHVyZU5vcm1hbGl6ZSA9IGV4cG9ydHMucHVibGljS2V5Q29tYmluZSA9IGV4cG9ydHMucHVibGljS2V5VHdlYWtNdWwgPSBleHBvcnRzLnB1YmxpY0tleVR3ZWFrQWRkID0gZXhwb3J0cy5wdWJsaWNLZXlWZXJpZnkgPSBleHBvcnRzLnB1YmxpY0tleUNvbnZlcnQgPSBleHBvcnRzLnB1YmxpY0tleUNyZWF0ZSA9IGV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrTXVsID0gZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtBZGQgPSBleHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZXhwb3J0cy5wcml2YXRlS2V5TmVnYXRlID0gZXhwb3J0cy5wcml2YXRlS2V5SW1wb3J0ID0gZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gdm9pZCAwO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEnKTtcbnZhciBzZWNwMjU2azF2MyA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtbGliL2luZGV4Jyk7XG52YXIgZGVyID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1saWIvZGVyJyk7XG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwcml2YXRlS2V5XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHByaXZhdGVLZXkgbGVuZ3RoIGlzIG5vdCAzMlxuICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKTtcbn07XG4vKipcbiAqIEV4cG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5RXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHByaXZhdGVLZXkgbGVuZ3RoIGlzIG5vdCAzMlxuICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHZhciBwdWJsaWNLZXkgPSBzZWNwMjU2azF2My5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpO1xuICAgIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpO1xufTtcbi8qKlxuICogSW1wb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgLy8gcHJpdmF0ZUtleUltcG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gICAgcHJpdmF0ZUtleSA9IGRlci5wcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpO1xuICAgIGlmIChwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBleHBvcnRzLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IGltcG9ydCBmcm9tIERFUiBmb3JtYXRcIik7XG59O1xuLyoqXG4gKiBOZWdhdGUgYSBwcml2YXRlS2V5IGJ5IHN1YnRyYWN0aW5nIGl0IGZyb20gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleU5lZ2F0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGEgcHJpdmF0ZUtleSAobW9kdWxvIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50KS5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleU1vZEludmVyc2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMucHJpdmF0ZUtleU1vZEludmVyc2UoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgYWRkaW5nIHR3ZWFrIHRvIGl0LlxuICogQG1ldGhvZCBwcml2YXRlS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHR3ZWFrKSk7XG59O1xuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2Vhay5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrTXVsID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspKSk7XG59O1xuLyoqXG4gKiBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciBhIHByaXZhdGVLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNyZWF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YmxpY0tleUNyZWF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgcHVibGljS2V5IHRvIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkIGZvcm0uXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNvbnZlcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YmxpY0tleUNvbnZlcnQgPSBmdW5jdGlvbiAocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHVibGljS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHB1YmxpY0tleSBsZW5ndGggaXMgbm90IDMzIG9yIDY1XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xufTtcbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgYWRkaW5nIHR3ZWFrIHRpbWVzIHRoZSBnZW5lcmF0b3IgdG8gaXQuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YmxpY0tleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrIHZhbHVlXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBBZGQgYSBnaXZlbiBwdWJsaWNLZXlzIHRvZ2V0aGVyLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb21iaW5lXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IHB1YmxpY0tleXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgcHVibGljS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAgICAga2V5cy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbWJpbmUoa2V5cywgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQ29udmVydCBhIHNpZ25hdHVyZSB0byBhIG5vcm1hbGl6ZWQgbG93ZXItUyBmb3JtLlxuICogQG1ldGhvZCBzaWduYXR1cmVOb3JtYWxpemVcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduYXR1cmVOb3JtYWxpemUgPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBFQ0RTQSBzaWduYXR1cmUgaW4gREVSIGZvcm1hdC5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlRXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChub3QgZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0TGF4XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIC8vIHNpZ25hdHVyZUltcG9ydExheCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gICAgLy8gZW5zdXJlIHRoYXQgc2lnbmF0dXJlIGlzIGdyZWF0ZXIgdGhhbiAwXG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpZ25hdHVyZSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpO1xuICAgIGlmIChzaWdPYmogPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgcGFyc2UgREVSIHNpZ25hdHVyZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3AyNTZrMXYzLnNpZ25hdHVyZUltcG9ydChzaWdPYmopO1xufTtcbi8qKlxuICogQ3JlYXRlIGFuIEVDRFNBIHNpZ25hdHVyZS4gQWx3YXlzIHJldHVybiBsb3ctUyBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBhbiBPYmplY3QnKTtcbiAgICB9XG4gICAgdmFyIHNpZ25PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHNpZ25PcHRpb25zID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIG9wdGlvbi5kYXRhIGxlbmd0aFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubGVuZ3RoICE9IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29wdGlvbnMuZGF0YSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbk9wdGlvbnMuZGF0YSA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2VmbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5ub25jZWZuIHNob3VsZCBiZSBhIEZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgICAgICAgLy8gY29udmVydCBvcHRpb24ubm9uY2VmbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgICAgICAgIHNpZ25PcHRpb25zLm5vbmNlZm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgYWxnbywgZGF0YSwgYXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXJBbGdvID0gYWxnbyAhPSBudWxsID8gQnVmZmVyLmZyb20oYWxnbykgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXJEYXRhID0gZGF0YSAhPSBudWxsID8gQnVmZmVyLmZyb20oZGF0YSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbSgnJyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBvcHRpb25zLm5vbmNlZm4oQnVmZmVyLmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHByaXZhdGVLZXkpLCBidWZmZXJBbGdvLCBidWZmZXJEYXRhLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzaWcgPSBzZWNwMjU2azEuZWNkc2FTaWduKFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBzaWduT3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuc2lnbmF0dXJlKSxcbiAgICAgICAgcmVjb3Zlcnk6IHNpZy5yZWNpZCxcbiAgICB9O1xufTtcbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgdmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy52ZXJpZnkgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIHB1YmxpY0tleSk7XG59O1xuLyoqXG4gKiBSZWNvdmVyIGFuIEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgcmVjb3ZlclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWNpZFxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmVjb3ZlciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHJlY2lkLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RzYVJlY292ZXIoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIHJlY2lkLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCBhcHBsaWVkIHNoYTI1NiB0byBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gKiBAbWV0aG9kIGVjZGhcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZWNkaCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICAvLyBub3RlOiBzZWNwMjU2azEgdjMgZG9lc24ndCBhbGxvdyBvcHRpb25hbCBwYXJhbWV0ZXJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZGgoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwge30pKTtcbn07XG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgLy8gZWNkaFVuc2FmZSBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gICAgLy8gZW5zdXJlIHZhbGlkIHB1YmxpY0tleSBsZW5ndGhcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3B1YmxpYyBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIHZhbGlkIHByaXZhdGVLZXkgbGVuZ3RoXG4gICAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLmVjZGhVbnNhZmUoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMXYzLWFkYXB0ZXIuanMubWFwIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIHRoZVxuLy8gYnJvd3NlciB0aGlzIGlzIGEgbGl0dGxlIGNvbXBsaWNhdGVkIGR1ZSB0byB1bmtub3duIHF1YWxpdHkgb2YgTWF0aC5yYW5kb20oKVxuLy8gYW5kIGluY29uc2lzdGVudCBzdXBwb3J0IGZvciB0aGUgYGNyeXB0b2AgQVBJLiAgV2UgZG8gdGhlIGJlc3Qgd2UgY2FuIHZpYVxuLy8gZmVhdHVyZS1kZXRlY3Rpb25cblxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvXG4vLyBpbXBsZW1lbnRhdGlvbi4gQWxzbywgZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIG9uIElFMTEuXG52YXIgZ2V0UmFuZG9tVmFsdWVzID0gKHR5cGVvZihjcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0bykpO1xuXG5pZiAoZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8gUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICB2YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xuICAgIHJldHVybiBybmRzODtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWF0aFJORygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cbiIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuICByZXR1cm4gKFtidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCJjb25zdCBmaWx0ZXJOb29wID0gKCkgPT4gdHJ1ZVxuY29uc3QgaW50ZXJuYWxFdmVudHMgPSBbJ25ld0xpc3RlbmVyJywgJ3JlbW92ZUxpc3RlbmVyJ11cbmNvbnN0IGV4dGVybmFsRXZlbnRGaWx0ZXIgPSAobmFtZSkgPT4gIWludGVybmFsRXZlbnRzLmluY2x1ZGVzKG5hbWUpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgKGluaXRpYWxUYXJnZXQsIG9wdHMpIHtcbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICBsZXQgZXZlbnRGaWx0ZXIgPSBvcHRzLmV2ZW50RmlsdGVyIHx8IGZpbHRlck5vb3BcbiAgaWYgKGV2ZW50RmlsdGVyID09PSAnc2tpcEludGVybmFsJykgZXZlbnRGaWx0ZXIgPSBleHRlcm5hbEV2ZW50RmlsdGVyXG4gIGlmICh0eXBlb2YgZXZlbnRGaWx0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgLSBJbnZhbGlkIGV2ZW50RmlsdGVyJylcblxuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldFxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gJ3NldFRhcmdldCcpIHJldHVybiBzZXRUYXJnZXRcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSAnc2V0VGFyZ2V0Jykge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcHJveHlcblxuICBmdW5jdGlvbiBzZXRUYXJnZXQobmV3VGFyZ2V0KSB7XG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0XG4gICAgLy8gbWlncmF0ZSBsaXN0ZW5lcnNcbiAgICBvbGRUYXJnZXQuZXZlbnROYW1lcygpLmZpbHRlcihldmVudEZpbHRlcikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgZ2V0UmF3TGlzdGVuZXJzKG9sZFRhcmdldCwgbmFtZSkuZm9yRWFjaChoYW5kbGVyID0+IG5ld1RhcmdldC5vbihuYW1lLCBoYW5kbGVyKSlcbiAgICB9KVxuICAgIC8vIHJlbW92ZSBvbGRcbiAgICBvbGRUYXJnZXQucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSYXdMaXN0ZW5lcnMoZXZlbnRFbWl0dGVyLCBuYW1lKSB7XG4gIC8vIHByZWZlciBuYXRpdmVcbiAgaWYgKGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMpIHJldHVybiBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzKG5hbWUpXG4gIC8vIGZhbGxiYWNrIHRvIGxvb2t1cCBhZ2FpbnN0IGludGVybmFsIG9iamVjdFxuICBsZXQgZXZlbnRzID0gZXZlbnRFbWl0dGVyLl9ldmVudHNbbmFtZV0gfHwgW11cbiAgLy8gZW5zdXJlIGFycmF5XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpKSBldmVudHMgPSBbZXZlbnRzXVxuICAvLyByZXR1cm4gY29weVxuICByZXR1cm4gZXZlbnRzLnNsaWNlKClcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVTd2FwcGFibGVQcm94eSAoaW5pdGlhbFRhcmdldCkge1xuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldFxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gJ3NldFRhcmdldCcpIHJldHVybiBzZXRUYXJnZXRcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSAnc2V0VGFyZ2V0Jykge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcHJveHlcblxuICBmdW5jdGlvbiBzZXRUYXJnZXQobmV3VGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQmFzZUJsb2NrVHJhY2tlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUG9sbGluZ0Jsb2NrVHJhY2tlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU3Vic2NyaWJlQmxvY2tUcmFja2VyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIEJhc2U1OCBlbmNvZGluZy9kZWNvZGluZ1xuLy8gT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuLy8gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuLy8gTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcblxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG52YXIgQUxQSEFCRVRfTUFQID0ge31cbmZvcih2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICBBTFBIQUJFVF9NQVBbQUxQSEFCRVQuY2hhckF0KGkpXSA9IGlcbn1cbnZhciBCQVNFID0gNThcblxuZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG5cbiAgdmFyIGksIGosIGRpZ2l0cyA9IFswXVxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7IGorKykgZGlnaXRzW2pdIDw8PSA4XG5cbiAgICBkaWdpdHNbMF0gKz0gYnVmZmVyW2ldXG5cbiAgICB2YXIgY2FycnkgPSAwXG4gICAgZm9yIChqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgZGlnaXRzW2pdICs9IGNhcnJ5XG5cbiAgICAgIGNhcnJ5ID0gKGRpZ2l0c1tqXSAvIEJBU0UpIHwgMFxuICAgICAgZGlnaXRzW2pdICU9IEJBU0VcbiAgICB9XG5cbiAgICB3aGlsZSAoY2FycnkpIHtcbiAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgQkFTRSlcblxuICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSB8IDBcbiAgICB9XG4gIH1cblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IgKGkgPSAwOyBidWZmZXJbaV0gPT09IDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIGRpZ2l0cy5wdXNoKDApXG5cbiAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgdmFyIHN0cmluZ091dHB1dCA9IFwiXCJcbiAgZm9yICh2YXIgaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN0cmluZ091dHB1dCA9IHN0cmluZ091dHB1dCArIEFMUEhBQkVUW2RpZ2l0c1tpXV1cbiAgfVxuICByZXR1cm4gc3RyaW5nT3V0cHV0XG59XG5cbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBbXVxuXG4gIHZhciBpLCBqLCBieXRlcyA9IFswXVxuICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHJpbmdbaV1cbiAgICBpZiAoIShjIGluIEFMUEhBQkVUX01BUCkpIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2U1OCBjaGFyYWN0ZXInKVxuXG4gICAgZm9yIChqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgaisrKSBieXRlc1tqXSAqPSBCQVNFXG4gICAgYnl0ZXNbMF0gKz0gQUxQSEFCRVRfTUFQW2NdXG5cbiAgICB2YXIgY2FycnkgPSAwXG4gICAgZm9yIChqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBieXRlc1tqXSArPSBjYXJyeVxuXG4gICAgICBjYXJyeSA9IGJ5dGVzW2pdID4+IDhcbiAgICAgIGJ5dGVzW2pdICY9IDB4ZmZcbiAgICB9XG5cbiAgICB3aGlsZSAoY2FycnkpIHtcbiAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKVxuXG4gICAgICBjYXJyeSA+Pj0gOFxuICAgIH1cbiAgfVxuXG4gIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gIGZvciAoaSA9IDA7IHN0cmluZ1tpXSA9PT0gJzEnICYmIGkgPCBzdHJpbmcubGVuZ3RoIC0gMTsgaSsrKSBieXRlcy5wdXNoKDApXG5cbiAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGRlY29kZTogZGVjb2RlXG59XG4iLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2FyZGFub1R4V2l0bmVzc1R5cGUgPSBleHBvcnRzLkNhcmRhbm9UeFNpZ25pbmdNb2RlID0gZXhwb3J0cy5DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IGV4cG9ydHMuQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gZXhwb3J0cy5DYXJkYW5vTmF0aXZlU2NyaXB0VHlwZSA9IGV4cG9ydHMuQ2FyZGFub0NlcnRpZmljYXRlVHlwZSA9IGV4cG9ydHMuQ2FyZGFub0FkZHJlc3NUeXBlID0gdm9pZCAwO1xuXG52YXIgX3Byb3RvYnVmID0gcmVxdWlyZShcIi4uL3RyZXpvci9wcm90b2J1ZlwiKTtcblxuZXhwb3J0cy5DYXJkYW5vQWRkcmVzc1R5cGUgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vQWRkcmVzc1R5cGU7XG5leHBvcnRzLkNhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vQ2VydGlmaWNhdGVUeXBlO1xuZXhwb3J0cy5DYXJkYW5vTmF0aXZlU2NyaXB0VHlwZSA9IF9wcm90b2J1Zi5FbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlO1xuZXhwb3J0cy5DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQ7XG5leHBvcnRzLkNhcmRhbm9Qb29sUmVsYXlUeXBlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGU7XG5leHBvcnRzLkNhcmRhbm9UeFNpZ25pbmdNb2RlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub1R4U2lnbmluZ01vZGU7XG5leHBvcnRzLkNhcmRhbm9UeFdpdG5lc3NUeXBlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub1R4V2l0bmVzc1R5cGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDT05TVEFOVFMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpKTtcblxudmFyIFAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9wYXJhbXNcIikpO1xuXG52YXIgRGV2aWNlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdHJlem9yL2RldmljZVwiKSk7XG5cbnZhciBNZ21udCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3RyZXpvci9tYW5hZ2VtZW50XCIpKTtcblxudmFyIFByb3RvYnVmID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdHJlem9yL3Byb3RvYnVmXCIpKTtcblxudmFyIEFjY291bnQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9hY2NvdW50XCIpKTtcblxudmFyIEJpdGNvaW4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9iaXRjb2luXCIpKTtcblxudmFyIEJpbmFuY2UgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9iaW5hbmNlXCIpKTtcblxudmFyIENhcmRhbm8gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9jYXJkYW5vXCIpKTtcblxudmFyIENvaW5JbmZvID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvY29pbkluZm9cIikpO1xuXG52YXIgRU9TID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvZW9zXCIpKTtcblxudmFyIEV0aGVyZXVtID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvZXRoZXJldW1cIikpO1xuXG52YXIgTkVNID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvbmVtXCIpKTtcblxudmFyIFJpcHBsZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL3JpcHBsZVwiKSk7XG5cbnZhciBTdGVsbGFyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3Mvc3RlbGxhclwiKSk7XG5cbnZhciBUZXpvcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL3Rlem9zXCIpKTtcblxudmFyIE1pc2MgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9taXNjXCIpKTtcblxudmFyIEV2ZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2V2ZW50c1wiKSk7XG5cbnZhciBCbG9ja2NoYWluID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vYmFja2VuZC9ibG9ja2NoYWluXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRklBVF9SQVRFU19VUERBVEUgPSBleHBvcnRzLk5PVElGSUNBVElPTiA9IGV4cG9ydHMuQkxPQ0sgPSBleHBvcnRzLkNPTk5FQ1QgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuLy8gYmxvY2tjaGFpbiBldmVudHNcbnZhciBFUlJPUiA9ICdibG9ja2NoYWluLWVycm9yJztcbmV4cG9ydHMuRVJST1IgPSBFUlJPUjtcbnZhciBDT05ORUNUID0gJ2Jsb2NrY2hhaW4tY29ubmVjdCc7XG5leHBvcnRzLkNPTk5FQ1QgPSBDT05ORUNUO1xudmFyIEJMT0NLID0gJ2Jsb2NrY2hhaW4tYmxvY2snO1xuZXhwb3J0cy5CTE9DSyA9IEJMT0NLO1xudmFyIE5PVElGSUNBVElPTiA9ICdibG9ja2NoYWluLW5vdGlmaWNhdGlvbic7XG5leHBvcnRzLk5PVElGSUNBVElPTiA9IE5PVElGSUNBVElPTjtcbnZhciBGSUFUX1JBVEVTX1VQREFURSA9ICdmaWF0LXJhdGVzLXVwZGF0ZSc7XG5leHBvcnRzLkZJQVRfUkFURVNfVVBEQVRFID0gRklBVF9SQVRFU19VUERBVEU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLldBSVRfRk9SX1NFTEVDVElPTiA9IGV4cG9ydHMuV09SRCA9IGV4cG9ydHMuUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSBleHBvcnRzLlBBU1NQSFJBU0UgPSBleHBvcnRzLlBJTiA9IGV4cG9ydHMuQlVUVE9OID0gZXhwb3J0cy5MT0FESU5HID0gZXhwb3J0cy5VU0VEX0VMU0VXSEVSRSA9IGV4cG9ydHMuUkVMRUFTRUQgPSBleHBvcnRzLkFDUVVJUkVEID0gZXhwb3J0cy5SRUxFQVNFID0gZXhwb3J0cy5BQ1FVSVJFID0gZXhwb3J0cy5DSEFOR0VEID0gZXhwb3J0cy5ESVNDT05ORUNUID0gZXhwb3J0cy5DT05ORUNUX1VOQUNRVUlSRUQgPSBleHBvcnRzLkNPTk5FQ1QgPSB2b2lkIDA7XG4vLyBkZXZpY2UgbGlzdCBldmVudHNcbnZhciBDT05ORUNUID0gJ2RldmljZS1jb25uZWN0JztcbmV4cG9ydHMuQ09OTkVDVCA9IENPTk5FQ1Q7XG52YXIgQ09OTkVDVF9VTkFDUVVJUkVEID0gJ2RldmljZS1jb25uZWN0X3VuYWNxdWlyZWQnO1xuZXhwb3J0cy5DT05ORUNUX1VOQUNRVUlSRUQgPSBDT05ORUNUX1VOQUNRVUlSRUQ7XG52YXIgRElTQ09OTkVDVCA9ICdkZXZpY2UtZGlzY29ubmVjdCc7XG5leHBvcnRzLkRJU0NPTk5FQ1QgPSBESVNDT05ORUNUO1xudmFyIENIQU5HRUQgPSAnZGV2aWNlLWNoYW5nZWQnO1xuZXhwb3J0cy5DSEFOR0VEID0gQ0hBTkdFRDtcbnZhciBBQ1FVSVJFID0gJ2RldmljZS1hY3F1aXJlJztcbmV4cG9ydHMuQUNRVUlSRSA9IEFDUVVJUkU7XG52YXIgUkVMRUFTRSA9ICdkZXZpY2UtcmVsZWFzZSc7XG5leHBvcnRzLlJFTEVBU0UgPSBSRUxFQVNFO1xudmFyIEFDUVVJUkVEID0gJ2RldmljZS1hY3F1aXJlZCc7XG5leHBvcnRzLkFDUVVJUkVEID0gQUNRVUlSRUQ7XG52YXIgUkVMRUFTRUQgPSAnZGV2aWNlLXJlbGVhc2VkJztcbmV4cG9ydHMuUkVMRUFTRUQgPSBSRUxFQVNFRDtcbnZhciBVU0VEX0VMU0VXSEVSRSA9ICdkZXZpY2UtdXNlZF9lbHNld2hlcmUnO1xuZXhwb3J0cy5VU0VEX0VMU0VXSEVSRSA9IFVTRURfRUxTRVdIRVJFO1xudmFyIExPQURJTkcgPSAnZGV2aWNlLWxvYWRpbmcnOyAvLyB0cmV6b3ItbGluayBldmVudHMgaW4gcHJvdG9idWYgZm9ybWF0XG5cbmV4cG9ydHMuTE9BRElORyA9IExPQURJTkc7XG52YXIgQlVUVE9OID0gJ2J1dHRvbic7XG5leHBvcnRzLkJVVFRPTiA9IEJVVFRPTjtcbnZhciBQSU4gPSAncGluJztcbmV4cG9ydHMuUElOID0gUElOO1xudmFyIFBBU1NQSFJBU0UgPSAncGFzc3BocmFzZSc7XG5leHBvcnRzLlBBU1NQSFJBU0UgPSBQQVNTUEhSQVNFO1xudmFyIFBBU1NQSFJBU0VfT05fREVWSUNFID0gJ3Bhc3NwaHJhc2Vfb25fZGV2aWNlJztcbmV4cG9ydHMuUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSBQQVNTUEhSQVNFX09OX0RFVklDRTtcbnZhciBXT1JEID0gJ3dvcmQnOyAvLyBjdXN0b21cblxuZXhwb3J0cy5XT1JEID0gV09SRDtcbnZhciBXQUlUX0ZPUl9TRUxFQ1RJT04gPSAnZGV2aWNlLXdhaXRfZm9yX3NlbGVjdGlvbic7XG5leHBvcnRzLldBSVRfRk9SX1NFTEVDVElPTiA9IFdBSVRfRk9SX1NFTEVDVElPTjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ0FMTCA9IGV4cG9ydHMuRVJST1IgPSBleHBvcnRzLklOSVQgPSBleHBvcnRzLkxPQURFRCA9IGV4cG9ydHMuQk9PVFNUUkFQID0gdm9pZCAwO1xuLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpZnJhbWUuaHRtbCBpbmxpbmUgc2NyaXB0IGJlZm9yZSBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gaWZyYW1lIHRvIHdpbmRvdy5vcGVuZXIuXG52YXIgQk9PVFNUUkFQID0gJ2lmcmFtZS1ib290c3RyYXAnOyAvLyBNZXNzYWdlIGZyb20gaWZyYW1lLmpzIHRvIHdpbmRvdy5vcGVuZXIsIGNhbGxlZCBhZnRlciBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBzZWNvbmQgbWVzc2FnZSBmcm9tIGlmcmFtZSB0byB3aW5kb3cub3BlbmVyLlxuXG5leHBvcnRzLkJPT1RTVFJBUCA9IEJPT1RTVFJBUDtcbnZhciBMT0FERUQgPSAnaWZyYW1lLWxvYWRlZCc7IC8vIE1lc3NhZ2UgZnJvbSB3aW5kb3cub3BlbmVyIHRvIGlmcmFtZS5qc1xuXG5leHBvcnRzLkxPQURFRCA9IExPQURFRDtcbnZhciBJTklUID0gJ2lmcmFtZS1pbml0JzsgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIGlmcmFtZS5qcyB0byB3aW5kb3cub3BlbmVyLiBDb3VsZCBiZSB0aHJvd24gZHVyaW5nIGlmcmFtZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzXG5cbmV4cG9ydHMuSU5JVCA9IElOSVQ7XG52YXIgRVJST1IgPSAnaWZyYW1lLWVycm9yJzsgLy8gTWVzc2FnZSBmcm9tIHdpbmRvdy5vcGVuZXIgdG8gaWZyYW1lLiBDYWxsIG1ldGhvZFxuXG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgQ0FMTCA9ICdpZnJhbWUtY2FsbCc7XG5leHBvcnRzLkNBTEwgPSBDQUxMOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5UWVBFUyA9IHZvaWQgMDtcbnZhciBUWVBFUyA9IE9iamVjdC5mcmVlemUoe1xuICBiaXRjb2luOiAnQml0Y29pbicsXG4gIGV0aGVyZXVtOiAnRXRoZXJldW0nLFxuICBlb3M6ICdFb3MnLFxuICBuZW06ICdORU0nLFxuICBzdGVsbGFyOiAnU3RlbGxhcicsXG4gIGNhcmRhbm86ICdDYXJkYW5vJyxcbiAgcmlwcGxlOiAnUmlwcGxlJyxcbiAgdGV6b3M6ICdUZXpvcnMnLFxuICBiaW5hbmNlOiAnQmluYW5jZSdcbn0pO1xuZXhwb3J0cy5UWVBFUyA9IFRZUEVTOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DTE9TRV9XSU5ET1cgPSBleHBvcnRzLkNBTkNFTF9QT1BVUF9SRVFVRVNUID0gZXhwb3J0cy5DTE9TRUQgPSBleHBvcnRzLkhBTkRTSEFLRSA9IGV4cG9ydHMuRVhURU5TSU9OX1VTQl9QRVJNSVNTSU9OUyA9IGV4cG9ydHMuRVJST1IgPSBleHBvcnRzLklOSVQgPSBleHBvcnRzLkxPQURFRCA9IGV4cG9ydHMuQk9PVFNUUkFQID0gdm9pZCAwO1xuLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBwb3B1cC5odG1sIGlubGluZSBzY3JpcHQgYmVmb3JlIFwid2luZG93Lm9ubG9hZFwiIGV2ZW50LiBUaGlzIGlzIGZpcnN0IG1lc3NhZ2UgZnJvbSBwb3B1cCB0byB3aW5kb3cub3BlbmVyLlxudmFyIEJPT1RTVFJBUCA9ICdwb3B1cC1ib290c3RyYXAnOyAvLyBNZXNzYWdlIGZyb20gcG9wdXAuanMgdG8gd2luZG93Lm9wZW5lciwgY2FsbGVkIGFmdGVyIFwid2luZG93Lm9ubG9hZFwiIGV2ZW50LiBUaGlzIGlzIHNlY29uZCBtZXNzYWdlIGZyb20gcG9wdXAgdG8gd2luZG93Lm9wZW5lci5cblxuZXhwb3J0cy5CT09UU1RSQVAgPSBCT09UU1RSQVA7XG52YXIgTE9BREVEID0gJ3BvcHVwLWxvYWRlZCc7IC8vIE1lc3NhZ2UgZnJvbSB3aW5kb3cub3BlbmVyIHRvIHBvcHVwLmpzLiBTZW5kIHNldHRpbmdzIHRvIHBvcHVwLiBUaGlzIGlzIGZpcnN0IG1lc3NhZ2UgZnJvbSB3aW5kb3cub3BlbmVyIHRvIHBvcHVwLlxuXG5leHBvcnRzLkxPQURFRCA9IExPQURFRDtcbnZhciBJTklUID0gJ3BvcHVwLWluaXQnOyAvLyBFcnJvciBtZXNzYWdlIGZyb20gcG9wdXAgdG8gd2luZG93Lm9wZW5lci4gQ291bGQgYmUgdGhyb3duIGR1cmluZyBwb3B1cCBpbml0aWFsaXphdGlvbiBwcm9jZXNzIChQT1BVUC5JTklUKVxuXG5leHBvcnRzLklOSVQgPSBJTklUO1xudmFyIEVSUk9SID0gJ3BvcHVwLWVycm9yJzsgLy8gTWVzc2FnZSB0byB3ZWJleHRlbnNpb25zLCBvcGVucyBcInRyZXpvci11c2ItcGVybWlzc2lvbi5odG1sXCIgd2l0aGluIHdlYmV4dGVuc2lvblxuXG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgRVhURU5TSU9OX1VTQl9QRVJNSVNTSU9OUyA9ICdvcGVuLXVzYi1wZXJtaXNzaW9ucyc7IC8vIE1lc3NhZ2UgY2FsbGVkIGZyb20gYm90aCBbcG9wdXAgPiBpZnJhbWVdIHRoZW4gW2lmcmFtZSA+IHBvcHVwXSBpbiB0aGlzIGV4YWN0IG9yZGVyLlxuLy8gRmlyc3RseSBwb3B1cCBjYWxsIGlmcmFtZSB0byByZXNvbHZlIHBvcHVwIHByb21pc2UgaW4gQ29yZVxuLy8gVGhlbiBpZnJhbWUgcmVhY3RzIHRvIFBPUFVQLkhBTkRTSEFLRSBtZXNzYWdlIGFuZCBzZW5kcyBDb25uZWN0U2V0dGluZ3MsIHRyYW5zcG9ydCBpbmZvcm1hdGlvbiBhbmQgcmVxdWVzdGVkIG1ldGhvZCBkZXRhaWxzIGJhY2sgdG8gcG9wdXBcblxuZXhwb3J0cy5FWFRFTlNJT05fVVNCX1BFUk1JU1NJT05TID0gRVhURU5TSU9OX1VTQl9QRVJNSVNTSU9OUztcbnZhciBIQU5EU0hBS0UgPSAncG9wdXAtaGFuZHNoYWtlJzsgLy8gRXZlbnQgZW1pdHRlZCBmcm9tIFBvcHVwTWFuYWdlciBhdCB0aGUgZW5kIG9mIHBvcHVwIGNsb3NpbmcgcHJvY2Vzcy5cbi8vIFNlbnQgZnJvbSBwb3B1cCB0aHJ1IHdpbmRvdy5vcGVuZXIgdG8gYW4gaWZyYW1lIGJlY2F1c2UgbWVzc2FnZSBjaGFubmVsIGJldHdlZW4gcG9wdXAgYW5kIGlmcmFtZSBpcyBubyBsb25nZXIgYXZhaWxhYmxlXG5cbmV4cG9ydHMuSEFORFNIQUtFID0gSEFORFNIQUtFO1xudmFyIENMT1NFRCA9ICdwb3B1cC1jbG9zZWQnOyAvLyBNZXNzYWdlIGNhbGxlZCBmcm9tIGlmcmFtZSB0byBwb3B1cCwgaXQgbWVhbnMgdGhhdCBwb3B1cCB3aWxsIG5vdCBiZSBuZWVkZWQgKGV4YW1wbGU6IEJsb2NrY2hhaW4gbWV0aG9kcyBhcmUgbm90IHVzaW5nIHBvcHVwIGF0IGFsbClcbi8vIFRoaXMgd2lsbCBjbG9zZSBhY3RpdmUgcG9wdXAgd2luZG93IGFuZC9vciBjbGVhciBvcGVuaW5nIHByb2Nlc3MgaW4gUG9wdXBNYW5hZ2VyIChtYXliZSBwb3B1cCB3YXNuJ3Qgb3BlbmVkIHlldClcblxuZXhwb3J0cy5DTE9TRUQgPSBDTE9TRUQ7XG52YXIgQ0FOQ0VMX1BPUFVQX1JFUVVFU1QgPSAndWktY2FuY2VsLXBvcHVwLXJlcXVlc3QnOyAvLyBNZXNzYWdlIGNhbGxlZCBmcm9tIGlubGluZSBlbGVtZW50IGluIHBvcHVwLmh0bWwgKHdpbmRvdy5jbG9zZVdpbmRvdyksIHRoaXMgaXMgdXNlZCBvbmx5IHdpdGggd2ViZXh0ZW5zaW9ucyB0byBwcm9wZXJseSBoYW5kbGUgcG9wdXAgY2xvc2UgZXZlbnRcblxuZXhwb3J0cy5DQU5DRUxfUE9QVVBfUkVRVUVTVCA9IENBTkNFTF9QT1BVUF9SRVFVRVNUO1xudmFyIENMT1NFX1dJTkRPVyA9ICd3aW5kb3cuY2xvc2UnO1xuZXhwb3J0cy5DTE9TRV9XSU5ET1cgPSBDTE9TRV9XSU5ET1c7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlNUQVJUX1BFTkRJTkcgPSBleHBvcnRzLkRJU0FCTEVfV0VCVVNCID0gZXhwb3J0cy5SRVFVRVNUID0gZXhwb3J0cy5TVFJFQU0gPSBleHBvcnRzLlVQREFURSA9IGV4cG9ydHMuRVJST1IgPSBleHBvcnRzLlNUQVJUID0gdm9pZCAwO1xudmFyIFNUQVJUID0gJ3RyYW5zcG9ydC1zdGFydCc7XG5leHBvcnRzLlNUQVJUID0gU1RBUlQ7XG52YXIgRVJST1IgPSAndHJhbnNwb3J0LWVycm9yJztcbmV4cG9ydHMuRVJST1IgPSBFUlJPUjtcbnZhciBVUERBVEUgPSAndHJhbnNwb3J0LXVwZGF0ZSc7XG5leHBvcnRzLlVQREFURSA9IFVQREFURTtcbnZhciBTVFJFQU0gPSAndHJhbnNwb3J0LXN0cmVhbSc7XG5leHBvcnRzLlNUUkVBTSA9IFNUUkVBTTtcbnZhciBSRVFVRVNUID0gJ3RyYW5zcG9ydC1yZXF1ZXN0X2RldmljZSc7XG5leHBvcnRzLlJFUVVFU1QgPSBSRVFVRVNUO1xudmFyIERJU0FCTEVfV0VCVVNCID0gJ3RyYW5zcG9ydC1kaXNhYmxlX3dlYnVzYic7XG5leHBvcnRzLkRJU0FCTEVfV0VCVVNCID0gRElTQUJMRV9XRUJVU0I7XG52YXIgU1RBUlRfUEVORElORyA9ICd0cmFuc3BvcnQtc3RhcnRfcGVuZGluZyc7XG5leHBvcnRzLlNUQVJUX1BFTkRJTkcgPSBTVEFSVF9QRU5ESU5HOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5JRlJBTUVfRkFJTFVSRSA9IGV4cG9ydHMuQUREUkVTU19WQUxJREFUSU9OID0gZXhwb3J0cy5CVU5ETEVfUFJPR1JFU1MgPSBleHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVNQT05TRSA9IGV4cG9ydHMuTE9HSU5fQ0hBTExFTkdFX1JFUVVFU1QgPSBleHBvcnRzLkNVU1RPTV9NRVNTQUdFX1JFU1BPTlNFID0gZXhwb3J0cy5DVVNUT01fTUVTU0FHRV9SRVFVRVNUID0gZXhwb3J0cy5DSEFOR0VfU0VUVElOR1MgPSBleHBvcnRzLlJFQ0VJVkVfV09SRCA9IGV4cG9ydHMuUkVDRUlWRV9GRUUgPSBleHBvcnRzLlJFQ0VJVkVfQUNDT1VOVCA9IGV4cG9ydHMuQ0hBTkdFX0FDQ09VTlQgPSBleHBvcnRzLlJFQ0VJVkVfREVWSUNFID0gZXhwb3J0cy5SRUNFSVZFX1BBU1NQSFJBU0UgPSBleHBvcnRzLlJFQ0VJVkVfUElOID0gZXhwb3J0cy5SRUNFSVZFX0NPTkZJUk1BVElPTiA9IGV4cG9ydHMuUkVDRUlWRV9QRVJNSVNTSU9OID0gZXhwb3J0cy5SRVFVRVNUX1dPUkQgPSBleHBvcnRzLlJFUVVFU1RfQlVUVE9OID0gZXhwb3J0cy5JTlNVRkZJQ0lFTlRfRlVORFMgPSBleHBvcnRzLlVQREFURV9DVVNUT01fRkVFID0gZXhwb3J0cy5TRUxFQ1RfRkVFID0gZXhwb3J0cy5TRUxFQ1RfQUNDT1VOVCA9IGV4cG9ydHMuU0VMRUNUX0RFVklDRSA9IGV4cG9ydHMuU0VUX09QRVJBVElPTiA9IGV4cG9ydHMuTE9BRElORyA9IGV4cG9ydHMuQ09OTkVDVCA9IGV4cG9ydHMuSU5WQUxJRF9QQVNTUEhSQVNFX0FDVElPTiA9IGV4cG9ydHMuSU5WQUxJRF9QQVNTUEhSQVNFID0gZXhwb3J0cy5SRVFVRVNUX1BBU1NQSFJBU0VfT05fREVWSUNFID0gZXhwb3J0cy5SRVFVRVNUX1BBU1NQSFJBU0UgPSBleHBvcnRzLklOVkFMSURfUElOID0gZXhwb3J0cy5SRVFVRVNUX1BJTiA9IGV4cG9ydHMuUkVRVUVTVF9DT05GSVJNQVRJT04gPSBleHBvcnRzLlJFUVVFU1RfUEVSTUlTU0lPTiA9IGV4cG9ydHMuQ0xPU0VfVUlfV0lORE9XID0gZXhwb3J0cy5SRVFVRVNUX1VJX1dJTkRPVyA9IGV4cG9ydHMuREVWSUNFX05FRURTX0JBQ0tVUCA9IGV4cG9ydHMuRklSTVdBUkVfUFJPR1JFU1MgPSBleHBvcnRzLkZJUk1XQVJFX05PVF9JTlNUQUxMRUQgPSBleHBvcnRzLkZJUk1XQVJFX05PVF9DT01QQVRJQkxFID0gZXhwb3J0cy5GSVJNV0FSRV9OT1RfU1VQUE9SVEVEID0gZXhwb3J0cy5GSVJNV0FSRV9PVVREQVRFRCA9IGV4cG9ydHMuRklSTVdBUkVfT0xEID0gZXhwb3J0cy5TRUVETEVTUyA9IGV4cG9ydHMuSU5JVElBTElaRSA9IGV4cG9ydHMuUkVRVUlSRV9NT0RFID0gZXhwb3J0cy5OT1RfSU5fQk9PVExPQURFUiA9IGV4cG9ydHMuQk9PVExPQURFUiA9IGV4cG9ydHMuVFJBTlNQT1JUID0gdm9pZCAwO1xudmFyIFRSQU5TUE9SVCA9ICd1aS1ub190cmFuc3BvcnQnO1xuZXhwb3J0cy5UUkFOU1BPUlQgPSBUUkFOU1BPUlQ7XG52YXIgQk9PVExPQURFUiA9ICd1aS1kZXZpY2VfYm9vdGxvYWRlcl9tb2RlJztcbmV4cG9ydHMuQk9PVExPQURFUiA9IEJPT1RMT0FERVI7XG52YXIgTk9UX0lOX0JPT1RMT0FERVIgPSAndWktZGV2aWNlX25vdF9pbl9ib290bG9hZGVyX21vZGUnO1xuZXhwb3J0cy5OT1RfSU5fQk9PVExPQURFUiA9IE5PVF9JTl9CT09UTE9BREVSO1xudmFyIFJFUVVJUkVfTU9ERSA9ICd1aS1kZXZpY2VfcmVxdWlyZV9tb2RlJztcbmV4cG9ydHMuUkVRVUlSRV9NT0RFID0gUkVRVUlSRV9NT0RFO1xudmFyIElOSVRJQUxJWkUgPSAndWktZGV2aWNlX25vdF9pbml0aWFsaXplZCc7XG5leHBvcnRzLklOSVRJQUxJWkUgPSBJTklUSUFMSVpFO1xudmFyIFNFRURMRVNTID0gJ3VpLWRldmljZV9zZWVkbGVzcyc7XG5leHBvcnRzLlNFRURMRVNTID0gU0VFRExFU1M7XG52YXIgRklSTVdBUkVfT0xEID0gJ3VpLWRldmljZV9maXJtd2FyZV9vbGQnO1xuZXhwb3J0cy5GSVJNV0FSRV9PTEQgPSBGSVJNV0FSRV9PTEQ7XG52YXIgRklSTVdBUkVfT1VUREFURUQgPSAndWktZGV2aWNlX2Zpcm13YXJlX291dGRhdGVkJztcbmV4cG9ydHMuRklSTVdBUkVfT1VUREFURUQgPSBGSVJNV0FSRV9PVVREQVRFRDtcbnZhciBGSVJNV0FSRV9OT1RfU1VQUE9SVEVEID0gJ3VpLWRldmljZV9maXJtd2FyZV91bnN1cHBvcnRlZCc7XG5leHBvcnRzLkZJUk1XQVJFX05PVF9TVVBQT1JURUQgPSBGSVJNV0FSRV9OT1RfU1VQUE9SVEVEO1xudmFyIEZJUk1XQVJFX05PVF9DT01QQVRJQkxFID0gJ3VpLWRldmljZV9maXJtd2FyZV9ub3RfY29tcGF0aWJsZSc7XG5leHBvcnRzLkZJUk1XQVJFX05PVF9DT01QQVRJQkxFID0gRklSTVdBUkVfTk9UX0NPTVBBVElCTEU7XG52YXIgRklSTVdBUkVfTk9UX0lOU1RBTExFRCA9ICd1aS1kZXZpY2VfZmlybXdhcmVfbm90X2luc3RhbGxlZCc7XG5leHBvcnRzLkZJUk1XQVJFX05PVF9JTlNUQUxMRUQgPSBGSVJNV0FSRV9OT1RfSU5TVEFMTEVEO1xudmFyIEZJUk1XQVJFX1BST0dSRVNTID0gJ3VpLWZpcm13YXJlLXByb2dyZXNzJztcbmV4cG9ydHMuRklSTVdBUkVfUFJPR1JFU1MgPSBGSVJNV0FSRV9QUk9HUkVTUztcbnZhciBERVZJQ0VfTkVFRFNfQkFDS1VQID0gJ3VpLWRldmljZV9uZWVkc19iYWNrdXAnO1xuZXhwb3J0cy5ERVZJQ0VfTkVFRFNfQkFDS1VQID0gREVWSUNFX05FRURTX0JBQ0tVUDtcbnZhciBSRVFVRVNUX1VJX1dJTkRPVyA9ICd1aS1yZXF1ZXN0X3dpbmRvdyc7XG5leHBvcnRzLlJFUVVFU1RfVUlfV0lORE9XID0gUkVRVUVTVF9VSV9XSU5ET1c7XG52YXIgQ0xPU0VfVUlfV0lORE9XID0gJ3VpLWNsb3NlX3dpbmRvdyc7XG5leHBvcnRzLkNMT1NFX1VJX1dJTkRPVyA9IENMT1NFX1VJX1dJTkRPVztcbnZhciBSRVFVRVNUX1BFUk1JU1NJT04gPSAndWktcmVxdWVzdF9wZXJtaXNzaW9uJztcbmV4cG9ydHMuUkVRVUVTVF9QRVJNSVNTSU9OID0gUkVRVUVTVF9QRVJNSVNTSU9OO1xudmFyIFJFUVVFU1RfQ09ORklSTUFUSU9OID0gJ3VpLXJlcXVlc3RfY29uZmlybWF0aW9uJztcbmV4cG9ydHMuUkVRVUVTVF9DT05GSVJNQVRJT04gPSBSRVFVRVNUX0NPTkZJUk1BVElPTjtcbnZhciBSRVFVRVNUX1BJTiA9ICd1aS1yZXF1ZXN0X3Bpbic7XG5leHBvcnRzLlJFUVVFU1RfUElOID0gUkVRVUVTVF9QSU47XG52YXIgSU5WQUxJRF9QSU4gPSAndWktaW52YWxpZF9waW4nO1xuZXhwb3J0cy5JTlZBTElEX1BJTiA9IElOVkFMSURfUElOO1xudmFyIFJFUVVFU1RfUEFTU1BIUkFTRSA9ICd1aS1yZXF1ZXN0X3Bhc3NwaHJhc2UnO1xuZXhwb3J0cy5SRVFVRVNUX1BBU1NQSFJBU0UgPSBSRVFVRVNUX1BBU1NQSFJBU0U7XG52YXIgUkVRVUVTVF9QQVNTUEhSQVNFX09OX0RFVklDRSA9ICd1aS1yZXF1ZXN0X3Bhc3NwaHJhc2Vfb25fZGV2aWNlJztcbmV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFX09OX0RFVklDRSA9IFJFUVVFU1RfUEFTU1BIUkFTRV9PTl9ERVZJQ0U7XG52YXIgSU5WQUxJRF9QQVNTUEhSQVNFID0gJ3VpLWludmFsaWRfcGFzc3BocmFzZSc7XG5leHBvcnRzLklOVkFMSURfUEFTU1BIUkFTRSA9IElOVkFMSURfUEFTU1BIUkFTRTtcbnZhciBJTlZBTElEX1BBU1NQSFJBU0VfQUNUSU9OID0gJ3VpLWludmFsaWRfcGFzc3BocmFzZV9hY3Rpb24nO1xuZXhwb3J0cy5JTlZBTElEX1BBU1NQSFJBU0VfQUNUSU9OID0gSU5WQUxJRF9QQVNTUEhSQVNFX0FDVElPTjtcbnZhciBDT05ORUNUID0gJ3VpLWNvbm5lY3QnO1xuZXhwb3J0cy5DT05ORUNUID0gQ09OTkVDVDtcbnZhciBMT0FESU5HID0gJ3VpLWxvYWRpbmcnO1xuZXhwb3J0cy5MT0FESU5HID0gTE9BRElORztcbnZhciBTRVRfT1BFUkFUSU9OID0gJ3VpLXNldF9vcGVyYXRpb24nO1xuZXhwb3J0cy5TRVRfT1BFUkFUSU9OID0gU0VUX09QRVJBVElPTjtcbnZhciBTRUxFQ1RfREVWSUNFID0gJ3VpLXNlbGVjdF9kZXZpY2UnO1xuZXhwb3J0cy5TRUxFQ1RfREVWSUNFID0gU0VMRUNUX0RFVklDRTtcbnZhciBTRUxFQ1RfQUNDT1VOVCA9ICd1aS1zZWxlY3RfYWNjb3VudCc7XG5leHBvcnRzLlNFTEVDVF9BQ0NPVU5UID0gU0VMRUNUX0FDQ09VTlQ7XG52YXIgU0VMRUNUX0ZFRSA9ICd1aS1zZWxlY3RfZmVlJztcbmV4cG9ydHMuU0VMRUNUX0ZFRSA9IFNFTEVDVF9GRUU7XG52YXIgVVBEQVRFX0NVU1RPTV9GRUUgPSAndWktdXBkYXRlX2N1c3RvbV9mZWUnO1xuZXhwb3J0cy5VUERBVEVfQ1VTVE9NX0ZFRSA9IFVQREFURV9DVVNUT01fRkVFO1xudmFyIElOU1VGRklDSUVOVF9GVU5EUyA9ICd1aS1pbnN1ZmZpY2llbnRfZnVuZHMnO1xuZXhwb3J0cy5JTlNVRkZJQ0lFTlRfRlVORFMgPSBJTlNVRkZJQ0lFTlRfRlVORFM7XG52YXIgUkVRVUVTVF9CVVRUT04gPSAndWktYnV0dG9uJztcbmV4cG9ydHMuUkVRVUVTVF9CVVRUT04gPSBSRVFVRVNUX0JVVFRPTjtcbnZhciBSRVFVRVNUX1dPUkQgPSAndWktcmVxdWVzdF93b3JkJztcbmV4cG9ydHMuUkVRVUVTVF9XT1JEID0gUkVRVUVTVF9XT1JEO1xudmFyIFJFQ0VJVkVfUEVSTUlTU0lPTiA9ICd1aS1yZWNlaXZlX3Blcm1pc3Npb24nO1xuZXhwb3J0cy5SRUNFSVZFX1BFUk1JU1NJT04gPSBSRUNFSVZFX1BFUk1JU1NJT047XG52YXIgUkVDRUlWRV9DT05GSVJNQVRJT04gPSAndWktcmVjZWl2ZV9jb25maXJtYXRpb24nO1xuZXhwb3J0cy5SRUNFSVZFX0NPTkZJUk1BVElPTiA9IFJFQ0VJVkVfQ09ORklSTUFUSU9OO1xudmFyIFJFQ0VJVkVfUElOID0gJ3VpLXJlY2VpdmVfcGluJztcbmV4cG9ydHMuUkVDRUlWRV9QSU4gPSBSRUNFSVZFX1BJTjtcbnZhciBSRUNFSVZFX1BBU1NQSFJBU0UgPSAndWktcmVjZWl2ZV9wYXNzcGhyYXNlJztcbmV4cG9ydHMuUkVDRUlWRV9QQVNTUEhSQVNFID0gUkVDRUlWRV9QQVNTUEhSQVNFO1xudmFyIFJFQ0VJVkVfREVWSUNFID0gJ3VpLXJlY2VpdmVfZGV2aWNlJztcbmV4cG9ydHMuUkVDRUlWRV9ERVZJQ0UgPSBSRUNFSVZFX0RFVklDRTtcbnZhciBDSEFOR0VfQUNDT1VOVCA9ICd1aS1jaGFuZ2VfYWNjb3VudCc7XG5leHBvcnRzLkNIQU5HRV9BQ0NPVU5UID0gQ0hBTkdFX0FDQ09VTlQ7XG52YXIgUkVDRUlWRV9BQ0NPVU5UID0gJ3VpLXJlY2VpdmVfYWNjb3VudCc7XG5leHBvcnRzLlJFQ0VJVkVfQUNDT1VOVCA9IFJFQ0VJVkVfQUNDT1VOVDtcbnZhciBSRUNFSVZFX0ZFRSA9ICd1aS1yZWNlaXZlX2ZlZSc7XG5leHBvcnRzLlJFQ0VJVkVfRkVFID0gUkVDRUlWRV9GRUU7XG52YXIgUkVDRUlWRV9XT1JEID0gJ3VpLXJlY2VpdmVfd29yZCc7XG5leHBvcnRzLlJFQ0VJVkVfV09SRCA9IFJFQ0VJVkVfV09SRDtcbnZhciBDSEFOR0VfU0VUVElOR1MgPSAndWktY2hhbmdlX3NldHRpbmdzJztcbmV4cG9ydHMuQ0hBTkdFX1NFVFRJTkdTID0gQ0hBTkdFX1NFVFRJTkdTO1xudmFyIENVU1RPTV9NRVNTQUdFX1JFUVVFU1QgPSAndWktY3VzdG9tX3JlcXVlc3QnO1xuZXhwb3J0cy5DVVNUT01fTUVTU0FHRV9SRVFVRVNUID0gQ1VTVE9NX01FU1NBR0VfUkVRVUVTVDtcbnZhciBDVVNUT01fTUVTU0FHRV9SRVNQT05TRSA9ICd1aS1jdXN0b21fcmVzcG9uc2UnO1xuZXhwb3J0cy5DVVNUT01fTUVTU0FHRV9SRVNQT05TRSA9IENVU1RPTV9NRVNTQUdFX1JFU1BPTlNFO1xudmFyIExPR0lOX0NIQUxMRU5HRV9SRVFVRVNUID0gJ3VpLWxvZ2luX2NoYWxsZW5nZV9yZXF1ZXN0JztcbmV4cG9ydHMuTE9HSU5fQ0hBTExFTkdFX1JFUVVFU1QgPSBMT0dJTl9DSEFMTEVOR0VfUkVRVUVTVDtcbnZhciBMT0dJTl9DSEFMTEVOR0VfUkVTUE9OU0UgPSAndWktbG9naW5fY2hhbGxlbmdlX3Jlc3BvbnNlJztcbmV4cG9ydHMuTE9HSU5fQ0hBTExFTkdFX1JFU1BPTlNFID0gTE9HSU5fQ0hBTExFTkdFX1JFU1BPTlNFO1xudmFyIEJVTkRMRV9QUk9HUkVTUyA9ICd1aS1idW5kbGVfcHJvZ3Jlc3MnO1xuZXhwb3J0cy5CVU5ETEVfUFJPR1JFU1MgPSBCVU5ETEVfUFJPR1JFU1M7XG52YXIgQUREUkVTU19WQUxJREFUSU9OID0gJ3VpLWFkZHJlc3NfdmFsaWRhdGlvbic7XG5leHBvcnRzLkFERFJFU1NfVkFMSURBVElPTiA9IEFERFJFU1NfVkFMSURBVElPTjtcbnZhciBJRlJBTUVfRkFJTFVSRSA9ICd1aS1pZnJhbWVfZmFpbHVyZSc7XG5leHBvcnRzLklGUkFNRV9GQUlMVVJFID0gSUZSQU1FX0ZBSUxVUkU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLlBPT0xfUkVMQVlfVFlQRSA9IGV4cG9ydHMuQ0VSVElGSUNBVEVfVFlQRSA9IGV4cG9ydHMuQUREUkVTU19UWVBFID0gZXhwb3J0cy5ORVRXT1JLX0lEUyA9IGV4cG9ydHMuUFJPVE9DT0xfTUFHSUNTID0gdm9pZCAwO1xudmFyIFBST1RPQ09MX01BR0lDUyA9IE9iamVjdC5mcmVlemUoe1xuICBtYWlubmV0OiA3NjQ4MjQwNzMsXG4gIHRlc3RuZXQ6IDQyXG59KTtcbmV4cG9ydHMuUFJPVE9DT0xfTUFHSUNTID0gUFJPVE9DT0xfTUFHSUNTO1xudmFyIE5FVFdPUktfSURTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1haW5uZXQ6IDEsXG4gIHRlc3RuZXQ6IDBcbn0pOyAvLyBjb25zdGFudHMgYmVsb3cgYXJlIGRlcHJlY2F0ZWRcbi8vIHVzZSBgQ2FyZGFub0FkZHJlc3NUeXBlYCwgYENhcmRhbm9DZXJ0aWZpY2F0ZVR5cGVgIGFuZCBgQ2FyZGFub1Bvb2xSZWxheVR5cGVgIGZyb20gcHJvdG9idWYgaW5zdGVhZFxuXG5leHBvcnRzLk5FVFdPUktfSURTID0gTkVUV09SS19JRFM7XG52YXIgQUREUkVTU19UWVBFID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJhc2U6IDAsXG4gIFBvaW50ZXI6IDQsXG4gIEVudGVycHJpc2U6IDYsXG4gIEJ5cm9uOiA4LFxuICBSZXdhcmQ6IDE0XG59KTtcbmV4cG9ydHMuQUREUkVTU19UWVBFID0gQUREUkVTU19UWVBFO1xudmFyIENFUlRJRklDQVRFX1RZUEUgPSBPYmplY3QuZnJlZXplKHtcbiAgU3Rha2VSZWdpc3RyYXRpb246IDAsXG4gIFN0YWtlRGVyZWdpc3RyYXRpb246IDEsXG4gIFN0YWtlRGVsZWdhdGlvbjogMixcbiAgU3Rha2VQb29sUmVnaXN0cmF0aW9uOiAzXG59KTtcbmV4cG9ydHMuQ0VSVElGSUNBVEVfVFlQRSA9IENFUlRJRklDQVRFX1RZUEU7XG52YXIgUE9PTF9SRUxBWV9UWVBFID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFNpbmdsZUhvc3RJcDogMCxcbiAgU2luZ2xlSG9zdE5hbWU6IDEsXG4gIE11bHRpcGxlSG9zdE5hbWU6IDJcbn0pO1xuZXhwb3J0cy5QT09MX1JFTEFZX1RZUEUgPSBQT09MX1JFTEFZX1RZUEU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5MSUJVU0JfRVJST1JfTUVTU0FHRSA9IGV4cG9ydHMuV0VCVVNCX0VSUk9SX01FU1NBR0UgPSBleHBvcnRzLklOVkFMSURfUElOX0VSUk9SX01FU1NBR0UgPSBleHBvcnRzLldST05HX1BSRVZJT1VTX1NFU1NJT05fRVJST1JfTUVTU0FHRSA9IGV4cG9ydHMuVHlwZWRFcnJvciA9IGV4cG9ydHMuVHJlem9yRXJyb3IgPSBleHBvcnRzLkVSUk9SX0NPREVTID0gdm9pZCAwO1xuXG52YXIgX2luaGVyaXRzTG9vc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCIpKTtcblxudmFyIF93cmFwTmF0aXZlU3VwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXJcIikpO1xuXG52YXIgRVJST1JfQ09ERVMgPSB7XG4gIEluaXRfTm90SW5pdGlhbGl6ZWQ6ICdUcmV6b3JDb25uZWN0IG5vdCB5ZXQgaW5pdGlhbGl6ZWQnLFxuICAvLyByYWNlIGNvbmRpdGlvbjogY2FsbCBvbiBub3QgaW5pdGlhbGl6ZWQgQ29yZSAodXN1YWxseSBob3QtcmVsb2FkaW5nKVxuICBJbml0X0FscmVhZHlJbml0aWFsaXplZDogJ1RyZXpvckNvbm5lY3QgaGFzIGJlZW4gYWxyZWFkeSBpbml0aWFsaXplZCcsXG4gIC8vIHRocm93biBieSAuaW5pdCBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgSW5pdF9JZnJhbWVCbG9ja2VkOiAnSWZyYW1lIGJsb2NrZWQnLFxuICAvLyBpZnJhbWUgaW5qZWN0aW9uIGJsb2NrZWQgKGFkLWJsb2NrZXIpXG4gIEluaXRfSWZyYW1lVGltZW91dDogJ0lmcmFtZSB0aW1lb3V0JyxcbiAgLy8gaWZyYW1lIGRpZG4ndCBsb2FkIGluIHNwZWNpZmllZCB0aW1lXG4gIEluaXRfTWFuaWZlc3RNaXNzaW5nOiAnTWFuaWZlc3Qgbm90IHNldC4gUmVhZCBtb3JlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS90cmV6b3IvY29ubmVjdC9ibG9iL2RldmVsb3AvZG9jcy9pbmRleC5tZCcsXG4gIC8vIG1hbmlmZXN0IGlzIG5vdCBzZXRcbiAgUG9wdXBfQ29ubmVjdGlvbk1pc3Npbmc6ICdVbmFibGUgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24gd2l0aCBpZnJhbWUnLFxuICAvLyB0aHJvd24gYnkgcG9wdXBcbiAgVHJhbnNwb3J0X01pc3Npbmc6ICdUcmFuc3BvcnQgaXMgbWlzc2luZycsXG4gIC8vIG5vIHRyYW5zcG9ydCBhdmFpbGFibGVcbiAgVHJhbnNwb3J0X0ludmFsaWRQcm90b2J1ZjogJycsXG4gIC8vIGdlbmVyaWMgZXJyb3IgZnJvbSB0cmFuc3BvcnQgbGF5ZXIgKHRyZXpvci1saW5rKVxuICBNZXRob2RfSW52YWxpZFBhY2thZ2U6ICdUaGlzIHZlcnNpb24gb2YgdHJlem9yLWNvbm5lY3QgaXMgbm90IHN1aXRhYmxlIHRvIHdvcmsgd2l0aG91dCBicm93c2VyLiBVc2UgdHJlem9yLWNvbm5lY3RAZXh0ZW5kZWQgcGFja2FnZSBpbnN0ZWFkJyxcbiAgLy8gdGhyb3duIGJ5IG5vZGUgYW5kIHJlYWN0LW5hdGl2ZSBlbnYgd2hpbGUgdXNpbmcgcmVndWxhciAnd2ViJyBwYWNrYWdlXG4gIE1ldGhvZF9JbnZhbGlkUGFyYW1ldGVyOiAnJyxcbiAgLy8gcmVwbGFjZWQgYnkgZ2VuZXJpYyB0ZXh0XG4gIE1ldGhvZF9Ob3RBbGxvd2VkOiAnTWV0aG9kIG5vdCBhbGxvd2VkIGZvciB0aGlzIGNvbmZpZ3VyYXRpb24nLFxuICAvLyBleGFtcGxlOiBkZXZpY2UgbWFuYWdlbWVudCBpbiBwb3B1cCBtb2RlXG4gIE1ldGhvZF9QZXJtaXNzaW9uc05vdEdyYW50ZWQ6ICdQZXJtaXNzaW9ucyBub3QgZ3JhbnRlZCcsXG4gIC8vIHBlcm1pc3Npb24vY29uZmlybWF0aW9uIG5vdCBncmFudGVkIGluIHBvcHVwXG4gIE1ldGhvZF9DYW5jZWw6ICdDYW5jZWxsZWQnLFxuICAvLyBwZXJtaXNzaW9uL2NvbmZpcm1hdGlvbiBub3QgZ3JhbnRlZCBpbiBwb3B1cCBPUiAuY2FuY2VsKCkgY3VzdG9tIGVycm9yXG4gIE1ldGhvZF9JbnRlcnJ1cHRlZDogJ1BvcHVwIGNsb3NlZCcsXG4gIC8vIGludGVycnVwdGlvbjogcG9wdXAgY2xvc2VkXG4gIE1ldGhvZF9Vbmtub3duQ29pbjogJ0NvaW4gbm90IGZvdW5kJyxcbiAgLy8gY29pbiBkZWZpbml0aW9uIG5vdCBmb3VuZFxuICBNZXRob2RfQWRkcmVzc05vdE1hdGNoOiAnQWRkcmVzc2VzIGRvIG5vdCBtYXRjaCcsXG4gIC8vIHRocm93biBieSBhbGwgZ2V0QWRkcmVzcyBtZXRob2RzIHdpdGggY3VzdG9tIFVJIHZhbGlkYXRpb25cbiAgTWV0aG9kX0Zpcm13YXJlVXBkYXRlX0Rvd25sb2FkRmFpbGVkOiAnRmFpbGVkIHRvIGRvd25sb2FkIGZpcm13YXJlIGJpbmFyeScsXG4gIC8vIHRocm93biBieSBGaXJtd2FyZVVwZGF0ZSBtZXRob2RcbiAgTWV0aG9kX0N1c3RvbU1lc3NhZ2VfQ2FsbGJhY2s6ICdQYXJhbWV0ZXIgXCJjYWxsYmFja1wiIGlzIG5vdCBhIGZ1bmN0aW9uJyxcbiAgLy8gdGhyb3duIGJ5IEN1c3RvbU1lc3NhZ2UgbWV0aG9kXG4gIE1ldGhvZF9EaXNjb3ZlcnlfQnVuZGxlRXhjZXB0aW9uOiAnJyxcbiAgLy8gdGhyb3duIGJ5IGdldEFjY291bnRJbmZvIG1ldGhvZFxuICBNZXRob2RfT3ZlcnJpZGU6ICdvdmVycmlkZScsXG4gIC8vIGlubmVyIFwiZXJyb3JcIiwgaXQncyBtb3JlIGxpa2UgYSBpbnRlcnJ1cHRpb25cbiAgTWV0aG9kX05vUmVzcG9uc2U6ICdDYWxsIHJlc29sdmVkIHdpdGhvdXQgcmVzcG9uc2UnLFxuICAvLyB0aHJvd24gYnkgbnBtIGluZGV4KGVzKSwgY2FsbCB0byBDb3JlIHJlc29sdmVkIHdpdGhvdXQgcmVzcG9uc2UsIHNob3VsZCBub3QgaGFwcGVuXG4gIEJhY2tlbmRfTm90U3VwcG9ydGVkOiAnQmxvY2tjaGFpbkxpbmsgc2V0dGluZ3Mgbm90IGZvdW5kIGluIGNvaW5zLmpzb24nLFxuICAvLyB0aHJvd24gYnkgbWV0aG9kcyB3aGljaCB1c2luZyBiYWNrZW5kcywgYmxvY2tjaGFpbkxpbmsgbm90IGRlZmluZWQgZm9yIHRoaXMgY29pblxuICBCYWNrZW5kX1dvcmtlck1pc3Npbmc6ICcnLFxuICAvLyB0aHJvd24gYnkgQmxvY2tjaGFpbkxpbmsgY2xhc3MsIHdvcmtlciBub3Qgc3BlY2lmaWVkXG4gIEJhY2tlbmRfRGlzY29ubmVjdGVkOiAnQmFja2VuZCBkaXNjb25uZWN0ZWQnLFxuICAvLyB0aHJvd24gYnkgQmxvY2tjaGFpbkxpbmsgY2xhc3NcbiAgQmFja2VuZF9JbnZhbGlkOiAnSW52YWxpZCBiYWNrZW5kJyxcbiAgLy8gdGhyb3duIGJ5IEJsb2NrY2hhaW5MaW5rIGNsYXNzLCBpbnZhbGlkIGJhY2tlbmQgKGllOiBiYWNrZW5kIGZvciB3cm9uZyBjb2luIHNldClcbiAgQmFja2VuZF9FcnJvcjogJycsXG4gIC8vIHRocm93biBieSBCbG9ja2NoYWluTGluayBjbGFzcywgZ2VuZXJpYyBtZXNzYWdlIGZyb20gJ2Jsb2NrY2hhaW4tbGluaydcbiAgUnVudGltZTogJycsXG4gIC8vIHRocm93biBmcm9tIHNldmVyYWwgcGxhY2VzLCB0aGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiB0aG9cbiAgRGV2aWNlX05vdEZvdW5kOiAnRGV2aWNlIG5vdCBmb3VuZCcsXG4gIERldmljZV9Jbml0aWFsaXplRmFpbGVkOiAnJyxcbiAgLy8gZ2VuZXJpYyBlcnJvciBmcm9tIGZpcm13YXJlIHdoaWxlIGNhbGxpbmcgXCJJbml0aWFsaXplXCIgbWVzc2FnZVxuICBEZXZpY2VfRndFeGNlcHRpb246ICcnLFxuICAvLyBnZW5lcmljIEZpcm13YXJlRXhjZXB0aW9uIHR5cGVcbiAgRGV2aWNlX01vZGVFeGNlcHRpb246ICcnLFxuICAvLyBnZW5lcmljIERldmljZS5VbmV4cGVjdGVkTW9kZSB0eXBlXG4gIERldmljZV9EaXNjb25uZWN0ZWQ6ICdEZXZpY2UgZGlzY29ubmVjdGVkJyxcbiAgLy8gZGV2aWNlIGRpc2Nvbm5lY3RlZCBkdXJpbmcgY2FsbFxuICBEZXZpY2VfVXNlZEVsc2V3aGVyZTogJ0RldmljZSBpcyB1c2VkIGluIGFub3RoZXIgd2luZG93JyxcbiAgLy8gaW50ZXJydXB0aW9uOiBjdXJyZW50IHNlc3Npb24gdG9rZWQgYnkgb3RoZXIgYXBwbGljYXRpb25cbiAgRGV2aWNlX0ludmFsaWRTdGF0ZTogJ1Bhc3NwaHJhc2UgaXMgaW5jb3JyZWN0JyxcbiAgLy8gYXV0aG9yaXphdGlvbiBlcnJvciAoZGV2aWNlIHN0YXRlIGNvbXBhcmlzb24pXG4gIERldmljZV9DYWxsSW5Qcm9ncmVzczogJ0RldmljZSBjYWxsIGluIHByb2dyZXNzJyAvLyB0aHJvd24gd2hlbiB0cnlpbmcgdG8gbWFrZSBhbm90aGVyIGNhbGwgd2hpbGUgY3VycmVudCBpcyBzdGlsbCBydW5uaW5nXG5cbn07XG5leHBvcnRzLkVSUk9SX0NPREVTID0gRVJST1JfQ09ERVM7XG5cbnZhciBUcmV6b3JFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gICgwLCBfaW5oZXJpdHNMb29zZTJbXCJkZWZhdWx0XCJdKShUcmV6b3JFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBUcmV6b3JFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUcmV6b3JFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi8oMCwgX3dyYXBOYXRpdmVTdXBlcjJbXCJkZWZhdWx0XCJdKShFcnJvcikpO1xuXG5leHBvcnRzLlRyZXpvckVycm9yID0gVHJlem9yRXJyb3I7XG5cbnZhciBUeXBlZEVycm9yID0gZnVuY3Rpb24gVHlwZWRFcnJvcihpZCwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFRyZXpvckVycm9yKGlkLCBtZXNzYWdlIHx8IEVSUk9SX0NPREVTW2lkXSk7XG59OyAvLyBhIHNsaWdodCBoYWNrXG4vLyB0aGlzIGVycm9yIHN0cmluZyBpcyBoYXJkLWNvZGVkXG4vLyBpbiBib3RoIGJyaWRnZSBhbmQgZXh0ZW5zaW9uXG5cblxuZXhwb3J0cy5UeXBlZEVycm9yID0gVHlwZWRFcnJvcjtcbnZhciBXUk9OR19QUkVWSU9VU19TRVNTSU9OX0VSUk9SX01FU1NBR0UgPSAnd3JvbmcgcHJldmlvdXMgc2Vzc2lvbic7XG5leHBvcnRzLldST05HX1BSRVZJT1VTX1NFU1NJT05fRVJST1JfTUVTU0FHRSA9IFdST05HX1BSRVZJT1VTX1NFU1NJT05fRVJST1JfTUVTU0FHRTtcbnZhciBJTlZBTElEX1BJTl9FUlJPUl9NRVNTQUdFID0gJ1BJTiBpbnZhbGlkJztcbmV4cG9ydHMuSU5WQUxJRF9QSU5fRVJST1JfTUVTU0FHRSA9IElOVkFMSURfUElOX0VSUk9SX01FU1NBR0U7XG52YXIgV0VCVVNCX0VSUk9SX01FU1NBR0UgPSAnTmV0d29ya0Vycm9yOiBVbmFibGUgdG8gY2xhaW0gaW50ZXJmYWNlLic7IC8vIHRyZXpvcmQgZXJyb3IgcHJlZml4LlxuLy8gdXNlciBoYXMgaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zLiBtYXkgb2NjdXIgaW4gTGludXggKG1pc3NpbmcgdWRldiBydWxlcyksIFdpbmRvd3MgYW5kIE1hY09TLlxuXG5leHBvcnRzLldFQlVTQl9FUlJPUl9NRVNTQUdFID0gV0VCVVNCX0VSUk9SX01FU1NBR0U7XG52YXIgTElCVVNCX0VSUk9SX01FU1NBR0UgPSAnTElCVVNCX0VSUk9SJztcbmV4cG9ydHMuTElCVVNCX0VSUk9SX01FU1NBR0UgPSBMSUJVU0JfRVJST1JfTUVTU0FHRTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNsYXNzTmFtZSwgdXJsLCBvcmlnaW4pIHtcbiAgdmFyIHF1ZXJ5ID0gY2xhc3NOYW1lIHx8ICcudHJlem9yLXdlYnVzYi1idXR0b24nO1xuICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICB2YXIgc3JjID0gdXJsICsgXCI/XCIgKyBEYXRlLm5vdygpO1xuICBidXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAoYi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaWZyYW1lJykubGVuZ3RoIDwgMSkge1xuICAgICAgdmFyIGJvdW5kcyA9IGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgYnRuSWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBidG5JZnJhbWUuZnJhbWVCb3JkZXIgPSAnMCc7XG4gICAgICBidG5JZnJhbWUud2lkdGggPSBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCkgKyBcInB4XCI7XG4gICAgICBidG5JZnJhbWUuaGVpZ2h0ID0gTWF0aC5yb3VuZChib3VuZHMuaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgIGJ0bklmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBidG5JZnJhbWUuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICBidG5JZnJhbWUuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgYnRuSWZyYW1lLnN0eWxlLnpJbmRleCA9ICcxJzsgLy8gYnRuSWZyYW1lLnN0eWxlLm9wYWNpdHkgPSAnMCc7IC8vIHRoaXMgbWFrZXMgY2xpY2sgaW1wb3NzaWJsZSBvbiBjcm9zcy1vcmlnaW5cblxuICAgICAgYnRuSWZyYW1lLnNldEF0dHJpYnV0ZSgnYWxsb3cnLCAndXNiJyk7XG4gICAgICBidG5JZnJhbWUuc2V0QXR0cmlidXRlKCdzY3JvbGxpbmcnLCAnbm8nKTtcblxuICAgICAgYnRuSWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYnRuSWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2Uoey8vIHN0eWxlOiBKU09OLnN0cmluZ2lmeSggd2luZG93LmdldENvbXB1dGVkU3R5bGUoYikgKSxcbiAgICAgICAgICAvLyBvdXRlcjogYi5vdXRlckhUTUwsXG4gICAgICAgICAgLy8gaW5uZXI6IGIuaW5uZXJIVE1MXG4gICAgICAgIH0sIG9yaWdpbik7XG4gICAgICB9O1xuXG4gICAgICBidG5JZnJhbWUuc3JjID0gc3JjOyAvLyBpbmplY3QgaWZyYW1lIGludG8gYnV0dG9uXG5cbiAgICAgIGIuYXBwZW5kKGJ0bklmcmFtZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IHJlbmRlcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldExvZyA9IGV4cG9ydHMuZW5hYmxlTG9nQnlQcmVmaXggPSBleHBvcnRzLmVuYWJsZUxvZyA9IGV4cG9ydHMuaW5pdExvZyA9IHZvaWQgMDtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xudmFyIGNvbG9ycyA9IHtcbiAgLy8gZ3JlZW5cbiAgRGVzY3JpcHRvclN0cmVhbTogJ2NvbG9yOiAjNzdhYjU5JyxcbiAgRGV2aWNlTGlzdDogJ2NvbG9yOiAjMzY4MDJkJyxcbiAgRGV2aWNlOiAnY29sb3I6ICNiYWRhNTUnLFxuICBDb3JlOiAnY29sb3I6ICNjOWRmOGEnLFxuICBJRnJhbWU6ICdjb2xvcjogI0ZGRkZGRjsgYmFja2dyb3VuZDogI2Y0YTc0MjsnLFxuICBQb3B1cDogJ2NvbG9yOiAjZjQ4YTAwJ1xufTtcbnZhciBNQVhfRU5UUklFUyA9IDEwMDtcblxudmFyIExvZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvZyhwcmVmaXgsIGVuYWJsZWQpIHtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICB0aGlzLmNzcyA9IGNvbG9yc1twcmVmaXhdIHx8ICdjb2xvcjogIzAwMDAwMDsgYmFja2dyb3VuZDogI0ZGRkZGRjsnO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExvZy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZE1lc3NhZ2UgPSBmdW5jdGlvbiBhZGRNZXNzYWdlKGxldmVsLCBwcmVmaXgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBhcmdzLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubWVzc2FnZXMubGVuZ3RoID4gTUFYX0VOVFJJRVMpIHtcbiAgICAgIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1lc3NhZ2UuYXBwbHkodGhpcywgWydsb2cnLCB0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHZhciBfY29uc29sZTtcblxuICAgICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBbdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIHRoaXMuYWRkTWVzc2FnZS5hcHBseSh0aGlzLCBbJ2Vycm9yJywgdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB2YXIgX2NvbnNvbGUyO1xuXG4gICAgICAoX2NvbnNvbGUyID0gY29uc29sZSkuZXJyb3IuYXBwbHkoX2NvbnNvbGUyLCBbdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2FybigpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1lc3NhZ2UuYXBwbHkodGhpcywgWyd3YXJuJywgdGhpcy5wcmVmaXhdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB2YXIgX2NvbnNvbGUzO1xuXG4gICAgICAoX2NvbnNvbGUzID0gY29uc29sZSkud2Fybi5hcHBseShfY29uc29sZTMsIFt0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgfVxuXG4gICAgdGhpcy5hZGRNZXNzYWdlLmFwcGx5KHRoaXMsIFsnZGVidWcnLCB0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHZhciBfY29uc29sZTQ7XG5cbiAgICAgIChfY29uc29sZTQgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGU0LCBbXCIlY1wiICsgdGhpcy5wcmVmaXgsIHRoaXMuY3NzXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTG9nO1xufSgpO1xuXG52YXIgX2xvZ3MgPSB7fTtcblxudmFyIGluaXRMb2cgPSBmdW5jdGlvbiBpbml0TG9nKHByZWZpeCwgZW5hYmxlZCkge1xuICB2YXIgaW5zdGFuY2UgPSBuZXcgTG9nKHByZWZpeCwgISFlbmFibGVkKTtcbiAgX2xvZ3NbcHJlZml4XSA9IGluc3RhbmNlO1xuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG5leHBvcnRzLmluaXRMb2cgPSBpbml0TG9nO1xuXG52YXIgZW5hYmxlTG9nID0gZnVuY3Rpb24gZW5hYmxlTG9nKGVuYWJsZWQpIHtcbiAgT2JqZWN0LmtleXMoX2xvZ3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIF9sb2dzW2tleV0uZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5lbmFibGVMb2cgPSBlbmFibGVMb2c7XG5cbnZhciBlbmFibGVMb2dCeVByZWZpeCA9IGZ1bmN0aW9uIGVuYWJsZUxvZ0J5UHJlZml4KHByZWZpeCwgZW5hYmxlZCkge1xuICBpZiAoX2xvZ3NbcHJlZml4XSkge1xuICAgIF9sb2dzW3ByZWZpeF0uZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH1cbn07XG5cbmV4cG9ydHMuZW5hYmxlTG9nQnlQcmVmaXggPSBlbmFibGVMb2dCeVByZWZpeDtcblxudmFyIGdldExvZyA9IGZ1bmN0aW9uIGdldExvZygpIHtcbiAgdmFyIGxvZ3MgPSBbXTtcbiAgT2JqZWN0LmtleXMoX2xvZ3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGxvZ3MgPSBsb2dzLmNvbmNhdChfbG9nc1trZXldLm1lc3NhZ2VzKTtcbiAgfSk7XG4gIGxvZ3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wO1xuICB9KTtcbiAgcmV0dXJuIGxvZ3M7XG59O1xuXG5leHBvcnRzLmdldExvZyA9IGdldExvZzsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXJyb3JNZXNzYWdlID0gZXhwb3J0cy5wYXJzZU1lc3NhZ2UgPSB2b2lkIDA7XG5cbi8vIHBhcnNlIE1lc3NhZ2VFdmVudCAuZGF0YSBpbnRvIENvcmVNZXNzYWdlXG52YXIgcGFyc2VNZXNzYWdlID0gZnVuY3Rpb24gcGFyc2VNZXNzYWdlKG1lc3NhZ2VEYXRhKSB7XG4gIHZhciBtZXNzYWdlID0ge1xuICAgIGV2ZW50OiBtZXNzYWdlRGF0YS5ldmVudCxcbiAgICB0eXBlOiBtZXNzYWdlRGF0YS50eXBlLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2VEYXRhLnBheWxvYWRcbiAgfTtcblxuICBpZiAodHlwZW9mIG1lc3NhZ2VEYXRhLmlkID09PSAnbnVtYmVyJykge1xuICAgIG1lc3NhZ2UuaWQgPSBtZXNzYWdlRGF0YS5pZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWVzc2FnZURhdGEuc3VjY2VzcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgbWVzc2FnZS5zdWNjZXNzID0gbWVzc2FnZURhdGEuc3VjY2VzcztcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlO1xufTsgLy8gY29tbW9uIHJlc3BvbnNlIHVzZWQgc3RyYWlnaHQgZnJvbSBucG0gaW5kZXggKG5vdCBmcm9tIENvcmUpXG5cblxuZXhwb3J0cy5wYXJzZU1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2U7XG5cbnZhciBlcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIGNvZGU6IGVycm9yLmNvZGVcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNsZWFyVGltZW91dCA9IGV4cG9ydHMuZGlzcG9zZSA9IGV4cG9ydHMucG9zdE1lc3NhZ2UgPSBleHBvcnRzLmluaXQgPSBleHBvcnRzLm1lc3NhZ2VQcm9taXNlcyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLnRpbWVvdXQgPSBleHBvcnRzLmluaXRQcm9taXNlID0gZXhwb3J0cy5vcmlnaW4gPSBleHBvcnRzLmluc3RhbmNlID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZlcnJlZCA9IHJlcXVpcmUoXCIuLi91dGlscy9kZWZlcnJlZFwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX25ldHdvcmtVdGlscyA9IHJlcXVpcmUoXCIuLi9lbnYvYnJvd3Nlci9uZXR3b3JrVXRpbHNcIik7XG5cbnZhciBfaW5saW5lU3R5bGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbmxpbmUtc3R5bGVzXCIpKTtcblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xudmFyIGluc3RhbmNlO1xuZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xudmFyIG9yaWdpbjtcbmV4cG9ydHMub3JpZ2luID0gb3JpZ2luO1xudmFyIGluaXRQcm9taXNlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKCk7XG5leHBvcnRzLmluaXRQcm9taXNlID0gaW5pdFByb21pc2U7XG52YXIgdGltZW91dCA9IDA7XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xudmFyIGVycm9yO1xuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzICovXG5cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbnZhciBfbWVzc2FnZUlEID0gMDsgLy8gZXZlcnkgcG9zdE1lc3NhZ2UgdG8gaWZyYW1lIGhhcyBpdHMgb3duIHByb21pc2UgdG8gcmVzb2x2ZVxuXG52YXIgbWVzc2FnZVByb21pc2VzID0ge307XG5leHBvcnRzLm1lc3NhZ2VQcm9taXNlcyA9IG1lc3NhZ2VQcm9taXNlcztcblxudmFyIGluaXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNldHRpbmdzKSB7XG4gICAgdmFyIGV4aXN0ZWRGcmFtZSwgc3JjLCBtYW5pZmVzdFN0cmluZywgbWFuaWZlc3QsIG9uTG9hZDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgZXhwb3J0cy5pbml0UHJvbWlzZSA9IGluaXRQcm9taXNlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKCk7XG4gICAgICAgICAgICBleGlzdGVkRnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJlem9yY29ubmVjdCcpO1xuXG4gICAgICAgICAgICBpZiAoZXhpc3RlZEZyYW1lKSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZSA9IGV4aXN0ZWRGcmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mcmFtZUJvcmRlciA9ICcwJztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uud2lkdGggPSAnMHB4JztcbiAgICAgICAgICAgICAgaW5zdGFuY2UuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0eWxlLndpZHRoID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5pZCA9ICd0cmV6b3Jjb25uZWN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVudiA9PT0gJ3dlYicpIHtcbiAgICAgICAgICAgICAgbWFuaWZlc3RTdHJpbmcgPSBzZXR0aW5ncy5tYW5pZmVzdCA/IEpTT04uc3RyaW5naWZ5KHNldHRpbmdzLm1hbmlmZXN0KSA6ICd1bmRlZmluZWQnOyAvLyBub3RlOiBidG9hKHVuZGVmaW5lZCkgPT09IGJ0b2EoJ3VuZGVmaW5lZCcpID09PSBcImRXNWtaV1pwYm1Wa1wiXG5cbiAgICAgICAgICAgICAgbWFuaWZlc3QgPSBcInZlcnNpb249XCIgKyBzZXR0aW5ncy52ZXJzaW9uICsgXCImbWFuaWZlc3Q9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYnRvYShKU09OLnN0cmluZ2lmeShtYW5pZmVzdFN0cmluZykpKTtcbiAgICAgICAgICAgICAgc3JjID0gc2V0dGluZ3MuaWZyYW1lU3JjICsgXCI/XCIgKyBtYW5pZmVzdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNyYyA9IHNldHRpbmdzLmlmcmFtZVNyYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mud2VidXNiKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldEF0dHJpYnV0ZSgnYWxsb3cnLCAndXNiJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMub3JpZ2luID0gb3JpZ2luID0gKDAsIF9uZXR3b3JrVXRpbHMuZ2V0T3JpZ2luKShpbnN0YW5jZS5zcmMpO1xuICAgICAgICAgICAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaW5pdFByb21pc2UucmVqZWN0KF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lVGltZW91dCcpKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgICAgICAgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKCkge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaW5pdFByb21pc2UucmVqZWN0KF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGhvc3RpbmcgcGFnZSBpcyBhYmxlIHRvIGFjY2VzcyBjcm9zcy1vcmlnaW4gbG9jYXRpb24gaXQgbWVhbnMgdGhhdCB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWRcbiAgICAgICAgICAgICAgICB2YXIgaWZyYW1lT3JpZ2luID0gaW5zdGFuY2UuY29udGVudFdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlmcmFtZU9yaWdpbiB8fCBpZnJhbWVPcmlnaW4gPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICBoYW5kbGVJZnJhbWVCbG9ja2VkKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7Ly8gZW1wdHlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBleHRlbnNpb247IC8vICRGbG93SXNzdWUgY2hyb21lIGlzIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmIGNocm9tZS5ydW50aW1lICYmIHR5cGVvZiBjaHJvbWUucnVudGltZS5vbkNvbm5lY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBjaHJvbWUucnVudGltZS5pZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuSUZSQU1FLklOSVQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRlbnNpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIG9yaWdpbik7XG4gICAgICAgICAgICAgIGluc3RhbmNlLm9ubG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07IC8vIElFIGhhY2tcblxuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuYXR0YWNoRXZlbnQoJ29ubG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5vbmxvYWQgPSBvbkxvYWQ7XG4gICAgICAgICAgICB9IC8vIGluamVjdCBpZnJhbWUgaW50byBob3N0IGRvY3VtZW50IGJvZHlcblxuXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluc3RhbmNlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG5cbiAgICAgICAgICAgICAgaW5qZWN0U3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2UucHJvbWlzZTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTEpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBzdGF0ZSB0byBhbGxvdyBpbml0aWFsaXphdGlvbiBhZ2FpblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBleHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjA7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIwKTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMTEsIDE2LCAyMCwgMjRdXSk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gaW5pdChfeCkge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5cbnZhciBpbmplY3RTdHlsZVNoZWV0ID0gZnVuY3Rpb24gaW5qZWN0U3R5bGVTaGVldCgpIHtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIHRocm93IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpO1xuICB9XG5cbiAgdmFyIGRvYyA9IGluc3RhbmNlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciBoZWFkID0gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ1RyZXpvckNvbm5lY3RTdHlsZXNoZWV0Jyk7IC8vICRGbG93SXNzdWVcblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIC8vIElFXG4gICAgLy8gJEZsb3dJc3N1ZVxuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IF9pbmxpbmVTdHlsZXNbXCJkZWZhdWx0XCJdO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKF9pbmxpbmVTdHlsZXNbXCJkZWZhdWx0XCJdKSk7XG4gICAgaGVhZC5hcHBlbmQoc3R5bGUpO1xuICB9XG59O1xuXG52YXIgaGFuZGxlSWZyYW1lQmxvY2tlZCA9IGZ1bmN0aW9uIGhhbmRsZUlmcmFtZUJsb2NrZWQoKSB7XG4gIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gIGV4cG9ydHMuZXJyb3IgPSBlcnJvciA9IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcblxuICBkaXNwb3NlKCk7XG4gIGluaXRQcm9taXNlLnJlamVjdChlcnJvcik7XG59OyAvLyBwb3N0IG1lc3NhZ2VzIHRvIGlmcmFtZVxuXG5cbnZhciBwb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHVzZVByb21pc2UpIHtcbiAgaWYgKHVzZVByb21pc2UgPT09IHZvaWQgMCkge1xuICAgIHVzZVByb21pc2UgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIHRocm93IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpO1xuICB9XG5cbiAgaWYgKHVzZVByb21pc2UpIHtcbiAgICBfbWVzc2FnZUlEKys7XG4gICAgbWVzc2FnZS5pZCA9IF9tZXNzYWdlSUQ7XG4gICAgbWVzc2FnZVByb21pc2VzW19tZXNzYWdlSURdID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKCk7XG4gICAgdmFyIHByb21pc2UgPSBtZXNzYWdlUHJvbWlzZXNbX21lc3NhZ2VJRF0ucHJvbWlzZTtcbiAgICBpbnN0YW5jZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBpbnN0YW5jZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0cy5wb3N0TWVzc2FnZSA9IHBvc3RNZXNzYWdlO1xuXG52YXIgZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnROb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGluc3RhbmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5zdGFuY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBkbyBub3RoaW5nXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlID0gbnVsbDtcbiAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCA9IDA7XG59O1xuXG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuXG52YXIgY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KCkge1xuICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcblxuZXhwb3J0cy5jbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5CbG9ja2NoYWluTWVzc2FnZSA9IGV4cG9ydHMuUmVzcG9uc2VNZXNzYWdlID0gZXhwb3J0cy5UcmFuc3BvcnRNZXNzYWdlID0gZXhwb3J0cy5EZXZpY2VNZXNzYWdlID0gZXhwb3J0cy5VaU1lc3NhZ2UgPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFVpTWVzc2FnZSA9IGZ1bmN0aW9uIFVpTWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuVUlfRVZFTlQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH07XG59O1xuXG5leHBvcnRzLlVpTWVzc2FnZSA9IFVpTWVzc2FnZTtcblxudmFyIERldmljZU1lc3NhZ2UgPSBmdW5jdGlvbiBEZXZpY2VNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudDogX2NvbnN0YW50cy5ERVZJQ0VfRVZFTlQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH07XG59O1xuXG5leHBvcnRzLkRldmljZU1lc3NhZ2UgPSBEZXZpY2VNZXNzYWdlO1xuXG52YXIgVHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLlRSQU5TUE9SVF9FVkVOVCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIC8vIGNvbnZlcnQgRXJyb3IvVHlwZUVycm9yIG9iamVjdCBpbnRvIHBheWxvYWQgZXJyb3IgdHlwZSAoRXJyb3Igb2JqZWN0L2NsYXNzIGlzIGNvbnZlcnRlZCB0byBzdHJpbmcgd2hpbGUgc2VudCB2aWEgcG9zdE1lc3NhZ2UpXG4gICAgcGF5bG9hZDogcGF5bG9hZC5lcnJvciA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGF5bG9hZCksIHt9LCB7XG4gICAgICBlcnJvcjogcGF5bG9hZC5lcnJvci5tZXNzYWdlLFxuICAgICAgY29kZTogcGF5bG9hZC5lcnJvci5jb2RlXG4gICAgfSkgOiBwYXlsb2FkXG4gIH07XG59O1xuXG5leHBvcnRzLlRyYW5zcG9ydE1lc3NhZ2UgPSBUcmFuc3BvcnRNZXNzYWdlO1xuXG52YXIgUmVzcG9uc2VNZXNzYWdlID0gZnVuY3Rpb24gUmVzcG9uc2VNZXNzYWdlKGlkLCBzdWNjZXNzLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkID09PSB2b2lkIDApIHtcbiAgICBwYXlsb2FkID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuUkVTUE9OU0VfRVZFTlQsXG4gICAgdHlwZTogX2NvbnN0YW50cy5SRVNQT05TRV9FVkVOVCxcbiAgICBpZDogaWQsXG4gICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAvLyBjb252ZXJ0IEVycm9yL1R5cGVFcnJvciBvYmplY3QgaW50byBwYXlsb2FkIGVycm9yIHR5cGUgKEVycm9yIG9iamVjdC9jbGFzcyBpcyBjb252ZXJ0ZWQgdG8gc3RyaW5nIHdoaWxlIHNlbnQgdmlhIHBvc3RNZXNzYWdlKVxuICAgIHBheWxvYWQ6IHN1Y2Nlc3MgPyBwYXlsb2FkIDoge1xuICAgICAgZXJyb3I6IHBheWxvYWQuZXJyb3IubWVzc2FnZSxcbiAgICAgIGNvZGU6IHBheWxvYWQuZXJyb3IuY29kZVxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydHMuUmVzcG9uc2VNZXNzYWdlID0gUmVzcG9uc2VNZXNzYWdlO1xuXG52YXIgQmxvY2tjaGFpbk1lc3NhZ2UgPSBmdW5jdGlvbiBCbG9ja2NoYWluTWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuQkxPQ0tDSEFJTl9FVkVOVCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgfTtcbn07XG5cbmV4cG9ydHMuQmxvY2tjaGFpbk1lc3NhZ2UgPSBCbG9ja2NoYWluTWVzc2FnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnBhcnNlID0gZXhwb3J0cy5jb3JzVmFsaWRhdG9yID0gZXhwb3J0cy5nZXRFbnYgPSBleHBvcnRzLkRFRkFVTFRfUFJJT1JJVFkgPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qXG4gKiBJbml0aWFsIHNldHRpbmdzIGZvciBjb25uZWN0LlxuICogSXQgY291bGQgYmUgY2hhbmdlZCBieSBwYXNzaW5nIHZhbHVlcyBpbnRvIFRyZXpvckNvbm5lY3QuaW5pdCguLi4pIG1ldGhvZFxuICovXG52YXIgVkVSU0lPTiA9ICc4LjIuMyc7XG52YXIgdmVyc2lvbk4gPSBWRVJTSU9OLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBwYXJzZUludChzLCAxMCk7XG59KTsgLy8gY29uc3QgRElSRUNUT1JZID0gYCR7IHZlcnNpb25OWzBdIH0keyAodmVyc2lvbk5bMV0gPiAwID8gYC4ke3ZlcnNpb25OWzFdfWAgOiAnJykgfS9gO1xuXG52YXIgRElSRUNUT1JZID0gdmVyc2lvbk5bMF0gKyBcIi9cIjtcbnZhciBERUZBVUxUX0RPTUFJTiA9IFwiaHR0cHM6Ly9jb25uZWN0LnRyZXpvci5pby9cIiArIERJUkVDVE9SWTtcbnZhciBERUZBVUxUX1BSSU9SSVRZID0gMjtcbmV4cG9ydHMuREVGQVVMVF9QUklPUklUWSA9IERFRkFVTFRfUFJJT1JJVFk7XG52YXIgaW5pdGlhbFNldHRpbmdzID0ge1xuICBjb25maWdTcmM6ICcuL2RhdGEvY29uZmlnLmpzb24nLFxuICAvLyBjb25zdGFudFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICAvLyBjb25zdGFudFxuICBkZWJ1ZzogZmFsc2UsXG4gIHByaW9yaXR5OiBERUZBVUxUX1BSSU9SSVRZLFxuICB0cnVzdGVkSG9zdDogZmFsc2UsXG4gIGNvbm5lY3RTcmM6IERFRkFVTFRfRE9NQUlOLFxuICBpZnJhbWVTcmM6IERFRkFVTFRfRE9NQUlOICsgXCJpZnJhbWUuaHRtbFwiLFxuICBwb3B1cDogdHJ1ZSxcbiAgcG9wdXBTcmM6IERFRkFVTFRfRE9NQUlOICsgXCJwb3B1cC5odG1sXCIsXG4gIHdlYnVzYlNyYzogREVGQVVMVF9ET01BSU4gKyBcIndlYnVzYi5odG1sXCIsXG4gIHRyYW5zcG9ydFJlY29ubmVjdDogZmFsc2UsXG4gIHdlYnVzYjogdHJ1ZSxcbiAgcGVuZGluZ1RyYW5zcG9ydEV2ZW50OiB0cnVlLFxuICBzdXBwb3J0ZWRCcm93c2VyOiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/ICEvVHJpZGVudHxNU0lFfEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgOiB0cnVlLFxuICBtYW5pZmVzdDogbnVsbCxcbiAgZW52OiAnd2ViJyxcbiAgbGF6eUxvYWQ6IGZhbHNlLFxuICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICBpbnRlcmFjdGlvblRpbWVvdXQ6IDYwMCAvLyA1IG1pbnV0ZXNcblxufTtcbnZhciBjdXJyZW50U2V0dGluZ3MgPSBpbml0aWFsU2V0dGluZ3M7XG5cbnZhciBwYXJzZU1hbmlmZXN0ID0gZnVuY3Rpb24gcGFyc2VNYW5pZmVzdChtYW5pZmVzdCkge1xuICBpZiAoIW1hbmlmZXN0KSByZXR1cm47XG4gIGlmICh0eXBlb2YgbWFuaWZlc3QuZW1haWwgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbWFuaWZlc3QuYXBwVXJsICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuICByZXR1cm4ge1xuICAgIGVtYWlsOiBtYW5pZmVzdC5lbWFpbCxcbiAgICBhcHBVcmw6IG1hbmlmZXN0LmFwcFVybFxuICB9O1xufTtcblxudmFyIGdldEVudiA9IGZ1bmN0aW9uIGdldEVudigpIHtcbiAgLy8gJEZsb3dJc3N1ZTogY2hyb21lIGlzIG5vdCBkZWNsYXJlZCBvdXRzaWRlIHRoZSBwcm9qZWN0XG4gIGlmICh0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJyAmJiBjaHJvbWUucnVudGltZSAmJiB0eXBlb2YgY2hyb21lLnJ1bnRpbWUub25Db25uZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAnd2ViZXh0ZW5zaW9uJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZScpIHtcbiAgICAgIHJldHVybiAncmVhY3QtbmF0aXZlJztcbiAgICB9XG5cbiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCcgZWxlY3Ryb24vJykgPiAtMSkge1xuICAgICAgcmV0dXJuICdlbGVjdHJvbic7XG4gICAgfVxuICB9IC8vIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09ICdyZWFjdG5hdGl2ZScpIHtcbiAgLy8gICAgIHJldHVybiAncmVhY3QtbmF0aXZlJztcbiAgLy8gfVxuICAvLyBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMuaGFzT3duUHJvcGVydHkoJ2VsZWN0cm9uJykpIHtcbiAgLy8gICAgIHJldHVybiAnZWxlY3Ryb24nO1xuICAvLyB9XG5cblxuICByZXR1cm4gJ3dlYic7XG59OyAvLyBDb3JzIHZhbGlkYXRpb24gY29waWVkIGZyb20gVHJlem9yIEJyaWRnZVxuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdHJlem9yL3RyZXpvcmQtZ28vYmxvYi8wNTk5MWNlYTU5MDBkMThiY2M2ZWNlNWFlNWUzMTlkMTM4ZmM1NTUxL3NlcnZlci9hcGkvYXBpLmdvI0wyMjlcbi8vIEl0cyBwb2ludGxlc3MgdG8gYWxsb3cgYHRyZXpvci1jb25uZWN0YCBlbmRwb2ludHMgeyBjb25uZWN0U3JjIH0gZm9yIGRvbWFpbnMgb3RoZXIgdGhhbiBsaXN0ZWQgYmVsb3dcbi8vIGB0cmV6b3JkYCB3aWxsIGJsb2NrIGNvbW11bmljYXRpb24gYW55d2F5XG5cblxuZXhwb3J0cy5nZXRFbnYgPSBnZXRFbnY7XG5cbnZhciBjb3JzVmFsaWRhdG9yID0gZnVuY3Rpb24gY29yc1ZhbGlkYXRvcih1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gIGlmICh1cmwubWF0Y2goL15odHRwczpcXC9cXC8oW0EtWmEtejAtOVxcLV9dK1xcLikqdHJlem9yXFwuaW9cXC8vKSkgcmV0dXJuIHVybDtcbiAgaWYgKHVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC9sb2NhbGhvc3Q6WzU4XVswLTldezN9XFwvLykpIHJldHVybiB1cmw7XG4gIGlmICh1cmwubWF0Y2goL15odHRwczpcXC9cXC8oW0EtWmEtejAtOVxcLV9dK1xcLikqc2xkZXZcXC5jelxcLy8pKSByZXR1cm4gdXJsO1xuICBpZiAodXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLyhbQS1aYS16MC05XFwtX10rXFwuKSp0cmV6b3Jpb3ZwamNhaHB6a3Jld2VsY2x1bG1zendicXB6bXpndWIzN2diY2psdmx1eHRydXFhZFxcLm9uaW9uXFwvLykpIHJldHVybiB1cmw7XG59O1xuXG5leHBvcnRzLmNvcnNWYWxpZGF0b3IgPSBjb3JzVmFsaWRhdG9yO1xuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICBpZiAoaW5wdXQgPT09IHZvaWQgMCkge1xuICAgIGlucHV0ID0ge307XG4gIH1cblxuICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkKHt9LCBjdXJyZW50U2V0dGluZ3MpO1xuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5wdXQsICdkZWJ1ZycpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7Ly8gZW5hYmxlIGxvZyB3aXRoIHByZWZpeFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQuZGVidWcgPT09ICdib29sZWFuJykge1xuICAgICAgc2V0dGluZ3MuZGVidWcgPSBpbnB1dC5kZWJ1ZztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dC5kZWJ1ZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNldHRpbmdzLmRlYnVnID0gaW5wdXQuZGVidWcgPT09ICd0cnVlJztcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LmNvbm5lY3RTcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgc2V0dGluZ3MuY29ubmVjdFNyYyA9IGlucHV0LmNvbm5lY3RTcmM7XG4gIH0gLy8gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBgY29ubmVjdFNyY2AgY291bGQgYmUgZGVmaW5lZCBpbiBgZ2xvYmFsLl9fVFJFWk9SX0NPTk5FQ1RfU1JDYCB2YXJpYWJsZVxuXG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwuX19UUkVaT1JfQ09OTkVDVF9TUkMgPT09ICdzdHJpbmcnKSB7XG4gICAgc2V0dGluZ3MuY29ubmVjdFNyYyA9IGNvcnNWYWxpZGF0b3IoZ2xvYmFsLl9fVFJFWk9SX0NPTk5FQ1RfU1JDKTtcbiAgICBzZXR0aW5ncy5kZWJ1ZyA9IHRydWU7XG4gIH0gLy8gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBgY29ubmVjdFNyY2AgY291bGQgYmUgZGVmaW5lZCBpbiB1cmwgcXVlcnkgb2YgaG9zdGluZyBwYWdlLiBVc2FnZTpcbiAgLy8gaHR0cHM6Ly8zcmRwYXJ0eS1wYWdlLmNvbS8/dHJlem9yLWNvbm5lY3Qtc3JjPWh0dHBzOi8vbG9jYWxob3N0OjgwODgvXG5cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHR5cGVvZiB3aW5kb3cubG9jYXRpb24uc2VhcmNoID09PSAnc3RyaW5nJykge1xuICAgIHZhciB2YXJzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zcGxpdCgnJicpO1xuICAgIHZhciBjdXN0b21VcmwgPSB2YXJzLmZpbmQoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2LmluZGV4T2YoJ3RyZXpvci1jb25uZWN0LXNyYycpID49IDA7XG4gICAgfSk7XG5cbiAgICBpZiAoY3VzdG9tVXJsKSB7XG4gICAgICB2YXIgX2N1c3RvbVVybCRzcGxpdCA9IGN1c3RvbVVybC5zcGxpdCgnPScpLFxuICAgICAgICAgIGNvbm5lY3RTcmMgPSBfY3VzdG9tVXJsJHNwbGl0WzFdO1xuXG4gICAgICBzZXR0aW5ncy5jb25uZWN0U3JjID0gY29yc1ZhbGlkYXRvcihkZWNvZGVVUklDb21wb25lbnQoY29ubmVjdFNyYykpO1xuICAgICAgc2V0dGluZ3MuZGVidWcgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcmMgPSBzZXR0aW5ncy5jb25uZWN0U3JjIHx8IERFRkFVTFRfRE9NQUlOO1xuICBzZXR0aW5ncy5pZnJhbWVTcmMgPSBzcmMgKyBcImlmcmFtZS5odG1sXCI7XG4gIHNldHRpbmdzLnBvcHVwU3JjID0gc3JjICsgXCJwb3B1cC5odG1sXCI7XG4gIHNldHRpbmdzLndlYnVzYlNyYyA9IHNyYyArIFwid2VidXNiLmh0bWxcIjtcblxuICBpZiAodHlwZW9mIGlucHV0LnRyYW5zcG9ydFJlY29ubmVjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc2V0dGluZ3MudHJhbnNwb3J0UmVjb25uZWN0ID0gaW5wdXQudHJhbnNwb3J0UmVjb25uZWN0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC53ZWJ1c2IgPT09ICdib29sZWFuJykge1xuICAgIHNldHRpbmdzLndlYnVzYiA9IGlucHV0LndlYnVzYjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQucG9wdXAgPT09ICdib29sZWFuJykge1xuICAgIHNldHRpbmdzLnBvcHVwID0gaW5wdXQucG9wdXA7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LmxhenlMb2FkID09PSAnYm9vbGVhbicpIHtcbiAgICBzZXR0aW5ncy5sYXp5TG9hZCA9IGlucHV0LmxhenlMb2FkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5wZW5kaW5nVHJhbnNwb3J0RXZlbnQgPT09ICdib29sZWFuJykge1xuICAgIHNldHRpbmdzLnBlbmRpbmdUcmFuc3BvcnRFdmVudCA9IGlucHV0LnBlbmRpbmdUcmFuc3BvcnRFdmVudDtcbiAgfSAvLyBsb2NhbCBmaWxlc1xuXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICBzZXR0aW5ncy5vcmlnaW4gPSBcImZpbGU6Ly9cIiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICBzZXR0aW5ncy53ZWJ1c2IgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQuZXh0ZW5zaW9uID09PSAnc3RyaW5nJykge1xuICAgIHNldHRpbmdzLmV4dGVuc2lvbiA9IGlucHV0LmV4dGVuc2lvbjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQuZW52ID09PSAnc3RyaW5nJykge1xuICAgIHNldHRpbmdzLmVudiA9IGlucHV0LmVudjtcbiAgfSBlbHNlIHtcbiAgICBzZXR0aW5ncy5lbnYgPSBnZXRFbnYoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQudGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgIHNldHRpbmdzLnRpbWVzdGFtcCA9IGlucHV0LnRpbWVzdGFtcDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQuaW50ZXJhY3Rpb25UaW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgIHNldHRpbmdzLmludGVyYWN0aW9uVGltZW91dCA9IGlucHV0LmludGVyYWN0aW9uVGltZW91dDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQubWFuaWZlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgc2V0dGluZ3MubWFuaWZlc3QgPSBwYXJzZU1hbmlmZXN0KGlucHV0Lm1hbmlmZXN0KTtcbiAgfVxuXG4gIGN1cnJlbnRTZXR0aW5ncyA9IHNldHRpbmdzO1xuICByZXR1cm4gY3VycmVudFNldHRpbmdzO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2luaGVyaXRzTG9vc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9ldmVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJldmVudHNcIikpO1xuXG52YXIgUE9QVVAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vY29uc3RhbnRzL3BvcHVwXCIpKTtcblxudmFyIElGUkFNRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaWZyYW1lXCIpKTtcblxudmFyIFVJID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL2NvbnN0YW50cy91aVwiKSk7XG5cbnZhciBfc2hvd1BvcHVwUmVxdWVzdCA9IHJlcXVpcmUoXCIuL3Nob3dQb3B1cFJlcXVlc3RcIik7XG5cbnZhciBfbmV0d29ya1V0aWxzID0gcmVxdWlyZShcIi4uL2Vudi9icm93c2VyL25ldHdvcmtVdGlsc1wiKTtcblxudmFyIF9kZWZlcnJlZCA9IHJlcXVpcmUoXCIuLi91dGlscy9kZWZlcnJlZFwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLy8gY29uc3QgUE9QVVBfUkVRVUVTVF9USU1FT1VUID0gNjAyO1xudmFyIFBPUFVQX1JFUVVFU1RfVElNRU9VVCA9IDg1MDtcbnZhciBQT1BVUF9DTE9TRV9JTlRFUlZBTCA9IDUwMDtcbnZhciBQT1BVUF9PUEVOX1RJTUVPVVQgPSAzMDAwO1xuXG52YXIgUG9wdXBNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICgwLCBfaW5oZXJpdHNMb29zZTJbXCJkZWZhdWx0XCJdKShQb3B1cE1hbmFnZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIC8vIFdpbmRvd1xuICBmdW5jdGlvbiBQb3B1cE1hbmFnZXIoc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpLCBcInJlcXVlc3RUaW1lb3V0XCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpLCBcImNsb3NlSW50ZXJ2YWxcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcyksIFwiZXh0ZW5zaW9uVGFiSWRcIiwgMCk7XG4gICAgX3RoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICBfdGhpcy5vcmlnaW4gPSAoMCwgX25ldHdvcmtVdGlscy5nZXRPcmlnaW4pKHNldHRpbmdzLnBvcHVwU3JjKTtcbiAgICBfdGhpcy5oYW5kbGVNZXNzYWdlID0gX3RoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSk7XG4gICAgX3RoaXMuaWZyYW1lSGFuZHNoYWtlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKElGUkFNRS5MT0FERUQpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicpIHtcbiAgICAgIF90aGlzLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QgPSBfdGhpcy5oYW5kbGVFeHRlbnNpb25Db25uZWN0LmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKTtcbiAgICAgIF90aGlzLmhhbmRsZUV4dGVuc2lvbk1lc3NhZ2UgPSBfdGhpcy5oYW5kbGVFeHRlbnNpb25NZXNzYWdlLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKTsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgY2hyb21lLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKF90aGlzLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgX3RoaXMuaGFuZGxlTWVzc2FnZSwgZmFsc2UpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQb3B1cE1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChsYXp5TG9hZCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKGxhenlMb2FkID09PSB2b2lkIDApIHtcbiAgICAgIGxhenlMb2FkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcG9wdXAgcmVxdWVzdFxuICAgIC8vIFRPRE86IGllIC0gb3BlbiBpbW1lZGlhdGVseSBhbmQgaGlkZSBpdCBidXQgcG9zdCBoYW5kc2hha2UgYWZ0ZXIgdGltZW91dFxuICAgIC8vIGJyaW5nIHBvcHVwIHdpbmRvdyB0byBmcm9udFxuICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgaWYgKHRoaXMuX3dpbmRvdykge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbnYgPT09ICd3ZWJleHRlbnNpb24nKSB7XG4gICAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgICBjaHJvbWUudGFicy51cGRhdGUodGhpcy5fd2luZG93LmlkLCB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aW5kb3cuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9wZW5GbiA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5zdXBwb3J0ZWRCcm93c2VyKSB7XG4gICAgICBvcGVuRm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRpbWVvdXQgPSBsYXp5TG9hZCB8fCB0aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicgPyAxIDogUE9QVVBfUkVRVUVTVF9USU1FT1VUO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlcXVlc3RUaW1lb3V0ID0gMDtcbiAgICAgICAgb3BlbkZuKGxhenlMb2FkKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfTtcblxuICBfcHJvdG8udW5sb2NrID0gZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9wZW4gPSBmdW5jdGlvbiBvcGVuKGxhenlMb2FkKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgc3JjID0gdGhpcy5zZXR0aW5ncy5wb3B1cFNyYztcblxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5zdXBwb3J0ZWRCcm93c2VyKSB7XG4gICAgICB0aGlzLm9wZW5XcmFwcGVyKHNyYyArIFwiI3Vuc3VwcG9ydGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucG9wdXBQcm9taXNlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKFBPUFVQLkxPQURFRCk7XG4gICAgdGhpcy5vcGVuV3JhcHBlcihsYXp5TG9hZCA/IHNyYyArIFwiI2xvYWRpbmdcIiA6IHNyYyk7XG4gICAgdGhpcy5jbG9zZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMzLl93aW5kb3cpIHJldHVybjtcblxuICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbnYgPT09ICd3ZWJleHRlbnNpb24nKSB7XG4gICAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICAgIGNocm9tZS50YWJzLmdldChfdGhpczMuX3dpbmRvdy5pZCwgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgIGlmICghdGFiKSB7XG4gICAgICAgICAgICBfdGhpczMuY2xvc2UoKTtcblxuICAgICAgICAgICAgX3RoaXMzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfdGhpczMuX3dpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgX3RoaXMzLmNsb3NlKCk7XG5cbiAgICAgICAgX3RoaXMzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgIH1cbiAgICB9LCBQT1BVUF9DTE9TRV9JTlRFUlZBTCk7IC8vIG9wZW4gdGltZW91dCB3aWxsIGJlIGNhbmNlbGxlZCBieSBQT1BVUC5CT09UU1RSQVAgbWVzc2FnZVxuXG4gICAgdGhpcy5vcGVuVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5jbG9zZSgpO1xuXG4gICAgICAoMCwgX3Nob3dQb3B1cFJlcXVlc3Quc2hvd1BvcHVwUmVxdWVzdCkoX3RoaXMzLm9wZW4uYmluZChfdGhpczMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5lbWl0KFBPUFVQLkNMT1NFRCk7XG4gICAgICB9KTtcbiAgICB9LCBQT1BVUF9PUEVOX1RJTUVPVVQpO1xuICB9O1xuXG4gIF9wcm90by5vcGVuV3JhcHBlciA9IGZ1bmN0aW9uIG9wZW5XcmFwcGVyKHVybCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZW52ID09PSAnd2ViZXh0ZW5zaW9uJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgIGNocm9tZS53aW5kb3dzLmdldEN1cnJlbnQobnVsbCwgZnVuY3Rpb24gKGN1cnJlbnRXaW5kb3cpIHtcbiAgICAgICAgLy8gUmVxdWVzdCBjb21pbmcgZnJvbSBleHRlbnNpb24gcG9wdXAsXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgd2luZG93IGFib3ZlIGluc3RlYWQgb2Ygb3BlbmluZyBuZXcgdGFiXG4gICAgICAgIGlmIChjdXJyZW50V2luZG93LnR5cGUgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgICBjaHJvbWUud2luZG93cy5jcmVhdGUoe1xuICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICB9LCBmdW5jdGlvbiAobmV3V2luZG93KSB7XG4gICAgICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICAgICAgY2hyb21lLnRhYnMucXVlcnkoe1xuICAgICAgICAgICAgICB3aW5kb3dJZDogbmV3V2luZG93LmlkLFxuICAgICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0YWJzKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICBfdGhpczQuX3dpbmRvdyA9IHRhYnNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICAgIGNocm9tZS50YWJzLnF1ZXJ5KHtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9LCBmdW5jdGlvbiAodGFicykge1xuICAgICAgICAgICAgX3RoaXM0LmV4dGVuc2lvblRhYklkID0gdGFic1swXS5pZDsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgICAgICAgY2hyb21lLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgIGluZGV4OiB0YWJzWzBdLmluZGV4ICsgMVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgICBfdGhpczQuX3dpbmRvdyA9IHRhYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuZW52ID09PSAnZWxlY3Ryb24nKSB7XG4gICAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3cub3Blbih1cmwsICdtb2RhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3cub3BlbignJywgJ19ibGFuaycpO1xuXG4gICAgICBpZiAodGhpcy5fd2luZG93KSB7XG4gICAgICAgIHRoaXMuX3dpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsOyAvLyBvdGhlcndpc2UgYW5kcm9pZC9jaHJvbWUgbG9vc2Ugd2luZG93Lm9wZW5lciByZWZlcmVuY2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QgPSBmdW5jdGlvbiBoYW5kbGVFeHRlbnNpb25Db25uZWN0KHBvcnQpIHtcbiAgICBpZiAocG9ydC5uYW1lICE9PSAndHJlem9yLWNvbm5lY3QnKSByZXR1cm47XG5cbiAgICBpZiAoIXRoaXMuX3dpbmRvdyB8fCB0aGlzLl93aW5kb3cgJiYgdGhpcy5fd2luZG93LmlkICE9PSBwb3J0LnNlbmRlci50YWIuaWQpIHtcbiAgICAgIHBvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2luY2UgUE9QVVAuQk9PVFNUUkFQIHdpbGwgbm90IGJlIGhhbmRsZWQgYnkgXCJoYW5kbGVNZXNzYWdlXCIgd2UgbmVlZCB0byB0aHJlYXQgXCJjb250ZW50LXNjcmlwdFwiIGNvbm5lY3Rpb24gYXMgdGhlIHNhbWUgZXZlbnRcbiAgICAvLyBwb3B1cCBpcyBvcGVuZWQgcHJvcGVybHksIG5vdyB3YWl0IGZvciBQT1BVUC5MT0FERUQgbWVzc2FnZSAoaW4gdGhpcyBjYXNlIGhhbmRsZWQgYnkgXCJoYW5kbGVFeHRlbnNpb25NZXNzYWdlXCIpXG5cblxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgdGhpcy5leHRlbnNpb25Qb3J0ID0gcG9ydDsgLy8gJEZsb3dJc3N1ZSBuZWVkIHRvIHVwZGF0ZSBDaHJvbWVQb3J0IGRlZmluaXRpb25cblxuICAgIHRoaXMuZXh0ZW5zaW9uUG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIodGhpcy5oYW5kbGVFeHRlbnNpb25NZXNzYWdlKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRXh0ZW5zaW9uTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZUV4dGVuc2lvbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmV4dGVuc2lvblBvcnQpIHJldHVybjtcbiAgICB2YXIgcG9ydCA9IHRoaXMuZXh0ZW5zaW9uUG9ydDtcbiAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSByZXR1cm47XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSBQT1BVUC5FUlJPUikge1xuICAgICAgLy8gaGFuZGxlIHBvcHVwIGVycm9yXG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZGF0YS5wYXlsb2FkICYmIHR5cGVvZiBkYXRhLnBheWxvYWQuZXJyb3IgPT09ICdzdHJpbmcnID8gZGF0YS5wYXlsb2FkLmVycm9yIDogbnVsbDtcbiAgICAgIHRoaXMuZW1pdChQT1BVUC5DTE9TRUQsIGVycm9yTWVzc2FnZSA/IFwiUG9wdXAgZXJyb3I6IFwiICsgZXJyb3JNZXNzYWdlIDogbnVsbCk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkxPQURFRCkge1xuICAgICAgaWYgKHRoaXMucG9wdXBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pZnJhbWVIYW5kc2hha2UucHJvbWlzZS50aGVuKGZ1bmN0aW9uICh1c2VCcm9hZGNhc3RDaGFubmVsKSB7XG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFBPUFVQLklOSVQsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc2V0dGluZ3M6IF90aGlzNS5zZXR0aW5ncyxcbiAgICAgICAgICAgIHVzZUJyb2FkY2FzdENoYW5uZWw6IHVzZUJyb2FkY2FzdENoYW5uZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlMpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICBjaHJvbWUudGFicy5xdWVyeSh7XG4gICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfSwgZnVuY3Rpb24gKHRhYnMpIHtcbiAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgY2hyb21lLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgICB1cmw6ICd0cmV6b3ItdXNiLXBlcm1pc3Npb25zLmh0bWwnLFxuICAgICAgICAgIGluZGV4OiB0YWJzWzBdLmluZGV4ICsgMVxuICAgICAgICB9LCBmdW5jdGlvbiAoX3RhYikgey8vIGRvIG5vdGhpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuQ0xPU0VfV0lORE9XKSB7XG4gICAgICB0aGlzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIGlnbm9yZSBtZXNzYWdlcyBmcm9tIGRvbWFpbiBvdGhlciB0aGVuIHBvcHVwIG9yaWdpbiBhbmQgd2l0aG91dCBkYXRhXG4gICAgLy8gY29uc3QgZGF0YTogQ29yZU1lc3NhZ2UgPSBtZXNzYWdlLmRhdGE7XG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgaWYgKCgwLCBfbmV0d29ya1V0aWxzLmdldE9yaWdpbikobWVzc2FnZS5vcmlnaW4pICE9PSB0aGlzLm9yaWdpbiB8fCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHJldHVybjtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09IElGUkFNRS5MT0FERUQpIHtcbiAgICAgIHZhciB1c2VCcm9hZGNhc3RDaGFubmVsID0gZGF0YS5wYXlsb2FkICYmIHR5cGVvZiBkYXRhLnBheWxvYWQudXNlQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ2Jvb2xlYW4nID8gZGF0YS5wYXlsb2FkLnVzZUJyb2FkY2FzdENoYW5uZWwgOiBmYWxzZTtcbiAgICAgIHRoaXMuaWZyYW1lSGFuZHNoYWtlLnJlc29sdmUodXNlQnJvYWRjYXN0Q2hhbm5lbCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkJPT1RTVFJBUCkge1xuICAgICAgLy8gcG9wdXAgaXMgb3BlbmVkIHByb3Blcmx5LCBub3cgd2FpdCBmb3IgUE9QVVAuTE9BREVEIG1lc3NhZ2VcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkVSUk9SICYmIHRoaXMuX3dpbmRvdykge1xuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGRhdGEucGF5bG9hZCAmJiB0eXBlb2YgZGF0YS5wYXlsb2FkLmVycm9yID09PSAnc3RyaW5nJyA/IGRhdGEucGF5bG9hZC5lcnJvciA6IG51bGw7XG4gICAgICB0aGlzLmVtaXQoUE9QVVAuQ0xPU0VELCBlcnJvck1lc3NhZ2UgPyBcIlBvcHVwIGVycm9yOiBcIiArIGVycm9yTWVzc2FnZSA6IG51bGwpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBQT1BVUC5MT0FERUQpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnBvcHVwUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9IC8vIHBvcHVwIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcblxuXG4gICAgICB0aGlzLmlmcmFtZUhhbmRzaGFrZS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHVzZUJyb2FkY2FzdENoYW5uZWwpIHtcbiAgICAgICAgX3RoaXM2Ll93aW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFBPUFVQLklOSVQsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc2V0dGluZ3M6IF90aGlzNi5zZXR0aW5ncyxcbiAgICAgICAgICAgIHVzZUJyb2FkY2FzdENoYW5uZWw6IHVzZUJyb2FkY2FzdENoYW5uZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF90aGlzNi5vcmlnaW4pO1xuICAgICAgfSk7IC8vIHNlbmQgQ29ubmVjdFNldHRpbmdzIHRvIHBvcHVwXG4gICAgICAvLyBub3RlIHRoaXMgc2V0dGluZ3MgYW5kIGlmcmFtZS5Db25uZWN0U2V0dGluZ3MgY291bGQgYmUgZGlmZmVyZW50IChlc3BlY2lhbGx5OiBvcmlnaW4sIHBvcHVwLCB3ZWJ1c2IsIGRlYnVnKVxuICAgICAgLy8gbm93IHBvcHVwIGlzIGFibGUgdG8gbG9hZCBhc3NldHNcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuQ0FOQ0VMX1BPUFVQX1JFUVVFU1QgfHwgZGF0YS50eXBlID09PSBVSS5DTE9TRV9VSV9XSU5ET1cpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvcHVwUHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlblRpbWVvdXQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgICB0aGlzLm9wZW5UaW1lb3V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbG9zZUludGVydmFsKSB7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNsb3NlSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5jbG9zZUludGVydmFsID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHRlbnNpb25Qb3J0KSB7XG4gICAgICB0aGlzLmV4dGVuc2lvblBvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5leHRlbnNpb25Qb3J0ID0gbnVsbDtcbiAgICB9IC8vIHN3aXRjaCB0byBwcmV2aW91c2x5IGZvY3VzZWQgdGFiXG5cblxuICAgIGlmICh0aGlzLmV4dGVuc2lvblRhYklkKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgY2hyb21lLnRhYnMudXBkYXRlKHRoaXMuZXh0ZW5zaW9uVGFiSWQsIHtcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uVGFiSWQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl93aW5kb3cpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIHZhciBfZSA9IGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcjsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgICBjaHJvbWUudGFicy5yZW1vdmUodGhpcy5fd2luZG93LmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgX2UgPSBjaHJvbWUucnVudGltZS5sYXN0RXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2luZG93LmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wb3N0TWVzc2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wb3N0TWVzc2FnZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISghdGhpcy5fd2luZG93ICYmIG1lc3NhZ2UudHlwZSAhPT0gVUkuUkVRVUVTVF9VSV9XSU5ET1cgJiYgdGhpcy5vcGVuVGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgKDAsIF9zaG93UG9wdXBSZXF1ZXN0LnNob3dQb3B1cFJlcXVlc3QpKHRoaXMub3Blbi5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvcHVwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcHVwUHJvbWlzZS5wcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIC8vIHBvc3QgbWVzc2FnZSB0byBwb3B1cCB3aW5kb3dcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0aGlzLm9yaWdpbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoX3gpIHtcbiAgICAgIHJldHVybiBfcG9zdE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zdE1lc3NhZ2U7XG4gIH0oKTtcblxuICByZXR1cm4gUG9wdXBNYW5hZ2VyO1xufShfZXZlbnRzW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXBNYW5hZ2VyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZFRvRXZlbihoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2FwaScpKHJlcXVpcmUoJy4vbGliL2tlY2NhaycpKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBjcmVhdGVLZWNjYWtIYXNoID0gcmVxdWlyZSgna2VjY2FrJyk7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnc2VjcDI1NmsxJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgcmxwID0gcmVxdWlyZSgncmxwJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCByZXF1aXJlKCdldGhqcy11dGlsJykpO1xuXG4vKipcbiAqIHRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZSAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBNQVhfSU5URUdFUlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuXG4vKipcbiAqIDJeMjU2IChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IFRXT19QT1cyNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9OVUxMX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuZXhwb3J0cy5TSEEzX05VTExfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9OVUxMXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTDtcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfQVJSQVlfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3JztcbmV4cG9ydHMuU0hBM19STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUF9BUlJBWVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsICAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbmV4cG9ydHMuU0hBM19STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQO1xuXG4vKipcbiAqIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcylcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkJOID0gQk47XG5cbi8qKlxuICogW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5ybHAgPSBybHA7XG5cbi8qKlxuICogW2BzZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlLylcbiAqIEB2YXIge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwc1xuICogQG1ldGhvZCB6ZXJvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIHplcm9BZGRyZXNzXG4gICogQHJldHVybiB7U3RyaW5nfVxuICAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoemVyb0FkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQG1ldGhvZCBsc2V0TGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHtCb29sZWFufSBbcmlnaHQ9ZmFsc2VdIHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gIGlmIChyaWdodCkge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfSBhXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfVxuICovXG5leHBvcnRzLnVucGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYSk7XG4gIHZhciBmaXJzdCA9IGFbMF07XG4gIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgZmlyc3QgPSBhWzBdO1xuICB9XG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB7Kn0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGV4cG9ydHMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMucGFkVG9FdmVuKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHYgPSBleHBvcnRzLmludFRvQnVmZmVyKHYpO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IG51bVxuICogQHJldHVybiB7Qk59XG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCTn0gbnVtXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIEtlY2NhayB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICBpZiAoIWJpdHMpIGJpdHMgPSAyNTY7XG5cbiAgcmV0dXJuIGNyZWF0ZUtlY2Nha0hhc2goJ2tlY2NhaycgKyBiaXRzKS51cGRhdGUoYSkuZGlnZXN0KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIChLZWNjYWspIGhhc2ggb2YgdGhlIGlucHV0IFtPQlNPTEVURV1cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBTSEEtMyB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTMgPSBleHBvcnRzLmtlY2NhaztcblxuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtCb29sZWFufSBwYWRkZWQgd2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICB9XG5cbiAgaWYgKCFzYW5pdGl6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICBwdWJLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YktleSk7XG4gIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHByaXZhdGVLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHB1YmxpY0tleSA9IGV4cG9ydHMudG9CdWZmZXIocHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRUNEU0Egc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuXG4gIHZhciByZXQgPSB7fTtcbiAgcmV0LnIgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgcmV0LnMgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCk7XG4gIHJldC52ID0gc2lnLnJlY292ZXJ5ICsgMjc7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGhhc2hcbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIHByZWZpeCA9IGV4cG9ydHMudG9CdWZmZXIoJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcblxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcykge1xuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGgociwgMzIpLCBleHBvcnRzLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gIHZhciByZWNvdmVyeSA9IHYgLSAyNztcbiAgaWYgKHJlY292ZXJ5ICE9PSAwICYmIHJlY292ZXJ5ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gIH1cbiAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7U3RyaW5nfSBzaWdcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNvdmVyeSBpZCcpO1xuICB9XG5cbiAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgLy8gRklYTUU6IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUgLSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgZXhwb3J0cy50b0J1ZmZlcih2IC0gMjcpXSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgc2lnID0gZXhwb3J0cy50b0J1ZmZlcihzaWcpO1xuXG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmIChzaWcubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgdiA9IHNpZ1s2NF07XG4gIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICBpZiAodiA8IDI3KSB7XG4gICAgdiArPSAyNztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdjogdixcbiAgICByOiBzaWcuc2xpY2UoMCwgMzIpLFxuICAgIHM6IHNpZy5zbGljZSgzMiwgNjQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b29cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuICgvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKVxuICApO1xufTtcblxuLyoqXG4gICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgaXNaZXJvQWRkcmVzc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgcmV0dXJuIHplcm9BZGRyZXNzID09PSBleHBvcnRzLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBhZGRyZXNzID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzaCA9IGV4cG9ydHMua2VjY2FrKGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIHJldCA9ICcweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnJvbSB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbm9uY2UgdGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgZnJvbSA9IGV4cG9ydHMudG9CdWZmZXIoZnJvbSk7XG4gIG5vbmNlID0gbmV3IEJOKG5vbmNlKTtcblxuICBpZiAobm9uY2UuaXNaZXJvKCkpIHtcbiAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgIG5vbmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub25jZSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMucmxwaGFzaChbZnJvbSwgbm9uY2VdKS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSlcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIGEgPSBleHBvcnRzLnVucGFkKGFkZHJlc3MpO1xuICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG5cbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgRUNEU0Egc2lnbmF0dXJlXG4gKiBAbWV0aG9kIGlzVmFsaWRTaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hvbWVzdGVhZD10cnVlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkKSB7XG4gIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuXG4gIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgciA9IG5ldyBCTihyKTtcbiAgcyA9IG5ldyBCTihzKTtcblxuICBpZiAoci5pc1plcm8oKSB8fCByLmd0KFNFQ1AyNTZLMV9OKSB8fCBzLmlzWmVybygpIHx8IHMuZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhvbWVzdGVhZCA9PT0gZmFsc2UgJiYgbmV3IEJOKHMpLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT05cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBiYVxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICByZXR1cm4gJzB4JyArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIHsqfSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgc2VsZi5yYXcgPSBbXTtcbiAgc2VsZi5fZmllbGRzID0gW107XG5cbiAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIG9ialtmaWVsZF0gPSAnMHgnICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5iYVRvSlNPTih0aGlzLnJhdyk7XG4gIH07XG5cbiAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICB9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgIHYgPSBleHBvcnRzLnRvQnVmZmVyKHYpO1xuXG4gICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICB2ID0gZXhwb3J0cy5zdHJpcFplcm9zKHYpO1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IG5vdCBoYXZlIG1vcmUgJyArIGZpZWxkLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICcgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGV4cG9ydHMudG9CdWZmZXIoZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSkgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSkgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgfVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4LmpzJylcbiIsIi8vIENvbnNpc3RlbnQgd2l0aCBMYXR0aWNlJ3MgSVZcbmNvbnN0IEFFU19JViA9IFsweDZkLCAweDc5LCAweDczLCAweDY1LCAweDYzLCAweDcyLCAweDY1LCAweDc0LCAweDcwLCAweDYxLCAweDczLCAweDczLCAweDc3LCAweDZmLCAweDcyLCAweDY0XVxuXG5jb25zdCBBRERSX1NUUl9MRU4gPSAxMjk7IC8vIDEyOC1jaGFyIHN0cmluZ3MgKG51bGwgdGVybWluYXRlZClcblxuLy8gRGVjcnlwdGVkIHJlc3BvbnNlIGxlbmd0aHMgd2lsbCBiZSBmaXhlZCBmb3IgYW55IGdpdmVuIG1lc3NhZ2UgdHlwZS5cbi8vIFRoZXNlIGFyZSBkZWZpbmVkIGluIHRoZSBMYXR0aWNlIHNwZWMuXG4vLyBFdmVyeSBkZWNyeXB0ZWQgcmVzcG9uc2Ugc2hvdWxkIGhhdmUgYSA2NS1ieXRlIHB1YmtleSBwcmVmaXhpbmcgaXQgKGFuZCBhIDQtYnl0ZSByZXF1ZXN0IElEKVxuLy8gVGhlc2UgYXJlIE5PVCBjb3VudGVkIGluIGBkZWNSZXNMZW5ndGhzYCwgbWVhbmluZyB0aGVzZSB2YWx1ZXMgYXJlIDY5LWJ5dGVzIHNtYWxsZXIgdGhhbiB0aGVcbi8vIGNvcnJlc3BvbmRpbmcgc3RydWN0cyBpbiBmaXJtd2FyZS5cbmNvbnN0IGRlY1Jlc0xlbmd0aHMgPSB7XG4gICAgZW1wdHk6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjb250YWlucyB0aGUgcHVia2V5XG4gICAgZ2V0QWRkcmVzc2VzOiAxMCAqIEFERFJfU1RSX0xFTiwgICAgLy8gMTB4IDEyOSBieXRlIHN0cmluZ3MgKDEyOCBieXRlcyArIG51bGwgdGVybWluYXRvcilcbiAgICBzaWduOiAxMDkwLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIERFUiBzaWduYXR1cmUgZm9yIEVUSCwgMTAgZm9yIEJUQyArIGNoYW5nZSBwdWJrZXloYXNoXG4gICAgZ2V0V2FsbGV0czogMTQyLCAgICAgICAgICAgICAgICAgICAgLy8gNzEgYnl0ZXMgcGVyIHdhbGxldCByZWNvcmQgKHJlc3BvbnNlIGNvbnRhaW5zIGludGVybmFsIGFuZCBleHRlcm5hbClcbiAgICBhZGRBYmlEZWZzOiA4LFxuICAgIGdldEt2UmVjb3JkczogMTM5NSxcbiAgICB0ZXN0OiAxNjQ2ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXggc2l6ZSBvZiB0ZXN0IHJlc3BvbnNlIHBheWxvYWRcbn1cblxuLy8gRXZlcnkgY29ycmVzcG9uZGluZyBkZWNyeXB0ZWQgcmVzcG9uc2Ugc3RydWN0IGluIGZpcm13YXJlIGhhcyBhIHB1YmtleVxuLy8gYW5kIGNoZWNrc3VtIGFkZGVkLiBUaGVzZSBhcmUgbm90IGluY2x1ZGVkIGluIGBkZWNSZXNMZW5ndGhzYFxuY29uc3QgREVTX1JFU19FWFRSQURBVEFfTEVOID0gNjk7IFxuXG4vLyBFbmNyeXB0ZWQgcmVzcG9uc2VzIGFsc28gaGF2ZSBtZXRhZGF0YVxuLy8gUHJlZml4OlxuLy8gKiBwcm90b2NvbCB2ZXJzaW9uICgxIGJ5dGUpXG4vLyAqIHJlc3BvbnNlIHR5cGUsIHJlc2VydmVkICgxIGJ5dGUpIC0tIG5vdCB1c2VkXG4vLyAqIHJlc3BvbnNlIGlkICg0IGJ5dGVzKSAtLSBub3QgdXNlZFxuLy8gKiBwYXlsb2FkIGxlbmd0aCAoMiBieXRlcylcbi8vICogcmVzcG9uc2UgY29kZSAoMSBieXRlKVxuLy8gU3VmZml4OlxuLy8gKiBjaGVja3N1bSAoNCBieXRlcykgLS0gTk9UIHRoZSBzYW1lIGNoZWNrc3VtIGFzIGluc2lkZSB0aGUgZGVjcnlwdGVkIG1zZ1xuY29uc3QgRU5DX01TR19NRVRBREFUQV9MRU4gPSAxMztcblxuY29uc3QgRU5DX01TR19FWFRSQV9MRU4gPSBERVNfUkVTX0VYVFJBREFUQV9MRU4gKyBFTkNfTVNHX01FVEFEQVRBX0xFTjtcbi8vIFBlciBMYXR0aWNlIHNwZWMsIGFsbCBlbmNyeXB0ZWQgbWVzc2FnZXMgbXVzdCBmaXQgaW4gYSBidWZmZXIgb2YgdGhpcyBzaXplLlxuLy8gVGhlIGxlbmd0aCBjb21lcyBmcm9tIHRoZSBsYXJnZXN0IHJlcXVlc3QvcmVzcG9uc2UgZGF0YSB0eXBlIHNpemVcbi8vIFdlIGFsc28gYWRkIHRoZSBwcmVmaXggbGVuZ3RoXG5sZXQgRU5DX01TR19MRU4gPSAwO1xuT2JqZWN0LmtleXMoZGVjUmVzTGVuZ3RocykuZm9yRWFjaCgoaykgPT4ge1xuICAgIGlmIChkZWNSZXNMZW5ndGhzW2tdICsgRU5DX01TR19FWFRSQV9MRU4gPiBFTkNfTVNHX0xFTilcbiAgICAgICAgRU5DX01TR19MRU4gPSBkZWNSZXNMZW5ndGhzW2tdICsgRU5DX01TR19FWFRSQV9MRU47XG59KVxuICBcbmNvbnN0IGRldmljZUNvZGVzID0ge1xuICAgICdDT05ORUNUJzogMSxcbiAgICAnRU5DUllQVEVEX1JFUVVFU1QnOiAyLFxufVxuXG5jb25zdCBlbmNSZXFDb2RlcyA9IHtcbiAgICAnRklOQUxJWkVfUEFJUklORyc6IDAsXG4gICAgJ0dFVF9BRERSRVNTRVMnOiAxLFxuICAgICdBRERfUEVSTUlTU0lPTic6IDIsXG4gICAgJ1NJR05fVFJBTlNBQ1RJT04nOiAzLFxuICAgICdHRVRfV0FMTEVUUyc6IDQsXG4gICAgJ0FERF9QRVJNSVNTSU9OX1YwJzogNSxcbiAgICAnQUREX0FCSV9ERUZTJzogNixcbiAgICAnR0VUX0tWX1JFQ09SRFMnOiA3LFxuICAgICdBRERfS1ZfUkVDT1JEUyc6IDgsXG4gICAgJ1JFTU9WRV9LVl9SRUNPUkRTJzogOSxcbiAgICAnVEVTVCc6IDEwLFxufVxuXG5jb25zdCBtZXNzYWdlQ29uc3RhbnRzID0ge1xuICAgICdOT1RfUEFJUkVEJzogMHgwMCxcbiAgICAnUEFJUkVEJzogMHgwMSxcbn1cblxuY29uc3QgYWRkcmVzc1NpemVzID0ge1xuICAgICdCVEMnOiAyMCwgIC8vIDIwIGJ5dGUgcHVia2V5aGFzaFxuICAgICdFVEgnOiAyMCwgIC8vIDIwIGJ5dGUgYWRkcmVzcyBub3QgaW5jbHVkaW5nIDB4IHByZWZpeFxufVxuICBcbmNvbnN0IHJlc3BvbnNlQ29kZXMgPSB7XG4gICAgUkVTUF9TVUNDRVNTOiAweDAwLFxuICAgIFJFU1BfRVJSX0lOVkFMSURfTVNHOiAweDgwLFxuICAgIFJFU1BfRVJSX1VOU1VQUE9SVEVEX1ZFUjogMHg4MSxcbiAgICBSRVNQX0VSUl9ERVZfQlVTWTogMHg4MixcbiAgICBSRVNQX0VSUl9VU0VSX1RJTUVPVVQ6IDB4ODMsXG4gICAgUkVTUF9FUlJfVVNFUl9ERUNMSU5FRDogMHg4NCxcbiAgICBSRVNQX0VSUl9QQUlSX0ZBSUw6IDB4ODUsXG4gICAgUkVTUF9FUlJfUEFJUl9ESVNBQkxFRDogMHg4NixcbiAgICBSRVNQX0VSUl9QRVJNSVNTSU9OX0RJU0FCTEVEOiAweDg3LFxuICAgIFJFU1BfRVJSX0lOVEVSTkFMOiAweDg4LFxuICAgIFJFU1BfRVJSX0dDRV9USU1FT1VUOiAweDg5LFxuICAgIFJFU1BfRVJSX1dBTExFVF9OT1RfUFJFU0VOVDogMHg4YSxcbiAgICBSRVNQX0VSUl9ERVZfTE9DS0VEOiAweDhiLFxuICAgIFJFU1BfRVJSX0RJU0FCTEVEOiAweDhjLFxuICAgIFJFU1BfRVJSX0FMUkVBRFk6IDB4OGQsXG59XG5cbmNvbnN0IHJlc3BvbnNlTXNncyA9IHtcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX1NVQ0NFU1NdOiAweDAwLFxuICAgIFtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0lOVkFMSURfTVNHXTogJ0ludmFsaWQgUmVxdWVzdCcsXG4gICAgW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfVU5TVVBQT1JURURfVkVSXTogJ1Vuc3VwcG9ydGVkIFZlcnNpb24nLFxuICAgIFtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0RFVl9CVVNZXTogJ0RldmljZSBCdXN5JyxcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9VU0VSX1RJTUVPVVRdOiAnVGltZW91dCBXYWl0aW5nIGZvciBVc2VyJyxcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9VU0VSX0RFQ0xJTkVEXTogJ1JlcXVlc3QgRGVjbGluZWQgYnkgVXNlcicsXG4gICAgW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfUEFJUl9GQUlMXTogJ1BhaXJpbmcgRmFpbGVkJyxcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9QQUlSX0RJU0FCTEVEXTogJ1BhaXJpbmcgaXMgQ3VycmVudGx5IERpc2FibGVkJyxcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9QRVJNSVNTSU9OX0RJU0FCTEVEXTogJ0F1dG9tYXRlZCBTaWduaW5nIGlzIEN1cnJlbnRseSBEaXNhYmxlZCcsXG4gICAgW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfSU5URVJOQUxdOiAnRGV2aWNlIEVycm9yJyxcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9HQ0VfVElNRU9VVF06ICdUaW1lb3V0JyxcbiAgICBbcmVzcG9uc2VDb2Rlcy5SRVNQX0VSUl9XQUxMRVRfTk9UX1BSRVNFTlRdOiAnSW5jb3JyZWN0IFdhbGxldCBVSUQgUHJvdmlkZWQnLFxuICAgIFtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0RFVl9MT0NLRURdOiAnRGV2aWNlIExvY2tlZCcsXG4gICAgW3Jlc3BvbnNlQ29kZXMuUkVTUF9FUlJfRElTQUJMRURdOiAnRGlzYWJsZWQnLFxuICAgIFtyZXNwb25zZUNvZGVzLlJFU1BfRVJSX0FMUkVBRFldOiAnUmVjb3JkIGFscmVhZHkgZXhpc3RzLiBZb3UgbXVzdCBmaXJzdCByZW1vdmUgaXQgb24geW91ciBkZXZpY2UuJ1xufVxuIFxuXG5jb25zdCBzaWduaW5nU2NoZW1hID0ge1xuICAgIEJUQ19UUkFOU0ZFUjogMCxcbiAgICBFVEhfVFJBTlNGRVI6IDEsXG4gICAgRVJDMjBfVFJBTlNGRVI6IDIsXG4gICAgRVRIX01TRzogMyxcbiAgICBFWFRSQV9EQVRBOiA0LFxufVxuXG5jb25zdCBSRVFVRVNUX1RZUEVfQllURSA9IDB4MDI7IC8vIEZvciBhbGwgSFNNLWJvdW5kIHJlcXVlc3RzXG5jb25zdCBWRVJTSU9OX0JZVEUgPSAxO1xuY29uc3QgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMDsgLy8gSGFyZGVuZWQgb2Zmc2V0XG5jb25zdCBIQU5ETEVfTEFSR0VSX0NIQUlOX0lEID0gMjU1OyAvLyBDaGFpbklkIHZhbHVlIHRvIHNpZ25pZnkgbGFyZ2VyIGNoYWluSUQgaXMgaW4gZGF0YSBidWZmZXJcbmNvbnN0IE1BWF9DSEFJTl9JRF9CWVRFUyA9IDg7IC8vIE1heCBudW1iZXIgb2YgYnl0ZXMgdG8gY29udGFpbiBsYXJnZXIgY2hhaW5JRCBpbiBkYXRhIGJ1ZmZlclxuXG5jb25zdCBCQVNFX1VSTCA9ICdodHRwczovL3NpZ25pbmcuZ3JpZHBsLnVzJztcblxuY29uc3QgRUlQNzEyX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQID0ge1xuICAgICdhZGRyZXNzJzogMSxcbiAgICAnYm9vbCc6IDIsXG4gICAgJ3VpbnQ4JzogMyxcbiAgICAndWludDE2JzogNCxcbiAgICAndWludDI0JzogNSxcbiAgICAndWludDMyJzogNixcbiAgICAndWludDQwJzogNyxcbiAgICAndWludDQ4JzogOCxcbiAgICAndWludDU2JzogOSxcbiAgICAndWludDY0JzogMTAsXG4gICAgJ3VpbnQ3Mic6IDExLFxuICAgICd1aW50ODAnOiAxMixcbiAgICAndWludDg4JzogMTMsXG4gICAgJ3VpbnQ5Nic6IDE0LFxuICAgICd1aW50MTA0JzogMTUsXG4gICAgJ3VpbnQxMTInOiAxNixcbiAgICAndWludDEyMCc6IDE3LFxuICAgICd1aW50MTI4JzogMTgsXG4gICAgJ3VpbnQxMzYnOiAxOSxcbiAgICAndWludDE0NCc6IDIwLFxuICAgICd1aW50MTUyJzogMjEsXG4gICAgJ3VpbnQxNjAnOiAyMixcbiAgICAndWludDE2OCc6IDIzLFxuICAgICd1aW50MTc2JzogMjQsXG4gICAgJ3VpbnQxODQnOiAyNSxcbiAgICAndWludDE5Mic6IDI2LFxuICAgICd1aW50MjAwJzogMjcsXG4gICAgJ3VpbnQyMDgnOiAyOCxcbiAgICAndWludDIxNic6IDI5LFxuICAgICd1aW50MjI0JzogMzAsXG4gICAgJ3VpbnQyMzInOiAzMSxcbiAgICAndWludDI0MCc6IDMyLFxuICAgICd1aW50MjQ4JzogMzMsXG4gICAgJ3VpbnQyNTYnOiAzNCxcbiAgICAnaW50OCc6IDM1LFxuICAgICdpbnQxNic6IDM2LFxuICAgICdpbnQyNCc6IDM3LFxuICAgICdpbnQzMic6IDM4LFxuICAgICdpbnQ0MCc6IDM5LFxuICAgICdpbnQ0OCc6IDQwLFxuICAgICdpbnQ1Nic6IDQxLFxuICAgICdpbnQ2NCc6IDQyLFxuICAgICdpbnQ3Mic6IDQzLFxuICAgICdpbnQ4MCc6IDQ0LFxuICAgICdpbnQ4OCc6IDQ1LFxuICAgICdpbnQ5Nic6IDQ2LFxuICAgICdpbnQxMDQnOiA0NyxcbiAgICAnaW50MTEyJzogNDgsXG4gICAgJ2ludDEyMCc6IDQ5LFxuICAgICdpbnQxMjgnOiA1MCxcbiAgICAnaW50MTM2JzogNTEsXG4gICAgJ2ludDE0NCc6IDUyLFxuICAgICdpbnQxNTInOiA1MyxcbiAgICAnaW50MTYwJzogNTQsXG4gICAgJ2ludDE2OCc6IDU1LFxuICAgICdpbnQxNzYnOiA1NixcbiAgICAnaW50MTg0JzogNTcsXG4gICAgJ2ludDE5Mic6IDU4LFxuICAgICdpbnQyMDAnOiA1OSxcbiAgICAnaW50MjA4JzogNjAsXG4gICAgJ2ludDIxNic6IDYxLFxuICAgICdpbnQyMjQnOiA2MixcbiAgICAnaW50MjMyJzogNjMsXG4gICAgJ2ludDI0MCc6IDY0LFxuICAgICdpbnQyNDgnOiA2NSxcbiAgICAnaW50MjU2JzogNjYsXG4gICAgJ3VpbnQnOiA2NyxcbiAgICAnYnl0ZXMxJzogNjksXG4gICAgJ2J5dGVzMic6IDcwLFxuICAgICdieXRlczMnOiA3MSxcbiAgICAnYnl0ZXM0JzogNzIsXG4gICAgJ2J5dGVzNSc6IDczLFxuICAgICdieXRlczYnOiA3NCxcbiAgICAnYnl0ZXM3JzogNzUsXG4gICAgJ2J5dGVzOCc6IDc2LFxuICAgICdieXRlczknOiA3NyxcbiAgICAnYnl0ZXMxMCc6IDc4LFxuICAgICdieXRlczExJzogNzksXG4gICAgJ2J5dGVzMTInOiA4MCxcbiAgICAnYnl0ZXMxMyc6IDgxLFxuICAgICdieXRlczE0JzogODIsXG4gICAgJ2J5dGVzMTUnOiA4MyxcbiAgICAnYnl0ZXMxNic6IDg0LFxuICAgICdieXRlczE3JzogODUsXG4gICAgJ2J5dGVzMTgnOiA4NixcbiAgICAnYnl0ZXMxOSc6IDg3LFxuICAgICdieXRlczIwJzogODgsXG4gICAgJ2J5dGVzMjEnOiA4OSxcbiAgICAnYnl0ZXMyMic6IDkwLFxuICAgICdieXRlczIzJzogOTEsXG4gICAgJ2J5dGVzMjQnOiA5MixcbiAgICAnYnl0ZXMyNSc6IDkzLFxuICAgICdieXRlczI2JzogOTQsXG4gICAgJ2J5dGVzMjcnOiA5NSxcbiAgICAnYnl0ZXMyOCc6IDk2LFxuICAgICdieXRlczI5JzogOTcsXG4gICAgJ2J5dGVzMzAnOiA5OCxcbiAgICAnYnl0ZXMzMSc6IDk5LFxuICAgICdieXRlczMyJzogMTAwLFxuICAgICdieXRlcyc6IDEwMSxcbiAgICAnc3RyaW5nJzogMTAyLFxufVxuXG5jb25zdCBFVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgPSB7XG4gICAgLi4uRUlQNzEyX0FCSV9MQVRUSUNFX0ZXX1RZUEVfTUFQLFxuICAgICd0dXBsZTEnOiAxMDMsXG4gICAgJ3R1cGxlMic6IDEwNCxcbiAgICAndHVwbGUzJzogMTA1LFxuICAgICd0dXBsZTQnOiAxMDYsXG4gICAgJ3R1cGxlNSc6IDEwNyxcbiAgICAndHVwbGU2JzogMTA4LFxuICAgICd0dXBsZTcnOiAxMDksXG4gICAgJ3R1cGxlOCc6IDExMCxcbiAgICAndHVwbGU5JzogMTExLFxuICAgICd0dXBsZTEwJzogMTEyLFxuICAgICd0dXBsZTExJzogMTEzLFxuICAgICd0dXBsZTEyJzogMTE0LFxuICAgICd0dXBsZTEzJzogMTE1LFxuICAgICd0dXBsZTE0JzogMTE2LFxuICAgICd0dXBsZTE1JzogMTE3LFxuICAgICd0dXBsZTE2JzogMTE4LFxuICAgICd0dXBsZTE3JzogMTE5LCAgLy8gRmlybXdhcmUgY3VycmVudGx5IGNhbm5vdCBzdXBwb3J0IHR1cGxlcyBsYXJnZXIgdGhhbiB0aGlzXG59O1xuXG5jb25zdCBldGhNc2dQcm90b2NvbCA9IHtcbiAgICBTSUdOX1BFUlNPTkFMOiB7XG4gICAgICAgIHN0cjogJ3NpZ25QZXJzb25hbCcsXG4gICAgICAgIGVudW1JZHg6IDAsICAgICAgICAgICAgIC8vIEVudW0gaW5kZXggb2YgdGhpcyBwcm90b2NvbCBpbiBMYXR0aWNlIGZpcm13YXJlXG4gICAgfSxcbiAgICBUWVBFRF9EQVRBOiB7XG4gICAgICAgIHN0cjogJ3R5cGVkRGF0YScsXG4gICAgICAgIGVudW1JZHg6IDEsXG4gICAgICAgIHJhd0RhdGFNYXhMZW46IDE2MjksICAgIC8vIE1heCBzaXplIG9mIHJhdyBkYXRhIHBheWxvYWQgaW4gYnl0ZXNcbiAgICAgICAgdHlwZUNvZGVzOiBFSVA3MTJfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgLy8gRW51bSBpbmRpY2VzIG9mIGRhdGEgdHlwZXMgaW4gTGF0dGljZSBmaXJtd2FyZVxuICAgIH0sXG59XG5cbmZ1bmN0aW9uIGdldEZ3VmVyc2lvbkNvbnN0KHYpIHtcbiAgICBjb25zdCBjID0ge1xuICAgICAgICBleHRyYURhdGFGcmFtZVN6OiAwLFxuICAgICAgICBleHRyYURhdGFNYXhGcmFtZXM6IDAsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBndGUodiwgZXhwKSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCBgdmAgZmllbGRzIGNvbWUgaW4gYXMgW2ZpeHxtaW5vcnxtYWpvcl1cbiAgICAgICAgcmV0dXJuICAodlsyXSA+IGV4cFswXSkgfHwgXG4gICAgICAgICAgICAgICAgKHZbMl0gPT09IGV4cFswXSAmJiB2WzFdID4gZXhwWzFdKSB8fCBcbiAgICAgICAgICAgICAgICAodlsyXSA9PT0gZXhwWzBdICYmIHZbMV0gPT09IGV4cFsxXSAmJiB2WzBdID4gZXhwWzJdKSB8fFxuICAgICAgICAgICAgICAgICh2WzJdID09PSBleHBbMF0gJiYgdlsxXSA9PT0gZXhwWzFdICYmIHZbMF0gPT09IGV4cFsyXSk7XG4gICAgfVxuICAgIC8vIFZlcnkgb2xkIGxlZ2FjeSB2ZXJzaW9ucyBkbyBub3QgZ2l2ZSBhIHZlcnNpb24gbnVtYmVyXG4gICAgY29uc3QgbGVnYWN5ID0gKHYubGVuZ3RoID09PSAwKTtcblxuICAgIC8vIEJBU0UgRklFTERTXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gVmFyaW91cyBzaXplIGNvbnN0YW50cyBoYXZlIGNoYW5nZWQgb24gdGhlIGZpcm13YXJlIHNpZGUgb3ZlciB0aW1lIGFuZFxuICAgIC8vIGFyZSBjYXB0dXJlZCBoZXJlXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgNF0pKSB7XG4gICAgICAgIC8vID49MC4xMC4zXG4gICAgICAgIGMucmVxTWF4RGF0YVN6ID0gMTY3ODtcbiAgICAgICAgYy5ldGhNYXhHYXNQcmljZSA9IDIwMDAwMDAwMDAwMDAwOyAvLyAyMDAwMCBnd2VpXG4gICAgICAgIGMuYWRkckZsYWdzQWxsb3dlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDBdKSkge1xuICAgICAgICAvLyA+PTAuMTAuMFxuICAgICAgICBjLnJlcU1heERhdGFTeiA9IDE2Nzg7XG4gICAgICAgIGMuZXRoTWF4R2FzUHJpY2UgPSAyMDAwMDAwMDAwMDAwMDsgLy8gMjAwMDAgZ3dlaVxuICAgICAgICBjLmFkZHJGbGFnc0FsbG93ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZ2FjeSBvciA8MC4xMC4wXG4gICAgICAgIGMucmVxTWF4RGF0YVN6ID0gMTE1MjtcbiAgICAgICAgYy5ldGhNYXhHYXNQcmljZSA9IDUwMDAwMDAwMDAwMDsgLy8gNTAwIGd3ZWlcbiAgICAgICAgYy5hZGRyRmxhZ3NBbGxvd2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZXNlIHRyYW5zZm9ybWF0aW9ucyBhcHBseSB0byBhbGwgdmVyc2lvbnNcbiAgICBjLmV0aE1heERhdGFTeiA9IGMucmVxTWF4RGF0YVN6IC0gMTI4O1xuICAgIGMuZXRoTWF4TXNnU3ogPSBjLmV0aE1heERhdGFTejtcblxuICAgIC8vIEVYVFJBIEZJRUxEUyBBRERFRCBJTiBMQVRFUiBWRVJTSU9OU1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gVjAuMTEuNSBhZGRlZCBhbiBBUEkgZm9yIGNyZWF0aW5nLCByZW1vdmluZywgYW5kIGZldGNoaW5nIGtleS12YWwgZmlsZVxuICAgIC8vIHJlY29yZHMuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBTREssIHdlIG9ubHkgaG9vayBpbnRvIG9uZSB0eXBlIG9mIGt2XG4gICAgLy8gZmlsZTogYWRkcmVzcyBuYW1lcy5cbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEyLCAwXSkpIHtcbiAgICAgICAgYy5rdkFjdGlvbnNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgYy5rdktleU1heFN0clN6ID0gNjM7XG4gICAgICAgIGMua3ZWYWxNYXhTdHJTeiA9IDYzO1xuICAgICAgICBjLmt2QWN0aW9uTWF4TnVtID0gMTA7XG4gICAgICAgIGMua3ZSZW1vdmVNYXhOdW0gPSAxMDA7XG4gICAgfVxuXG4gICAgLy8gVjAuMTEuMiBjaGFuZ2VkIGhvdyBtZXNzYWdlcyBhcmUgZGlzcGxheWVkLiBGb3IgcGVyc29uYWxfc2lnbiBtZXNzYWdlc1xuICAgIC8vIHdlIG5vdyB3cml0ZSB0aGUgaGVhZGVyIChgU2lnbmVyOiA8cGF0aD5gKSBpbnRvIHRoZSBtYWluIGJvZHkgb2YgdGhlIHNjcmVlbi5cbiAgICAvLyBUaGlzIG1lYW5zIHBlcnNvbmFsIHNpZ24gbWVzc2FnZSBtYXggc2l6ZSBpcyBzbGlnaHRseSBzbWFsbGVyIHRoYW4gZm9yXG4gICAgLy8gRUlQNzEyIG1lc3NhZ2VzIGJlY2F1c2UgaW4gdGhlIGxhdHRlciBjYXNlIHRoZXJlIGlzIG5vIGhlYWRlclxuICAgIC8vIE5vdGUgdGhhdCBgPHBhdGg+YCBoYXMgbWF4IHNpemUgb2YgNjIgYnl0ZXMgKGBtL1gvWC8uLi5gKVxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTEsIDJdKSkge1xuICAgICAgICBjLnBlcnNvbmFsU2lnbkhlYWRlclN6ID0gNzI7XG4gICAgfVxuXG4gICAgLy8gVjAuMTEuMCBhbGxvd3MgbmV3IEVUSCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTEsIDBdKSkge1xuICAgICAgICBjLmFsbG93ZWRFdGhUeFR5cGVzVmVyc2lvbiA9IDE7XG4gICAgICAgIGMuYWxsb3dlZEV0aFR4VHlwZXMgPSBbXG4gICAgICAgICAgICAxLCAvLyBlaXAyOTMwXG4gICAgICAgICAgICAyLCAvLyBlaXAxNTU5XG4gICAgICAgIF1cbiAgICAgICAgYy50b3RhbEV4dHJhRXRoVHhEYXRhU3ogPSAxMDtcbiAgICB9XG5cbiAgICAvLyBWMC4xMC4xMCBhbGxvd3MgYSB1c2VyIHRvIHNpZ24gYSBwcmVoYXNoZWQgRVRIIG1lc3NhZ2UgaWYgcGF5bG9hZCB0b28gYmlnXG4gICAgaWYgKCFsZWdhY3kgJiYgZ3RlKHYsIFswLCAxMCwgMTBdKSkge1xuICAgICAgICBjLmV0aE1zZ1ByZUhhc2hBbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBWMC4xMC44IGFsbG93cyBhIHVzZXIgdG8gc2lnbiBhIHByZWhhc2hlZCB0cmFuc2FjdGlvbiBpZiB0aGUgcGF5bG9hZFxuICAgIC8vIGlzIHRvbyBiaWdcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCA4XSkpIHtcbiAgICAgICAgYy5wcmVoYXNoQWxsb3dlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIFYwLjEwLjUgYWRkZWQgdGhlIGFiaWxpdHkgdG8gdXNlIGZsZXhpYmxlIGFkZHJlc3MgcGF0aCBzaXplcywgd2hpY2hcbiAgICAvLyBjaGFuZ2VzIHRoZSBgZ2V0QWRkcmVzc2AgQVBJLiBJdCBhbHNvIGFkZGVkIHN1cHBvcnQgZm9yIEVJUDcxMlxuICAgIGlmICghbGVnYWN5ICYmIGd0ZSh2LCBbMCwgMTAsIDVdKSkge1xuICAgICAgICBjLnZhckFkZHJQYXRoU3pBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgYy5laXA3MTJTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBWMC4xMC40IGludHJvZHVjZWQgdGhlIGFiaWxpdHkgdG8gc2VuZCBzaWduaW5nIHJlcXVlc3RzIG92ZXIgbXVsdGlwbGVcbiAgICAvLyBkYXRhIGZyYW1lcyAoaS5lLiBpbiBtdWx0aXBsZSByZXF1ZXN0cylcbiAgICBpZiAoIWxlZ2FjeSAmJiBndGUodiwgWzAsIDEwLCA0XSkpIHtcbiAgICAgICAgYy5leHRyYURhdGFGcmFtZVN6ID0gMTUwMDsgLy8gMTUwMCBieXRlcyBwZXIgZnJhbWUgb2YgZXh0cmFEYXRhIGFsbG93ZWRcbiAgICAgICAgYy5leHRyYURhdGFNYXhGcmFtZXMgPSAxOyAgLy8gMSBmcmFtZSBvZiBleHRyYURhdGEgYWxsb3dlZFxuICAgIH1cblxuICAgIHJldHVybiBjO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBU0NJSV9SRUdFWDogKC9eW1xceDAwLVxceDdGXSskLyksXG4gICAgZ2V0RndWZXJzaW9uQ29uc3QsXG4gICAgQUREUl9TVFJfTEVOLFxuICAgIEFFU19JVixcbiAgICBCQVNFX1VSTCxcbiAgICBFTkNfTVNHX0xFTixcbiAgICBhZGRyZXNzU2l6ZXMsXG4gICAgZGVjUmVzTGVuZ3RocyxcbiAgICBkZXZpY2VDb2RlcyxcbiAgICBlbmNSZXFDb2RlcyxcbiAgICBldGhNc2dQcm90b2NvbCxcbiAgICBtZXNzYWdlQ29uc3RhbnRzLFxuICAgIHJlc3BvbnNlQ29kZXMsXG4gICAgcmVzcG9uc2VNc2dzLFxuICAgIHNpZ25pbmdTY2hlbWEsXG4gICAgUkVRVUVTVF9UWVBFX0JZVEUsXG4gICAgVkVSU0lPTl9CWVRFLFxuICAgIEhBUkRFTkVEX09GRlNFVCxcbiAgICBIQU5ETEVfTEFSR0VSX0NIQUlOX0lELFxuICAgIE1BWF9DSEFJTl9JRF9CWVRFUyxcbiAgICBFVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAsXG59IiwiLy8gVXRpbCBmb3IgQml0Y29pbi1zcGVjaWZpYyBmdW5jdGlvbmFsaXR5XG5jb25zdCBiZWNoMzIgPSByZXF1aXJlKCdiZWNoMzInKS5iZWNoMzI7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBERUZBVUxUX1NFUVVFTkNFID0gMHhmZmZmZmZmZjtcbmNvbnN0IERFRkFVTFRfU0lHSEFTSF9CVUZGRVIgPSBCdWZmZXIuZnJvbSgnMDEnLCAnaGV4Jyk7IC8vIFNJR0hBU0hfQUxMID0gMHgwMVxuY29uc3QgeyBIQVJERU5FRF9PRkZTRVQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBERUZBVUxUX0NIQU5HRSA9IFs0NCArIEhBUkRFTkVEX09GRlNFVCwgSEFSREVORURfT0ZGU0VULCBIQVJERU5FRF9PRkZTRVQsIDEsIDBdO1xuXG5jb25zdCBPUCA9IHtcbiAgWkVSTzogMHgwMCxcbiAgSEFTSDE2MDogMHhhOSxcbiAgRFVQOiAweDc2LFxuICBFUVVBTDogMHg4NyxcbiAgRVFVQUxWRVJJRlk6IDB4ODgsXG4gIENIRUNLU0lHOiAweGFjLFxufVxuXG5jb25zdCBhZGRyZXNzVmVyc2lvbiA9IHtcbiAgJ0xFR0FDWSc6IDB4MDAsXG4gICdTRUdXSVQnOiAweDA1LFxuICAnVEVTVE5FVCc6IDB4NkYsXG4gICdTRUdXSVRfVEVTVE5FVCc6IDB4QzQsXG4gICdTRUdXSVRfTkFUSVZFX1YwJzogMHhEMCxcbiAgJ1NFR1dJVF9OQVRJVkVfVjBfVEVTVE5FVCc6IDB4RjAsXG59XG5leHBvcnRzLmFkZHJlc3NWZXJzaW9uID0gYWRkcmVzc1ZlcnNpb247XG5cbi8vIEJpdGNvaW4gc2NyaXB0IHR5cGVzIC0tIGRlZmluZWQgYnkgdGhlIExhdHRpY2UgcHJvdG9jb2wgc3BlY1xuLy8gTk9URTogT25seSBjZXJ0YWluIHNjcmlwdCB0eXBlcyBhcmUgc3VwcG9ydGVkIGZvciB0aGUgc3BlbmRlciwgYnV0IGFsbCBhcmUgc3VwcG9ydGVkIGZvciByZWNpcGllbnRcbmNvbnN0IHNjcmlwdFR5cGVzID0ge1xuICBQMlBLSDogMHgwMSwgLy8gU3VwcG9ydGVkIHNwZW5kZXIgdHlwZVxuICBQMlNIOiAweDAyLFxuICBQMlNIX1AyV1BLSDogMHgwMywgLy8gU3VwcG9ydGVkIHNwZW5kZXIgdHlwZVxuICBQMldQS0hfVjA6IDB4MDQsXG59XG5leHBvcnRzLnNjcmlwdFR5cGVzID0gc2NyaXB0VHlwZXNcblxuLy8gV2UgbmVlZCB0byBidWlsZCB0d28gZGlmZmVyZW50IG9iamVjdHMgaGVyZTpcbi8vIDEuIGJpdGNvaW5qcy1saWIgVHJhbnNhY3Rpb25CdWlsZGVyIG9iamVjdCwgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uXG4vLyAgICB3aXRoIHRoZSByZXR1cm5lZCBzaWduYXR1cmVzIHRvIGJ1aWxkIGFuZCBzZXJpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGJlZm9yZVxuLy8gICAgYnJvYWRjYXN0aW5nIGl0LiBXZSB3aWxsIHJlcGxhY2UgYGJpdGNvaW5qcy1saWJgJ3Mgc2lnbmF0dXJlcyB3aXRoIHRoZSBvbmVzXG4vLyAgICB3ZSBnZXQgZnJvbSB0aGUgTGF0dGljZVxuLy8gMi4gVGhlIHNlcmlhbGl6ZWQgTGF0dGljZSByZXF1ZXN0LCB3aGljaCBpbmNsdWRlcyBkYXRhIChvdXRsaW5lZCBpbiB0aGUgc3BlY2lmaWNhdGlvbilcbi8vICAgIHRoYXQgaXMgbmVlZGVkIHRvIHNpZ24gYWxsIG9mIHRoZSBpbnB1dHMgYW5kIGJ1aWxkIGEgY2hhbmdlIG91dHB1dC4gXG4vLyBAaW5wdXRzIChjb250YWluZWQgaW4gYGRhdGFgKVxuLy8gYHByZXZPdXRzYDogYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vICAgICAgICAgICBhLiB0eEhhc2hcbi8vICAgICAgICAgICBiLiB2YWx1ZVxuLy8gICAgICAgICAgIGMuIGluZGV4ICAgICAgICAgIC0tIHRoZSBpbmRleCBvZiB0aGUgb3V0cHV0IGluIHRoZSB0cmFuc2FjdGlvblxuLy8gICAgICAgICAgIGQuIHNpZ25lclBhdGggLS0gdGhlIHBhdGggb2YgdGhlIGFkZHJlc3MgaW4gb3VyIHdhbGxldCB0aGF0IGlzIHNpZ25pbmcgdGhpcyBpbnB1dFxuLy8gYHJlY2lwaWVudGA6IFJlY2VpdmluZyBhZGRyZXNzLCB3aGljaCBtdXN0IGJlIGNvbnZlcnRlZCB0byBhIHB1YmtleWhhc2hcbi8vIGB2YWx1ZWA6ICAgICBOdW1iZXIgb2Ygc2F0b3NoaXMgdG8gc2VuZCB0aGUgcmVjaXBpZW50XG4vLyBgZmVlYDogICAgICAgTnVtYmVyIG9mIHNhdG9zaGlzIHRvIHVzZSBmb3IgYSB0cmFuc2FjdGlvbiBmZWUgKHNob3VsZCBoYXZlIGJlZW4gY2FsY3VsYXRlZClcbi8vICAgICAgICAgICAgICBhbHJlYWR5IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgaW5wdXRzIHBsdXMgdHdvIG91dHB1dHNcbi8vIGB2ZXJzaW9uYDogICBUcmFuc2FjdGlvbiB2ZXJzaW9uIG9mIHRoZSBpbnB1dHMuIEFsbCBpbnB1dHMgbXVzdCBiZSBvZiB0aGUgc2FtZSB2ZXJzaW9uISBcbi8vIGBpc1NlZ3dpdGA6IGEgYm9vbGVhbiB3aGljaCBkZXRlcm1pbmVzIGhvdyB3ZSBzZXJpYWxpemUgdGhlIGRhdGEgYW5kIHBhcmFtZXRlcml6ZSB0eGJcbmV4cG9ydHMuYnVpbGRCaXRjb2luVHhSZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgXG4gICAgICBwcmV2T3V0cywgcmVjaXBpZW50LCB2YWx1ZSwgY2hhbmdlUGF0aD1ERUZBVUxUX0NIQU5HRSwgXG4gICAgICBmZWUsIGlzU2Vnd2l0PW51bGwsIGNoYW5nZVZlcnNpb249J1NFR1dJVCcsIHNwZW5kZXJTY3JpcHRUeXBlPW51bGwgXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGNoYW5nZVBhdGgubGVuZ3RoICE9PSA1KSB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgZnVsbCBjaGFuZ2UgcGF0aC4nKVxuICAgIC8vIFNlcmlhbGl6ZSB0aGUgcmVxdWVzdFxuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoNTkgKyAoNjkgKiBwcmV2T3V0cy5sZW5ndGgpKTtcbiAgICBsZXQgb2ZmID0gMDtcbiAgICAvLyBDaGFuZ2UgdmVyc2lvbiBieXRlIChhLmsuYS4gYWRkcmVzcyBmb3JtYXQgYnl0ZSlcbiAgICBpZiAoYWRkcmVzc1ZlcnNpb25bY2hhbmdlVmVyc2lvbl0gPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFuZ2UgdmVyc2lvbiBzcGVjaWZpZWQuJyk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KGFkZHJlc3NWZXJzaW9uW2NoYW5nZVZlcnNpb25dKTsgb2ZmKys7XG5cbiAgICAvLyBCdWlsZCB0aGUgY2hhbmdlIGRhdGFcbiAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoY2hhbmdlUGF0aC5sZW5ndGgsIG9mZik7IG9mZiArPSA0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKGNoYW5nZVBhdGhbaV0sIG9mZik7IG9mZiArPSA0O1xuICAgIH0gICAgXG5cbiAgICAvLyBGZWUgaXMgYSBwYXJhbVxuICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShmZWUsIG9mZik7IG9mZiArPSA0O1xuICAgIGNvbnN0IGRlYyA9IGRlY29kZUFkZHJlc3MocmVjaXBpZW50KTtcbiAgICAvLyBQYXJhbWV0ZXJpemUgdGhlIHJlY2lwaWVudCBvdXRwdXRcbiAgICBwYXlsb2FkLndyaXRlVUludDgoZGVjLnZlcnNpb25CeXRlLCBvZmYpOyBvZmYrKztcbiAgICBkZWMucGtoLmNvcHkocGF5bG9hZCwgb2ZmKTsgb2ZmICs9IGRlYy5wa2gubGVuZ3RoO1xuICAgIHdyaXRlVUludDY0TEUodmFsdWUsIHBheWxvYWQsIG9mZik7IG9mZiArPSA4O1xuXG4gICAgLy8gQnVpbGQgdGhlIGlucHV0cyBmcm9tIHRoZSBwcmV2aW91cyBvdXRwdXRzXG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KHByZXZPdXRzLmxlbmd0aCwgb2ZmKTsgb2ZmKys7XG4gICAgbGV0IGlucHV0U3VtID0gMDtcblxuICAgIGxldCBzcGVuZGVyU2NyaXB0VHlwZVRvVXNlO1xuICAgIGlmIChzcGVuZGVyU2NyaXB0VHlwZSAhPT0gbnVsbCAmJiBzY3JpcHRUeXBlc1tzcGVuZGVyU2NyaXB0VHlwZV0pIHtcbiAgICAgIC8vIEZvciBuZXdlciB2ZXJzaW9ucyB3ZSB1c2UgdGhlIGlucHV0IHNjcmlwdFR5cGVcbiAgICAgIHNwZW5kZXJTY3JpcHRUeXBlVG9Vc2UgPSBzY3JpcHRUeXBlc1tzcGVuZGVyU2NyaXB0VHlwZV07XG4gICAgfSBlbHNlIGlmIChpc1NlZ3dpdCAhPT0gbnVsbCkge1xuICAgICAgLy8gRm9yIGxlZ2FjeSBjYWxsZXJzIHdlIHVzZSB0aGUgYm9vbGVhbiBgaXNTZWd3aXRgIHRvIGRlbm90ZSBpZiB3ZSBhcmUgc3BlbmRpbmdcbiAgICAgIC8vICp3cmFwcGVkKiBzZWd3aXQgaW5wdXRzXG4gICAgICBzcGVuZGVyU2NyaXB0VHlwZVRvVXNlID0gaXNTZWd3aXQgPT09IHRydWUgPyBzY3JpcHRUeXBlcy5QMlNIX1AyV1BLSCA6IHNjcmlwdFR5cGVzLlAyUEtIO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNwZW5kZXIgc2NyaXB0IHR5cGUgb3Igbm9uZSBwcm92aWRlZC4nKVxuICAgIH1cbiAgICBwcmV2T3V0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKCFpbnB1dC5zaWduZXJQYXRoIHx8IGlucHV0LnNpZ25lclBhdGgubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnVsbCByZWNpcGllbnQgcGF0aCBub3Qgc3BlY2lmaWVkICcpXG4gICAgICB9XG4gICAgICBwYXlsb2FkLndyaXRlVUludDMyTEUoaW5wdXQuc2lnbmVyUGF0aC5sZW5ndGgsIG9mZik7IG9mZiArPSA0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5zaWduZXJQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShpbnB1dC5zaWduZXJQYXRoW2ldLCBvZmYpOyBvZmYgKz0gNDtcbiAgICAgIH1cbiAgICAgIHBheWxvYWQud3JpdGVVSW50MzJMRShpbnB1dC5pbmRleCwgb2ZmKTsgb2ZmICs9IDQ7XG4gICAgICB3cml0ZVVJbnQ2NExFKGlucHV0LnZhbHVlLCBwYXlsb2FkLCBvZmYpOyBvZmYgKz0gODtcbiAgICAgIGlucHV0U3VtICs9IGlucHV0LnZhbHVlO1xuICAgICAgcGF5bG9hZC53cml0ZVVJbnQ4KHNwZW5kZXJTY3JpcHRUeXBlVG9Vc2UsIG9mZik7IG9mZisrO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQudHhIYXNoKSkgaW5wdXQudHhIYXNoID0gQnVmZmVyLmZyb20oaW5wdXQudHhIYXNoLCAnaGV4Jyk7XG4gICAgICBpbnB1dC50eEhhc2guY29weShwYXlsb2FkLCBvZmYpOyBvZmYgKz0gaW5wdXQudHhIYXNoLmxlbmd0aDtcbiAgICB9KVxuICAgIC8vIFNlbmQgdGhlbSBiYWNrIVxuICAgIHJldHVybiB7XG4gICAgICBwYXlsb2FkLFxuICAgICAgc3BlbmRlclNjcmlwdFR5cGU6IHNwZW5kZXJTY3JpcHRUeXBlVG9Vc2UsXG4gICAgICBzY2hlbWE6IGNvbnN0YW50cy5zaWduaW5nU2NoZW1hLkJUQ19UUkFOU0ZFUixcbiAgICAgIG9yaWdEYXRhOiBkYXRhLCAgIC8vIFdlIHdpbGwgbmVlZCB0aGUgb3JpZ2luYWwgZGF0YSBmb3Igc2VyaWFsaXppbmcgdGhlIHR4XG4gICAgICBjaGFuZ2VEYXRhOiB7ICAgICAvLyBUaGlzIGRhdGEgaGVscHMgZmlsbCBpbiB0aGUgY2hhbmdlIG91dHB1dFxuICAgICAgICBjaGFuZ2VWZXJzaW9uLFxuICAgICAgICB2YWx1ZTogaW5wdXRTdW0gLSAodmFsdWUgKyBmZWUpLFxuICAgICAgfVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IGVyciB9O1xuICB9XG59XG5cbi8vIFNlcmlhbGl6ZSBhIHRyYW5zYWN0aW9uIGNvbnNpc3Rpbmcgb2YgaW5wdXRzLCBvdXRwdXRzLCBhbmQgc29tZVxuLy8gbWV0YWRhdGFcbi8vIC0tIGlucHV0cyAgPSB7IGhhc2gsIGluZGV4LCBzaWcsIHB1YmtleSB9XG4vLyAtLSBvdXRwdXRzID0geyB2YWx1ZSwgcmVjaXBpZW50IH0gIC8vIGV4cGVjdHMgYW4gYWRkcmVzcyBzdHJpbmcgZm9yIGByZWNpcGllbnRgXG4vLyAtLSBpc1NlZ3dpdFNwZW5kID0gdHJ1ZSBpZiB0aGUgaW5wdXRzIGFyZSBiZWluZyBzcGVudCB1c2luZyBzZWd3aXRcbi8vICAgICAgICAgICAgICAgICAgICAoTk9URTogZWl0aGVyIEFMTCBhcmUgYmVpbmcgc3BlbnQsIG9yIG5vbmUgYXJlKVxuLy8gLS0gbmV0d29yayA9IE5hbWUgb2YgbmV0d29yaywgdXNlZCB0byBkZXRlcm1pbmUgdHJhbnNhY3Rpb24gdmVyc2lvblxuLy8gLS0gbG9ja1RpbWUgPSBXaWxsIHByb2JhYmx5IGFsd2F5cyBiZSAwXG5leHBvcnRzLnNlcmlhbGl6ZVR4ID0gZnVuY3Rpb24oZGF0YSkge1xuICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgc3BlbmRlclNjcmlwdFR5cGUsIGxvY2tUaW1lPTAsIGNyeXB0byB9ID0gZGF0YTtcbiAgbGV0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gIGxldCBvZmYgPSAwO1xuICAvLyBBbHdheXMgdXNlIHZlcnNpb24gMlxuICBjb25zdCB2ZXJzaW9uID0gMjtcbiAgcGF5bG9hZC53cml0ZVVJbnQzMkxFKHZlcnNpb24sIG9mZik7IG9mZiArPSA0O1xuICBpZiAoc3BlbmRlclNjcmlwdFR5cGUgPT09IHNjcmlwdFR5cGVzLlAyU0hfUDJXUEtIKSB7XG4gICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBCdWZmZXIuZnJvbSgnMDAnLCAnaGV4JykpOyAvLyBtYXJrZXIgPSAweDAwXG4gICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBCdWZmZXIuZnJvbSgnMDEnLCAnaGV4JykpOyAvLyBmbGFnID0gMHgwMVxuICB9XG4gIC8vIFNlcmlhbGl6ZSBzaWduZWQgaW5wdXRzXG4gIGNvbnN0IG51bUlucHV0cyA9IGdldFZhckludChpbnB1dHMubGVuZ3RoKTtcbiAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBudW1JbnB1dHMpOyBvZmYgKz0gbnVtSW5wdXRzLmxlbmd0aDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBpbnB1dC5oYXNoLnJldmVyc2UoKSk7IG9mZiArPSBpbnB1dC5oYXNoLmxlbmd0aDtcbiAgICBjb25zdCBpbmRleCA9IGdldFUzMkxFKGlucHV0LmluZGV4KTtcbiAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIGluZGV4KTsgb2ZmICs9IGluZGV4Lmxlbmd0aDtcbiAgICBpZiAoc3BlbmRlclNjcmlwdFR5cGUgPT09IHNjcmlwdFR5cGVzLlAyU0hfUDJXUEtIKSB7XG4gICAgICAvLyBCdWlsZCBhIHZlY3RvciAodmFyU2xpY2Ugb2YgdmFyU2xpY2UpIGNvbnRhaW5pbmcgdGhlIHJlZGVlbVNjcmlwdFxuICAgICAgY29uc3QgcmVkZWVtU2NyaXB0ID0gYnVpbGRSZWRlZW1TY3JpcHQoaW5wdXQucHVia2V5LCBjcnlwdG8pO1xuICAgICAgY29uc3QgcmVkZWVtU2NyaXB0TGVuID0gZ2V0VmFySW50KHJlZGVlbVNjcmlwdC5sZW5ndGgpO1xuICAgICAgY29uc3Qgc2xpY2UgPSBCdWZmZXIuY29uY2F0KFtyZWRlZW1TY3JpcHRMZW4sIHJlZGVlbVNjcmlwdF0pO1xuICAgICAgY29uc3Qgc2xpY2VMZW4gPSBnZXRWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2xpY2VMZW4pOyBvZmYgKz0gc2xpY2VMZW4ubGVuZ3RoO1xuICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzbGljZSk7IG9mZiArPSBzbGljZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ1aWxkIHRoZSBzaWduYXR1cmUgKyBwdWJrZXkgc2NyaXB0IHRvIHNwZW5kIHRoaXMgaW5wdXRcbiAgICAgIGNvbnN0IHNsaWNlID0gYnVpbGRTaWcoaW5wdXQuc2lnLCBpbnB1dC5wdWJrZXkpO1xuICAgICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzbGljZSk7IG9mZiArPSBzbGljZS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgZGVmYXVsdCBzZXF1ZW5jZSBmb3IgYWxsIHRyYW5zYWN0aW9uc1xuICAgIGNvbnN0IHNlcXVlbmNlID0gZ2V0VTMyTEUoREVGQVVMVF9TRVFVRU5DRSk7XG4gICAgcGF5bG9hZCA9IGNvbmNhdChwYXlsb2FkLCBzZXF1ZW5jZSk7IG9mZiArPSBzZXF1ZW5jZS5sZW5ndGg7XG4gIH0pXG4gIC8vIFNlcmlhbGl6ZSBvdXRwdXRzXG4gIGNvbnN0IG51bU91dHB1dHMgPSBnZXRWYXJJbnQob3V0cHV0cy5sZW5ndGgpO1xuICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIG51bU91dHB1dHMpOyBvZmYgKz0gbnVtT3V0cHV0cy5sZW5ndGg7XG4gIG91dHB1dHMuZm9yRWFjaCgob3V0cHV0KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVNjRMRShvdXRwdXQudmFsdWUpO1xuICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgdmFsdWUpOyBvZmYgKz0gdmFsdWUubGVuZ3RoO1xuICAgIC8vIEJ1aWxkIHRoZSBvdXRwdXQgbG9ja2luZyBzY3JpcHQgYW5kIHdyaXRlIGl0IGFzIGEgdmFyIHNsaWNlXG4gICAgY29uc3Qgc2NyaXB0ID0gYnVpbGRMb2NraW5nU2NyaXB0KG91dHB1dC5yZWNpcGllbnQpO1xuICAgIGNvbnN0IHNjcmlwdExlbiA9IGdldFZhckludChzY3JpcHQubGVuZ3RoKTtcbiAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIHNjcmlwdExlbik7IG9mZiArPSBzY3JpcHRMZW4ubGVuZ3RoO1xuICAgIHBheWxvYWQgPSBjb25jYXQocGF5bG9hZCwgc2NyaXB0KTsgb2ZmICs9IHNjcmlwdC5sZW5ndGg7XG4gIH0pXG4gIC8vIEFkZCB3aXRuZXNzIGRhdGEgaWYgbmVlZGVkXG4gIGlmIChzcGVuZGVyU2NyaXB0VHlwZSA9PT0gc2NyaXB0VHlwZXMuUDJTSF9QMldQS0gpIHtcbiAgICBjb25zdCBzaWdzID0gW107XG4gICAgY29uc3QgcHVia2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaWdzLnB1c2goaW5wdXRzW2ldLnNpZyk7XG4gICAgICBwdWJrZXlzLnB1c2goaW5wdXRzW2ldLnB1YmtleSk7XG4gICAgfVxuICAgIGNvbnN0IHdpdG5lc3NTbGljZSA9IGJ1aWxkV2l0bmVzcyhzaWdzLCBwdWJrZXlzKTtcbiAgICBwYXlsb2FkID0gY29uY2F0KHBheWxvYWQsIHdpdG5lc3NTbGljZSk7IG9mZiArPSB3aXRuZXNzU2xpY2UubGVuZ3RoO1xuICB9XG4gIC8vIEZpbmlzaCB3aXRoIGxvY2t0aW1lXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtwYXlsb2FkLCBnZXRVMzJMRShsb2NrVGltZSldKS50b1N0cmluZygnaGV4Jyk7XG59XG5cbi8vIENvbnZlcnQgYSBwdWJrZXloYXNoIHRvIGEgYml0Y29pbiBiYXNlNThjaGVjayBhZGRyZXNzIHdpdGggYSB2ZXJzaW9uIGJ5dGVcbmV4cG9ydHMuZ2V0Qml0Y29pbkFkZHJlc3MgPSBmdW5jdGlvbihwdWJrZXloYXNoLCB2ZXJzaW9uKSB7XG4gIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFt2ZXJzaW9uXSksIHB1YmtleWhhc2hdKSk7XG59XG5cblxuLy8gQnVpbGRlciB1dGlsc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRSZWRlZW1TY3JpcHQocHVia2V5LCBjcnlwdG8pIHtcbiAgY29uc3QgcmVkZWVtU2NyaXB0ID0gQnVmZmVyLmFsbG9jKDIyKTtcbiAgY29uc3Qgc2hhSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUocHVia2V5KS5kaWdlc3QoKTtcbiAgY29uc3QgcHVia2V5aGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoc2hhSGFzaCkuZGlnZXN0KCk7XG4gIHJlZGVlbVNjcmlwdC53cml0ZVVJbnQ4KE9QLlpFUk8pO1xuICByZWRlZW1TY3JpcHQud3JpdGVVSW50OChwdWJrZXloYXNoLmxlbmd0aCwgMSk7XG4gIHB1YmtleWhhc2guY29weShyZWRlZW1TY3JpcHQsIDIpO1xuICByZXR1cm4gcmVkZWVtU2NyaXB0O1xufVxuXG4vLyBWYXIgc2xpY2Ugb2Ygc2lnbmF0dXJlICsgdmFyIHNsaWNlIG9mIHB1YmtleVxuZnVuY3Rpb24gYnVpbGRTaWcoc2lnLCBwdWJrZXkpIHtcbiAgc2lnID0gQnVmZmVyLmNvbmNhdChbc2lnLCBERUZBVUxUX1NJR0hBU0hfQlVGRkVSXSlcbiAgY29uc3Qgc2lnTGVuID0gZ2V0VmFySW50KHNpZy5sZW5ndGgpO1xuICBjb25zdCBwdWJrZXlMZW4gPSBnZXRWYXJJbnQocHVia2V5Lmxlbmd0aCk7XG4gIGNvbnN0IHNsaWNlID0gQnVmZmVyLmNvbmNhdChbc2lnTGVuLCBzaWcsIHB1YmtleUxlbiwgcHVia2V5XSk7XG4gIGNvbnN0IGxlbiA9IGdldFZhckludChzbGljZS5sZW5ndGgpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbGVuLCBzbGljZV0pO1xufVxuXG4vLyBXaXRuZXNzIGlzIHdyaXR0ZW4gYXMgYSBcInZlY3RvclwiLCB3aGljaCBpcyBhIGxpc3Qgb2YgdmFyU2xpY2VzXG4vLyBwcmVmaXhlZCBieSB0aGUgbnVtYmVyIG9mIGl0ZW1zXG5mdW5jdGlvbiBidWlsZFdpdG5lc3Moc2lncywgcHVia2V5cykge1xuICBsZXQgd2l0bmVzcyA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgLy8gVHdvIGl0ZW1zIGluIGVhY2ggdmVjdG9yIChzaWcsIHB1YmtleSlcbiAgY29uc3QgbGVuID0gQnVmZmVyLmFsbG9jKDEpOyBsZW4ud3JpdGVVSW50OCgyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2lnID0gQnVmZmVyLmNvbmNhdChbc2lnc1tpXSwgREVGQVVMVF9TSUdIQVNIX0JVRkZFUl0pO1xuICAgIGNvbnN0IHNpZ0xlbiA9IGdldFZhckludChzaWcubGVuZ3RoKTtcbiAgICBjb25zdCBwdWJrZXkgPSBwdWJrZXlzW2ldO1xuICAgIGNvbnN0IHB1YmtleUxlbiA9IGdldFZhckludChwdWJrZXkubGVuZ3RoKTtcbiAgICB3aXRuZXNzID0gQnVmZmVyLmNvbmNhdChbd2l0bmVzcywgbGVuLCBzaWdMZW4sIHNpZywgcHVia2V5TGVuLCBwdWJrZXldKTtcbiAgfVxuICByZXR1cm4gd2l0bmVzcztcbn1cblxuLy8gTG9ja2luZyBzY3JpcHQgYnVpZGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRMb2NraW5nU2NyaXB0KGFkZHJlc3MpIHtcbiAgY29uc3QgZGVjID0gZGVjb2RlQWRkcmVzcyhhZGRyZXNzKTtcbiAgc3dpdGNoIChkZWMudmVyc2lvbkJ5dGUpIHtcbiAgICBjYXNlIGFkZHJlc3NWZXJzaW9uLlNFR1dJVF9OQVRJVkVfVjA6XG4gICAgY2FzZSBhZGRyZXNzVmVyc2lvbi5TRUdXSVRfTkFUSVZFX1YwX1RFU1RORVQ6XG4gICAgICByZXR1cm4gYnVpbGRQMndwa2hMb2NraW5nU2NyaXB0KGRlYy5wa2gpO1xuICAgIGNhc2UgYWRkcmVzc1ZlcnNpb24uU0VHV0lUOlxuICAgIGNhc2UgYWRkcmVzc1ZlcnNpb24uU0VHV0lUX1RFU1RORVQ6XG4gICAgICByZXR1cm4gYnVpbGRQMnNoTG9ja2luZ1NjcmlwdChkZWMucGtoKTtcbiAgICBjYXNlIGFkZHJlc3NWZXJzaW9uLkxFR0FDWTpcbiAgICBjYXNlIGFkZHJlc3NWZXJzaW9uLlRFU1RORVQ6XG4gICAgICByZXR1cm4gYnVpbGRQMnBraExvY2tpbmdTY3JpcHQoZGVjLnBraCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB2ZXJzaW9uIGJ5dGU6ICR7ZGVjLnZlcnNpb25CeXRlfS4gQ2Fubm90IGJ1aWxkIEJUQyB0cmFuc2FjdGlvbi5gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFAycGtoTG9ja2luZ1NjcmlwdChwdWJrZXloYXNoKSB7XG4gIGNvbnN0IG91dCA9IEJ1ZmZlci5hbGxvYyg1ICsgcHVia2V5aGFzaC5sZW5ndGgpO1xuICBsZXQgb2ZmID0gMDtcbiAgb3V0LndyaXRlVUludDgoT1AuRFVQLCBvZmYpOyBvZmYrKztcbiAgb3V0LndyaXRlVUludDgoT1AuSEFTSDE2MCwgb2ZmKTsgb2ZmKys7XG4gIG91dC53cml0ZVVJbnQ4KHB1YmtleWhhc2gubGVuZ3RoLCBvZmYpOyBvZmYrKztcbiAgcHVia2V5aGFzaC5jb3B5KG91dCwgb2ZmKTsgb2ZmICs9IHB1YmtleWhhc2gubGVuZ3RoO1xuICBvdXQud3JpdGVVSW50OChPUC5FUVVBTFZFUklGWSwgb2ZmKTsgb2ZmKys7XG4gIG91dC53cml0ZVVJbnQ4KE9QLkNIRUNLU0lHLCBvZmYpOyBvZmYrKztcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQMnNoTG9ja2luZ1NjcmlwdChwdWJrZXloYXNoKSB7XG4gIGNvbnN0IG91dCA9IEJ1ZmZlci5hbGxvYygzICsgcHVia2V5aGFzaC5sZW5ndGgpO1xuICBsZXQgb2ZmID0gMDtcbiAgb3V0LndyaXRlVUludDgoT1AuSEFTSDE2MCwgb2ZmKTsgb2ZmKys7XG4gIG91dC53cml0ZVVJbnQ4KHB1YmtleWhhc2gubGVuZ3RoLCBvZmYpOyBvZmYrKztcbiAgcHVia2V5aGFzaC5jb3B5KG91dCwgb2ZmKTsgb2ZmICs9IHB1YmtleWhhc2gubGVuZ3RoO1xuICBvdXQud3JpdGVVSW50OChPUC5FUVVBTCwgb2ZmKTsgb2ZmKys7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUDJ3cGtoTG9ja2luZ1NjcmlwdChwdWJrZXloYXNoKSB7XG4gIGNvbnN0IG91dCA9IEJ1ZmZlci5hbGxvYygyICsgcHVia2V5aGFzaC5sZW5ndGgpO1xuICBvdXQud3JpdGVVSW50OChPUC5aRVJPLCAwKTtcbiAgb3V0LndyaXRlVUludDgocHVia2V5aGFzaC5sZW5ndGgsIDEpO1xuICBwdWJrZXloYXNoLmNvcHkob3V0LCAyKTtcbiAgcmV0dXJuIG91dDsgIFxufVxuXG4vLyBTdGF0aWMgVXRpbHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29uY2F0KGJhc2UsIGFkZGl0aW9uKSB7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtiYXNlLCBhZGRpdGlvbl0pO1xufVxuXG5mdW5jdGlvbiBnZXRVNjRMRSh4KSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgd3JpdGVVSW50NjRMRSh4LCBidWZmZXIsIDApO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBnZXRVMzJMRSh4KSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYnVmZmVyLndyaXRlVUludDMyTEUoeCk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGdldFZhckludCAoeCkge1xuICBsZXQgYnVmZmVyO1xuICBpZiAoeCA8IDB4ZmQpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgYnVmZmVyLndyaXRlVUludDgoeCk7XG4gIH0gZWxzZSBpZiAoeCA8PSAweGZmZmYpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMyk7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgMCk7XG4gICAgYnVmZmVyLndyaXRlVUludDE2TEUoeCwgMSk7XG4gIH0gZWxzZSBpZiAoeCA8IDB4ZmZmZmZmZmYpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MoNSk7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZSwgMCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoeCwgMSk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDkpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYsIDApO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHggPj4+IDAsIDEpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKCh4IC8gMHgxMDAwMDAwMDApIHwgMCwgNSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50NjRMRShuLCBidWYsIG9mZikge1xuICBpZiAodHlwZW9mIG4gPT09ICdudW1iZXInKSBuID0gbi50b1N0cmluZygxNik7XG4gIGNvbnN0IHByZUJ1ZiA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgY29uc3QgblN0ciA9IG4ubGVuZ3RoICUgMiA9PT0gMCA/IG4udG9TdHJpbmcoMTYpIDogYDAke24udG9TdHJpbmcoMTYpfWA7XG4gIGNvbnN0IG5CdWYgPSBCdWZmZXIuZnJvbShuU3RyLCAnaGV4Jyk7XG4gIG5CdWYucmV2ZXJzZSgpLmNvcHkocHJlQnVmLCAwKTtcbiAgcHJlQnVmLmNvcHkoYnVmLCBvZmYpO1xuICByZXR1cm4gcHJlQnVmO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBZGRyZXNzKGFkZHJlc3MpIHtcbmxldCB2ZXJzaW9uQnl0ZSwgcGtoO1xuICB0cnkge1xuICAgIHZlcnNpb25CeXRlID0gYnM1OGNoZWNrLmRlY29kZShhZGRyZXNzKVswXTtcbiAgICBwa2ggPSBiczU4Y2hlY2suZGVjb2RlKGFkZHJlc3MpLnNsaWNlKDEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmVjaDMyRGVjID0gYmVjaDMyLmRlY29kZShhZGRyZXNzKTtcbiAgICAgIGlmIChiZWNoMzJEZWMucHJlZml4ID09PSAnYmMnKVxuICAgICAgICB2ZXJzaW9uQnl0ZSA9IDB4RDA7XG4gICAgICBlbHNlIGlmIChiZWNoMzJEZWMucHJlZml4ID09PSAndGInKVxuICAgICAgICB2ZXJzaW9uQnl0ZSA9IDB4RjA7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJlZml4OiBtdXN0IGJlIGJjIG9yIHRiLicpO1xuICAgICAgaWYgKGJlY2gzMkRlYy53b3Jkc1swXSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzZWd3aXQgdmVyc2lvbjogbXVzdCBiZSAwLCBnb3QgJHtiZWNoMzJEZWMud29yZHNbMF19YCk7XG4gICAgICBwa2ggPSBCdWZmZXIuZnJvbShiZWNoMzIuZnJvbVdvcmRzKGJlY2gzMkRlYy53b3Jkcy5zbGljZSgxKSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGVjb2RlIGFkZHJlc3M6ICR7YWRkcmVzc306ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt2ZXJzaW9uQnl0ZSwgcGtofTtcbn0iLCJjb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyXG5jb25zdCBrZWNjYWsyNTYgPSByZXF1aXJlKCdqcy1zaGEzJykua2VjY2FrMjU2O1xuY29uc3QgeyBFVEhfQUJJX0xBVFRJQ0VfRldfVFlQRV9NQVAgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBOQU1FX01BWF9TWiA9IDEwMDtcbmNvbnN0IEhFQURFUl9TWiA9IDUgKyBOQU1FX01BWF9TWjsgLy8gNCBieXRlIHNpZyArIG5hbWUgKyAxIGJ5dGUgcGFyYW0gY291bnRcbmNvbnN0IENBVEVHT1JZX1NaID0gMzI7XG5jb25zdCBQQVJBTV9TWiA9IDI2OyAvLyAyMCBieXRlIG5hbWUgKyA2IGJ5dGUgZGVmXG5jb25zdCBNQVhfUEFSQU1TID0gMTg7XG5jb25zdCBNQVhfQUJJX0RFRlMgPSAyO1xuZXhwb3J0cy5NQVhfQUJJX0RFRlMgPSBNQVhfQUJJX0RFRlM7XG5cbi8vIEJ1aWxkIGEgcmVxdWVzdCB0byBhZGQgQUJJIGRhdGFcbmV4cG9ydHMuYnVpbGRBZGRBYmlQYXlsb2FkID0gZnVuY3Rpb24oZGVmcykge1xuICBpZiAoIWRlZnMgfHwgIUFycmF5LmlzQXJyYXkoZGVmcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRlZmluaXRpb25zLicpO1xuICBpZiAoZGVmcy5sZW5ndGggPiBleHBvcnRzLk1BWF9BQklfREVGUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtYXkgb25seSBhZGQgJHtNQVhfQUJJX0RFRlN9IEFCSSBkZWZpbml0aW9ucyBwZXIgcmVxdWVzdC5gKTtcbiAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYygxICsgKE1BWF9BQklfREVGUyAqIChIRUFERVJfU1ogKyBDQVRFR09SWV9TWiArIChQQVJBTV9TWiAqIE1BWF9QQVJBTVMpKSkpO1xuICBsZXQgb2ZmID0gMDtcbiAgYi53cml0ZVVJbnQ4KGRlZnMubGVuZ3RoLCBvZmYpOyBvZmYrKztcbiAgZGVmcy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICBpZiAoIWRlZi5zaWcgfHwgIWRlZi5uYW1lIHx8ICFkZWYucGFyYW1zKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lLCBzaWcsIGFuZCBwYXJhbXMgbXVzdCBiZSBwcmVzZW50IGZvciBldmVyeSBBQkkgZGVmaW5pdGlvbi4nKVxuICAgIC8vIC0tIEhlYWRlciBkYXRhIC0tXG4gICAgY29uc3Qgc2lnID0gQnVmZmVyLmZyb20oZGVmLnNpZywgJ2hleCcpO1xuICAgIGlmIChzaWcubGVuZ3RoICE9PSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBzaWduYXR1cmVzIG11c3QgYWx3YXlzIGJlIGZvdXIgYnl0ZXMuJyk7XG4gICAgc2lnLmNvcHkoYiwgb2ZmKTsgb2ZmICs9IHNpZy5sZW5ndGg7XG4gICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKGRlZi5uYW1lKTtcbiAgICBpZiAobmFtZS5sZW5ndGggPiBOQU1FX01BWF9TWiAtIDEpIC8vIFRoZSAtMSBhY2NvdW50cyBmb3IgdGhlIG51bGwgdGVybWluYXRvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGZ1bmN0aW9uIG5hbWVzIHNob3J0ZXIgdGhhbiAke05BTUVfTUFYX1NaLTF9IGNoYXJhY3RlcnMgYXJlIHN1cHBvcnRlZC5gKTtcbiAgICBCdWZmZXIuZnJvbShkZWYubmFtZSkuc2xpY2UoMCwgTkFNRV9NQVhfU1opLmNvcHkoYiwgb2ZmKTsgb2ZmICs9IE5BTUVfTUFYX1NaO1xuICAgIC8vIE51bWJlciBvZiBwYXJhbWV0ZXJzXG4gICAgY29uc3QgbnVtUGFyYW1zID0gQXJyYXkuaXNBcnJheShkZWYucGFyYW1zKSA/IGRlZi5wYXJhbXMubGVuZ3RoIDogMDtcbiAgICBiLndyaXRlVUludDgobnVtUGFyYW1zLCBvZmYpOyBvZmYrKztcbiAgICAvLyAtLSAob3B0aW9uYWwpIENhdGVnb3J5IG5hbWUgLS1cbiAgICBpZiAoZGVmLmNhdGVnb3J5ICYmIHR5cGVvZiBkZWYuY2F0ZWdvcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjYXRlZ29yeSA9IEJ1ZmZlci5mcm9tKGRlZi5jYXRlZ29yeSk7XG4gICAgICBpZiAoY2F0ZWdvcnkubGVuZ3RoID4gQ0FURUdPUllfU1ogLSAxKSAvLyAtMSBhY2NvdW50cyBmb3IgbnVsbCB0ZXJtaW5hdG9yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2F0ZWdvcnkgbmFtZSBtdXN0IGJlIHNob3J0ZXIgdGhhbiAke0NBVEVHT1JZX1NaIC0gMX0uIEdvdCAke2NhdGVnb3J5Lmxlbmd0aH1gKTtcbiAgICAgIGNhdGVnb3J5LmNvcHkoYiwgb2ZmKTtcbiAgICB9XG4gICAgb2ZmICs9IENBVEVHT1JZX1NaO1xuICAgIC8vIC0tIFBhcmFtIGRhdGEgLS1cbiAgICBpZiAobnVtUGFyYW1zID4gTUFYX1BBUkFNUylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgQUJJIGRlZmludGlvbnMgd2l0aCA8PTEwIHBhcmFtZXRlcnMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICBpZiAobnVtUGFyYW1zID4gMCkge1xuICAgICAgLy8gRmlyc3QgY29weSBwYXJhbSBuYW1lcyAoZmlyc3QgMjAgYnl0ZXMpXG4gICAgICBkZWYucGFyYW1zLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbS5uYW1lID09PSB1bmRlZmluZWQgfHwgcGFyYW0ubGF0dGljZVR5cGVJZHggPT09IHVuZGVmaW5lZCB8fCBwYXJhbS5pc0FycmF5ID09PSB1bmRlZmluZWQgfHwgcGFyYW0uYXJyYXlTeiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmFtZSwgbGF0dGljZVR5cGVJZHgsIGlzQXJyYXksIGFuZCBhcnJheVN6IG11c3QgYmUgZGVmaW5lZCBmb3IgYWxsIEFCSSBwYXJhbXMuJyk7XG4gICAgICAgIEJ1ZmZlci5mcm9tKHBhcmFtLm5hbWUpLnNsaWNlKDAsIDIwKS5jb3B5KGIsIG9mZik7IG9mZiArPSAyMDtcbiAgICAgIH0pXG4gICAgICAvLyBCdW1wIG9mZnNldCB0byBhY2NvdW50IGZvciBibGFuayBwYXJhbSBzbG90c1xuICAgICAgb2ZmICs9IDIwICogKE1BWF9QQVJBTVMgLSBudW1QYXJhbXMpO1xuICAgICAgLy8gTmV4dCBjb3B5IHRoZSBkZWZpbml0aW9uc1xuICAgICAgZGVmLnBhcmFtcy5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICBiLndyaXRlVUludDgocGFyYW0ubGF0dGljZVR5cGVJZHgsIG9mZik7IG9mZisrO1xuICAgICAgICBiLndyaXRlVUludDgocGFyYW0uaXNBcnJheSA9PT0gdHJ1ZSwgb2ZmKTsgb2ZmKys7XG4gICAgICAgIGIud3JpdGVVSW50MzJMRShwYXJhbS5hcnJheVN6LCBvZmYpOyBvZmYgKz0gNDtcbiAgICAgIH0pXG4gICAgICAvLyBCdW1wIG9mZnNldCBhZ2FpblxuICAgICAgb2ZmICs9IDYgKiAoTUFYX1BBUkFNUyAtIG51bVBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXJhbXMsIGp1c3QgYnVtcCB0aGUgb2Zmc2V0XG4gICAgICBvZmYgKz0gUEFSQU1fU1ogKiBNQVhfUEFSQU1TO1xuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGI7XG59XG5cbi8vIEdldCB0aGUgNC1ieXRlIGZ1bmN0aW9uIGlkZW50aWZpZXIgYmFzZWQgb24gdGhlIGNhbm9uaWNhbCBuYW1lXG5leHBvcnRzLmdldEZ1bmNTaWcgPSBmdW5jdGlvbihmKSB7XG4gIC8vIENhbm9uaWNhbCBuYW1lIGlzOlxuICAvLyBmdW5jTmFtZShwYXJhbVR5cGUwLCAuLi4sIHBhcmFtVHlwZU4pXG4gIGxldCBjYW5vbmljYWxOYW1lID0gYCR7Zi5uYW1lfShgO1xuICBmLmlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgIGlmIChpbnB1dC50eXBlLmluZGV4T2YoJ3R1cGxlJykgPiAtMSkge1xuICAgICAgY29uc3QgYXJyU3VmZml4ID0gaW5wdXQudHlwZS5zbGljZShpbnB1dC50eXBlLmluZGV4T2YoJ3R1cGxlJykgKyA1KTtcbiAgICAgIGNhbm9uaWNhbE5hbWUgKz0gJygnXG4gICAgICBpbnB1dC5jb21wb25lbnRzLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgICAgY2Fub25pY2FsTmFtZSArPSBgJHtjLnR5cGV9JHtpID09PSBpbnB1dC5jb21wb25lbnRzLmxlbmd0aCAtIDEgPyAnJyA6ICcsJ31gO1xuICAgICAgfSlcbiAgICAgIGNhbm9uaWNhbE5hbWUgKz0gYCkke2FyclN1ZmZpeH0sYFxuICAgIH0gZWxzZSB7XG4gICAgICBjYW5vbmljYWxOYW1lICs9IGAke2lucHV0LnR5cGV9LGBcbiAgICB9XG4gIH0pXG4gIGlmIChmLmlucHV0cy5sZW5ndGggPiAwKVxuICAgIGNhbm9uaWNhbE5hbWUgPSBjYW5vbmljYWxOYW1lLnNsaWNlKDAsIGNhbm9uaWNhbE5hbWUubGVuZ3RoIC0gMSlcbiAgY2Fub25pY2FsTmFtZSArPSAnKSdcbiAgcmV0dXJuIGtlY2NhazI1NihjYW5vbmljYWxOYW1lKS5zbGljZSgwLCA4KTtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUEFSU0VSU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gcGFyc2VFdGhlcnNjYW5BYmlEZWZzKF9kZWZzLCBza2lwRXJyb3JzPWZhbHNlKSB7IC8vIGBfZGVmc2AgYXJlIGByZXN1bHRgIG9mIHRoZSBwYXJzZWQgcmVzcG9uc2VcbiAgY29uc3QgZGVmcyA9IFtdO1xuICBfZGVmcy5mb3JFYWNoKChkKSA9PiB7XG4gICAgaWYgKGQubmFtZSAmJiBkLmlucHV0cyAmJiBkLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgZC5zdGF0ZU11dGFiaWxpdHkgIT09ICd2aWV3JyAmJiBkLmNvbnN0YW50ICE9PSB0cnVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzaWcgPSBleHBvcnRzLmdldEZ1bmNTaWcoZCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlRXRoZXJzY2FuQWJpSW5wdXRzKGQuaW5wdXRzKTtcbiAgICAgICAgZGVmcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBkLm5hbWUsXG4gICAgICAgICAgc2lnLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoc2tpcEVycm9ycyA9PT0gdHJ1ZSlcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBkZWY6JywgZC5uYW1lLCBlcnIudG9TdHJpbmcoKSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gZGVmcztcbn1cblxuZXhwb3J0cy5hYmlQYXJzZXJzID0ge1xuICBldGhlcnNjYW46IHBhcnNlRXRoZXJzY2FuQWJpRGVmcyxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSEVMUEVSU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2UgdGhlIEFCSSBwYXJhbSBkYXRhIGludG8gc3RydWN0cyBMYXR0aWNlIGZpcm13YXJlIHdpbGwgcmVjb2duaXplLlxuZnVuY3Rpb24gcGFyc2VFdGhlcnNjYW5BYmlJbnB1dHMoaW5wdXRzLCBkYXRhPVtdLCBpc05lc3RlZFR1cGxlPWZhbHNlKSB7XG4gIGxldCB0dXBsZVBhcmFtcyA9IFtdO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGlucHV0LnR5cGU7XG4gICAgY29uc3QgZCA9IHsgaXNBcnJheTogZmFsc2UsIGFycmF5U3o6IDAsIG5hbWU6IGlucHV0Lm5hbWUsIH07XG4gICAgY29uc3Qgb3BlbkJyYWNrZXRJZHggPSB0eXBlTmFtZS5pbmRleE9mKCdbJyk7XG4gICAgY29uc3QgY2xvc2VCcmFja2V0SWR4ID0gdHlwZU5hbWUuaW5kZXhPZignXScpO1xuICAgIGNvbnN0IGlzTXVsdGlEaW0gPSB0eXBlTmFtZS5zcGxpdCgnWycpLmxlbmd0aCA+IDI7XG4gICAgaWYgKGlzTXVsdGlEaW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2tpcHBpbmcgZnVuY3Rpb24gd2l0aCB1bnN1cHBvcnRlZCBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IHR5cGUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3BlbkJyYWNrZXRJZHggPiAtMSAmJiBjbG9zZUJyYWNrZXRJZHggPiAtMSkge1xuICAgICAgICBpZiAob3BlbkJyYWNrZXRJZHggPj0gY2xvc2VCcmFja2V0SWR4KSB7XG4gICAgICAgICAgOyAvLyBub3QgYSB2YWxpZCBwYXJhbSAtLSBza2lwIGl0XG4gICAgICAgIH0gZWxzZSBpZiAoKG9wZW5CcmFja2V0SWR4ICsgMSkgPT09IGNsb3NlQnJhY2tldElkeCkge1xuICAgICAgICAgIGQuaXNBcnJheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIGFycmF5IHNpemUgaWYgYXBwbGljYWJsZVxuICAgICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHR5cGVOYW1lLnNsaWNlKG9wZW5CcmFja2V0SWR4ICsgMSwgY2xvc2VCcmFja2V0SWR4KSlcbiAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQuaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAgZC5hcnJheVN6ID0gbnVtYmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgc2luZ3VsYXJUeXBlTmFtZSA9IG9wZW5CcmFja2V0SWR4ID4gLTEgPyB0eXBlTmFtZS5zbGljZSgwLCBvcGVuQnJhY2tldElkeCkgOiB0eXBlTmFtZTtcbiAgICAgIGlmIChzaW5ndWxhclR5cGVOYW1lID09PSAndHVwbGUnKSB7XG4gICAgICAgIGlmIChpc05lc3RlZFR1cGxlID09PSB0cnVlKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGVkIHR1cGxlcyBhcmUgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgIHNpbmd1bGFyVHlwZU5hbWUgPSBgdHVwbGUke2lucHV0LmNvbXBvbmVudHMubGVuZ3RofWA7XG4gICAgICAgIHR1cGxlUGFyYW1zID0gcGFyc2VFdGhlcnNjYW5BYmlJbnB1dHMoaW5wdXQuY29tcG9uZW50cywgdHVwbGVQYXJhbXMsIHRydWUpO1xuICAgICAgfVxuICAgICAgZC5sYXR0aWNlVHlwZUlkeCA9IGdldFR5cGVJZHhMYXR0aWNlRncoc2luZ3VsYXJUeXBlTmFtZSlcbiAgICAgIGlmICghZC5sYXR0aWNlVHlwZUlkeClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlOiAke3R5cGVOYW1lfWApXG4gICAgICBkYXRhLnB1c2goZClcbiAgICB9XG4gIH0pXG4gIGNvbnN0IHBhcmFtcyA9IGRhdGEuY29uY2F0KHR1cGxlUGFyYW1zKVxuICBpZiAocGFyYW1zLmxlbmd0aCA+IDE4KVxuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gaGFzIHRvbyBtYW55IHBhcmFtZXRlcnMgZm9yIExhdHRpY2UgZmlybXdhcmUgKDE4IG1heCknKVxuICByZXR1cm4gZGF0YS5jb25jYXQodHVwbGVQYXJhbXMpO1xufVxuXG4vLyBFbnVtIHZhbHVlcyBmcm9tIGluc2lkZSBMYXR0aWNlIGZpcm13YXJlXG5mdW5jdGlvbiBnZXRUeXBlSWR4TGF0dGljZUZ3KHR5cGUpIHtcbiAgcmV0dXJuIEVUSF9BQklfTEFUVElDRV9GV19UWVBFX01BUFt0eXBlXTtcbn1cbiIsIi8vIFN0YXRpYyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgeyBidWlsZEJpdGNvaW5UeFJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vYml0Y29pbicpO1xuY29uc3QgeyBidWlsZEV0aGVyZXVtVHhSZXF1ZXN0LCBidWlsZEV0aGVyZXVtTXNnUmVxdWVzdCwgZW5zdXJlSGV4QnVmZmVyIH0gPSByZXF1aXJlKCcuL2V0aGVyZXVtJyk7XG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyXG5jb25zdCBhZXMgPSByZXF1aXJlKCdhZXMtanMnKTtcbmNvbnN0IGNyYzMyID0gcmVxdWlyZSgnY3JjLTMyJyk7XG5jb25zdCBlbGxpcHRpYyA9IHJlcXVpcmUoJ2VsbGlwdGljJyk7XG5jb25zdCB7IEFFU19JViwgcmVzcG9uc2VDb2RlcywgcmVzcG9uc2VNc2dzLCBWRVJTSU9OX0JZVEUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBFQyA9IGVsbGlwdGljLmVjO1xuY29uc3QgZWMgPSBuZXcgRUMoJ3AyNTYnKTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTEFUVElDRSBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBQYXJzZSBhIHJlc3BvbnNlIGZyb20gdGhlIExhdHRpY2UxXG5mdW5jdGlvbiBwYXJzZUxhdHRpY2UxUmVzcG9uc2Uocikge1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgZXJyOiBudWxsLFxuICAgIGRhdGE6IG51bGwsXG4gIH1cbiAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHIsICdoZXgnKTtcbiAgbGV0IG9mZiA9IDA7XG4gIFxuICAvLyBHZXQgcHJvdG9jb2wgdmVyc2lvblxuICBjb25zdCBwcm90b1ZlciA9IGIucmVhZFVJbnQ4KG9mZik7IG9mZisrO1xuICBpZiAocHJvdG9WZXIgIT09IFZFUlNJT05fQllURSkge1xuICAgIHBhcnNlZC5lcnIgPSAnSW5jb3JyZWN0IHByb3RvY29sIHZlcnNpb24uIFBsZWFzZSB1cGRhdGUgeW91ciBTREsnO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvLyBHZXQgdGhlIHR5cGUgb2YgcmVzcG9uc2VcbiAgLy8gU2hvdWxkIGFsd2F5cyBiZSAweDAwXG4gIGNvbnN0IG1zZ1R5cGUgPSBiLnJlYWRVSW50OChvZmYpOyBvZmYrKztcbiAgaWYgKG1zZ1R5cGUgIT09IDB4MDApIHtcbiAgICBwYXJzZWQuZXJyID0gJ0luY29ycmVjdCByZXNwb25zZSBmcm9tIExhdHRpY2UxJztcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBwYXlsb2FkXG4gIGIucmVhZFVJbnQzMkJFKG9mZik7IG9mZis9NDsgLy8gRmlyc3QgNCBieXRlcyBpcyB0aGUgaWQsIGJ1dCB3ZSBkb24ndCBuZWVkIHRoYXQgYW55bW9yZVxuICBjb25zdCBsZW4gPSBiLnJlYWRVSW50MTZCRShvZmYpOyBvZmYrPTI7XG4gIGNvbnN0IHBheWxvYWQgPSBiLnNsaWNlKG9mZiwgb2ZmK2xlbik7IG9mZis9bGVuO1xuXG4gIC8vIEdldCByZXNwb25zZSBjb2RlXG4gIGNvbnN0IHJlc3BvbnNlQ29kZSA9IHBheWxvYWQucmVhZFVJbnQ4KDApO1xuICBpZiAocmVzcG9uc2VDb2RlICE9PSByZXNwb25zZUNvZGVzLlJFU1BfU1VDQ0VTUykge1xuICAgIHBhcnNlZC5lcnIgPSBgRXJyb3IgZnJvbSBkZXZpY2U6ICR7cmVzcG9uc2VNc2dzW3Jlc3BvbnNlQ29kZV0gPyByZXNwb25zZU1zZ3NbcmVzcG9uc2VDb2RlXSA6ICdVbmtub3duIEVycm9yJ31gO1xuICAgIHBhcnNlZC5yZXNwb25zZUNvZGUgPSByZXNwb25zZUNvZGU7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQuZGF0YSA9IHBheWxvYWQuc2xpY2UoMSwgcGF5bG9hZC5sZW5ndGgpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IGNoZWNrc3VtXG4gIGNvbnN0IGNzID0gYi5yZWFkVUludDMyQkUob2ZmKTtcbiAgY29uc3QgZXhwZWN0ZWRDcyA9IGNoZWNrc3VtKGIuc2xpY2UoMCwgYi5sZW5ndGggLSA0KSk7XG4gIGlmIChjcyAhPT0gZXhwZWN0ZWRDcykge1xuICAgIHBhcnNlZC5lcnIgPSAnSW52YWxpZCBjaGVja3N1bSBmcm9tIGRldmljZSByZXNwb25zZSdcbiAgICBwYXJzZWQuZGF0YSA9IG51bGw7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBcbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gY2hlY2tzdW0oeCkge1xuICAvLyBjcmMzMiByZXR1cm5zIGEgc2lnbmVkIGludGVnZXIgLSBuZWVkIHRvIGNhc3QgaXQgdG8gdW5zaWduZWRcbiAgLy8gTm90ZSB0aGF0IHRoaXMgdXNlcyB0aGUgZGVmYXVsdCAweGVkYjg4MzIwIHBvbHlub21pYWxcbiAgcmV0dXJuIGNyYzMyLmJ1Zih4KSA+Pj4gMDsgLy8gTmVlZCB0aGlzIHRvIGJlIGEgdWludCwgaGVuY2UgdGhlIGJpdCBzaGlmdFxufVxuXG4vLyBHZXQgYSA3NC1ieXRlIHBhZGRlZCBERVItZW5jb2RlZCBzaWduYXR1cmUgYnVmZmVyXG4vLyBgc2lnYCBtdXN0IGJlIHRoZSBzaWduYXR1cmUgb3V0cHV0IGZyb20gZWxsaXB0aWMuanNcbmZ1bmN0aW9uIHRvUGFkZGVkREVSKHNpZykge1xuICAvLyBXZSB1c2UgNzQgYXMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIGEgREVSIHNpZ25hdHVyZS4gQWxsIHNpZ3MgbXVzdFxuICAvLyBiZSByaWdodC1wYWRkZWQgd2l0aCB6ZXJvcyBzbyB0aGF0IHRoaXMgY2FuIGJlIGEgZml4ZWQgc2l6ZSBmaWVsZFxuICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKDc0KTtcbiAgY29uc3QgZHMgPSBCdWZmZXIuZnJvbShzaWcudG9ERVIoKSk7XG4gIGRzLmNvcHkoYik7XG4gIHJldHVybiBiO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUUkFOU0FDVElPTiBVVElMU1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3Qgc2lnblJlcVJlc29sdmVyID0ge1xuICAnQlRDJzogYnVpbGRCaXRjb2luVHhSZXF1ZXN0LFxuICAnRVRIJzogYnVpbGRFdGhlcmV1bVR4UmVxdWVzdCxcbiAgJ0VUSF9NU0cnOiBidWlsZEV0aGVyZXVtTXNnUmVxdWVzdCxcbn1cblxuLy8gVGVtcG9yYXJ5IGhlbHBlciB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhIHN1cHBvcnRlZCBCSVA0NCBwYXJlbnQgcGF0aFxuZnVuY3Rpb24gaXNWYWxpZEFzc2V0UGF0aChwYXRoKSB7XG4gIGNvbnN0IEhBUkRFTkVEX09GRlNFVCA9IDB4ODAwMDAwMDA7XG4gIGNvbnN0IGFsbG93ZWRQdXJwb3NlcyA9IFtIQVJERU5FRF9PRkZTRVQrNDksIEhBUkRFTkVEX09GRlNFVCs0NF07XG4gIGNvbnN0IGFsbG93ZWRDb2lucyA9IFtIQVJERU5FRF9PRkZTRVQsIEhBUkRFTkVEX09GRlNFVCsxLCBIQVJERU5FRF9PRkZTRVQrNjBdO1xuICBjb25zdCBhbGxvd2VkQWNjb3VudHMgPSBbSEFSREVORURfT0ZGU0VUXTtcbiAgY29uc3QgYWxsb3dlZENoYW5nZSA9IFswLCAxXVxuICByZXR1cm4gKFxuICAgIChhbGxvd2VkUHVycG9zZXMuaW5kZXhPZihwYXRoWzBdKSA+PSAwKSAmJlxuICAgIChhbGxvd2VkQ29pbnMuaW5kZXhPZihwYXRoWzFdKSA+PSAwKSAmJlxuICAgIChhbGxvd2VkQWNjb3VudHMuaW5kZXhPZihwYXRoWzJdKSA+PSAwKSAmJlxuICAgIChhbGxvd2VkQ2hhbmdlLmluZGV4T2YocGF0aFszXSkgPj0gMClcbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZENvaW5UeXBlKHBhdGgpIHtcbiAgcmV0dXJuIFsweDgwMDAwMDAwLCAweDgwMDAwMDAwKzEsIDB4ODAwMDAwMDArNjBdLmluZGV4T2YocGF0aFsxXSkgPj0gMFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUllQVE8gVVRJTFNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGFlczI1Nl9lbmNyeXB0KGRhdGEsIGtleSkge1xuICBjb25zdCBpdiA9IEJ1ZmZlci5mcm9tKEFFU19JVik7XG4gIGNvbnN0IGFlc0NiYyA9IG5ldyBhZXMuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcbiAgY29uc3QgcGFkZGVkRGF0YSA9IChkYXRhLmxlbmd0aCkgJSAxNiA9PT0gMCA/IGRhdGEgOiBhZXMucGFkZGluZy5wa2NzNy5wYWQoZGF0YSk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShhZXNDYmMuZW5jcnlwdChwYWRkZWREYXRhKSk7XG59XG5cbmZ1bmN0aW9uIGFlczI1Nl9kZWNyeXB0KGRhdGEsIGtleSkge1xuICBjb25zdCBpdiA9IEJ1ZmZlci5mcm9tKEFFU19JVik7XG4gIGNvbnN0IGFlc0NiYyA9IG5ldyBhZXMuTW9kZU9mT3BlcmF0aW9uLmNiYyhrZXksIGl2KTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFlc0NiYy5kZWNyeXB0KGRhdGEpKTtcbn1cblxuLy8gRGVjb2RlIGEgREVSIHNpZ25hdHVyZS4gUmV0dXJucyBzaWduYXR1cmUgb2JqZWN0IHtyLCBzIH0gb3IgbnVsbCBpZiB0aGVyZSBpcyBhbiBlcnJvclxuZnVuY3Rpb24gcGFyc2VERVIoc2lnQnVmKSB7XG4gIGlmIChzaWdCdWZbMF0gIT09IDB4MzAgfHwgc2lnQnVmWzJdICE9PSAweDAyKSByZXR1cm4gbnVsbDtcbiAgbGV0IG9mZiA9IDM7XG4gIGNvbnN0IHNpZyA9IHsgcjogbnVsbCwgczogbnVsbCB9XG4gIGNvbnN0IHJMZW4gPSBzaWdCdWZbb2ZmXTsgb2ZmKys7XG4gIHNpZy5yID0gc2lnQnVmLnNsaWNlKG9mZiwgb2ZmICsgckxlbik7IG9mZiArPSByTGVuXG4gIGlmIChzaWdCdWZbb2ZmXSAhPT0gMHgwMikgcmV0dXJuIG51bGw7XG4gIG9mZisrO1xuICBjb25zdCBzTGVuID0gc2lnQnVmW29mZl07IG9mZisrO1xuICBzaWcucyA9IHNpZ0J1Zi5zbGljZShvZmYsIG9mZiArIHNMZW4pO1xuICByZXR1cm4gc2lnO1xufVxuXG5mdW5jdGlvbiBnZXRQMjU2S2V5UGFpciAocHJpdikge1xuICByZXR1cm4gZWMua2V5RnJvbVByaXZhdGUocHJpdiwgJ2hleCcpO1xufVxuXG5mdW5jdGlvbiBnZXRQMjU2S2V5UGFpckZyb21QdWIocHViKSB7XG4gIHJldHVybiBlYy5rZXlGcm9tUHVibGljKHB1YiwgJ2hleCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNWYWxpZEFzc2V0UGF0aCxcbiAgaXNWYWxpZENvaW5UeXBlLFxuICBlbnN1cmVIZXhCdWZmZXIsXG4gIHNpZ25SZXFSZXNvbHZlcixcbiAgYWVzMjU2X2RlY3J5cHQsXG4gIGFlczI1Nl9lbmNyeXB0LFxuICBwYXJzZURFUixcbiAgY2hlY2tzdW0sXG4gIHBhcnNlTGF0dGljZTFSZXNwb25zZSxcbiAgZ2V0UDI1NktleVBhaXIsXG4gIGdldFAyNTZLZXlQYWlyRnJvbVB1YixcbiAgdG9QYWRkZWRERVIsXG59IiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG52YXIgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG52YXIgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50LWJhc2UnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufVxuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgICAmJiAoIXJvb3QubG9jYXRpb24gfHwgJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sXG4gICAgICAgICAgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJCcm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUlwiKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgZm9yKHZhciBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXkgKyAnWycgKyBzdWJrZXkgKyAnXScsIHZhbFtzdWJrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgdmFyIHBhaXI7XG4gIHZhciBwb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgeyAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdmFyIHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgc3RhdHVzID0gMjA0O1xuICB9XG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAobnVsbCA9PT0gdGhpcy50ZXh0ICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuUmVzcG9uc2VCYXNlKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3BhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgdmFyIG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbmNvZGVyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcblxuLyoqXG4gKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4gKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiAqICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIG9wdGlvbnMpe1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblJlcXVlc3QucHJvdG90eXBlLmJ1ZmZlciA9IFJlcXVlc3QucHJvdG90eXBlLmNhID0gUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGhpcyB0aHJvd3MsIGJlY2F1c2UgaXQgY2FuJ3Qgc2VuZC9yZWNlaXZlIGRhdGEgYXMgZXhwZWN0ZWRcblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKCl7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIik7XG4gIH1cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gKHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKSk7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID49IDIgJiYgc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIGlmICg0ICE9IHJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoIXN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQgfHwgc2VsZi5fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cbiAgICBlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ2Rvd25sb2FkJyk7XG4gICAgICBpZiAoeGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB0cnkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBzZWUgIzExNDlcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICghdGhpcy5fZm9ybURhdGEgJiYgJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5yZXF1ZXN0LmFnZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQWdlbnQoKTtcbn07XG5cbltcIkdFVFwiLCBcIlBPU1RcIiwgXCJPUFRJT05TXCIsIFwiUEFUQ0hcIiwgXCJQVVRcIiwgXCJERUxFVEVcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgZm4pIHtcbiAgICB2YXIgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5uaWJibGUgPSBleHBvcnRzLmludGVnZXIgPSBleHBvcnRzLmJ5dGUgPSBleHBvcnRzLmJ1ZmZlciA9IGV4cG9ydHMuYml0cyA9IHZvaWQgMDtcbnZhciBiaXRzXzEgPSByZXF1aXJlKFwiLi9iaXRzXCIpO1xuZXhwb3J0cy5iaXRzID0gYml0c18xLmRlZmF1bHQ7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9idWZmZXJcIik7XG5leHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlcl8xLmRlZmF1bHQ7XG52YXIgYnl0ZV8xID0gcmVxdWlyZShcIi4vYnl0ZVwiKTtcbmV4cG9ydHMuYnl0ZSA9IGJ5dGVfMS5kZWZhdWx0O1xudmFyIGludGVnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVnZXJcIik7XG5leHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyXzEuZGVmYXVsdDtcbnZhciBuaWJibGVfMSA9IHJlcXVpcmUoXCIuL25pYmJsZVwiKTtcbmV4cG9ydHMubmliYmxlID0gbmliYmxlXzEuZGVmYXVsdDtcbnZhciBzdHJpbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKTtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nXzEuZGVmYXVsdDtcbnZhciBiaXR3aXNlID0geyBiaXRzOiBiaXRzXzEuZGVmYXVsdCwgYnVmZmVyOiBidWZmZXJfMS5kZWZhdWx0LCBieXRlOiBieXRlXzEuZGVmYXVsdCwgaW50ZWdlcjogaW50ZWdlcl8xLmRlZmF1bHQsIG5pYmJsZTogbmliYmxlXzEuZGVmYXVsdCwgc3RyaW5nOiBzdHJpbmdfMS5kZWZhdWx0IH07XG5leHBvcnRzLmRlZmF1bHQgPSBiaXR3aXNlO1xuIiwiLy8gVXRpbHMgZm9yIEV0aGVyZXVtIHRyYW5zYWN0aW9ucy4gVGhpcyBpcyBlZmZlY2l0dmVseSBhIHNoaW0gb2YgZXRoZXJldW1qcy11dGlsLCB3aGljaFxuLy8gZG9lcyBub3QgaGF2ZSBicm93c2VyIChvciwgYnkgcHJveHksIFJlYWN0LU5hdGl2ZSkgc3VwcG9ydC5cbmNvbnN0IEJOID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xuY29uc3QgY2JvciA9IHJlcXVpcmUoJ2JvcmMnKTtcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBldGhlcnMgPSByZXF1aXJlKCdldGhlcnMnKTtcbmNvbnN0IGVpcDcxMiA9IHJlcXVpcmUoJ2V0aGVycy1laXA3MTInKTtcbmNvbnN0IGtlY2NhazI1NiA9IHJlcXVpcmUoJ2pzLXNoYTMnKS5rZWNjYWsyNTY7XG5jb25zdCBybHAgPSByZXF1aXJlKCdybHAtYnJvd3NlcicpO1xuY29uc3Qgc2VjcDI1NmsxID0gcmVxdWlyZSgnc2VjcDI1NmsxJyk7XG5cbmV4cG9ydHMuYnVpbGRFdGhlcmV1bU1zZ1JlcXVlc3QgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZiAoIWlucHV0LnBheWxvYWQgfHwgIWlucHV0LnByb3RvY29sIHx8ICFpbnB1dC5zaWduZXJQYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBgcGF5bG9hZGAsIGBzaWduZXJQYXRoYCwgYW5kIGBwcm90b2NvbGAgYXJndW1lbnRzIGluIHRoZSBtZXNzc2FnZSByZXF1ZXN0Jyk7XG4gIGlmIChpbnB1dC5zaWduZXJQYXRoLmxlbmd0aCA+IDUgfHwgaW5wdXQuc2lnbmVyUGF0aC5sZW5ndGggPCAyKSBcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgc2lnbmVyIHBhdGggd2l0aCAyLTUgaW5kaWNlcycpO1xuICBjb25zdCByZXEgPSB7XG4gICAgc2NoZW1hOiBjb25zdGFudHMuc2lnbmluZ1NjaGVtYS5FVEhfTVNHLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgaW5wdXQsIC8vIFNhdmUgdGhlIGlucHV0IGZvciBsYXRlclxuICAgIG1zZzogbnVsbCwgLy8gU2F2ZSB0aGUgYnVmZmVyZWQgbWVzc2FnZSBmb3IgbGF0ZXJcbiAgfVxuICB0cnkge1xuICAgIHN3aXRjaCAoaW5wdXQucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgJ3NpZ25QZXJzb25hbCc6XG4gICAgICAgIHJldHVybiBidWlsZFBlcnNvbmFsU2lnblJlcXVlc3QocmVxLCBpbnB1dClcbiAgICAgIGNhc2UgJ2VpcDcxMic6XG4gICAgICAgIGlmICghaW5wdXQuZndDb25zdGFudHMuZWlwNzEyU3VwcG9ydGVkKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQNzEyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBMYXR0aWNlIGZpcm13YXJlIHZlcnNpb24uIFBsZWFzZSB1cGdyYWRlLicpXG4gICAgICAgIHJldHVybiBidWlsZEVJUDcxMlJlcXVlc3QocmVxLCBpbnB1dClcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IGVycjogZXJyLnRvU3RyaW5nKCkgfVxuICB9XG59XG5cbmV4cG9ydHMudmFsaWRhdGVFdGhlcmV1bU1zZ1Jlc3BvbnNlID0gZnVuY3Rpb24ocmVzLCByZXEpIHtcbiAgY29uc3QgeyBzaWduZXIsIHNpZyB9ID0gcmVzO1xuICBjb25zdCB7IGlucHV0LCBtc2csIHByZWhhc2g9bnVsbCB9ID0gcmVxO1xuICBpZiAoaW5wdXQucHJvdG9jb2wgPT09ICdzaWduUGVyc29uYWwnKSB7XG4gICAgLy8gTk9URTogV2UgYXJlIGN1cnJlbnRseSBoYXJkY29kaW5nIG5ldHdvcmtJRD0xIGFuZCB1c2VFSVAxNTU9ZmFsc2UgYnV0IHRoZXNlXG4gICAgLy8gICAgICAgbWF5IGJlIGNvbmZpZ3VyYWJsZSBpbiBmdXR1cmUgdmVyc2lvbnNcbiAgICBjb25zdCBoYXNoID0gIHByZWhhc2ggPyBcbiAgICAgICAgICAgICAgICAgIHByZWhhc2ggOiBcbiAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtnZXRfcGVyc29uYWxfc2lnbl9wcmVmaXgobXNnLmxlbmd0aCksIG1zZ10pKSwgJ2hleCcpO1xuICAgIC8vIEdldCByZWNvdmVyeSBwYXJhbSB3aXRoIGEgYHZgIHZhbHVlIG9mIFsyNywyOF0gYnkgc2V0dGluZyBgdXNlRUlQMTU1PWZhbHNlYFxuICAgIHJldHVybiBhZGRSZWNvdmVyeVBhcmFtKGhhc2gsIHNpZywgc2lnbmVyLCB7IGNoYWluSWQ6IDEsIHVzZUVJUDE1NTogZmFsc2UgfSlcbiAgfSBlbHNlIGlmIChpbnB1dC5wcm90b2NvbCA9PT0gJ2VpcDcxMicpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBwcmVoYXNoID8gcHJlaGFzaCA6IGVpcDcxMi5UeXBlZERhdGFVdGlscy5lbmNvZGVEaWdlc3QocmVxLmlucHV0LnBheWxvYWQpO1xuICAgIC8vIEdldCByZWNvdmVyeSBwYXJhbSB3aXRoIGEgYHZgIHZhbHVlIG9mIFsyNywyOF0gYnkgc2V0dGluZyBgdXNlRUlQMTU1PWZhbHNlYFxuICAgIHJldHVybiBhZGRSZWNvdmVyeVBhcmFtKGRpZ2VzdCwgc2lnLCBzaWduZXIsIHsgdXNlRUlQMTU1OiBmYWxzZSB9KVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wnKTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkRXRoZXJldW1UeFJlcXVlc3QgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRyeSB7XG4gICAgbGV0IHsgY2hhaW5JZD0xIH0gPSBkYXRhO1xuICAgIGNvbnN0IHsgc2lnbmVyUGF0aCwgZWlwMTU1PW51bGwsIGZ3Q29uc3RhbnRzLCB0eXBlPW51bGwgfSA9IGRhdGE7XG4gICAgY29uc3QgeyBleHRyYURhdGFGcmFtZVN6LCBleHRyYURhdGFNYXhGcmFtZXMsIHByZWhhc2hBbGxvd2VkIH0gPSBmd0NvbnN0YW50cztcbiAgICBjb25zdCBFWFRSQV9EQVRBX0FMTE9XRUQgPSBleHRyYURhdGFGcmFtZVN6ID4gMCAmJiBleHRyYURhdGFNYXhGcmFtZXMgPiAwO1xuICAgIGxldCBNQVhfQkFTRV9EQVRBX1NaID0gZndDb25zdGFudHMuZXRoTWF4RGF0YVN6O1xuICAgIGNvbnN0IFZBUl9QQVRIX1NaID0gZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQ7XG4gICAgLy8gU2FuaXR5IGNoZWNrczpcbiAgICAvLyBUaGVyZSBhcmUgYSBoYW5kZnVsIG9mIG5hbWVkIGNoYWlucyB3ZSBhbGxvdyB0aGUgdXNlciB0byByZWZlcmVuY2UgKGBjaGFpbklkc2ApXG4gICAgLy8gQ3VzdG9tIGNoYWluSURzIHNob3VsZCBiZSBlaXRoZXIgbnVtZXJpY2FsIG9yIGhleCBzdHJpbmdzXG4gICAgaWYgKHR5cGVvZiBjaGFpbklkICE9PSAnbnVtYmVyJyAmJiBpc1ZhbGlkQ2hhaW5JZEhleE51bVN0cihjaGFpbklkKSA9PT0gZmFsc2UpIFxuICAgICAgY2hhaW5JZCA9IGNoYWluSWRzW2NoYWluSWRdO1xuICAgIC8vIElmIHRoaXMgd2FzIG5vdCBhIGN1c3RvbSBjaGFpbklEIGFuZCB3ZSBjYW5ub3QgZmluZCB0aGUgbmFtZSBvZiBpdCwgZXhpdFxuICAgIGlmICghY2hhaW5JZCkgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNoYWluIElEIG9yIG5hbWUnKTtcbiAgICAvLyBTYW5pdHkgY2hlY2sgb24gc2lnbmVQYXRoXG4gICAgaWYgKCFzaWduZXJQYXRoKSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHNpZ25lclBhdGhgIG5vdCBwcm92aWRlZCcpO1xuICAgIFxuICAgIC8vIFdlIHN1cHBvcnQgZWlwMTU1OSBhbmQgZWlwMjkzMCB0eXBlcyAoYXMgd2VsbCBhcyBsZWdhY3kpXG4gICAgY29uc3QgZWlwMTU1OUlzQWxsb3dlZCA9IChmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlcyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzLmluZGV4T2YoMikgPiAtMSk7XG4gICAgY29uc3QgZWlwMjkzMElzQWxsb3dlZCA9IChmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlcyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ3Q29uc3RhbnRzLmFsbG93ZWRFdGhUeFR5cGVzLmluZGV4T2YoMSkgPiAtMSk7XG4gICAgY29uc3QgaXNFaXAxNTU5ID0gKGVpcDE1NTlJc0FsbG93ZWQgJiYgKHR5cGUgPT09IDIgfHwgdHlwZSA9PT0gJ2VpcDE1NTknKSk7XG4gICAgY29uc3QgaXNFaXAyOTMwID0gKGVpcDI5MzBJc0FsbG93ZWQgJiYgKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gJ2VpcDI5MzAnKSk7XG4gICAgaWYgKHR5cGUgIT09IG51bGwgJiYgIWlzRWlwMTU1OSAmJiAhaXNFaXAyOTMwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBFdGhlcmV1bSB0cmFuc2FjdGlvbiB0eXBlJyk7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgRUlQMTU1IGdpdmVuIHRoZSBjaGFpbklELlxuICAgIC8vIElmIHdlIGFyZSBleHBsaWNpdGx5IHRvbGQgdG8gdXNlIGVpcDE1NSwgd2Ugd2lsbCB1c2UgaXQuIE90aGVyd2lzZSxcbiAgICAvLyB3ZSB3aWxsIGxvb2sgdXAgaWYgdGhlIHNwZWNpZmllZCBjaGFpbklkIGlzIGFzc29jaWF0ZWQgd2l0aCBhIGNoYWluXG4gICAgLy8gdGhhdCBkb2VzIG5vdCB1c2UgRUlQMTU1IGJ5IGRlZmF1bHQuIE5vdGUgdGhhdCBtb3N0IGRvIHVzZSBFSVAxNTUuXG4gICAgbGV0IHVzZUVJUDE1NSA9IGNoYWluVXNlc0VJUDE1NShjaGFpbklkKTtcbiAgICBpZiAoZWlwMTU1ICE9PSBudWxsICYmIHR5cGVvZiBlaXAxNTUgPT09ICdib29sZWFuJykge1xuICAgICAgdXNlRUlQMTU1ID0gZWlwMTU1O1xuICAgIH0gZWxzZSBpZiAoaXNFaXAxNTU5IHx8IGlzRWlwMjkzMCkge1xuICAgICAgLy8gTmV3ZXIgdHJhbnNhY3Rpb24gdHlwZXMgZG8gbm90IHVzZSBFSVAxNTUgc2luY2UgdGhlIGNoYWluSWQgaXMgc2VyaWFsaXplZFxuICAgICAgdXNlRUlQMTU1ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSGFjayBmb3IgbWV0YW1hc2ssIHdoaWNoIHNlbmRzIHZhbHVlPW51bGwgZm9yIDAgRVRIIHRyYW5zYWN0aW9uc1xuICAgIGlmICghZGF0YS52YWx1ZSlcbiAgICAgIGRhdGEudmFsdWUgPSAwO1xuICAgICAgXG4gICAgLy8tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDEuIEJVSUxEIFRIRSBSQVcgVFggRk9SIEZVVFVSRSBSTFAgRU5DT0RJTkdcbiAgICAvLy0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRW5zdXJlIGFsbCBmaWVsZHMgYXJlIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzXG4gICAgY29uc3QgcmF3VHggPSBbXTtcbiAgICAvLyBCdWlsZCB0aGUgdHJhbnNhY3Rpb24gYnVmZmVyIGFycmF5XG4gICAgY29uc3QgY2hhaW5JZEJ5dGVzID0gZW5zdXJlSGV4QnVmZmVyKGNoYWluSWQpO1xuICAgIGNvbnN0IG5vbmNlQnl0ZXMgPSBlbnN1cmVIZXhCdWZmZXIoZGF0YS5ub25jZSk7XG4gICAgbGV0IGdhc1ByaWNlQnl0ZXM7XG4gICAgY29uc3QgZ2FzTGltaXRCeXRlcyA9IGVuc3VyZUhleEJ1ZmZlcihkYXRhLmdhc0xpbWl0KTtcbiAgICBjb25zdCB0b0J5dGVzID0gZW5zdXJlSGV4QnVmZmVyKGRhdGEudG8pO1xuICAgIGNvbnN0IHZhbHVlQnl0ZXMgPSBlbnN1cmVIZXhCdWZmZXIoZGF0YS52YWx1ZSk7XG4gICAgY29uc3QgZGF0YUJ5dGVzID0gZW5zdXJlSGV4QnVmZmVyKGRhdGEuZGF0YSk7XG5cbiAgICBpZiAoaXNFaXAxNTU5IHx8IGlzRWlwMjkzMCkge1xuICAgICAgLy8gRUlQMTU1OSBhbmQgRUlQMjkzMCB0cmFuc2FjdGlvbnMgaGF2ZSBhIGNoYWluSUQgZmllbGRcbiAgICAgIHJhd1R4LnB1c2goY2hhaW5JZEJ5dGVzKTtcbiAgICB9XG4gICAgcmF3VHgucHVzaChub25jZUJ5dGVzKTtcbiAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcywgbWF4RmVlUGVyR2FzQnl0ZXM7XG4gICAgaWYgKGlzRWlwMTU1OSkge1xuICAgICAgaWYgKCFkYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VJUDE1NTkgdHJhbnNhY3Rpb25zIG11c3QgaW5jbHVkZSBgbWF4UHJpb3JpdHlGZWVQZXJHYXNgJyk7XG4gICAgICBpZiAoIWRhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRUlQMTU1OSB0cmFuc2FjdGlvbnMgbXVzdCBpbmNsdWRlIGBtYXhGZWVQZXJHYXNgJyk7XG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzID0gZW5zdXJlSGV4QnVmZmVyKGRhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgcmF3VHgucHVzaChtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzKTtcbiAgICAgIG1heEZlZVBlckdhc0J5dGVzID0gZW5zdXJlSGV4QnVmZmVyKGRhdGEubWF4RmVlUGVyR2FzKTtcbiAgICAgIHJhd1R4LnB1c2gobWF4RmVlUGVyR2FzQnl0ZXMpO1xuICAgICAgLy8gRUlQMTU1OSByZW5hbWVkIFwiZ2FzUHJpY2VcIiB0byBcIm1heEZlZVBlckdhc1wiLCBidXQgZmlybXdhcmUgc3RpbGxcbiAgICAgIC8vIHVzZXMgYGdhc1ByaWNlYCBpbiB0aGUgc3RydWN0LCBzbyB1cGRhdGUgdGhhdCB2YWx1ZSBoZXJlLlxuICAgICAgZ2FzUHJpY2VCeXRlcyA9IG1heEZlZVBlckdhc0J5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFSVAxNTU5IHRyYW5zYWN0aW9ucyBkbyBub3QgaGF2ZSB0aGUgZ2FzUHJpY2UgZmllbGRcbiAgICAgIGdhc1ByaWNlQnl0ZXMgPSBlbnN1cmVIZXhCdWZmZXIoZGF0YS5nYXNQcmljZSk7XG4gICAgICByYXdUeC5wdXNoKGdhc1ByaWNlQnl0ZXMpO1xuICAgIH1cbiAgICByYXdUeC5wdXNoKGdhc0xpbWl0Qnl0ZXMpO1xuICAgIHJhd1R4LnB1c2godG9CeXRlcyk7XG4gICAgcmF3VHgucHVzaCh2YWx1ZUJ5dGVzKTtcbiAgICByYXdUeC5wdXNoKGRhdGFCeXRlcyk7XG4gICAgLy8gV2UgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGFjY2Vzc0xpc3QgaW4gZmlybXdhcmUgc28gd2UgbmVlZCB0byBwcmVoYXNoIGlmXG4gICAgLy8gdGhlIGxpc3QgaXMgbm9uLW51bGxcbiAgICBsZXQgUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUID0gZmFsc2U7XG4gICAgaWYgKGlzRWlwMTU1OSB8fCBpc0VpcDI5MzApIHtcbiAgICAgIGNvbnN0IGFjY2Vzc0xpc3QgPSBbXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuYWNjZXNzTGlzdCkpIHtcbiAgICAgICAgZGF0YS5hY2Nlc3NMaXN0LmZvckVhY2goKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgIGxpc3RJdGVtLnN0b3JhZ2VLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAga2V5cy5wdXNoKGVuc3VyZUhleEJ1ZmZlcihrZXkpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYWNjZXNzTGlzdC5wdXNoKFsgZW5zdXJlSGV4QnVmZmVyKGxpc3RJdGVtLmFkZHJlc3MpLCBrZXlzIF0pXG4gICAgICAgICAgUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUID0gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJhd1R4LnB1c2goYWNjZXNzTGlzdCk7XG4gICAgfSBlbHNlIGlmICh1c2VFSVAxNTUgPT09IHRydWUpIHtcbiAgICAgIC8vIEFkZCBlbXB0eSB2LHIscyB2YWx1ZXMgZm9yIEVJUDE1NSBsZWdhY3kgdHJhbnNhY3Rpb25zXG4gICAgICByYXdUeC5wdXNoKGNoYWluSWRCeXRlcyk7IC8vIHYgKHdoaWNoIGlzIHRoZSBzYW1lIGFzIGNoYWluSWQgaW4gRUlQMTU1IHR4cylcbiAgICAgIHJhd1R4LnB1c2goZW5zdXJlSGV4QnVmZmVyKG51bGwpKTsgICAgLy8gclxuICAgICAgcmF3VHgucHVzaChlbnN1cmVIZXhCdWZmZXIobnVsbCkpOyAgICAvLyBzXG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAyLiBCVUlMRCBUSEUgTEFUVElDRSBSRVFVRVNUIFBBWUxPQURcbiAgICAvLy0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3QgRVRIX1RYX05PTl9EQVRBX1NaID0gMTIyOyAvLyBBY2NvdW50cyBmb3IgbWV0YWRhdGEgYW5kIG5vbi1kYXRhIHBhcmFtc1xuICAgIGxldCBFVEhfVFhfRVhUUkFfRklFTERTX1NaID0gMDsgLy8gQWNjb3VudHMgZm9yIG5ld2VyIEVUSCB0eCB0eXBlcyAoZS5nLiBlaXAxNTU5KVxuICAgIGlmIChmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlc1ZlcnNpb24gPT09IDEpIHtcbiAgICAgIC8vIGVpcDE1NTkgYW5kIGVpcDI5MzBcbiAgICAgIC8vIEFkZCBleHRyYSBwYXJhbXMgYW5kIHNocmluayB0aGUgZGF0YSByZWdpb24gKGV4dHJhRGF0YSBibG9ja3MgYXJlIHVuYWZmZWN0ZWQpXG4gICAgICBFVEhfVFhfRVhUUkFfRklFTERTX1NaID0gZndDb25zdGFudHMudG90YWxFeHRyYUV0aFR4RGF0YVN6O1xuICAgICAgTUFYX0JBU0VfREFUQV9TWiAtPSBFVEhfVFhfRVhUUkFfRklFTERTX1NaO1xuICAgIH1cbiAgICBjb25zdCB0eFJlcVBheWxvYWQgPSBCdWZmZXIuYWxsb2MoTUFYX0JBU0VfREFUQV9TWiArIEVUSF9UWF9OT05fREFUQV9TWik7XG4gICAgbGV0IG9mZiA9IDA7XG4gICAgLy8gMS4gRUlQMTU1IHN3aXRjaCBhbmQgY2hhaW5JRFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdHhSZXFQYXlsb2FkLndyaXRlVUludDgoTnVtYmVyKHVzZUVJUDE1NSksIG9mZik7IG9mZisrO1xuICAgIC8vIE5PVEU6IE9yaWdpbmFsbHkgd2UgZGVzaWduZWQgZm9yIGEgMS1ieXRlIGNoYWluSUQsIGJ1dCBtb2Rlcm4gcm9sbHVwIGNoYWlucyB1c2UgbXVjaCBsYXJnZXJcbiAgICAvLyBjaGFpbklEIHZhbHVlcy4gVG8gYWNjb3VudCBmb3IgdGhlc2UsIHdlIHdpbGwgcHV0IHRoZSBjaGFpbklEIGludG8gdGhlIGBkYXRhYCBidWZmZXIgaWYgaXRcbiAgICAvLyBpcyA+PTI1NS4gVmFsdWVzIHVwIHRvIFVJTlQ2NF9NQVggd2lsbCBiZSBhbGxvd2VkLlxuICAgIGxldCBjaGFpbklkQnVmOyBcbiAgICBsZXQgY2hhaW5JZEJ1ZlN6ID0gMDtcbiAgICBpZiAodXNlQ2hhaW5JZEJ1ZmZlcihjaGFpbklkKSA9PT0gdHJ1ZSkge1xuICAgICAgY2hhaW5JZEJ1ZiA9IGdldENoYWluSWRCdWYoY2hhaW5JZCk7XG4gICAgICBjaGFpbklkQnVmU3ogPSBjaGFpbklkQnVmLmxlbmd0aDtcbiAgICAgIGlmIChjaGFpbklkQnVmU3ogPiBjb25zdGFudHMuTUFYX0NIQUlOX0lEX0JZVEVTKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYWluSUQgcHJvdmlkZWQgaXMgdG9vIGxhcmdlLicpO1xuICAgICAgLy8gU2lnbmFsIHRvIExhdHRpY2UgZmlybXdhcmUgdGhhdCBpdCBuZWVkcyB0byByZWFkIHRoZSBjaGFpbklkIGZyb20gdGhlIHR4LmRhdGEgYnVmZmVyXG4gICAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50OChjb25zdGFudHMuSEFORExFX0xBUkdFUl9DSEFJTl9JRCwgb2ZmKTsgb2ZmKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBjaGFpbklEcyA8MjU1LCB3cml0ZSBpdCB0byB0aGUgY2hhaW5JZCB1OCBzbG90IGluIHRoZSBtYWluIHR4IGJ1ZmZlclxuICAgICAgY2hhaW5JZEJ1ZiA9IGVuc3VyZUhleEJ1ZmZlcihjaGFpbklkKTtcbiAgICAgIGlmIChjaGFpbklkQnVmLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGNoYWluSUQnKTtcbiAgICAgIGNoYWluSWRCdWYuY29weSh0eFJlcVBheWxvYWQsIG9mZik7IG9mZiArPSBjaGFpbklkQnVmLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gMi4gU2lnbmVyIFBhdGhcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IHNpZ25lclBhdGhCdWYgPSBidWlsZFNpZ25lclBhdGhCdWYoc2lnbmVyUGF0aCwgVkFSX1BBVEhfU1opO1xuICAgIHNpZ25lclBhdGhCdWYuY29weSh0eFJlcVBheWxvYWQsIG9mZik7XG4gICAgb2ZmICs9IHNpZ25lclBhdGhCdWYubGVuZ3RoO1xuXG4gICAgLy8gMy4gRVRIIFRYIHJlcXVlc3QgZGF0YVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaWYgKG5vbmNlQnl0ZXMubGVuZ3RoID4gNClcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uY2UgdG9vIGxhcmdlJyk7XG4gICAgbm9uY2VCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDQgLSBub25jZUJ5dGVzLmxlbmd0aCkpOyBvZmYgKz0gNDtcbiAgICBpZiAoZ2FzUHJpY2VCeXRlcy5sZW5ndGggPiA4KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYXMgcHJpY2UgdG9vIGxhcmdlJyk7XG4gICAgZ2FzUHJpY2VCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDggLSBnYXNQcmljZUJ5dGVzLmxlbmd0aCkpOyBvZmYgKz0gODtcbiAgICBpZiAoZ2FzTGltaXRCeXRlcy5sZW5ndGggPiA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHYXMgbGltaXQgdG9vIGxhcmdlJyk7XG4gICAgZ2FzTGltaXRCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDQgLSBnYXNMaW1pdEJ5dGVzLmxlbmd0aCkpOyBvZmYgKz0gNDtcbiAgICBpZiAodG9CeXRlcy5sZW5ndGggIT09IDIwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGB0b2AgYWRkcmVzcycpO1xuICAgIHRvQnl0ZXMuY29weSh0eFJlcVBheWxvYWQsIG9mZik7IG9mZiArPSAyMDtcbiAgICBpZiAodmFsdWVCeXRlcy5sZW5ndGggPiAzMilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdG9vIGxhcmdlJyk7XG4gICAgdmFsdWVCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDMyIC0gdmFsdWVCeXRlcy5sZW5ndGgpKTsgb2ZmICs9IDMyO1xuXG4gICAgLy8gRXh0cmEgVHggZGF0YSBjb21lcyBiZWZvcmUgYGRhdGFgIGluIHRoZSBzdHJ1Y3RcbiAgICBsZXQgUFJFSEFTSF9VTlNVUFBPUlRFRCA9IGZhbHNlO1xuICAgIGlmIChmd0NvbnN0YW50cy5hbGxvd2VkRXRoVHhUeXBlc1ZlcnNpb24gPT09IDEpIHtcbiAgICAgIGNvbnN0IGV4dHJhRXRoVHhEYXRhU3ogPSBmd0NvbnN0YW50cy50b3RhbEV4dHJhRXRoVHhEYXRhU3ogfHwgMDtcbiAgICAgIC8vIFNvbWUgdHlwZXMgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgYnkgZmlybXdhcmUsIHNvIHdlIHdpbGwgbmVlZCB0byBwcmVoYXNoXG4gICAgICBpZiAoUFJFSEFTSF9GUk9NX0FDQ0VTU19MSVNUKSB7XG4gICAgICAgIFBSRUhBU0hfVU5TVVBQT1JURUQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdHhSZXFQYXlsb2FkLndyaXRlVWludDgoUFJFSEFTSF9VTlNVUFBPUlRFRCA9PT0gdHJ1ZSwgb2ZmKTsgb2ZmICs9IDE7ICBcbiAgICAgIC8vIEVJUDE1NTkgJiBFSVAyOTMwIHN0cnVjdCB2ZXJzaW9uXG4gICAgICBpZiAoaXNFaXAxNTU5KSB7XG4gICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVpbnQ4KDIsIG9mZik7IG9mZiArPSAxOyAvLyBFaXAxNTU5IHR5cGUgZW51bSB2YWx1ZVxuICAgICAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcy5sZW5ndGggPiA4KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXNCeXRlcy5jb3B5KHR4UmVxUGF5bG9hZCwgb2ZmICsgKDggLSBtYXhQcmlvcml0eUZlZVBlckdhc0J5dGVzLmxlbmd0aCkpOyBvZmYgKz0gODtcbiAgICAgIH0gZWxzZSBpZiAoaXNFaXAyOTMwKSB7XG4gICAgICAgIHR4UmVxUGF5bG9hZC53cml0ZVVpbnQ4KDEsIG9mZik7IG9mZiArPSAxOyAvLyBFaXAyOTMwIHR5cGUgZW51bSB2YWx1ZVxuICAgICAgICBvZmYgKz0gZXh0cmFFdGhUeERhdGFTeiAtIDI7IC8vIFNraXAgRUlQMTU1OSBwYXJhbXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZiArPSBleHRyYUV0aFR4RGF0YVN6IC0gMTsgLy8gU2tpcCBFSVAxNTU5IGFuZCBFSVAyOTMwIHBhcmFtc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSByZXF1ZXN0cywgd2hpY2ggd2lsbCBmb2xsb3ctdXAgdHJhbnNhY3Rpb24gcmVxdWVzdHMsIGlmIHN1cHBvcnRlZC9hcHBsaWNhYmxlICAgIFxuICAgIGNvbnN0IGV4dHJhRGF0YVBheWxvYWRzID0gW107XG4gICAgbGV0IHByZWhhc2ggPSBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBidWZmZXIsIHByZWZpeCB3aXRoIGNoYWluSWQgKGlmIG5lZWRlZCkgYW5kIGFkZCBkYXRhIHNsaWNlXG4gICAgY29uc3QgZGF0YVN6ID0gZGF0YUJ5dGVzLmxlbmd0aCB8fCAwO1xuICAgIGNvbnN0IGNoYWluSWRFeHRyYVN6ID0gY2hhaW5JZEJ1ZlN6ID4gMCA/IGNoYWluSWRCdWZTeiArIDEgOiAwO1xuICAgIGNvbnN0IGRhdGFUb0NvcHkgPSBCdWZmZXIuYWxsb2MoZGF0YVN6ICsgY2hhaW5JZEV4dHJhU3opO1xuICAgIGlmIChjaGFpbklkRXh0cmFTeiA+IDApIHtcbiAgICAgICAgZGF0YVRvQ29weS53cml0ZVVJbnQ4KGNoYWluSWRCdWZTeiwgMCk7XG4gICAgICAgIGNoYWluSWRCdWYuY29weShkYXRhVG9Db3B5LCAxKTtcbiAgICB9XG4gICAgZGF0YUJ5dGVzLmNvcHkoZGF0YVRvQ29weSwgY2hhaW5JZEV4dHJhU3opO1xuXG4gICAgaWYgKGRhdGFTeiA+IE1BWF9CQVNFX0RBVEFfU1opIHtcbiAgICAgIC8vIERldGVybWluZSBzaXplcyBhbmQgcnVuIHRocm91Z2ggc2FuaXR5IGNoZWNrc1xuICAgICAgY29uc3QgdG90YWxTeiA9IGRhdGFTeiArIGNoYWluSWRFeHRyYVN6O1xuICAgICAgY29uc3QgbWF4U3pBbGxvd2VkID0gTUFYX0JBU0VfREFUQV9TWiArIChleHRyYURhdGFNYXhGcmFtZXMgKiBleHRyYURhdGFGcmFtZVN6KTtcblxuICAgICAgaWYgKHByZWhhc2hBbGxvd2VkICYmIHRvdGFsU3ogPiBtYXhTekFsbG93ZWQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBzZW5kLCBidXQgdGhlIExhdHRpY2UgYWxsb3dzIGEgcHJlaGFzaGVkIG1lc3NhZ2UsIGRvIHRoYXRcbiAgICAgICAgcHJlaGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2NhazI1NihnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UocmF3VHgsIHR5cGUpKSwgJ2hleCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKCFFWFRSQV9EQVRBX0FMTE9XRUQpIHx8IChFWFRSQV9EQVRBX0FMTE9XRUQgJiYgdG90YWxTeiA+IG1heFN6QWxsb3dlZCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIGZpZWxkIHRvbyBsYXJnZSAoZ290ICR7ZGF0YUJ5dGVzLmxlbmd0aH07IG11c3QgYmUgPD0ke21heFN6QWxsb3dlZC1jaGFpbklkRXh0cmFTen0gYnl0ZXMpYCk7XG4gICAgICAgIC8vIFNwbGl0IG92ZXJmbG93IGRhdGEgaW50byBleHRyYURhdGEgZnJhbWVzXG4gICAgICAgIGNvbnN0IGZyYW1lcyA9IHNwbGl0RnJhbWVzKGRhdGFUb0NvcHkuc2xpY2UoTUFYX0JBU0VfREFUQV9TWiksIGV4dHJhRGF0YUZyYW1lU3opO1xuICAgICAgICBmcmFtZXMuZm9yRWFjaCgoZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzekxFID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgIHN6TEUud3JpdGVVSW50MzJMRShmcmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGV4dHJhRGF0YVBheWxvYWRzLnB1c2goQnVmZmVyLmNvbmNhdChbc3pMRSwgZnJhbWVdKSk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQUkVIQVNIX1VOU1VQUE9SVEVEKSB7XG4gICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5zdXBwb3J0ZWQgaW4gZmlybXdhcmUgYnV0IHdlIHdhbnQgdG8gYWxsb3cgc3VjaCB0cmFuc2FjdGlvbnMsXG4gICAgICAvLyB3ZSBwcmVoYXNoIHRoZSBtZXNzYWdlIGhlcmUuXG4gICAgICBwcmVoYXNoID0gQnVmZmVyLmZyb20oa2VjY2FrMjU2KGdldF9ybHBfZW5jb2RlZF9wcmVpbWFnZShyYXdUeCwgdHlwZSkpLCAnaGV4JylcbiAgICB9XG5cbiAgICAvLyBXcml0ZSB0aGUgZGF0YSBzaXplIChkb2VzICpOT1QqIGluY2x1ZGUgdGhlIGNoYWluSWQgYnVmZmVyLCBpZiB0aGF0IGV4aXN0cylcbiAgICB0eFJlcVBheWxvYWQud3JpdGVVSW50MTZCRShkYXRhQnl0ZXMubGVuZ3RoLCBvZmYpOyBvZmYgKz0gMjtcbiAgICAvLyBDb3B5IGluIHRoZSBjaGFpbklkIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICBpZiAoY2hhaW5JZEJ1ZlN6ID4gMCkge1xuICAgICAgdHhSZXFQYXlsb2FkLndyaXRlVUludDgoY2hhaW5JZEJ1ZlN6LCBvZmYpOyBvZmYrKztcbiAgICAgIGNoYWluSWRCdWYuY29weSh0eFJlcVBheWxvYWQsIG9mZik7IG9mZiArPSBjaGFpbklkQnVmU3o7XG4gICAgfVxuICAgIC8vIENvcHkgdGhlIGZpcnN0IHNsaWNlIG9mIHRoZSBkYXRhIGl0c2VsZi4gSWYgdGhpcyBwYXlsb2FkIGhhcyBiZWVuIHByZS1oYXNoZWQsIGluY2x1ZGUgaXRcbiAgICAvLyBpbiB0aGUgYGRhdGFgIGZpZWxkLiBUaGlzIHdpbGwgcmVzdWx0IGluIGEgZGlmZmVyZW50IExhdHRpY2Ugc2NyZWVuIGJlaW5nIGRyYXduLlxuICAgIGlmIChwcmVoYXNoKSB7XG4gICAgICBwcmVoYXNoLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpOyBvZmYgKz0gTUFYX0JBU0VfREFUQV9TWjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUJ5dGVzLnNsaWNlKDAsIE1BWF9CQVNFX0RBVEFfU1opLmNvcHkodHhSZXFQYXlsb2FkLCBvZmYpOyBvZmYgKz0gTUFYX0JBU0VfREFUQV9TWjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhd1R4LFxuICAgICAgdHlwZSxcbiAgICAgIHBheWxvYWQ6IHR4UmVxUGF5bG9hZC5zbGljZSgwLCBvZmYpLFxuICAgICAgZXh0cmFEYXRhUGF5bG9hZHMsXG4gICAgICBzY2hlbWE6IGNvbnN0YW50cy5zaWduaW5nU2NoZW1hLkVUSF9UUkFOU0ZFUiwgIC8vIFdlIHdpbGwgdXNlIGV0aCB0cmFuc2ZlciBmb3IgYWxsIEVUSCB0eHMgZm9yIHYxIFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHVzZUVJUDE1NSxcbiAgICAgIHNpZ25lclBhdGgsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHsgZXJyOiBlcnIubWVzc2FnZSB9O1xuICB9XG59XG5cbi8vIEZyb20gZXRoZXJldW1qcy11dGlsXG5mdW5jdGlvbiBzdHJpcFplcm9zKGEpIHtcbiAgbGV0IGZpcnN0ID0gYVswXVxuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpXG4gICAgZmlyc3QgPSBhWzBdXG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLy8gR2l2ZW4gYSA2NC1ieXRlIHNpZ25hdHVyZSBbcixzXSB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgdGhlIHYgdmFsdWVcbi8vIGFuZCBhdHRhaCB0aGUgZnVsbCBzaWduYXR1cmUgdG8gdGhlIGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24gcGF5bG9hZFxuZXhwb3J0cy5idWlsZEV0aFJhd1R4ID0gZnVuY3Rpb24odHgsIHNpZywgYWRkcmVzcykge1xuICAvLyBSTFAtZW5jb2RlIHRoZSBkYXRhIHdlIHNlbnQgdG8gdGhlIGxhdHRpY2VcbiAgY29uc3QgaGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2NhazI1NihnZXRfcmxwX2VuY29kZWRfcHJlaW1hZ2UodHgucmF3VHgsIHR4LnR5cGUpKSwgJ2hleCcpO1xuICBjb25zdCBuZXdTaWcgPSBhZGRSZWNvdmVyeVBhcmFtKGhhc2gsIHNpZywgYWRkcmVzcywgdHgpO1xuICAvLyBVc2UgdGhlIHNpZ25hdHVyZSB0byBnZW5lcmF0ZSBhIG5ldyByYXcgdHJhbnNhY3Rpb24gcGF5bG9hZFxuICAvLyBTdHJpcCB0aGUgbGFzdCAzIGl0ZW1zIGFuZCByZXBsYWNlIHRoZW0gd2l0aCBzaWduYXR1cmUgY29tcG9uZW50c1xuICBjb25zdCBuZXdSYXdUeCA9IHR4LnVzZUVJUDE1NSA/IHR4LnJhd1R4LnNsaWNlKDAsIC0zKSA6IHR4LnJhd1R4O1xuICBuZXdSYXdUeC5wdXNoKG5ld1NpZy52KTtcbiAgLy8gUGVyIGBldGhlcmV1bWpzLXR4YCwgUkxQIGVuY29kaW5nIHNob3VsZCBpbmNsdWRlIHNpZ25hdHVyZSBjb21wb25lbnRzIHcvIHN0cmlwcGVkIHplcm9zXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvZXRoZXJldW1qcy10eC9ibG9iL21hc3Rlci9zcmMvdHJhbnNhY3Rpb24udHMjTDE4N1xuICBuZXdSYXdUeC5wdXNoKHN0cmlwWmVyb3MobmV3U2lnLnIpKTtcbiAgbmV3UmF3VHgucHVzaChzdHJpcFplcm9zKG5ld1NpZy5zKSk7XG4gIGxldCBybHBFbmNvZGVkV2l0aFNpZyA9IHJscC5lbmNvZGUobmV3UmF3VHgpO1xuICBpZiAodHgudHlwZSkge1xuICAgIHJscEVuY29kZWRXaXRoU2lnID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oW3R4LnR5cGVdKSwgcmxwRW5jb2RlZFdpdGhTaWddKVxuICB9XG4gIHJldHVybiBybHBFbmNvZGVkV2l0aFNpZy50b1N0cmluZygnaGV4Jyk7XG59XG5cbi8vIEF0dGFjaCBhIHJlY292ZXJ5IHBhcmFtZXRlciB0byBhIHNpZ25hdHVyZSBieSBicnV0ZS1mb3JjaW5nIEVDUmVjb3ZlclxuZnVuY3Rpb24gYWRkUmVjb3ZlcnlQYXJhbShoYXNoQnVmLCBzaWcsIGFkZHJlc3MsIHR4RGF0YT17fSkge1xuICB0cnkge1xuICAgIC8vIFJlYnVpbGQgdGhlIGtlY2NhazI1NiBoYXNoIGhlcmUgc28gd2UgY2FuIGBlY3JlY292ZXJgXG4gICAgY29uc3QgaGFzaCA9IG5ldyBVaW50OEFycmF5KGhhc2hCdWYpO1xuICAgIGxldCB2ID0gMDtcbiAgICAvLyBGaXggc2lnbmF0dXJlIGNvbXBvbmVuZXQgbGVuZ3RocyB0byAzMiBieXRlcyBlYWNoXG4gICAgY29uc3QgciA9IGZpeExlbihzaWcuciwgMzIpOyBzaWcuciA9IHI7XG4gICAgY29uc3QgcyA9IGZpeExlbihzaWcucywgMzIpOyBzaWcucyA9IHM7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByZWNvdmVyeSBwYXJhbVxuICAgIGNvbnN0IHJzID0gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChbciwgc10pKTtcbiAgICBsZXQgcHVia2V5ID0gc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihycywgdiwgaGFzaCwgZmFsc2UpLnNsaWNlKDEpXG4gICAgLy8gSWYgdGhlIGZpcnN0IGB2YCB2YWx1ZSBpcyBhIG1hdGNoLCByZXR1cm4gdGhlIHNpZyFcbiAgICBpZiAocHViVG9BZGRyU3RyKHB1YmtleSkgPT09IGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKSB7XG4gICAgICBzaWcudiAgPSBnZXRSZWNvdmVyeVBhcmFtKHYsIHR4RGF0YSk7XG4gICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHRyeSB0aGUgb3RoZXIgYHZgIHZhbHVlXG4gICAgdiA9IDE7XG4gICAgcHVia2V5ID0gc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihycywgdiwgaGFzaCwgZmFsc2UpLnNsaWNlKDEpXG4gICAgaWYgKHB1YlRvQWRkclN0cihwdWJrZXkpID09PSBhZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSkge1xuICAgICAgc2lnLnYgID0gZ2V0UmVjb3ZlcnlQYXJhbSh2LCB0eERhdGEpO1xuICAgICAgcmV0dXJuIHNpZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbmVpdGhlciBpcyBhIG1hdGNoLCB3ZSBzaG91bGQgcmV0dXJuIGFuIGVycm9yXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXRoZXJldW0gc2lnbmF0dXJlIHJldHVybmVkLicpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gIH1cbn1cblxuLy8gQ29udmVydCBhbiBSTFAtc2VyaWFsaXplZCB0cmFuc2FjdGlvbiAocGx1cyBzaWduYXR1cmUpIGludG8gYSB0cmFuc2FjdGlvbiBoYXNoXG5leHBvcnRzLmhhc2hUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRUeCkge1xuICByZXR1cm4ga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWRUeCwgJ2hleCcpKTsgXG59XG5cbi8vIFJldHVybnMgYWRkcmVzcyBzdHJpbmcgZ2l2ZW4gcHVibGljIGtleSBidWZmZXJcbmZ1bmN0aW9uIHB1YlRvQWRkclN0cihwdWIpIHtcbiAgcmV0dXJuIGtlY2NhazI1NihwdWIpLnNsaWNlKC00MCk7XG59XG5cbmZ1bmN0aW9uIGZpeExlbihtc2csIGxlbmd0aCkge1xuICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKVxuICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aClcbiAgICByZXR1cm4gYnVmXG4gIH1cbiAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKVxufVxuXG4vLyBDb252ZXJ0IGEgMC8xIGB2YCBpbnRvIGEgcmVjb3ZlcnkgcGFyYW06XG4vLyAqIEZvciBub24tRUlQMTU1IHRyYW5zYWN0aW9ucywgcmV0dXJuIGAyNyArIHZgXG4vLyAqIEZvciBFSVAxNTUgdHJhbnNhY3Rpb25zLCByZXR1cm4gYChDSEFJTl9JRCoyKSArIDM1ICsgdmBcbmZ1bmN0aW9uIGdldFJlY292ZXJ5UGFyYW0odiwgdHhEYXRhPXt9KSB7XG4gIGNvbnN0IHsgY2hhaW5JZCwgdXNlRUlQMTU1LCB0eXBlIH0gPSB0eERhdGE7XG4gIC8vIEZvciBFSVAxNTU5IGFuZCBFSVAyOTMwIHRyYW5zYWN0aW9ucywgd2Ugd2FudCB0aGUgcmVjb3ZlcnlQYXJhbSAoMCBvciAxKVxuICAvLyByYXRoZXIgdGhhbiB0aGUgYHZgIHZhbHVlIGJlY2F1c2UgdGhlIGBjaGFpbklkYCBpcyBhbHJlYWR5IGluY2x1ZGVkIGluIHRoZVxuICAvLyB0cmFuc2FjdGlvbiBwYXlsb2FkLlxuICBpZiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSAyKSB7XG4gICAgcmV0dXJuIGVuc3VyZUhleEJ1ZmZlcih2LCB0cnVlKTsgLy8gMCBvciAxLCB3aXRoIDAgZXhwZWN0ZWQgYXMgYW4gZW1wdHkgYnVmZmVyXG4gIH0gZWxzZSBpZiAoZmFsc2UgPT09IHVzZUVJUDE1NSB8fCBjaGFpbklkID09PSBudWxsKSB7XG4gICAgLy8gRm9yIEVUSCBtZXNzYWdlcyBhbmQgbm9uLUVJUDE1NSBjaGFpbnMgdGhlIHNldCBzaG91bGQgYmUgWzI3LCAyOF0gZm9yIGB2YFxuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgQk4odikucGx1cygyNykudG9TdHJpbmcoMTYpLCAnaGV4Jyk7XG4gIH1cblxuICAvLyBXZSB3aWxsIHVzZSBFSVAxNTUgaW4gbW9zdCBjYXNlcy4gQ29udmVydCB2IHRvIGEgYmlnbnVtIGFuZCBvcGVyYXRlIG9uIGl0LlxuICAvLyBOb3RlIHRoYXQgdGhlIHByb3RvY29sIGNhbGxzIGZvciB2ID0gKENIQUlOX0lEKjIpICsgMzUvMzYsIHdoZXJlIDM1IG9yIDM2XG4gIC8vIGlzIGRlY2lkZWQgb24gYmFzZWQgb24gdGhlIGVjcmVjb3ZlciByZXN1bHQuIGB2YCBpcyBwYXNzZWQgaW4gYXMgZWl0aGVyIDAgb3IgMVxuICAvLyBzbyB3ZSBhZGQgMzUgdG8gdGhhdC5cbiAgY29uc3QgY2hhaW5JZEJ1ZiA9IGdldENoYWluSWRCdWYoY2hhaW5JZCk7XG4gIGNvbnN0IGNoYWluSWRCTiA9IG5ldyBCTihjaGFpbklkQnVmLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICByZXR1cm4gZW5zdXJlSGV4QnVmZmVyKGAweCR7Y2hhaW5JZEJOLnRpbWVzKDIpLnBsdXMoMzUpLnBsdXModikudG9TdHJpbmcoMTYpfWApO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgdGhlIExhdHRpY2UgY2FuIGRpc3BsYXkgYSBzdHJpbmcgd2UgZ2l2ZSBpdC4gQ3VycmVudGx5LCB0aGUgTGF0dGljZSBjYW4gb25seVxuLy8gZGlzcGxheSBBU0NJSSBzdHJpbmdzLCBzbyB3ZSB3aWxsIHJlamVjdCBvdGhlciBVVEY4IGNvZGVzLlxuLy8gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgYWRkIGEgbWVjaGFuaXNtIHRvIGRpc3BsYXkgY2VydGFpbiBVVEY4IGNvZGVzIHN1Y2ggYXMgcG9wdWxhciBlbW9qaXMuXG5mdW5jdGlvbiBsYXR0aWNlQ2FuRGlzcGxheVN0cihzdHIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDwgMHgwMDIwIHx8IHN0ci5jaGFyQ29kZUF0KGkpID4gMHgwMDdmKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgY2hhaW5JZHMgPSB7XG4gIG1haW5uZXQ6IDEsXG4gIHJvcHRzdGVuOiAzLFxuICByaW5rZWJ5OiA0LFxuICBrb3ZhbjogNDIsXG4gIGdvZXJsaTogNVxufVxuXG4vLyBHZXQgYSBidWZmZXIgY29udGFpbmluZyB0aGUgY2hhaW5JZCB2YWx1ZS5cbi8vIFJldHVybnMgYSAxLCAyLCA0LCBvciA4IGJ5dGUgYnVmZmVyIHdpdGggdGhlIGNoYWluSWQgZW5jb2RlZCBpbiBiaWcgZW5kaWFuXG5mdW5jdGlvbiBnZXRDaGFpbklkQnVmKGNoYWluSWQpIHtcbiAgbGV0IGI7XG4gIC8vIElmIG91ciBjaGFpbklEIGlzIGEgaGV4IHN0cmluZywgd2UgY2FuIGNvbnZlcnQgaXQgdG8gYSBoZXhcbiAgLy8gYnVmZmVyIGRpcmVjdGx5XG4gIGlmICh0cnVlID09PSBpc1ZhbGlkQ2hhaW5JZEhleE51bVN0cihjaGFpbklkKSlcbiAgICBiID0gZW5zdXJlSGV4QnVmZmVyKGNoYWluSWQpO1xuICAvLyBJZiBvdXIgY2hhaW5JRCBpcyBhIGJhc2UtMTAgbnVtYmVyLCBwYXJzZSB3aXRoIGJpZ251bWJlci5qcyBhbmQgY29udmVydCB0byBoZXggYnVmZmVyXG4gIGVsc2VcbiAgICBiID0gZW5zdXJlSGV4QnVmZmVyKGAweCR7bmV3IEJOKGNoYWluSWQpLnRvU3RyaW5nKDE2KX1gKTtcbiAgLy8gTWFrZSBzdXJlIHRoZSBidWZmZXIgaXMgYW4gYWxsb3dlZCBzaXplXG4gIGlmIChiLmxlbmd0aCA+IDgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDaGFpbklEIHByb3ZpZGVkIGlzIHRvbyBsYXJnZS4nKTtcbiAgLy8gSWYgdGhpcyBtYXRjaGVzIGEgdTE2LCB1MzIsIG9yIHU2NCBzaXplLCByZXR1cm4gaXQgbm93XG4gIGlmIChiLmxlbmd0aCA8PSAyIHx8IGIubGVuZ3RoID09PSA0IHx8IGIubGVuZ3RoID09PSA4KVxuICAgIHJldHVybiBiO1xuICAvLyBGb3Igb3RoZXIgc2l6ZSBidWZmZXJzLCB3ZSBuZWVkIHRvIHBhY2sgaW50byB1MzIgb3IgdTY0IGJlZm9yZSByZXR1cm5pbmc7XG4gIGxldCBidWY7XG4gIGlmIChiLmxlbmd0aCA9PT0gMykge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICBidWYud3JpdGVVSW50MzJCRShjaGFpbklkKTtcbiAgfSBlbHNlIGlmIChiLmxlbmd0aCA8PSA4KSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKDgpO1xuICAgIGIuY29weShidWYsIDggLSBiLmxlbmd0aClcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgdGhlIGNoYWluIHVzZXMgRUlQMTU1IGJ5IGRlZmF1bHQsIGJhc2VkIG9uIHRoZSBjaGFpbklEXG5mdW5jdGlvbiBjaGFpblVzZXNFSVAxNTUoY2hhaW5JRCkge1xuICBzd2l0Y2ggKGNoYWluSUQpIHtcbiAgICBjYXNlIDM6IC8vIHJvcHN0ZW5cbiAgICBjYXNlIDQ6IC8vIHJpbmtlYnlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIDE6IC8vIG1haW5uZXRcbiAgICBjYXNlIDQyOiAvLyBrb3ZhblxuICAgIGNhc2UgNTogLy8gZ29lcmxpXG4gICAgZGVmYXVsdDogLy8gYWxsIG90aGVycyBzaG91bGQgdXNlIGVpcDE1NVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIGEgdmFsaWQgbnVtYmVyIHdhcyBwYXNzZWQgaW4gYXMgYSBoZXggc3RyaW5nXG5mdW5jdGlvbiBpc1ZhbGlkQ2hhaW5JZEhleE51bVN0cihzKSB7XG4gIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5zbGljZSgwLCAyKSAhPT0gJzB4JylcbiAgICByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3QgYiA9IG5ldyBCTihzLCAxNilcbiAgICByZXR1cm4gYi5pc05hTigpID09PSBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIElmIHRoaXMgaXMgYSBudWJtZXIgdGhhdCBmaXRzIGluIG9uZSBieXRlLCB3ZSBkb24ndCBuZWVkIHRvIGFkZCBpdFxuLy8gdG8gdGhlIGBkYXRhYCBidWZmZXIgb2YgdGhlIG1haW4gdHJhbnNhY3Rpb24uIFxuLy8gTm90ZSB0aGUgb25lIGVkZ2UgY2FzZTogd2Ugc3RpbGwgbmVlZCB0byB1c2UgdGhlIGBkYXRhYCBmaWVsZCBmb3IgY2hhaW5JRD0yNTUuXG5mdW5jdGlvbiB1c2VDaGFpbklkQnVmZmVyKGlkKSB7XG4gIGNvbnN0IGJ1ZiA9IGdldENoYWluSWRCdWYoaWQpO1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50OCgwKSA9PT0gMjU1O1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5jaGFpbklkcyA9IGNoYWluSWRzO1xuXG5mdW5jdGlvbiBpc0Jhc2UxME51bVN0cih4KSB7XG4gIGNvbnN0IGJuID0gbmV3IEJOKHgpLnRvU3RyaW5nKCkuc3BsaXQoJy4nKS5qb2luKCcnKTtcbiAgY29uc3QgcyA9IG5ldyBTdHJpbmcoeClcbiAgLy8gTm90ZSB0aGF0IHRoZSBKUyBuYXRpdmUgYFN0cmluZygpYCBsb3NlcyBwcmVjaXNpb24gZm9yIGxhcmdlIG51bWJlcnMsIGJ1dCB3ZSBvbmx5XG4gIC8vIHdhbnQgdG8gdmFsaWRhdGUgdGhlIGJhc2Ugb2YgdGhlIG51bWJlciBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IGZhciBvdXQgcHJlY2lzaW9uLlxuICByZXR1cm4gYm4uc2xpY2UoMCwgOCkgPT09IHMuc2xpY2UoMCwgOClcbn1cblxuLy8gRW5zdXJlIGEgcGFyYW0gaXMgcmVwcmVzZW50ZWQgYnkgYSBidWZmZXJcbi8vIFRPRE86IFJlbW92ZSBjaXJjdWxhciBkZXBlbmRlbmN5IGluIHV0aWwuanMgc28gdGhhdCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gdGhlcmVcbmZ1bmN0aW9uIGVuc3VyZUhleEJ1ZmZlcih4LCB6ZXJvSXNOdWxsPXRydWUpIHtcbiAgdHJ5IHtcbiAgICAvLyBGb3IgbnVsbCB2YWx1ZXMsIHJldHVybiBhIDAtc2l6ZWQgYnVmZmVyLiBGb3IgbW9zdCBzaXR1YXRpb25zIHdlIGFzc3VtZVxuICAgIC8vIDAgc2hvdWxkIGJlIHJlcHJlc2VudGVkIHdpdGggYSB6ZXJvLWxlbmd0aCBidWZmZXIgKGUuZy4gZm9yIFJMUC1idWlsZGluZ1xuICAgIC8vIHR4cyksIGJ1dCBpdCBjYW4gYWxzbyBiZSB0cmVhdGVkIGFzIGEgMS1ieXRlIGJ1ZmZlciAoYDAwYCkgaWYgbmVlZGVkXG4gICAgaWYgKHggPT09IG51bGwgfHwgKHggPT09IDAgJiYgemVyb0lzTnVsbCA9PT0gdHJ1ZSkpIFxuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBjb25zdCBpc051bWJlciA9IHR5cGVvZiB4ID09PSAnbnVtYmVyJyB8fCBpc0Jhc2UxME51bVN0cih4KTtcbiAgICAvLyBPdGhlcndpc2UgdHJ5IHRvIGdldCB0aGlzIGNvbnZlcnRlZCB0byBhIGhleCBzdHJpbmdcbiAgICBpZiAoaXNOdW1iZXIpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBudW1iZXIgb3IgYSBiYXNlLTEwIG51bWJlciBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gaGV4XG4gICAgICB4ID0gYCR7bmV3IEJOKHgpLnRvU3RyaW5nKDE2KX1gO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmIHguc2xpY2UoMCwgMikgPT09ICcweCcpIHtcbiAgICAgIHggPSB4LnNsaWNlKDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC50b1N0cmluZygnaGV4JylcbiAgICB9XG4gICAgaWYgKHgubGVuZ3RoICUgMiA+IDApIHggPSBgMCR7eH1gO1xuICAgIGlmICh4ID09PSAnMDAnICYmICFpc051bWJlcilcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHgsICdoZXgnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCAke3gudG9TdHJpbmcoKX0gdG8gaGV4IGJ1ZmZlciAoJHtlcnIudG9TdHJpbmcoKX0pYCk7XG4gIH1cbn1cbmV4cG9ydHMuZW5zdXJlSGV4QnVmZmVyID0gZW5zdXJlSGV4QnVmZmVyO1xuXG5cbmZ1bmN0aW9uIGJ1aWxkUGVyc29uYWxTaWduUmVxdWVzdChyZXEsIGlucHV0KSB7XG4gIGNvbnN0IE1BWF9CQVNFX01TR19TWiA9IGlucHV0LmZ3Q29uc3RhbnRzLmV0aE1heE1zZ1N6O1xuICBjb25zdCBWQVJfUEFUSF9TWiA9IGlucHV0LmZ3Q29uc3RhbnRzLnZhckFkZHJQYXRoU3pBbGxvd2VkO1xuICBjb25zdCBMID0gKDI0KSArIE1BWF9CQVNFX01TR19TWiArIDQ7XG4gIGxldCBvZmYgPSAwO1xuICByZXEucGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhMKTtcbiAgcmVxLnBheWxvYWQud3JpdGVVSW50OChjb25zdGFudHMuZXRoTXNnUHJvdG9jb2wuU0lHTl9QRVJTT05BTCwgMCk7IG9mZiArPSAxO1xuICAvLyBXcml0ZSB0aGUgc2lnbmVyIHBhdGggaW50byB0aGUgYnVmZmVyXG4gIGNvbnN0IHNpZ25lclBhdGhCdWYgPSBidWlsZFNpZ25lclBhdGhCdWYoaW5wdXQuc2lnbmVyUGF0aCwgVkFSX1BBVEhfU1opO1xuICBzaWduZXJQYXRoQnVmLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gIG9mZiArPSBzaWduZXJQYXRoQnVmLmxlbmd0aDtcbiAgLy8gV3JpdGUgdGhlIHBheWxvYWQgYnVmZmVyLiBUaGUgcGF5bG9hZCBjYW4gY29tZSBpbiBlaXRoZXIgYXMgYSBidWZmZXIgb3IgYXMgYSBzdHJpbmdcbiAgbGV0IHBheWxvYWQgPSBpbnB1dC5wYXlsb2FkO1xuICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIGhleCBzdHJpbmdcbiAgbGV0IGRpc3BsYXlIZXggPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBpbnB1dC5wYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpbnB1dC5wYXlsb2FkLnNsaWNlKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICBwYXlsb2FkID0gZW5zdXJlSGV4QnVmZmVyKGlucHV0LnBheWxvYWQpXG4gICAgICBkaXNwbGF5SGV4ID0gZmFsc2UgPT09IGNvbnN0YW50cy5BU0NJSV9SRUdFWC50ZXN0KEJ1ZmZlci5mcm9tKGlucHV0LnBheWxvYWQuc2xpY2UoMiksICdoZXgnKS50b1N0cmluZygpKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGxhdHRpY2VDYW5EaXNwbGF5U3RyKGlucHV0LnBheWxvYWQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnRseSwgdGhlIExhdHRpY2UgY2FuIG9ubHkgZGlzcGxheSBBU0NJSSBzdHJpbmdzLicpO1xuICAgICAgcGF5bG9hZCA9IEJ1ZmZlci5mcm9tKGlucHV0LnBheWxvYWQpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dC5kaXNwbGF5SGV4ID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgYnVmZmVyIGFuZCB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIHdoZXRoZXIgb3Igbm90IHRoaXNcbiAgICAvLyBpcyBhIGhleCBidWZmZXIgd2l0aCB0aGUgb3B0aW9uYWwgYXJndW1lbnQsIHdyaXRlIHRoYXRcbiAgICBkaXNwbGF5SGV4ID0gaW5wdXQuZGlzcGxheUhleFxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgZGV0ZXJtaW5lIGlmIHRoaXMgYnVmZmVyIGlzIGFuIEFTQ0lJIHN0cmluZy4gSWYgaXQgaXMsIHNldCBgZGlzcGxheUhleGAgYWNjb3JkaW5nbHkuXG4gICAgLy8gTk9URTogVEhJUyBNRUFOUyBUSEFUIE5PTi1BU0NJSSBTVFJJTkdTIFdJTEwgRElTUExBWSBBUyBIRVggU0lOQ0UgV0UgQ0FOTk9UIEtOT1cgSUYgVEhFIFJFUVVFU1RFUlxuICAgIC8vICAgICAgICBFWFBFQ1RFRCBOT04tQVNDSUkgQ0hBUkFDVEVSUyBUTyBESVNQTEFZIElOIEEgU1RSSU5HXG4gICAgLy8gVE9ETzogRGV2ZWxvcCBhIG1vcmUgZWxlZ2FudCBzb2x1dGlvbiBmb3IgdGhpc1xuICAgIGlmICghaW5wdXQucGF5bG9hZC50b1N0cmluZylcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgaW5wdXQgZGF0YSB0eXBlJyk7XG4gICAgZGlzcGxheUhleCA9IGZhbHNlID09PSBjb25zdGFudHMuQVNDSUlfUkVHRVgudGVzdChpbnB1dC5wYXlsb2FkLnRvU3RyaW5nKCkpXG4gIH1cbiAgY29uc3QgZndDb25zdCA9IGlucHV0LmZ3Q29uc3RhbnRzO1xuICBsZXQgbWF4U3pBbGxvd2VkID0gTUFYX0JBU0VfTVNHX1NaICsgKGZ3Q29uc3QuZXh0cmFEYXRhTWF4RnJhbWVzICogZndDb25zdC5leHRyYURhdGFGcmFtZVN6KTtcbiAgaWYgKGZ3Q29uc3QucGVyc29uYWxTaWduSGVhZGVyU3opIHtcbiAgICAvLyBBY2NvdW50IGZvciB0aGUgcGVyc29uYWxfc2lnbiBoZWFkZXIgc3RyaW5nXG4gICAgbWF4U3pBbGxvd2VkIC09IGZ3Q29uc3QucGVyc29uYWxTaWduSGVhZGVyU3o7XG4gIH1cbiAgaWYgKGZ3Q29uc3QuZXRoTXNnUHJlSGFzaEFsbG93ZWQgJiYgcGF5bG9hZC5sZW5ndGggPiBtYXhTekFsbG93ZWQpIHtcbiAgICAvLyBJZiB0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgZml0IGFuZCBwcmUtaGFzaGluZyBpcyBhbGxvd2VkLCBkbyB0aGF0XG4gICAgcmVxLnBheWxvYWQud3JpdGVVSW50OChkaXNwbGF5SGV4LCBvZmYpOyBvZmYgKz0gMTtcbiAgICByZXEucGF5bG9hZC53cml0ZVVJbnQxNkxFKHBheWxvYWQubGVuZ3RoLCBvZmYpOyBvZmYgKz0gMjtcbiAgICBjb25zdCBwcmVoYXNoID0gQnVmZmVyLmZyb20oa2VjY2FrMjU2KEJ1ZmZlci5jb25jYXQoW2dldF9wZXJzb25hbF9zaWduX3ByZWZpeChwYXlsb2FkLmxlbmd0aCksIHBheWxvYWRdKSksICdoZXgnKTtcbiAgICBwcmVoYXNoLmNvcHkocmVxLnBheWxvYWQsIG9mZik7XG4gICAgcmVxLnByZWhhc2ggPSBwcmVoYXNoO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gZml0IHRoZSBwYXlsb2FkLlxuICAgIC8vIEZsb3cgZGF0YSBpbnRvIGV4dHJhRGF0YSByZXF1ZXN0cywgd2hpY2ggd2lsbCBmb2xsb3ctdXAgdHJhbnNhY3Rpb24gcmVxdWVzdHMsIGlmIHN1cHBvcnRlZC9hcHBsaWNhYmxlICAgIFxuICAgIGNvbnN0IGV4dHJhRGF0YVBheWxvYWRzID0gZ2V0RXh0cmFEYXRhKHBheWxvYWQsIGlucHV0KTtcbiAgICAvLyBXcml0ZSB0aGUgcGF5bG9hZCBhbmQgbWV0YWRhdGEgaW50byBvdXIgYnVmZmVyXG4gICAgcmVxLmV4dHJhRGF0YVBheWxvYWRzID0gZXh0cmFEYXRhUGF5bG9hZHNcbiAgICByZXEubXNnID0gcGF5bG9hZDtcbiAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KGRpc3BsYXlIZXgsIG9mZik7IG9mZiArPSAxO1xuICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDE2TEUocGF5bG9hZC5sZW5ndGgsIG9mZik7IG9mZiArPSAyO1xuICAgIHBheWxvYWQuY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgfVxuICByZXR1cm4gcmVxO1xufVxuXG5mdW5jdGlvbiBidWlsZEVJUDcxMlJlcXVlc3QocmVxLCBpbnB1dCkge1xuICB0cnkge1xuICAgIGNvbnN0IE1BWF9CQVNFX01TR19TWiA9IGlucHV0LmZ3Q29uc3RhbnRzLmV0aE1heE1zZ1N6O1xuICAgIGNvbnN0IFZBUl9QQVRIX1NaID0gaW5wdXQuZndDb25zdGFudHMudmFyQWRkclBhdGhTekFsbG93ZWQ7XG4gICAgY29uc3QgVFlQRURfREFUQSA9IGNvbnN0YW50cy5ldGhNc2dQcm90b2NvbC5UWVBFRF9EQVRBO1xuICAgIGNvbnN0IEwgPSAoMjQpICsgTUFYX0JBU0VfTVNHX1NaICsgNDtcbiAgICBsZXQgb2ZmID0gMDtcbiAgICByZXEucGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhMKTtcbiAgICByZXEucGF5bG9hZC53cml0ZVVJbnQ4KFRZUEVEX0RBVEEuZW51bUlkeCwgMCk7IG9mZiArPSAxO1xuICAgIC8vIFdyaXRlIHRoZSBzaWduZXIgcGF0aFxuICAgIGNvbnN0IHNpZ25lclBhdGhCdWYgPSBidWlsZFNpZ25lclBhdGhCdWYoaW5wdXQuc2lnbmVyUGF0aCwgVkFSX1BBVEhfU1opO1xuICAgIHNpZ25lclBhdGhCdWYuY29weShyZXEucGF5bG9hZCwgb2ZmKTtcbiAgICBvZmYgKz0gc2lnbmVyUGF0aEJ1Zi5sZW5ndGg7XG4gICAgLy8gUGFyc2UvY2xlYW4gdGhlIEVJUDcxMiBwYXlsb2FkLCBzZXJpYWxpemUgd2l0aCBDQk9SLCBhbmQgd3JpdGUgdG8gdGhlIHBheWxvYWRcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dC5wYXlsb2FkKSk7XG4gICAgaWYgKCFkYXRhLnByaW1hcnlUeXBlIHx8ICFkYXRhLnR5cGVzW2RhdGEucHJpbWFyeVR5cGVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmltYXJ5VHlwZSBtdXN0IGJlIHNwZWNpZmllZCBhbmQgdGhlIHR5cGUgbXVzdCBiZSBpbmNsdWRlZC4nKVxuICAgIGlmICghZGF0YS5tZXNzYWdlIHx8ICFkYXRhLmRvbWFpbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSBhbmQgZG9tYWluIG11c3QgYmUgc3BlY2lmaWVkLicpXG4gICAgaWYgKDAgPiBPYmplY3Qua2V5cyhkYXRhLnR5cGVzKS5pbmRleE9mKCdFSVA3MTJEb21haW4nKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignRUlQNzEyRG9tYWluIHR5cGUgbXVzdCBiZSBkZWZpbmVkLicpXG4gICAgLy8gUGFyc2UgdGhlIHBheWxvYWQgdG8gZW5zdXJlIHdlIGhhdmUgdmFsaWQgRUlQNzEyIGRhdGEgdHlwZXMgYW5kIHRoYXRcbiAgICAvLyB0aGV5IGFyZSBlbmNvZGVkIHN1Y2ggdGhhdCBMYXR0aWNlIGZpcm13YXJlIGNhbiBwYXJzZSB0aGVtLlxuICAgIC8vIFdlIG5lZWQgdHdvIGRpZmZlcmVudCBlbmNvZGluZ3M6XG4gICAgLy8gMS4gVXNlIGBldGhlcnNgIEJpZ051bWJlciB3aGVuIGJ1aWxkaW5nIHRoZSByZXF1ZXN0IHRvIGJlIHZhbGlkYXRlZCBieSBldGhlcnMtZWlwNzEyLlxuICAgIC8vICAgIE1ha2Ugc3VyZSB3ZSB1c2UgYSBjb3B5IG9mIHRoZSBkYXRhIHRvIGF2b2lkIG11dGF0aW9uIHByb2JsZW1zXG4gICAgaW5wdXQucGF5bG9hZC5tZXNzYWdlID0gcGFyc2VFSVA3MTJNc2coIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YS5tZXNzYWdlKSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEucHJpbWFyeVR5cGUpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YS50eXBlcykpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSk7XG4gICAgaW5wdXQucGF5bG9hZC5kb21haW4gPSBwYXJzZUVJUDcxMk1zZyggSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLmRvbWFpbikpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0VJUDcxMkRvbWFpbicsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEudHlwZXMpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpO1xuICAgIC8vIDIuIFVzZSBgYmlnbnVtYmVyLmpzYCBmb3IgdGhlIHJlcXVlc3QgZ29pbmcgdG8gdGhlIExhdHRpY2UsIHNpbmNlIGl0J3MgdGhlIHJlcXVpcmVkXG4gICAgLy8gICAgQmlnTnVtYmVyIGxpYiBmb3IgYGNib3JgLCB3aGljaCB3ZSB1c2UgdG8gZW5jb2RlIHRoZSByZXF1ZXN0IGRhdGEgdG8gdGhlIExhdHRpY2UuXG4gICAgZGF0YS5kb21haW4gPSBwYXJzZUVJUDcxMk1zZyhkYXRhLmRvbWFpbiwgJ0VJUDcxMkRvbWFpbicsIGRhdGEudHlwZXMsIGZhbHNlKTtcbiAgICBkYXRhLm1lc3NhZ2UgPSBwYXJzZUVJUDcxMk1zZyhkYXRhLm1lc3NhZ2UsIGRhdGEucHJpbWFyeVR5cGUsIGRhdGEudHlwZXMsIGZhbHNlKTtcbiAgICAvLyBOb3cgYnVpbGQgdGhlIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgTGF0dGljZVxuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShjYm9yLmVuY29kZShkYXRhKSk7XG4gICAgY29uc3QgZndDb25zdCA9IGlucHV0LmZ3Q29uc3RhbnRzO1xuICAgIGNvbnN0IG1heFN6QWxsb3dlZCA9IE1BWF9CQVNFX01TR19TWiArIChmd0NvbnN0LmV4dHJhRGF0YU1heEZyYW1lcyAqIGZ3Q29uc3QuZXh0cmFEYXRhRnJhbWVTeik7XG4gICAgaWYgKGZ3Q29uc3QuZXRoTXNnUHJlSGFzaEFsbG93ZWQgJiYgcGF5bG9hZC5sZW5ndGggPiBtYXhTekFsbG93ZWQpIHtcbiAgICAgIC8vIElmIHRoaXMgcGF5bG9hZCBpcyB0b28gbGFyZ2UgdG8gc2VuZCwgYnV0IHRoZSBMYXR0aWNlIGFsbG93cyBhIHByZWhhc2hlZCBtZXNzYWdlLCBkbyB0aGF0XG4gICAgICByZXEucGF5bG9hZC53cml0ZVVJbnQxNkxFKHBheWxvYWQubGVuZ3RoLCBvZmYpOyBvZmYgKz0gMjtcbiAgICAgIGNvbnN0IHByZWhhc2ggPSBCdWZmZXIuZnJvbShrZWNjYWsyNTYoZWlwNzEyLlR5cGVkRGF0YVV0aWxzLmVuY29kZURpZ2VzdChyZXEuaW5wdXQucGF5bG9hZCksICdoZXgnKSwgJ2hleCcpO1xuICAgICAgcHJlaGFzaC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpO1xuICAgICAgcmVxLnByZWhhc2ggPSBwcmVoYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleHRyYURhdGFQYXlsb2FkcyA9IGdldEV4dHJhRGF0YShwYXlsb2FkLCBpbnB1dCk7XG4gICAgICByZXEuZXh0cmFEYXRhUGF5bG9hZHMgPSBleHRyYURhdGFQYXlsb2FkcztcbiAgICAgIHJlcS5wYXlsb2FkLndyaXRlVUludDE2TEUocGF5bG9hZC5sZW5ndGgsIG9mZik7IG9mZiArPSAyO1xuICAgICAgcGF5bG9hZC5jb3B5KHJlcS5wYXlsb2FkLCBvZmYpOyBvZmYgKz0gcGF5bG9hZC5sZW5ndGg7XG4gICAgICAvLyBTbGljZSBvdXQgdGhlIHBhcnQgb2YgdGhlIGJ1ZmZlciB0aGF0IHdlIGRpZG4ndCB1c2UuXG4gICAgICByZXEucGF5bG9hZCA9IHJlcS5wYXlsb2FkLnNsaWNlKDAsIG9mZik7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7IGVycjogYEZhaWxlZCB0byBidWlsZCBFSVA3MTIgcmVxdWVzdDogJHtlcnIubWVzc2FnZX1gIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRTaWduZXJQYXRoQnVmKHNpZ25lclBhdGgsIHZhckFkZHJQYXRoU3pBbGxvd2VkKSB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYygyNCk7XG4gIGxldCBvZmYgPSAwO1xuICBpZiAodmFyQWRkclBhdGhTekFsbG93ZWQgJiYgc2lnbmVyUGF0aC5sZW5ndGggPiA1KVxuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmVyIHBhdGggbXVzdCBiZSA8PTUgaW5kaWNlcy4nKTtcbiAgaWYgKCF2YXJBZGRyUGF0aFN6QWxsb3dlZCAmJiBzaWduZXJQYXRoLmxlbmd0aCAhPT0gNSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgTGF0dGljZSBmaXJtd2FyZSBvbmx5IHN1cHBvcnRzIDUtaW5kZXggZGVyaXZhdGlvbiBwYXRocy4gUGxlYXNlIHVwZ3JhZGUuJyk7XG4gIGJ1Zi53cml0ZVVJbnQzMkxFKHNpZ25lclBhdGgubGVuZ3RoLCBvZmYpOyBvZmYgKz0gNDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICBpZiAoaSA8IHNpZ25lclBhdGgubGVuZ3RoKVxuICAgICAgYnVmLndyaXRlVUludDMyTEUoc2lnbmVyUGF0aFtpXSwgb2ZmKTsgXG4gICAgZWxzZVxuICAgICAgYnVmLndyaXRlVUludDMyTEUoMCwgb2ZmKTtcbiAgICBvZmYgKz0gNDtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBnZXRFeHRyYURhdGEocGF5bG9hZCwgaW5wdXQpIHtcbiAgY29uc3QgeyBldGhNYXhNc2dTeiwgZXh0cmFEYXRhRnJhbWVTeiwgZXh0cmFEYXRhTWF4RnJhbWVzIH0gPSBpbnB1dC5md0NvbnN0YW50cztcbiAgY29uc3QgTUFYX0JBU0VfTVNHX1NaID0gZXRoTWF4TXNnU3o7XG4gIGNvbnN0IEVYVFJBX0RBVEFfQUxMT1dFRCA9IGV4dHJhRGF0YUZyYW1lU3ogPiAwICYmIGV4dHJhRGF0YU1heEZyYW1lcyA+IDA7XG4gIGNvbnN0IGV4dHJhRGF0YVBheWxvYWRzID0gW107XG4gIGlmIChwYXlsb2FkLmxlbmd0aCA+IE1BWF9CQVNFX01TR19TWikge1xuICAgIC8vIERldGVybWluZSBzaXplcyBhbmQgcnVuIHRocm91Z2ggc2FuaXR5IGNoZWNrc1xuICAgIGNvbnN0IG1heFN6QWxsb3dlZCA9IE1BWF9CQVNFX01TR19TWiArIChleHRyYURhdGFNYXhGcmFtZXMgKiBleHRyYURhdGFGcmFtZVN6KTtcbiAgICBpZiAoIUVYVFJBX0RBVEFfQUxMT1dFRClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91ciBtZXNzYWdlIGlzICR7cGF5bG9hZC5sZW5ndGh9IGJ5dGVzLCBidXQgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mICR7TUFYX0JBU0VfTVNHX1NafWApO1xuICAgIGVsc2UgaWYgKEVYVFJBX0RBVEFfQUxMT1dFRCAmJiBwYXlsb2FkLmxlbmd0aCA+IG1heFN6QWxsb3dlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91ciBtZXNzYWdlIGlzICR7cGF5bG9hZC5sZW5ndGh9IGJ5dGVzLCBidXQgY2FuIG9ubHkgYmUgYSBtYXhpbXVtIG9mICR7bWF4U3pBbGxvd2VkfWApO1xuICAgIC8vIFNwbGl0IG92ZXJmbG93IGRhdGEgaW50byBleHRyYURhdGEgZnJhbWVzXG4gICAgY29uc3QgZnJhbWVzID0gc3BsaXRGcmFtZXMocGF5bG9hZC5zbGljZShNQVhfQkFTRV9NU0dfU1opLCBleHRyYURhdGFGcmFtZVN6KTtcbiAgICBmcmFtZXMuZm9yRWFjaCgoZnJhbWUpID0+IHtcbiAgICAgIGNvbnN0IHN6TEUgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICBzekxFLndyaXRlVUludDMyTEUoZnJhbWUubGVuZ3RoKTtcbiAgICAgIGV4dHJhRGF0YVBheWxvYWRzLnB1c2goQnVmZmVyLmNvbmNhdChbc3pMRSwgZnJhbWVdKSk7XG4gICAgfSlcbiAgfVxuICByZXR1cm4gZXh0cmFEYXRhUGF5bG9hZHM7XG59XG5cbmZ1bmN0aW9uIHNwbGl0RnJhbWVzKGRhdGEsIGZyYW1lU3opIHtcbiAgY29uc3QgZnJhbWVzID0gW11cbiAgY29uc3QgbiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIGZyYW1lU3opO1xuICBsZXQgb2ZmID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBmcmFtZXMucHVzaChkYXRhLnNsaWNlKG9mZiwgb2ZmICsgZnJhbWVTeikpO1xuICAgIG9mZiArPSBmcmFtZVN6O1xuICB9XG4gIHJldHVybiBmcmFtZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRUlQNzEyTXNnKG1zZywgdHlwZU5hbWUsIHR5cGVzLCBpc0V0aGVycz1mYWxzZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgdHlwZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBjb25zdCBpc0FycmF5VHlwZSA9IGl0ZW0udHlwZS5pbmRleE9mKCdbJykgPiAtMTtcbiAgICAgIGNvbnN0IHNpbmd1bGFyVHlwZSA9IGlzQXJyYXlUeXBlID8gaXRlbS50eXBlLnNsaWNlKDAsIGl0ZW0udHlwZS5pbmRleE9mKCdbJykpIDogaXRlbS50eXBlO1xuICAgICAgY29uc3QgaXNDdXN0b21UeXBlID0gT2JqZWN0LmtleXModHlwZXMpLmluZGV4T2Yoc2luZ3VsYXJUeXBlKSA+IC0xO1xuICAgICAgaWYgKGlzQ3VzdG9tVHlwZSAmJiBBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAgICAgLy8gRm9yIGN1c3RvbSB0eXBlcyB3ZSBuZWVkIHRvIGp1bXAgaW50byB0aGUgYG1zZ2AgdXNpbmcgdGhlIGtleSAobmFtZSBvZiB0eXBlKSBhbmQgXG4gICAgICAgIC8vIHBhcnNlIHRoYXQgZW50aXJlIHN1Yi1zdHJ1Y3QgYXMgaWYgaXQgd2VyZSBhIG1lc3NhZ2UuXG4gICAgICAgIC8vIFdlIHdpbGwgcmVjdXJzZSBpbnRvIHN1Yi1zdHJ1Y3RzIHVudGlsIHdlIHJlYWNoIGEgbGV2ZWwgd2hlcmUgZXZlcnkgaXRlbSBpcyBhblxuICAgICAgICAvLyBlbGVtZW50YXJ5IChpLmUuIG5vbi1jdXN0b20pIHR5cGUuXG4gICAgICAgIC8vIEZvciBhcnJheXMsIHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGVhY2ggbWVzc2FnZSBpdGVtLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbXNnW2ldW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMk1zZyhtc2dbaV1baXRlbS5uYW1lXSwgc2luZ3VsYXJUeXBlLCB0eXBlcywgaXNFdGhlcnMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21UeXBlKSB7XG4gICAgICAgIC8vIE5vdCBhbiBhcnJheSBtZWFucyB3ZSBjYW4ganVtcCBkaXJlY3RseSBpbnRvIHRoZSBzdWItc3RydWN0IHRvIGNvbnZlcnRcbiAgICAgICAgbXNnW2l0ZW0ubmFtZV0gPSBwYXJzZUVJUDcxMk1zZyhtc2dbaXRlbS5uYW1lXSwgc2luZ3VsYXJUeXBlLCB0eXBlcywgaXNFdGhlcnMpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFycmF5IGZvciB0aGlzIHBhcnRpY3VsYXIgdHlwZSBhbmQgdGhlIHR5cGUgd2UgYXJlIHBhcnNpbmdcbiAgICAgICAgLy8gaXMgKm5vdCogYSBjdXN0b20gdHlwZSwgbG9vcCB0aHJvdWdoIHRoZSBhcnJheSBlbGVtZW50cyBhbmQgY29udmVydCB0aGUgdHlwZXMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlUeXBlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHR5cGUgaXMgaXRzZWxmIGFuIGFycmF5LCBsb29wIHRocm91Z2ggdGhvc2UgZWxlbWVudHMgYW5kIHBhcnNlIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSBpcyBub3QgcmVhY2hhYmxlIGZvciBjdXN0b20gdHlwZXMgc28gd2UgYXNzdW1lIHRoZXNlIGFyZSBhcnJheXMgb2ZcbiAgICAgICAgICAgIC8vIGVsZW1lbnRhcnkgdHlwZXMuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1zZ1tpXVtpdGVtLm5hbWVdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIG1zZ1tpXVtpdGVtLm5hbWVdW2pdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpXVtpdGVtLm5hbWVdW2pdLCBzaW5ndWxhclR5cGUsIGlzRXRoZXJzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb24tYXJyYXlzIHBhcnNlICsgcmVwbGFjZSBvbmUgdmFsdWUgZm9yIHRoZSBlbGVtZW50YXJ5IHR5cGVcbiAgICAgICAgICAgIG1zZ1tpXVtpdGVtLm5hbWVdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpXVtpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIGlzRXRoZXJzKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5VHlwZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGVsZW1lbnRhcnkgYXJyYXkgdHlwZSBhbmQgYSBub24tYXJyYXkgbWVzc2FnZSBsZXZlbCwgXG4gICAgICAgIC8vbG9vcCB0aHJvdWdoIHRoZSBhcnJheSBhbmQgcGFyc2UgKyByZXBsYWNlICBlYWNoIGl0ZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZ1tpdGVtLm5hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnW2l0ZW0ubmFtZV1baV0gPSBwYXJzZUVJUDcxMkl0ZW0obXNnW2l0ZW0ubmFtZV1baV0sIHNpbmd1bGFyVHlwZSwgaXNFdGhlcnMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBzaW5ndWxhciBlbGVtZW50YXJ5IHR5cGUsIHNpbXBseSBwYXJzZSArIHJlcGxhY2UuXG4gICAgICAgIG1zZ1tpdGVtLm5hbWVdID0gcGFyc2VFSVA3MTJJdGVtKG1zZ1tpdGVtLm5hbWVdLCBzaW5ndWxhclR5cGUsIGlzRXRoZXJzKVxuICAgICAgfVxuICAgICAgXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyci5tZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gbXNnO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVJUDcxMkl0ZW0oZGF0YSwgdHlwZSwgaXNFdGhlcnM9ZmFsc2UpIHtcbiAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAvLyBWYXJpYWJsZSBzaXplZCBieXRlcyBuZWVkIHRvIGJlIGJ1ZmZlciB0eXBlXG4gICAgZGF0YSA9IGVuc3VyZUhleEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmICh0eXBlLnNsaWNlKDAsIDUpID09PSAnYnl0ZXMnKSB7XG4gICAgLy8gRml4ZWQgc2l6ZXMgYnl0ZXMgbmVlZCB0byBiZSBidWZmZXIgdHlwZS4gV2UgYWxzbyBhZGQgc29tZSBzYW5pdHkgY2hlY2tzLlxuICAgIGNvbnN0IG5CeXRlcyA9IHBhcnNlSW50KHR5cGUuc2xpY2UoNSkpO1xuICAgIGRhdGEgPSBlbnN1cmVIZXhCdWZmZXIoZGF0YSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSBuQnl0ZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dHlwZX0gdHlwZSwgYnV0IGdvdCAke2RhdGEubGVuZ3RofSBieXRlc2ApO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgIC8vIEFkZHJlc3MgbXVzdCBiZSBhIDIwIGJ5dGUgYnVmZmVyXG4gICAgZGF0YSA9IGVuc3VyZUhleEJ1ZmZlcihkYXRhKTtcbiAgICAvLyBFZGdlIGNhc2UgdG8gaGFuZGxlIHRoZSAwLWFkZHJlc3NcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuYWxsb2MoMjApO1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IDIwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzIHR5cGUgbXVzdCBiZSAyMCBieXRlcywgYnV0IGdvdCAke2RhdGEubGVuZ3RofSBieXRlc2ApO1xuICAgIC8vIEV0aGVycyB3YW50cyBhZGRyZXNzZXMgYXMgaGV4IHN0cmluZ3NcbiAgICBpZiAoaXNFdGhlcnMgPT09IHRydWUpIHtcbiAgICAgIGRhdGEgPSBgMHgke2RhdGEudG9TdHJpbmcoJ2hleCcpfWBcbiAgICB9XG4gIH0gZWxzZSBpZiAoIChjb25zdGFudHMuZXRoTXNnUHJvdG9jb2wuVFlQRURfREFUQS50eXBlQ29kZXNbdHlwZV0pICYmIFxuICAgICAgICAgICAgICAodHlwZS5pbmRleE9mKCd1aW50JykgPiAtMSB8fCB0eXBlLmluZGV4T2YoJ2ludCcpID4gLTEpKSB7XG4gICAgbGV0IGIgPSBlbnN1cmVIZXhCdWZmZXIoZGF0YSk7XG4gICAgLy8gRWRnZSBjYXNlIHRvIGhhbmRsZSAwLXZhbHVlIGJpZ251bXNcbiAgICBpZiAoYi5sZW5ndGggPT09IDApIHtcbiAgICAgIGIgPSBCdWZmZXIuZnJvbSgnMDAnLCAnaGV4Jyk7XG4gICAgfVxuICAgIC8vIFVpbnQyNTZzIHNob3VsZCBiZSBlbmNvZGVkIGFzIGJpZ251bXMuXG4gICAgaWYgKGlzRXRoZXJzID09PSB0cnVlKSB7XG4gICAgICAvLyBgZXRoZXJzYCB1c2VzIHRoZWlyIG93biBCaWdOdW1iZXIgbGliXG4gICAgICBkYXRhID0gZXRoZXJzLkJpZ051bWJlci5mcm9tKGAweCR7Yi50b1N0cmluZygnaGV4Jyl9YClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYGJpZ251bWJlci5qc2AgaXMgbmVlZGVkIGZvciBgY2JvcmAgZW5jb2RpbmcsIHdoaWNoIGdldHMgc2VudCB0byB0aGUgTGF0dGljZSBhbmQgcGxheXNcbiAgICAgIC8vIG5pY2VseSB3aXRoIGl0cyBmaXJtd2FyZSBjYm9yIGxpYi5cbiAgICAgIC8vIE5PVEU6IElmIHdlIGluc3RhbnRpYXRlIGEgYGJpZ251bWJlci5qc2Agb2JqZWN0LCBpdCB3aWxsIG5vdCBtYXRjaCB3aGF0IGBib3JjYCBjcmVhdGVzXG4gICAgICAvLyB3aGVuIHJ1biBpbnNpZGUgb2YgdGhlIGJyb3dzZXIgKGkuZS4gTWV0YU1hc2spLiBUaHVzIHdlIGludHJvZHVjZSB0aGlzIGhhY2sgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB3ZSBhcmUgY3JlYXRpbmcgYSBjb21wYXRpYmxlIHR5cGUuXG4gICAgICAvLyBUT0RPOiBGaW5kIGFub3RoZXIgY2JvciBsaWIgdGhhdCBpcyBjb21wYXRhaWJsZSB3aXRoIHRoZSBmaXJtd2FyZSdzIGxpYiBpbiBhIGJyb3dzZXJcbiAgICAgIC8vIGNvbnRleHQuIFRoaXMgaXMgc3VycHJpc2luZ2x5IGRpZmZpY3VsdCAtIEkgdHJpZWQgc2V2ZXJhbCBsaWJzIGFuZCBvbmx5IGNib3IvYm9yYyBoYXZlXG4gICAgICAvLyB3b3JrZWQgKGJvcmMgaXMgYSBzdXBwb3NlZGx5IFwiYnJvd3NlciBjb21wYXRpYmxlXCIgdmVyc2lvbiBvZiBjYm9yKVxuICAgICAgZGF0YSA9IG5ldyBjYm9yLkVuY29kZXIoKS5zZW1hbnRpY1R5cGVzWzFdWzBdKGIudG9TdHJpbmcoJ2hleCcpLCAxNilcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgLy8gQm9vbGVhbnMgbmVlZCB0byBiZSBjYXN0IHRvIGEgdThcbiAgICBkYXRhID0gZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICB9XG4gIC8vIE90aGVyIHR5cGVzIGRvbid0IG5lZWQgdG8gYmUgbW9kaWZpZWRcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGdldF9wZXJzb25hbF9zaWduX3ByZWZpeChMKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICBgXFx1MDAxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbiR7TC50b1N0cmluZygpfWAsXG4gICAgJ3V0Zi04JyxcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0X3JscF9lbmNvZGVkX3ByZWltYWdlKHJhd1R4LCB0eFR5cGUpIHtcbiAgaWYgKHR4VHlwZSkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbdHhUeXBlXSksIHJscC5lbmNvZGUocmF3VHgpXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUocmF3VHgpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0aWwgPSBleHBvcnRzLmdldEFub255bWl6ZWRTdGF0ZSA9IGV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZXhwb3J0cy5CYXNlQ29udHJvbGxlclYyID0gdm9pZCAwO1xucmVxdWlyZShcImlzb21vcnBoaWMtZmV0Y2hcIik7XG5jb25zdCB1dGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxcIikpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvQWNjb3VudFRyYWNrZXJDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyL0FkZHJlc3NCb29rQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBwcm92YWwvQXBwcm92YWxDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvQXNzZXRzQ29udHJhY3RDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvQXNzZXRzRGV0ZWN0aW9uQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQmFzZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xudmFyIEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDb250cm9sbGVyVjJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJvbGxlclYyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQZXJzaXN0ZW50U3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2VDb250cm9sbGVyVjJfMS5nZXRQZXJzaXN0ZW50U3RhdGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBbm9ueW1pemVkU3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2VDb250cm9sbGVyVjJfMS5nZXRBbm9ueW1pemVkU3RhdGU7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zYWJsZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJNZXNzZW5nZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9DdXJyZW5jeVJhdGVDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlyaW5nL0tleXJpbmdDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXNzYWdlLW1hbmFnZXIvTWVzc2FnZU1hbmFnZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25ldHdvcmsvTmV0d29ya0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RoaXJkLXBhcnR5L1BoaXNoaW5nQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXNlci9QcmVmZXJlbmNlc0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Ub2tlbkJhbGFuY2VzQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL1Rva2VuUmF0ZXNDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9UcmFuc2FjdGlvbkNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2UtbWFuYWdlci9QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXNzYWdlLW1hbmFnZXIvVHlwZWRNZXNzYWdlTWFuYWdlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm90aWZpY2F0aW9uL05vdGlmaWNhdGlvbkNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Ub2tlbkxpc3RDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nYXMvR2FzRmVlQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL1Rva2Vuc0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Db2xsZWN0aWJsZXNDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMudGltZVNpbmNlID0gdm9pZCAwO1xuY29uc3QgZmFzdF9kZWVwX2VxdWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSk7XG4vKipcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbmNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iamVjdCwga2V5KSA9PiBSZWZsZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5O1xuLyoqXG4gKiB7QGxpbmsgTm9uRW1wdHlBcnJheX0gdHlwZSBndWFyZC5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5leHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGlzTm9uRW1wdHlBcnJheTtcbi8qKlxuICoge0BsaW5rIEpzb259IHR5cGUgZ3VhcmQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgdmFsaWQgSlNPTi5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmFzdF9kZWVwX2VxdWFsXzEuZGVmYXVsdCh2YWx1ZSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBpc1ZhbGlkSnNvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JTkxJTkVfU05BUFMgPSB2b2lkIDA7XG5leHBvcnRzLklOTElORV9TTkFQUyA9IHtcbiAgICBJRExFOiBgXG4gICAgY29uc29sZS5sb2coJ1dlbGNvbWUgdG8gRmxhdm9ydG93bi4nKTtcbiAgYCxcbiAgICBJTkZJTklURV9MT09QOiBgXG4gICAgY29uc29sZS5sb2coJ0luZmluaXRlIGxvb3Agc25hcCBzdGFydC4nKTtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBsZXQgdGltZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGlmIChudW0gPT09ICgyZTggLSAxKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRGluZywgZ3JhdHouJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGUubG9nKChEYXRlLm5vdygpIC0gdGltZSkgLyAxMDAwKSlcbiAgICAgIH1cbiAgICAgIG51bSA9IChudW0gKyAxKSAlIDJlODtcbiAgYCxcbiAgICBNRU1PUllfTEVBSzogYFxuICAgIGNvbnNvbGUubG9nKCdNZW1vcnkgbGVhayBzbmFwIHN0YXJ0LicpXG4gICAgY29uc3QgZ2V0U3RyID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygyKVxuICAgIGNvbnN0IGdldExvbmdTdHIgPSAoc3RyKSA9PiBuZXcgQXJyYXkoMTAwMDAwMCkuam9pbihzdHIpXG4gICAgd2FsbGV0LmxlYWt5Qm9pID0ge31cbiAgICBsZXQgc3RyXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN0ciA9IGdldFN0cigpXG4gICAgICB3YWxsZXQubGVha3lCb2lbc3RyXSA9IE9iamVjdC5hc3NpZ24oe30sIHdhbGxldC5sZWFreUJvaSwgeyBbc3RyXTogZ2V0TG9uZ1N0cihzdHIpIH0pXG4gICAgfVxuICBgLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlubGluZVNuYXBzLmpzLm1hcCIsImxldCB7IHVybEFscGhhYmV0IH0gPSByZXF1aXJlKCcuL3VybC1hbHBoYWJldC9pbmRleC5janMnKVxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnICYmXG4gICAgdHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1JlYWN0IE5hdGl2ZSBkb2VzIG5vdCBoYXZlIGEgYnVpbHQtaW4gc2VjdXJlIHJhbmRvbSBnZW5lcmF0b3IuICcgK1xuICAgICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcyB1c2UgYG5hbm9pZC9ub24tc2VjdXJlYC4gJyArXG4gICAgICAgICdGb3Igc2VjdXJlIElEcywgaW1wb3J0IGByZWFjdC1uYXRpdmUtZ2V0LXJhbmRvbS12YWx1ZXNgICcgK1xuICAgICAgICAnYmVmb3JlIE5hbm8gSUQuJ1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbXBvcnQgZmlsZSB3aXRoIGBpZiAoIXdpbmRvdy5jcnlwdG8pIHdpbmRvdy5jcnlwdG8gPSB3aW5kb3cubXNDcnlwdG9gJyArXG4gICAgICAgICcgYmVmb3JlIGltcG9ydGluZyBOYW5vIElEIHRvIGZpeCBJRSAxMSBzdXBwb3J0J1xuICAgIClcbiAgfVxuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91ciBicm93c2VyIGRvZXMgbm90IGhhdmUgc2VjdXJlIHJhbmRvbSBnZW5lcmF0b3IuICcgK1xuICAgICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgbmFub2lkL25vbi1zZWN1cmUuJ1xuICAgIClcbiAgfVxufVxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgc2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIGxldCBtYXNrID0gKDIgPDwgKE1hdGgubG9nKGFscGhhYmV0Lmxlbmd0aCAtIDEpIC8gTWF0aC5MTjIpKSAtIDFcbiAgbGV0IHN0ZXAgPSAtfigoMS42ICogbWFzayAqIHNpemUpIC8gYWxwaGFiZXQubGVuZ3RoKVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgbGV0IGogPSBzdGVwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIHNpemUpID0+IGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGJ5dGVzID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSlcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIGxldCBieXRlID0gYnl0ZXNbc2l6ZV0gJiA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjMpIHtcbiAgICAgIGlkICs9ICdfJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkXG59XG5tb2R1bGUuZXhwb3J0cyA9IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCwgY3VzdG9tUmFuZG9tLCB1cmxBbHBoYWJldCwgcmFuZG9tIH1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNTdHJlYW1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbXBvc2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01lcmdlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU05BUF9TVFJFQU1fTkFNRVMgPSB2b2lkIDA7XG52YXIgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU05BUF9TVFJFQU1fTkFNRVNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuU1RSRUFNX05BTUVTOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUgPSBleHBvcnRzLmNyZWF0ZUVuZ2luZVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IGNyZWF0ZUVuZ2luZVN0cmVhbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NyZWF0ZUVuZ2luZVN0cmVhbVwiKSk7XG5leHBvcnRzLmNyZWF0ZUVuZ2luZVN0cmVhbSA9IGNyZWF0ZUVuZ2luZVN0cmVhbV8xLmRlZmF1bHQ7XG5jb25zdCBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3JlYXRlU3RyZWFtTWlkZGxld2FyZVwiKSk7XG5leHBvcnRzLmNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUgPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgT2JqZWN0TXVsdGlwbGV4XzEgPSByZXF1aXJlKFwiLi9PYmplY3RNdWx0aXBsZXhcIik7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdE11bHRpcGxleF8xLk9iamVjdE11bHRpcGxleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JrZXJQYXJlbnRQb3N0TWVzc2FnZVN0cmVhbSA9IGV4cG9ydHMuV29ya2VyUG9zdE1lc3NhZ2VTdHJlYW0gPSBleHBvcnRzLldpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtID0gdm9pZCAwO1xudmFyIFdpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9XaW5kb3dQb3N0TWVzc2FnZVN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXaW5kb3dQb3N0TWVzc2FnZVN0cmVhbV8xLldpbmRvd1Bvc3RNZXNzYWdlU3RyZWFtOyB9IH0pO1xudmFyIFdvcmtlclBvc3RNZXNzYWdlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9Xb3JrZXJQb3N0TWVzc2FnZVN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlclBvc3RNZXNzYWdlU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXb3JrZXJQb3N0TWVzc2FnZVN0cmVhbV8xLldvcmtlclBvc3RNZXNzYWdlU3RyZWFtOyB9IH0pO1xudmFyIFdvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9Xb3JrZXJQYXJlbnRQb3N0TWVzc2FnZVN0cmVhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBXb3JrZXJQYXJlbnRQb3N0TWVzc2FnZVN0cmVhbV8xLldvcmtlclBhcmVudFBvc3RNZXNzYWdlU3RyZWFtOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IgPSBleHBvcnRzLkR1cGxpY2F0ZUNhdmVhdEVycm9yID0gZXhwb3J0cy5Gb3JiaWRkZW5DYXZlYXRFcnJvciA9IGV4cG9ydHMuSW52YWxpZENhdmVhdEZpZWxkc0Vycm9yID0gZXhwb3J0cy5DYXZlYXRJbnZhbGlkSnNvbkVycm9yID0gZXhwb3J0cy5DYXZlYXRNaXNzaW5nVmFsdWVFcnJvciA9IGV4cG9ydHMuSW52YWxpZENhdmVhdFR5cGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZENhdmVhdEVycm9yID0gZXhwb3J0cy5DYXZlYXRBbHJlYWR5RXhpc3RzRXJyb3IgPSBleHBvcnRzLkNhdmVhdERvZXNOb3RFeGlzdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3IgPSBleHBvcnRzLlVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvciA9IGV4cG9ydHMuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3IgPSBleHBvcnRzLlVucmVjb2duaXplZFN1YmplY3RFcnJvciA9IGV4cG9ydHMuSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3IgPSBleHBvcnRzLmludGVybmFsRXJyb3IgPSBleHBvcnRzLnVzZXJSZWplY3RlZFJlcXVlc3QgPSBleHBvcnRzLmludmFsaWRQYXJhbXMgPSBleHBvcnRzLm1ldGhvZE5vdEZvdW5kID0gZXhwb3J0cy51bmF1dGhvcml6ZWQgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuZnVuY3Rpb24gdW5hdXRob3JpemVkKG9wdHMpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgbWVzc2FnZTogJ1VuYXV0aG9yaXplZCB0byBwZXJmb3JtIGFjdGlvbi4gVHJ5IHJlcXVlc3RpbmcgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb24ocykgZmlyc3QuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ycGMtYXBpLmh0bWwjcGVybWlzc2lvbnMnLFxuICAgICAgICBkYXRhOiBvcHRzLmRhdGEsXG4gICAgfSk7XG59XG5leHBvcnRzLnVuYXV0aG9yaXplZCA9IHVuYXV0aG9yaXplZDtcbmZ1bmN0aW9uIG1ldGhvZE5vdEZvdW5kKG9wdHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBtZXRob2QgXCIke29wdHMubWV0aG9kfVwiIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoeyBkYXRhOiBvcHRzLmRhdGEsIG1lc3NhZ2UgfSk7XG59XG5leHBvcnRzLm1ldGhvZE5vdEZvdW5kID0gbWV0aG9kTm90Rm91bmQ7XG5mdW5jdGlvbiBpbnZhbGlkUGFyYW1zKG9wdHMpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoe1xuICAgICAgICBkYXRhOiBvcHRzLmRhdGEsXG4gICAgICAgIG1lc3NhZ2U6IG9wdHMubWVzc2FnZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaW52YWxpZFBhcmFtcyA9IGludmFsaWRQYXJhbXM7XG5mdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCh7IGRhdGEgfSk7XG59XG5leHBvcnRzLnVzZXJSZWplY3RlZFJlcXVlc3QgPSB1c2VyUmVqZWN0ZWRSZXF1ZXN0O1xuZnVuY3Rpb24gaW50ZXJuYWxFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2UsIGRhdGEgfSk7XG59XG5leHBvcnRzLmludGVybmFsRXJyb3IgPSBpbnRlcm5hbEVycm9yO1xuY2xhc3MgSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luKSB7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIHN1YmplY3QgaWRlbnRpZmllcjogXCIke3R5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnID8gb3JpZ2luIDogdHlwZW9mIG9yaWdpbn1cImApO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFN1YmplY3RJZGVudGlmaWVyRXJyb3IgPSBJbnZhbGlkU3ViamVjdElkZW50aWZpZXJFcnJvcjtcbmNsYXNzIFVucmVjb2duaXplZFN1YmplY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4pIHtcbiAgICAgICAgc3VwZXIoYFVucmVjb2duaXplZCBzdWJqZWN0OiBcIiR7b3JpZ2lufVwiIGhhcyBubyBwZXJtaXNzaW9ucy5gKTtcbiAgICB9XG59XG5leHBvcnRzLlVucmVjb2duaXplZFN1YmplY3RFcnJvciA9IFVucmVjb2duaXplZFN1YmplY3RFcnJvcjtcbmNsYXNzIEludmFsaWRBcHByb3ZlZFBlcm1pc3Npb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIGFwcHJvdmVkIHBlcm1pc3Npb24gZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGFuZCB0YXJnZXQgXCIke3RhcmdldH1cIi5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBvcmlnaW4sIHRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uIH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3IgPSBJbnZhbGlkQXBwcm92ZWRQZXJtaXNzaW9uRXJyb3I7XG5jbGFzcyBQZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoYFN1YmplY3QgXCIke29yaWdpbn1cIiBoYXMgbm8gcGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvciA9IFBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcjtcbmNsYXNzIFVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgVW5yZWNvZ25pemVkIGNhdmVhdCB0eXBlOiBcIiR7Y2F2ZWF0VHlwZX1cImApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUgfTtcbiAgICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yID0gVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yO1xuY2xhc3MgSW52YWxpZENhdmVhdHNQcm9wZXJ0eUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRzUHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoYFRoZSBcImNhdmVhdHNcIiBwcm9wZXJ0eSBvZiBwZXJtaXNzaW9uIGZvciBcIiR7dGFyZ2V0fVwiIG9mIHN1YmplY3QgXCIke29yaWdpbn1cIiBpcyBpbnZhbGlkLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5IGlmIHNwZWNpZmllZC5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBvcmlnaW4sIHRhcmdldCwgY2F2ZWF0c1Byb3BlcnR5IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3IgPSBJbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3I7XG5jbGFzcyBDYXZlYXREb2VzTm90RXhpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIiBvZiBzdWJqZWN0IFwiJHtvcmlnaW59XCIgaGFzIG5vIGNhdmVhdCBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3IgPSBDYXZlYXREb2VzTm90RXhpc3RFcnJvcjtcbmNsYXNzIENhdmVhdEFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIiBvZiBzdWJqZWN0IFwiJHtvcmlnaW59XCIgYWxyZWFkeSBoYXMgYSBjYXZlYXQgb2YgdHlwZSBcIiR7Y2F2ZWF0VHlwZX1cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvciA9IENhdmVhdEFscmVhZHlFeGlzdHNFcnJvcjtcbmNsYXNzIEludmFsaWRDYXZlYXRFcnJvciBleHRlbmRzIGV0aF9ycGNfZXJyb3JzXzEuRXRoZXJldW1ScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZWRDYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGV0aF9ycGNfZXJyb3JzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYEludmFsaWQgY2F2ZWF0LiBDYXZlYXRzIG11c3QgYmUgcGxhaW4gb2JqZWN0cy5gLCB7IHJlY2VpdmVkQ2F2ZWF0IH0pO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IG9yaWdpbiwgdGFyZ2V0IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RXJyb3IgPSBJbnZhbGlkQ2F2ZWF0RXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0VHlwZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoYENhdmVhdCB0eXBlcyBtdXN0IGJlIHN0cmluZ3MuIFJlY2VpdmVkOiBcIiR7dHlwZW9mIGNhdmVhdC50eXBlfVwiYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENhdmVhdFR5cGVFcnJvciA9IEludmFsaWRDYXZlYXRUeXBlRXJyb3I7XG5jbGFzcyBDYXZlYXRNaXNzaW5nVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBDYXZlYXQgaXMgbWlzc2luZyBcInZhbHVlXCIgZmllbGQuYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0TWlzc2luZ1ZhbHVlRXJyb3IgPSBDYXZlYXRNaXNzaW5nVmFsdWVFcnJvcjtcbmNsYXNzIENhdmVhdEludmFsaWRKc29uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IFwidmFsdWVcIiBpcyBpbnZhbGlkIEpTT04uYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0SW52YWxpZEpzb25FcnJvciA9IENhdmVhdEludmFsaWRKc29uRXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IGhhcyB1bmV4cGVjdGVkIG51bWJlciBvZiBmaWVsZHM6IFwiJHtPYmplY3Qua2V5cyhjYXZlYXQpLmxlbmd0aH1cImApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQgfTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDYXZlYXRGaWVsZHNFcnJvciA9IEludmFsaWRDYXZlYXRGaWVsZHNFcnJvcjtcbmNsYXNzIEZvcmJpZGRlbkNhdmVhdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0TmFtZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbnMgZm9yIHRhcmdldCBcIiR7dGFyZ2V0TmFtZX1cIiBtYXkgbm90IGhhdmUgY2F2ZWF0cyBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0OiB0YXJnZXROYW1lIH07XG4gICAgfVxufVxuZXhwb3J0cy5Gb3JiaWRkZW5DYXZlYXRFcnJvciA9IEZvcmJpZGRlbkNhdmVhdEVycm9yO1xuY2xhc3MgRHVwbGljYXRlQ2F2ZWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBQZXJtaXNzaW9ucyBmb3IgdGFyZ2V0IFwiJHt0YXJnZXROYW1lfVwiIGNvbnRhaW5zIG11bHRpcGxlIGNhdmVhdHMgb2YgdHlwZSBcIiR7Y2F2ZWF0VHlwZX1cIi5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldDogdGFyZ2V0TmFtZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRHVwbGljYXRlQ2F2ZWF0RXJyb3IgPSBEdXBsaWNhdGVDYXZlYXRFcnJvcjtcbmNsYXNzIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaWQpIHtcbiAgICAgICAgc3VwZXIoYFBlcm1pc3Npb25zIHJlcXVlc3Qgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFBlcm1pc3Npb25zSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5leHBvcnRzLmdldFBlcm1pc3Npb25zSGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogW3V0aWxzXzEuTWV0aG9kTmFtZXMuZ2V0UGVybWlzc2lvbnNdLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRQZXJtaXNzaW9uc0ltcGxlbWVudGF0aW9uLFxuICAgIGhvb2tOYW1lczoge1xuICAgICAgICBnZXRQZXJtaXNzaW9uc0Zvck9yaWdpbjogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zSW1wbGVtZW50YXRpb24oX3JlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IGdldFBlcm1pc3Npb25zRm9yT3JpZ2luIH0pIHtcbiAgICByZXMucmVzdWx0ID0gT2JqZWN0LnZhbHVlcyhnZXRQZXJtaXNzaW9uc0Zvck9yaWdpbigpIHx8IHt9KTtcbiAgICByZXR1cm4gZW5kKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQZXJtaXNzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmV4cG9ydHMucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogW3V0aWxzXzEuTWV0aG9kTmFtZXMucmVxdWVzdFBlcm1pc3Npb25zXSxcbiAgICBpbXBsZW1lbnRhdGlvbjogcmVxdWVzdFBlcm1pc3Npb25zSW1wbGVtZW50YXRpb24sXG4gICAgaG9va05hbWVzOiB7XG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbjogdHJ1ZSxcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RQZXJtaXNzaW9uc0ltcGxlbWVudGF0aW9uKHJlcSwgcmVzLCBfbmV4dCwgZW5kLCB7IHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbiB9KSB7XG4gICAgY29uc3QgeyBpZCwgcGFyYW1zIH0gPSByZXE7XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdudW1iZXInICYmIHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmICFpZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuZChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgcmVxdWVzdDogTXVzdCBzcGVjaWZ5IGEgdmFsaWQgaWQuJyxcbiAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdDogcmVxIH0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykgfHwgIXV0aWxzXzIuaXNQbGFpbk9iamVjdChwYXJhbXNbMF0pKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyb3JzXzEuaW52YWxpZFBhcmFtcyh7IGRhdGE6IHsgcmVxdWVzdDogcmVxIH0gfSkpO1xuICAgIH1cbiAgICBjb25zdCBbcmVxdWVzdGVkUGVybWlzc2lvbnNdID0gcGFyYW1zO1xuICAgIGNvbnN0IFtncmFudGVkUGVybWlzc2lvbnNdID0gYXdhaXQgcmVxdWVzdFBlcm1pc3Npb25zRm9yT3JpZ2luKHJlcXVlc3RlZFBlcm1pc3Npb25zLCBTdHJpbmcoaWQpKTtcbiAgICAvLyBgd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9uYCBpcyBzcGVjaWZpZWQgdG8gcmV0dXJuIGFuIGFycmF5LlxuICAgIHJlcy5yZXN1bHQgPSBPYmplY3QudmFsdWVzKGdyYW50ZWRQZXJtaXNzaW9ucyk7XG4gICAgcmV0dXJuIGVuZCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdFBlcm1pc3Npb25zLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVlcEZyZWV6ZSAobykge1xuICBPYmplY3QuZnJlZXplKG8pO1xuXG4gIHZhciBvSXNGdW5jdGlvbiA9IHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCI7XG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKGhhc093blByb3AuY2FsbChvLCBwcm9wKVxuICAgICYmIChvSXNGdW5jdGlvbiA/IHByb3AgIT09ICdjYWxsZXInICYmIHByb3AgIT09ICdjYWxsZWUnICYmIHByb3AgIT09ICdhcmd1bWVudHMnIDogdHJ1ZSApXG4gICAgJiYgb1twcm9wXSAhPT0gbnVsbFxuICAgICYmICh0eXBlb2Ygb1twcm9wXSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICYmICFPYmplY3QuaXNGcm96ZW4ob1twcm9wXSkpIHtcbiAgICAgIGRlZXBGcmVlemUob1twcm9wXSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBvO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQZXJtaXNzaW9uTWlkZGxld2FyZUZhY3RvcnkgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIHBlcm1pc3Npb24gbWlkZGxld2FyZSBmdW5jdGlvbiBmYWN0b3J5LiBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gKiBpbiB0aGUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyfS4gTGlrZSBhbnkge0BsaW5rIEpzb25ScGNFbmdpbmV9XG4gKiBtaWRkbGV3YXJlLCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBvbmx5IHJlY2VpdmUgcmVxdWVzdHMgZnJvbSBhIHBhcnRpY3VsYXJcbiAqIHN1YmplY3QgLyBvcmlnaW4uIEhvd2V2ZXIsIGVhY2ggbWlkZGxld2FyZSBhbHNvIHJlcXVpcmVzIGFjY2VzcyB0byBzb21lXG4gKiBgUGVybWlzc2lvbkNvbnRyb2xsZXJgIGludGVybmFscywgd2hpY2ggaXMgd2h5IHRoaXMgXCJmYWN0b3J5IGZhY3RvcnlcIiBleGlzdHMuXG4gKlxuICogVGhlIG1pZGRsZXdhcmVzIHJldHVybmVkIGJ5IHRoZSBmYWN0b3J5IHdpbGwgcGFzcyB0aHJvdWdoIHJlcXVlc3RzIGZvclxuICogdW5yZXN0cmljdGVkIG1ldGhvZHMsIGFuZCBhdHRlbXB0IHRvIGV4ZWN1dGUgcmVzdHJpY3RlZCBtZXRob2RzLiBJZiBhIG1ldGhvZFxuICogaXMgbmVpdGhlciByZXN0cmljdGVkIG5vciB1bnJlc3RyaWN0ZWQsIGEgXCJtZXRob2Qgbm90IGZvdW5kXCIgZXJyb3Igd2lsbCBiZVxuICogcmV0dXJuZWQuXG4gKiBJZiBhIG1ldGhvZCBpcyByZXN0cmljdGVkLCB0aGUgbWlkZGxld2FyZSB3aWxsIGZpcnN0IGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlXG4gKiBzdWJqZWN0J3MgcGVybWlzc2lvbiBmb3IgdGhhdCBtZXRob2QuIElmIHRoZSBwZXJtaXNzaW9uIGlzIGZvdW5kLCB0aGUgbWV0aG9kXG4gKiB3aWxsIGJlIGV4ZWN1dGVkLiBPdGhlcndpc2UsIGFuIFwidW5hdXRob3JpemVkXCIgZXJyb3Igd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMuZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QgLSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuX2V4ZWN1dGVSZXN0cmljdGVkTWV0aG9kfS5cbiAqIEBwYXJhbSBvcHRpb25zLmdldFJlc3RyaWN0ZWRNZXRob2QgLSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZ2V0UmVzdHJpY3RlZE1ldGhvZH0uXG4gKiBAcGFyYW0gb3B0aW9ucy5pc1VucmVzdHJpY3RlZE1ldGhvZCAtIEEgZnVuY3Rpb24gdGhhdCBjaGVja3Mgd2hldGhlciBhXG4gKiBwYXJ0aWN1bGFyIG1ldGhvZCBpcyB1bnJlc3RyaWN0ZWQuXG4gKiBAcmV0dXJucyBBIHBlcm1pc3Npb24gbWlkZGxld2FyZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uTWlkZGxld2FyZUZhY3RvcnkoeyBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZCwgZ2V0UmVzdHJpY3RlZE1ldGhvZCwgaXNVbnJlc3RyaWN0ZWRNZXRob2QsIH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUGVybWlzc2lvbk1pZGRsZXdhcmUoc3ViamVjdCkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gc3ViamVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnIHx8ICFvcmlnaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YmplY3QgXCJvcmlnaW5cIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJtaXNzaW9uc01pZGRsZXdhcmUgPSBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IHJlcTtcbiAgICAgICAgICAgIC8vIFNraXAgcmVnaXN0ZXJlZCB1bnJlc3RyaWN0ZWQgbWV0aG9kcy5cbiAgICAgICAgICAgIGlmIChpc1VucmVzdHJpY3RlZE1ldGhvZChtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBubyByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBpcyBmb3VuZC5cbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEltcGxlbWVudGF0aW9uID0gZ2V0UmVzdHJpY3RlZE1ldGhvZChtZXRob2QsIG9yaWdpbik7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlIHBlcm1pc3Npb24gZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZChtZXRob2RJbXBsZW1lbnRhdGlvbiwgc3ViamVjdCwgbWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzLmVycm9yID0gZXJyb3JzXzEuaW50ZXJuYWxFcnJvcihgUmVxdWVzdCBmb3IgbWV0aG9kIFwiJHtyZXEubWV0aG9kfVwiIHJldHVybmVkIHVuZGVmaW5lZCByZXN1bHQuYCwgeyByZXF1ZXN0OiByZXEgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHBlcm1pc3Npb25zTWlkZGxld2FyZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5ID0gZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVybWlzc2lvbi1taWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgQ29tcG9zZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW4gfHwge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2NoaWxkcmVuKS5mb3JFYWNoKChjaGlsZEtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltjaGlsZEtleV07XG4gICAgICAgICAgICB0aGlzLl9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVGcm9tQ2hpbGQgPSAoY2hpbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzdGF0ZVtjaGlsZEtleV0gPSBjaGlsZFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSh1cGRhdGVGcm9tQ2hpbGQpO1xuICAgICAgICB1cGRhdGVGcm9tQ2hpbGQoY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gQ29tcG9zZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gdm9pZCAwO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIik7XG5jbGFzcyBNZXJnZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICAvLyBUeXBlY2FzdDogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2FkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCkpO1xuICAgIH1cbiAgICBfdXBkYXRlV2hvbGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZXMgPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gYXBwbHkgc2hhbGxvdyBtZXJnZSBvdmVyIHN0YXRlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmNoaWxkU3RhdGVzKTtcbiAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IE1lcmdlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaW5pdFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGluaXRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0L2RlZmF1bHQgc3RhdGU6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIGdldFN0YXRlXG4gICAgZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBwdXRTdGF0ZVxuICAgIHB1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkge1xuICAgICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgcGFydGlhbFN0YXRlKSk7XG4gICAgICAgICAgICAvLyBpZiBub3Qgb2JqZWN0LCB1c2UgbmV3IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLm9uKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gcHJpdmF0ZVxuICAgIC8vXG4gICAgLy8gcmVhZCBmcm9tIHBlcnNpc3RlbmNlXG4gICAgX2dldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRvIHBlcnNpc3RlbmNlXG4gICAgX3B1dFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxufVxuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSBPYnNlcnZhYmxlU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgdGhyb3VnaDJfMSA9IHJlcXVpcmUoXCJ0aHJvdWdoMlwiKTtcbmZ1bmN0aW9uIHN0b3JlVHJhbnNmb3JtU3RyZWFtKHN5bmNUcmFuc2Zvcm1Gbikge1xuICAgIHJldHVybiB0aHJvdWdoMl8xLm9iaigoc3RhdGUsIF9lbmNvZGluZywgY2IpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc3luY1RyYW5zZm9ybUZuKHN0YXRlKTtcbiAgICAgICAgICAgIGNiKG51bGwsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSBzdG9yZVRyYW5zZm9ybVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmNVclJlZ2lzdHJ5ID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnknKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG5cbmNvbnN0IHtcbiAgUmVnaXN0cnlUeXBlXG59ID0gYmNVclJlZ2lzdHJ5LmV4dGVuZDtcbmNvbnN0IEV4dGVuZGVkUmVnaXN0cnlUeXBlcyA9IHtcbiAgRVRIX1NJR05fUkVRVUVTVDogLyojX19QVVJFX18qL25ldyBSZWdpc3RyeVR5cGUoJ2V0aC1zaWduLXJlcXVlc3QnLCA0MDEpLFxuICBFVEhfU0lHTkFUQVVSRTogLyojX19QVVJFX18qL25ldyBSZWdpc3RyeVR5cGUoJ2V0aC1zaWduYXR1cmUnLCA0MDIpXG59O1xuXG5jb25zdCB7XG4gIGRlY29kZVRvRGF0YUl0ZW0sXG4gIFJlZ2lzdHJ5VHlwZXNcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xudmFyIEtleXM7XG5cbihmdW5jdGlvbiAoS2V5cykge1xuICBLZXlzW0tleXNbXCJyZXF1ZXN0SWRcIl0gPSAxXSA9IFwicmVxdWVzdElkXCI7XG4gIEtleXNbS2V5c1tcInNpZ25EYXRhXCJdID0gMl0gPSBcInNpZ25EYXRhXCI7XG4gIEtleXNbS2V5c1tcImRhdGFUeXBlXCJdID0gM10gPSBcImRhdGFUeXBlXCI7XG4gIEtleXNbS2V5c1tcImNoYWluSWRcIl0gPSA0XSA9IFwiY2hhaW5JZFwiO1xuICBLZXlzW0tleXNbXCJkZXJpdmF0aW9uUGF0aFwiXSA9IDVdID0gXCJkZXJpdmF0aW9uUGF0aFwiO1xuICBLZXlzW0tleXNbXCJhZGRyZXNzXCJdID0gNl0gPSBcImFkZHJlc3NcIjtcbiAgS2V5c1tLZXlzW1wib3JpZ2luXCJdID0gN10gPSBcIm9yaWdpblwiO1xufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XG5cbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ0cmFuc2FjdGlvblwiXSA9IDFdID0gXCJ0cmFuc2FjdGlvblwiO1xuICBEYXRhVHlwZVtEYXRhVHlwZVtcInR5cGVkRGF0YVwiXSA9IDJdID0gXCJ0eXBlZERhdGFcIjtcbiAgRGF0YVR5cGVbRGF0YVR5cGVbXCJwZXJzb25hbE1lc3NhZ2VcIl0gPSAzXSA9IFwicGVyc29uYWxNZXNzYWdlXCI7XG4gIERhdGFUeXBlW0RhdGFUeXBlW1widHlwZWRUcmFuc2FjdGlvblwiXSA9IDRdID0gXCJ0eXBlZFRyYW5zYWN0aW9uXCI7XG59KShleHBvcnRzLkRhdGFUeXBlIHx8IChleHBvcnRzLkRhdGFUeXBlID0ge30pKTtcblxuY2xhc3MgRXRoU2lnblJlcXVlc3QgZXh0ZW5kcyBiY1VyUmVnaXN0cnkuUmVnaXN0cnlJdGVtIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfU0lHTl9SRVFVRVNUO1xuXG4gICAgdGhpcy5zZXR1cERhdGEgPSBhcmdzID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdElkID0gYXJncy5yZXF1ZXN0SWQ7XG4gICAgICB0aGlzLnNpZ25EYXRhID0gYXJncy5zaWduRGF0YTtcbiAgICAgIHRoaXMuZGF0YVR5cGUgPSBhcmdzLmRhdGFUeXBlO1xuICAgICAgdGhpcy5jaGFpbklkID0gYXJncy5jaGFpbklkO1xuICAgICAgdGhpcy5kZXJpdmF0aW9uUGF0aCA9IGFyZ3MuZGVyaXZhdGlvblBhdGg7XG4gICAgICB0aGlzLmFkZHJlc3MgPSBhcmdzLmFkZHJlc3M7XG4gICAgICB0aGlzLm9yaWdpbiA9IGFyZ3Mub3JpZ2luO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFJlcXVlc3RJZCA9ICgpID0+IHRoaXMucmVxdWVzdElkO1xuXG4gICAgdGhpcy5nZXRTaWduRGF0YSA9ICgpID0+IHRoaXMuc2lnbkRhdGE7XG5cbiAgICB0aGlzLmdldERhdGFUeXBlID0gKCkgPT4gdGhpcy5kYXRhVHlwZTtcblxuICAgIHRoaXMuZ2V0Q2hhaW5JZCA9ICgpID0+IHRoaXMuY2hhaW5JZDtcblxuICAgIHRoaXMuZ2V0RGVyaXZhdGlvblBhdGggPSAoKSA9PiB0aGlzLmRlcml2YXRpb25QYXRoLmdldFBhdGgoKTtcblxuICAgIHRoaXMuZ2V0U2lnblJlcXVlc3RBZGRyZXNzID0gKCkgPT4gdGhpcy5hZGRyZXNzO1xuXG4gICAgdGhpcy5nZXRPcmlnaW4gPSAoKSA9PiB0aGlzLm9yaWdpbjtcblxuICAgIHRoaXMudG9EYXRhSXRlbSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0SWQpIHtcbiAgICAgICAgbWFwW0tleXMucmVxdWVzdElkXSA9IG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsIFJlZ2lzdHJ5VHlwZXMuVVVJRC5nZXRUYWcoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFkZHJlc3MpIHtcbiAgICAgICAgbWFwW0tleXMuYWRkcmVzc10gPSB0aGlzLmFkZHJlc3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoYWluSWQpIHtcbiAgICAgICAgbWFwW0tleXMuY2hhaW5JZF0gPSB0aGlzLmNoYWluSWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICBtYXBbS2V5cy5vcmlnaW5dID0gdGhpcy5vcmlnaW47XG4gICAgICB9XG5cbiAgICAgIG1hcFtLZXlzLnNpZ25EYXRhXSA9IHRoaXMuc2lnbkRhdGE7XG4gICAgICBtYXBbS2V5cy5kYXRhVHlwZV0gPSB0aGlzLmRhdGFUeXBlO1xuICAgICAgY29uc3Qga2V5UGF0aCA9IHRoaXMuZGVyaXZhdGlvblBhdGgudG9EYXRhSXRlbSgpO1xuICAgICAga2V5UGF0aC5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSk7XG4gICAgICBtYXBbS2V5cy5kZXJpdmF0aW9uUGF0aF0gPSBrZXlQYXRoO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXR1cERhdGEoYXJncyk7XG4gIH1cblxuICBzdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdChzaWduRGF0YSwgc2lnbkRhdGFUeXBlLCBoZFBhdGgsIHhmcCwgdXVpZFN0cmluZywgY2hhaW5JZCwgYWRkcmVzcywgb3JpZ2luKSB7XG4gICAgY29uc3QgcGF0aHMgPSBoZFBhdGgucmVwbGFjZSgvW218TV1cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgICBjb25zdCBoZHBhdGhPYmplY3QgPSBuZXcgYmNVclJlZ2lzdHJ5LkNyeXB0b0tleXBhdGgocGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChwYXRoLnJlcGxhY2UoXCInXCIsICcnKSk7XG4gICAgICBsZXQgaXNIYXJkZW5lZCA9IGZhbHNlO1xuXG4gICAgICBpZiAocGF0aC5lbmRzV2l0aChcIidcIikpIHtcbiAgICAgICAgaXNIYXJkZW5lZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgYmNVclJlZ2lzdHJ5LlBhdGhDb21wb25lbnQoe1xuICAgICAgICBpbmRleCxcbiAgICAgICAgaGFyZGVuZWQ6IGlzSGFyZGVuZWRcbiAgICAgIH0pO1xuICAgIH0pLCBCdWZmZXIuZnJvbSh4ZnAsICdoZXgnKSk7XG4gICAgcmV0dXJuIG5ldyBFdGhTaWduUmVxdWVzdCh7XG4gICAgICByZXF1ZXN0SWQ6IHV1aWRTdHJpbmcgPyBCdWZmZXIuZnJvbSh1dWlkLnBhcnNlKHV1aWRTdHJpbmcpKSA6IHVuZGVmaW5lZCxcbiAgICAgIHNpZ25EYXRhLFxuICAgICAgZGF0YVR5cGU6IHNpZ25EYXRhVHlwZSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBoZHBhdGhPYmplY3QsXG4gICAgICBjaGFpbklkLFxuICAgICAgYWRkcmVzczogYWRkcmVzcyA/IEJ1ZmZlci5mcm9tKGFkZHJlc3MucmVwbGFjZSgnMHgnLCAnJyksICdoZXgnKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9yaWdpbjogb3JpZ2luIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG5cbn1cblxuRXRoU2lnblJlcXVlc3QuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25EYXRhID0gbWFwW0tleXMuc2lnbkRhdGFdO1xuICBjb25zdCBkYXRhVHlwZSA9IG1hcFtLZXlzLmRhdGFUeXBlXTtcbiAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBiY1VyUmVnaXN0cnkuQ3J5cHRvS2V5cGF0aC5mcm9tRGF0YUl0ZW0obWFwW0tleXMuZGVyaXZhdGlvblBhdGhdKTtcbiAgY29uc3QgY2hhaW5JZCA9IG1hcFtLZXlzLmNoYWluSWRdID8gbWFwW0tleXMuY2hhaW5JZF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGFkZHJlc3MgPSBtYXBbS2V5cy5hZGRyZXNzXSA/IG1hcFtLZXlzLmFkZHJlc3NdIDogdW5kZWZpbmVkO1xuICBjb25zdCByZXF1ZXN0SWQgPSBtYXBbS2V5cy5yZXF1ZXN0SWRdID8gbWFwW0tleXMucmVxdWVzdElkXS5nZXREYXRhKCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWdpbiA9IG1hcFtLZXlzLm9yaWdpbl0gPyBtYXBbS2V5cy5vcmlnaW5dIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IEV0aFNpZ25SZXF1ZXN0KHtcbiAgICByZXF1ZXN0SWQsXG4gICAgc2lnbkRhdGEsXG4gICAgZGF0YVR5cGUsXG4gICAgY2hhaW5JZCxcbiAgICBkZXJpdmF0aW9uUGF0aCxcbiAgICBhZGRyZXNzLFxuICAgIG9yaWdpblxuICB9KTtcbn07XG5cbkV0aFNpZ25SZXF1ZXN0LmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtKF9jYm9yUGF5bG9hZCk7XG4gIHJldHVybiBFdGhTaWduUmVxdWVzdC5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuY29uc3Qge1xuICBSZWdpc3RyeVR5cGVzOiBSZWdpc3RyeVR5cGVzJDEsXG4gIGRlY29kZVRvRGF0YUl0ZW06IGRlY29kZVRvRGF0YUl0ZW0kMVxufSA9IGJjVXJSZWdpc3RyeS5leHRlbmQ7XG52YXIgS2V5cyQxO1xuXG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgS2V5c1tLZXlzW1wicmVxdWVzdElkXCJdID0gMV0gPSBcInJlcXVlc3RJZFwiO1xuICBLZXlzW0tleXNbXCJzaWduYXR1cmVcIl0gPSAyXSA9IFwic2lnbmF0dXJlXCI7XG59KShLZXlzJDEgfHwgKEtleXMkMSA9IHt9KSk7XG5cbmNsYXNzIEVUSFNpZ25hdHVyZSBleHRlbmRzIGJjVXJSZWdpc3RyeS5SZWdpc3RyeUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHJlcXVlc3RJZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmdldFJlZ2lzdHJ5VHlwZSA9ICgpID0+IEV4dGVuZGVkUmVnaXN0cnlUeXBlcy5FVEhfU0lHTkFUQVVSRTtcblxuICAgIHRoaXMuZ2V0UmVxdWVzdElkID0gKCkgPT4gdGhpcy5yZXF1ZXN0SWQ7XG5cbiAgICB0aGlzLmdldFNpZ25hdHVyZSA9ICgpID0+IHRoaXMuc2lnbmF0dXJlO1xuXG4gICAgdGhpcy50b0RhdGFJdGVtID0gKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0ge307XG5cbiAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCkge1xuICAgICAgICBtYXBbS2V5cyQxLnJlcXVlc3RJZF0gPSBuZXcgYmNVclJlZ2lzdHJ5LkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLCBSZWdpc3RyeVR5cGVzJDEuVVVJRC5nZXRUYWcoKSk7XG4gICAgICB9XG5cbiAgICAgIG1hcFtLZXlzJDEuc2lnbmF0dXJlXSA9IHRoaXMuc2lnbmF0dXJlO1xuICAgICAgcmV0dXJuIG5ldyBiY1VyUmVnaXN0cnkuRGF0YUl0ZW0obWFwKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gIH1cblxufVxuXG5FVEhTaWduYXR1cmUuZnJvbURhdGFJdGVtID0gZGF0YUl0ZW0gPT4ge1xuICBjb25zdCBtYXAgPSBkYXRhSXRlbS5nZXREYXRhKCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IG1hcFtLZXlzJDEuc2lnbmF0dXJlXTtcbiAgY29uc3QgcmVxdWVzdElkID0gbWFwW0tleXMkMS5yZXF1ZXN0SWRdID8gbWFwW0tleXMkMS5yZXF1ZXN0SWRdLmdldERhdGEoKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBFVEhTaWduYXR1cmUoc2lnbmF0dXJlLCByZXF1ZXN0SWQpO1xufTtcblxuRVRIU2lnbmF0dXJlLmZyb21DQk9SID0gX2Nib3JQYXlsb2FkID0+IHtcbiAgY29uc3QgZGF0YUl0ZW0gPSBkZWNvZGVUb0RhdGFJdGVtJDEoX2Nib3JQYXlsb2FkKTtcbiAgcmV0dXJuIEVUSFNpZ25hdHVyZS5mcm9tRGF0YUl0ZW0oZGF0YUl0ZW0pO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgZ2VuZXJhdGVBZGRyZXNzZnJvbVhwdWIgPSAoeHB1YiwgZGVyaXZlUGF0aCkgPT4ge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG5vZGUgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkoeHB1Yik7XG4gIGNvbnN0IHB1YmxpY0tleSA9IG5vZGUuZGVyaXZlKGRlcml2ZVBhdGgpO1xuICBjb25zdCBhZGRyZXNzID0gJzB4JyArIGV0aGVyZXVtanNVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkucHVibGljS2V5LCB0cnVlKS50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbn07XG5jb25zdCBmaW5kSERwYXRmcm9tQWRkcmVzcyA9IChhZGRyZXNzLCB4cHViLCBudW1iZXJMaW1pdCwgcm9vdFBhdGgpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJMaW1pdDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IGBNLzAvJHtpfWA7XG4gICAgY29uc3QgY2FjdWxhdGVBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzZnJvbVhwdWIoeHB1YiwgcGF0aCk7XG5cbiAgICBpZiAoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09IGNhY3VsYXRlQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICByZXR1cm4gYCR7cm9vdFBhdGh9LzAvJHtpfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCB7XG4gIGNib3Jcbn0gPSBiY1VyUmVnaXN0cnkuZXh0ZW5kO1xuY2Jvci5wYXRjaFRhZ3MoT2JqZWN0LnZhbHVlcyhFeHRlbmRlZFJlZ2lzdHJ5VHlwZXMpLmZpbHRlcihydCA9PiAhIXJ0LmdldFRhZygpKS5tYXAocnQgPT4gcnQuZ2V0VGFnKCkpKTtcblxuT2JqZWN0LmtleXMoYmNVclJlZ2lzdHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmNVclJlZ2lzdHJ5W2tdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbmV4cG9ydHMuRVRIU2lnbmF0dXJlID0gRVRIU2lnbmF0dXJlO1xuZXhwb3J0cy5FdGhTaWduUmVxdWVzdCA9IEV0aFNpZ25SZXF1ZXN0O1xuZXhwb3J0cy5maW5kSERwYXRmcm9tQWRkcmVzcyA9IGZpbmRIRHBhdGZyb21BZGRyZXNzO1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3Nmcm9tWHB1YiA9IGdlbmVyYXRlQWRkcmVzc2Zyb21YcHViO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmMtdXItcmVnaXN0cnktZXRoLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB0LGU9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5XCIpLHM9cmVxdWlyZShcInV1aWRcIiksYT0odD1yZXF1aXJlKFwiaGRrZXlcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJkZWZhdWx0XCJpbiB0P3QuZGVmYXVsdDp0LGk9cmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtjb25zdHtSZWdpc3RyeVR5cGU6cn09ZS5leHRlbmQsbj17RVRIX1NJR05fUkVRVUVTVDpuZXcgcihcImV0aC1zaWduLXJlcXVlc3RcIiw0MDEpLEVUSF9TSUdOQVRBVVJFOm5ldyByKFwiZXRoLXNpZ25hdHVyZVwiLDQwMil9LHtkZWNvZGVUb0RhdGFJdGVtOmQsUmVnaXN0cnlUeXBlczpvfT1lLmV4dGVuZDt2YXIgaCx1OyFmdW5jdGlvbih0KXt0W3QucmVxdWVzdElkPTFdPVwicmVxdWVzdElkXCIsdFt0LnNpZ25EYXRhPTJdPVwic2lnbkRhdGFcIix0W3QuZGF0YVR5cGU9M109XCJkYXRhVHlwZVwiLHRbdC5jaGFpbklkPTRdPVwiY2hhaW5JZFwiLHRbdC5kZXJpdmF0aW9uUGF0aD01XT1cImRlcml2YXRpb25QYXRoXCIsdFt0LmFkZHJlc3M9Nl09XCJhZGRyZXNzXCIsdFt0Lm9yaWdpbj03XT1cIm9yaWdpblwifShofHwoaD17fSkpLCh1PWV4cG9ydHMuRGF0YVR5cGV8fChleHBvcnRzLkRhdGFUeXBlPXt9KSlbdS50cmFuc2FjdGlvbj0xXT1cInRyYW5zYWN0aW9uXCIsdVt1LnR5cGVkRGF0YT0yXT1cInR5cGVkRGF0YVwiLHVbdS5wZXJzb25hbE1lc3NhZ2U9M109XCJwZXJzb25hbE1lc3NhZ2VcIix1W3UudHlwZWRUcmFuc2FjdGlvbj00XT1cInR5cGVkVHJhbnNhY3Rpb25cIjtjbGFzcyBnIGV4dGVuZHMgZS5SZWdpc3RyeUl0ZW17Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+bi5FVEhfU0lHTl9SRVFVRVNULHRoaXMuc2V0dXBEYXRhPXQ9Pnt0aGlzLnJlcXVlc3RJZD10LnJlcXVlc3RJZCx0aGlzLnNpZ25EYXRhPXQuc2lnbkRhdGEsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMuY2hhaW5JZD10LmNoYWluSWQsdGhpcy5kZXJpdmF0aW9uUGF0aD10LmRlcml2YXRpb25QYXRoLHRoaXMuYWRkcmVzcz10LmFkZHJlc3MsdGhpcy5vcmlnaW49dC5vcmlnaW59LHRoaXMuZ2V0UmVxdWVzdElkPSgpPT50aGlzLnJlcXVlc3RJZCx0aGlzLmdldFNpZ25EYXRhPSgpPT50aGlzLnNpZ25EYXRhLHRoaXMuZ2V0RGF0YVR5cGU9KCk9PnRoaXMuZGF0YVR5cGUsdGhpcy5nZXRDaGFpbklkPSgpPT50aGlzLmNoYWluSWQsdGhpcy5nZXREZXJpdmF0aW9uUGF0aD0oKT0+dGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRQYXRoKCksdGhpcy5nZXRTaWduUmVxdWVzdEFkZHJlc3M9KCk9PnRoaXMuYWRkcmVzcyx0aGlzLmdldE9yaWdpbj0oKT0+dGhpcy5vcmlnaW4sdGhpcy50b0RhdGFJdGVtPSgpPT57Y29uc3QgdD17fTt0aGlzLnJlcXVlc3RJZCYmKHRbaC5yZXF1ZXN0SWRdPW5ldyBlLkRhdGFJdGVtKHRoaXMucmVxdWVzdElkLG8uVVVJRC5nZXRUYWcoKSkpLHRoaXMuYWRkcmVzcyYmKHRbaC5hZGRyZXNzXT10aGlzLmFkZHJlc3MpLHRoaXMuY2hhaW5JZCYmKHRbaC5jaGFpbklkXT10aGlzLmNoYWluSWQpLHRoaXMub3JpZ2luJiYodFtoLm9yaWdpbl09dGhpcy5vcmlnaW4pLHRbaC5zaWduRGF0YV09dGhpcy5zaWduRGF0YSx0W2guZGF0YVR5cGVdPXRoaXMuZGF0YVR5cGU7Y29uc3Qgcz10aGlzLmRlcml2YXRpb25QYXRoLnRvRGF0YUl0ZW0oKTtyZXR1cm4gcy5zZXRUYWcodGhpcy5kZXJpdmF0aW9uUGF0aC5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUYWcoKSksdFtoLmRlcml2YXRpb25QYXRoXT1zLG5ldyBlLkRhdGFJdGVtKHQpfSx0aGlzLnNldHVwRGF0YSh0KX1zdGF0aWMgY29uc3RydWN0RVRIUmVxdWVzdCh0LGEsaSxyLG4sZCxvLGgpe2NvbnN0IHU9aS5yZXBsYWNlKC9bbXxNXVxcLy8sXCJcIikuc3BsaXQoXCIvXCIpLGM9bmV3IGUuQ3J5cHRvS2V5cGF0aCh1Lm1hcCh0PT57Y29uc3Qgcz1wYXJzZUludCh0LnJlcGxhY2UoXCInXCIsXCJcIikpO2xldCBhPSExO3JldHVybiB0LmVuZHNXaXRoKFwiJ1wiKSYmKGE9ITApLG5ldyBlLlBhdGhDb21wb25lbnQoe2luZGV4OnMsaGFyZGVuZWQ6YX0pfSksQnVmZmVyLmZyb20ocixcImhleFwiKSk7cmV0dXJuIG5ldyBnKHtyZXF1ZXN0SWQ6bj9CdWZmZXIuZnJvbShzLnBhcnNlKG4pKTp2b2lkIDAsc2lnbkRhdGE6dCxkYXRhVHlwZTphLGRlcml2YXRpb25QYXRoOmMsY2hhaW5JZDpkLGFkZHJlc3M6bz9CdWZmZXIuZnJvbShvLnJlcGxhY2UoXCIweFwiLFwiXCIpLFwiaGV4XCIpOnZvaWQgMCxvcmlnaW46aHx8dm9pZCAwfSl9fWcuZnJvbURhdGFJdGVtPXQ9Pntjb25zdCBzPXQuZ2V0RGF0YSgpLGE9c1toLnNpZ25EYXRhXSxpPXNbaC5kYXRhVHlwZV0scj1lLkNyeXB0b0tleXBhdGguZnJvbURhdGFJdGVtKHNbaC5kZXJpdmF0aW9uUGF0aF0pLG49c1toLmNoYWluSWRdP3NbaC5jaGFpbklkXTp2b2lkIDAsZD1zW2guYWRkcmVzc10/c1toLmFkZHJlc3NdOnZvaWQgMCxvPXNbaC5yZXF1ZXN0SWRdP3NbaC5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyBnKHtyZXF1ZXN0SWQ6byxzaWduRGF0YTphLGRhdGFUeXBlOmksY2hhaW5JZDpuLGRlcml2YXRpb25QYXRoOnIsYWRkcmVzczpkLG9yaWdpbjpzW2gub3JpZ2luXT9zW2gub3JpZ2luXTp2b2lkIDB9KX0sZy5mcm9tQ0JPUj10PT57Y29uc3QgZT1kKHQpO3JldHVybiBnLmZyb21EYXRhSXRlbShlKX07Y29uc3R7UmVnaXN0cnlUeXBlczpjLGRlY29kZVRvRGF0YUl0ZW06SX09ZS5leHRlbmQ7dmFyIHA7IWZ1bmN0aW9uKHQpe3RbdC5yZXF1ZXN0SWQ9MV09XCJyZXF1ZXN0SWRcIix0W3Quc2lnbmF0dXJlPTJdPVwic2lnbmF0dXJlXCJ9KHB8fChwPXt9KSk7Y2xhc3MgeSBleHRlbmRzIGUuUmVnaXN0cnlJdGVte2NvbnN0cnVjdG9yKHQscyl7c3VwZXIoKSx0aGlzLmdldFJlZ2lzdHJ5VHlwZT0oKT0+bi5FVEhfU0lHTkFUQVVSRSx0aGlzLmdldFJlcXVlc3RJZD0oKT0+dGhpcy5yZXF1ZXN0SWQsdGhpcy5nZXRTaWduYXR1cmU9KCk9PnRoaXMuc2lnbmF0dXJlLHRoaXMudG9EYXRhSXRlbT0oKT0+e2NvbnN0IHQ9e307cmV0dXJuIHRoaXMucmVxdWVzdElkJiYodFtwLnJlcXVlc3RJZF09bmV3IGUuRGF0YUl0ZW0odGhpcy5yZXF1ZXN0SWQsYy5VVUlELmdldFRhZygpKSksdFtwLnNpZ25hdHVyZV09dGhpcy5zaWduYXR1cmUsbmV3IGUuRGF0YUl0ZW0odCl9LHRoaXMuc2lnbmF0dXJlPXQsdGhpcy5yZXF1ZXN0SWQ9c319eS5mcm9tRGF0YUl0ZW09dD0+e2NvbnN0IGU9dC5nZXREYXRhKCkscz1lW3Auc2lnbmF0dXJlXSxhPWVbcC5yZXF1ZXN0SWRdP2VbcC5yZXF1ZXN0SWRdLmdldERhdGEoKTp2b2lkIDA7cmV0dXJuIG5ldyB5KHMsYSl9LHkuZnJvbUNCT1I9dD0+e2NvbnN0IGU9SSh0KTtyZXR1cm4geS5mcm9tRGF0YUl0ZW0oZSl9O2NvbnN0IFQ9KHQsZSk9Pntjb25zdCBzPWEuZnJvbUV4dGVuZGVkS2V5KHQpLmRlcml2ZShlKSxyPVwiMHhcIitpLnB1YmxpY1RvQWRkcmVzcyhzLnB1YmxpY0tleSwhMCkudG9TdHJpbmcoXCJoZXhcIik7cmV0dXJuIGkudG9DaGVja3N1bUFkZHJlc3Mocil9LHtjYm9yOkR9PWUuZXh0ZW5kO0QucGF0Y2hUYWdzKE9iamVjdC52YWx1ZXMobikuZmlsdGVyKHQ9PiEhdC5nZXRUYWcoKSkubWFwKHQ9PnQuZ2V0VGFnKCkpKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtcImRlZmF1bHRcIiE9PXQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLHQse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbdF19fSl9KSksZXhwb3J0cy5FVEhTaWduYXR1cmU9eSxleHBvcnRzLkV0aFNpZ25SZXF1ZXN0PWcsZXhwb3J0cy5maW5kSERwYXRmcm9tQWRkcmVzcz0odCxlLHMsYSk9Pntmb3IobGV0IGk9MDtpPHM7aSsrKXtjb25zdCBzPVQoZSxcIk0vMC9cIitpKTtpZih0LnRvTG93ZXJDYXNlKCk9PXMudG9Mb3dlckNhc2UoKSlyZXR1cm5gJHthfS8wLyR7aX1gfXJldHVybiBudWxsfSxleHBvcnRzLmdlbmVyYXRlQWRkcmVzc2Zyb21YcHViPVQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYy11ci1yZWdpc3RyeS1ldGguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgdHggPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xudmFyIGJjVXJSZWdpc3RyeUV0aCA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2JjLXVyLXJlZ2lzdHJ5LWV0aCcpO1xudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG5cbmNvbnN0IGtleXJpbmdUeXBlID0gJ1FSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2UnO1xuY29uc3QgcGF0aEJhc2UgPSAnbSc7XG5jb25zdCBNQVhfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9DSElMRFJFTl9QQVRIID0gJzAvKic7XG52YXIgS0VZUklOR19NT0RFO1xuXG4oZnVuY3Rpb24gKEtFWVJJTkdfTU9ERSkge1xuICBLRVlSSU5HX01PREVbXCJoZFwiXSA9IFwiaGRcIjtcbiAgS0VZUklOR19NT0RFW1wicHVia2V5XCJdID0gXCJwdWJrZXlcIjtcbn0pKEtFWVJJTkdfTU9ERSB8fCAoS0VZUklOR19NT0RFID0ge30pKTtcblxudmFyIEtFWVJJTkdfQUNDT1VOVDtcblxuKGZ1bmN0aW9uIChLRVlSSU5HX0FDQ09VTlQpIHtcbiAgS0VZUklOR19BQ0NPVU5UW1wic3RhbmRhcmRcIl0gPSBcImFjY291bnQuc3RhbmRhcmRcIjtcbiAgS0VZUklOR19BQ0NPVU5UW1wibGVkZ2VyX2xpdmVcIl0gPSBcImFjY291bnQubGVkZ2VyX2xpdmVcIjtcbiAgS0VZUklOR19BQ0NPVU5UW1wibGVkZ2VyX2xlZ2FjeVwiXSA9IFwiYWNjb3VudC5sZWRnZXJfbGVnYWN5XCI7XG59KShLRVlSSU5HX0FDQ09VTlQgfHwgKEtFWVJJTkdfQUNDT1VOVCA9IHt9KSk7XG5cbmNsYXNzIEJhc2VLZXlyaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuXG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbiA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuJyk7XG4gICAgfTtcblxuICAgIHRoaXMudHlwZSA9IGtleXJpbmdUeXBlO1xuXG4gICAgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlID0gYXN5bmMgKF9yZXF1ZXN0SWQsIHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbikgPT4ge1xuICAgICAgY29uc3QgZXRoU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlcXVlc3RTaWduYXR1cmUoc2lnblJlcXVlc3QsIHJlcXVlc3RUaXRsZSwgcmVxdWVzdERlc2NyaXB0aW9uKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZEJ1ZmZlciA9IGV0aFNpZ25hdHVyZS5nZXRSZXF1ZXN0SWQoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFNpZ25hdHVyZS5nZXRTaWduYXR1cmUoKTtcblxuICAgICAgaWYgKHJlcXVlc3RJZEJ1ZmZlcikge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnN0cmluZ2lmeShyZXF1ZXN0SWRCdWZmZXIpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0SWQgIT09IF9yZXF1ZXN0SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiByZWFkIHNpZ25hdHVyZSBlcnJvcjogbWlzbWF0Y2hlZCByZXF1ZXN0SWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByID0gc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUuc2xpY2UoNjQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgdlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9IREtleSA9IGNyeXB0b0hES2V5ID0+IHtcbiAgICAgIHZhciBfY3J5cHRvSERLZXkkZ2V0T3JpZ2ksIF9jcnlwdG9IREtleSRnZXRDaGlsZDtcblxuICAgICAgY29uc3QgaGRQYXRoID0gYG0vJHtjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRQYXRoKCl9YDtcbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvSERLZXkkZ2V0T3JpZ2kgPSBjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldE9yaWdpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aCA9ICgoX2NyeXB0b0hES2V5JGdldENoaWxkID0gY3J5cHRvSERLZXkuZ2V0Q2hpbGRyZW4oKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jcnlwdG9IREtleSRnZXRDaGlsZC5nZXRQYXRoKCkpIHx8IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICAgIGNvbnN0IG5hbWUgPSBjcnlwdG9IREtleS5nZXROYW1lKCk7XG5cbiAgICAgIGlmIChjcnlwdG9IREtleS5nZXROb3RlKCkgPT09IEtFWVJJTkdfQUNDT1VOVC5zdGFuZGFyZCkge1xuICAgICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgICAgfSBlbHNlIGlmIChjcnlwdG9IREtleS5nZXROb3RlKCkgPT09IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGVnYWN5KSB7XG4gICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xlZ2FjeTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF4ZnApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8taGRrZXksIGNhbm5vdCBnZXQgc291cmNlIGZpbmdlcnByaW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhwdWIgPSBjcnlwdG9IREtleS5nZXRCaXAzMktleSgpO1xuICAgICAgdGhpcy54ZnAgPSB4ZnA7XG4gICAgICB0aGlzLnhwdWIgPSB4cHViO1xuICAgICAgdGhpcy5oZFBhdGggPSBoZFBhdGg7XG4gICAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IGNoaWxkcmVuUGF0aDtcblxuICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCAmJiBuYW1lICE9PSAnJykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50ID0gY3J5cHRvQWNjb3VudCA9PiB7XG4gICAgICB2YXIgX2NyeXB0b0FjY291bnQkZ2V0TWFzLCBfY3J5cHRvQWNjb3VudCRnZXRPdXQ7XG5cbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvQWNjb3VudCRnZXRNYXMgPSBjcnlwdG9BY2NvdW50LmdldE1hc3RlckZpbmdlcnByaW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRNYXMudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICBpZiAoIXhmcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnhmcCA9IHhmcDtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBjcnlwdG9BY2NvdW50LmdldE91dHB1dERlc2NyaXB0b3JzKCk7XG5cbiAgICAgIGlmICghb3V0cHV0cyB8fCBvdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBubyBjcnlwdG8gb3V0cHV0IGZvdW5kJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRzLmxlbmd0aCAlIDUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogb25seSBzdXBwb3J0IDV4IHB1YmtleSBhY2NvdW50cyBmb3Igbm93Jyk7XG4gICAgICB9XG5cbiAgICAgIChfY3J5cHRvQWNjb3VudCRnZXRPdXQgPSBjcnlwdG9BY2NvdW50LmdldE91dHB1dERlc2NyaXB0b3JzKCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRPdXQuZm9yRWFjaChvZCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3J5cHRvSERLZXkgPSBvZC5nZXRIREtleSgpO1xuXG4gICAgICAgICAgaWYgKGNyeXB0b0hES2V5KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjcnlwdG9IREtleS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBgTS8ke2NyeXB0b0hES2V5LmdldE9yaWdpbigpLmdldFBhdGgoKX1gO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9ICcweCcgKyBldGhlcmV1bWpzVXRpbC5wdWJsaWNUb0FkZHJlc3Moa2V5LCB0cnVlKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBjcnlwdG9IREtleS5nZXROYW1lKCk7XG5cbiAgICAgICAgICAgIGlmIChjcnlwdG9IREtleS5nZXROb3RlKCkgPT09IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9saXZlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoc1tldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXRoc1tldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBwYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9OyAvLyBwcml2YXRlIF9fcmVhZExlZGdlckxpdmVBY2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIC8vICAgICBpZiAocmVzdWx0LmdldFJlZ2lzdHJ5VHlwZSgpID09PSBleHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVCkge1xuICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQgYXMgQ3J5cHRvQWNjb3VudCk7XG4gICAgLy8gICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX25ld19hY2NvdW50YCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQudW5leHBlY3RlZF91cnR5cGVgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH07XG5cblxuICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgIH07XG5cbiAgICB0aGlzLl9fZ2V0Tm9ybWFsUGFnZSA9IGluY3JlbWVudCA9PiB7XG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuXG4gICAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgICAgdGhpcy5wYWdlID0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcbiAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpO1xuICAgICAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoYWNjb3VudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX2dldExlZGdlckxpdmVQYWdlID0gaW5jcmVtZW50ID0+IHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdGhpcy5wYWdlICsgaW5jcmVtZW50O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gKG5leHRQYWdlIC0gMSkgKiB0aGlzLnBlclBhZ2U7XG4gICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgcmVzb2x2ZShhY2NvdW50cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleCA9IGFzeW5jIChwYiwgaSkgPT4ge1xuICAgICAgaWYgKHRoaXMua2V5cmluZ01vZGUgPT09IEtFWVJJTkdfTU9ERS5oZCkge1xuICAgICAgICB0aGlzLmNoZWNrS2V5cmluZygpO1xuXG4gICAgICAgIGlmICghdGhpcy5oZGspIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5oZGsgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkodGhpcy54cHViKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuUGF0aCA9IHRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoJyonLCBTdHJpbmcoaSkpLnJlcGxhY2VBbGwoJyonLCAnMCcpO1xuICAgICAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BifS8ke2NoaWxkcmVuUGF0aH1gKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9ICcweCcgKyBldGhlcmV1bWpzVXRpbC5wdWJsaWNUb0FkZHJlc3MoZGtleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGV0aGVyZXVtanNVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModGhpcy5wYXRocylbaV07XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBldGhlcmV1bWpzVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvL2NvbW1vbiBwcm9wc1xuXG5cbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLm5hbWUgPSAnUVIgSGFyZHdhcmUnO1xuICAgIHRoaXMua2V5cmluZ01vZGUgPSBLRVlSSU5HX01PREUuaGQ7XG4gICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5zdGFuZGFyZDtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7IC8vaGQgcHJvcHM7XG5cbiAgICB0aGlzLnhmcCA9ICcnO1xuICAgIHRoaXMueHB1YiA9ICcnO1xuICAgIHRoaXMuaGRQYXRoID0gJyc7XG4gICAgdGhpcy5jaGlsZHJlblBhdGggPSBERUZBVUxUX0NISUxEUkVOX1BBVEg7XG4gICAgdGhpcy5pbmRleGVzID0ge307IC8vcHVia2V5IHByb3BzO1xuXG4gICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIHRoaXMuZGVzZXJpYWxpemUob3B0cyk7XG4gIH0gLy9pbml0aWFsIHJlYWRcblxuXG4gIGFzeW5jIHJlYWRLZXlyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZWFkQ3J5cHRvSERLZXlPckNyeXB0b0FjY291bnQoKTtcblxuICAgIGlmIChyZXN1bHQuZ2V0UmVnaXN0cnlUeXBlKCkgPT09IGJjVXJSZWdpc3RyeUV0aC5leHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkpIHtcbiAgICAgIHRoaXMua2V5cmluZ01vZGUgPSBLRVlSSU5HX01PREUuaGQ7XG5cbiAgICAgIHRoaXMuX19yZWFkQ3J5cHRvSERLZXkocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlyaW5nTW9kZSA9IEtFWVJJTkdfTU9ERS5wdWJrZXk7XG5cbiAgICAgIHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrS2V5cmluZygpIHtcbiAgICBpZiAoIXRoaXMueGZwIHx8ICF0aGlzLnhwdWIgfHwgIXRoaXMuaGRQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXN0b25lRXJyb3IjaW52YWxpZF9rZXlyaW5nOiBrZXlyaW5nIG5vdCBmdWxmaWxsZWQsIHBsZWFzZSBjYWxsIGZ1bmN0aW9uIGByZWFkS2V5cmluZ2AgZmlyc3RseScpO1xuICAgIH1cbiAgfVxuXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC8vY29tbW9uXG4gICAgICBpbml0aWFsaXplZDogdGhpcy5pbml0aWFsaXplZCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgY3VycmVudEFjY291bnQ6IHRoaXMuY3VycmVudEFjY291bnQsXG4gICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICBwZXJQYWdlOiB0aGlzLnBlclBhZ2UsXG4gICAgICBrZXlyaW5nQWNjb3VudDogdGhpcy5rZXlyaW5nQWNjb3VudCxcbiAgICAgIGtleXJpbmdNb2RlOiB0aGlzLmtleXJpbmdNb2RlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgeGZwOiB0aGlzLnhmcCxcbiAgICAgIC8vaGRcbiAgICAgIHhwdWI6IHRoaXMueHB1YixcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgICBjaGlsZHJlblBhdGg6IHRoaXMuY2hpbGRyZW5QYXRoLFxuICAgICAgaW5kZXhlczogdGhpcy5pbmRleGVzLFxuICAgICAgLy9wdWJrZXlcbiAgICAgIHBhdGhzOiB0aGlzLnBhdGhzXG4gICAgfSk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZShvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIC8vY29tbW9uIHByb3BzO1xuICAgICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHM7XG4gICAgICB0aGlzLmN1cnJlbnRBY2NvdW50ID0gb3B0cy5jdXJyZW50QWNjb3VudDtcbiAgICAgIHRoaXMucGFnZSA9IG9wdHMucGFnZTtcbiAgICAgIHRoaXMucGVyUGFnZSA9IG9wdHMucGVyUGFnZTtcbiAgICAgIHRoaXMubmFtZSA9IG9wdHMubmFtZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBvcHRzLmluaXRpYWxpemVkO1xuICAgICAgdGhpcy5rZXlyaW5nTW9kZSA9IG9wdHMua2V5cmluZ01vZGUgfHwgS0VZUklOR19NT0RFLmhkO1xuICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IG9wdHMua2V5cmluZ0FjY291bnQgfHwgS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgICAgdGhpcy54ZnAgPSBvcHRzLnhmcDsgLy9oZCBwcm9wcztcblxuICAgICAgdGhpcy54cHViID0gb3B0cy54cHViO1xuICAgICAgdGhpcy5oZFBhdGggPSBvcHRzLmhkUGF0aDtcbiAgICAgIHRoaXMuaW5kZXhlcyA9IG9wdHMuaW5kZXhlcztcbiAgICAgIHRoaXMucGF0aHMgPSBvcHRzLnBhdGhzO1xuICAgICAgdGhpcy5jaGlsZHJlblBhdGggPSBvcHRzLmNoaWxkcmVuUGF0aCB8fCBERUZBVUxUX0NISUxEUkVOX1BBVEg7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudEFjY291bnQoaW5kZXgpIHtcbiAgICB0aGlzLmN1cnJlbnRBY2NvdW50ID0gaW5kZXg7XG4gIH1cblxuICBnZXRDdXJyZW50QWNjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QWNjb3VudDtcbiAgfVxuXG4gIGdldEN1cnJlbnRBZGRyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRzW3RoaXMuY3VycmVudEFjY291bnRdO1xuICB9XG5cbiAgYWRkQWNjb3VudHMobiA9IDEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMudW5sb2NrZWRBY2NvdW50O1xuICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuICAgICAgICBjb25zdCBuZXdBY2NvdW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgICAgbmV3QWNjb3VudHMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgICAgIHRoaXMudW5sb2NrZWRBY2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5jb25jYXQobmV3QWNjb3VudHMpO1xuICAgICAgICByZXNvbHZlKHRoaXMuYWNjb3VudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRGaXJzdFBhZ2UoKSB7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoMSk7XG4gIH1cblxuICBnZXROZXh0UGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoMSk7XG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKC0xKTtcbiAgfVxuXG4gIGFzeW5jIF9fZ2V0UGFnZShpbmNyZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVhZEtleXJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZXlyaW5nTW9kZSA9PT0gS0VZUklOR19NT0RFLmhkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldE5vcm1hbFBhZ2UoaW5jcmVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX19nZXRMZWRnZXJMaXZlUGFnZShpbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldEFjY291bnRzKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hY2NvdW50cyk7XG4gIH1cblxuICByZW1vdmVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKGEgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHthZGRyZXNzfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuZmlsdGVyKGEgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICB9IC8vIHR4IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBldGhlcmV1bWpzLXRyYW5zYWN0aW9uIGNsYXNzLlxuXG5cbiAgc3RhdGljIHNlcmlhbGl6ZVR4KHR4KSB7XG4gICAgLy8gbmVlZCB1c2UgRUlQLTE1NVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0eC52ID0gbmV3IGV0aGVyZXVtanNVdGlsLkJOKHR4LmNvbW1vbi5jaGFpbklkKCkpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0eC5yID0gbmV3IGV0aGVyZXVtanNVdGlsLkJOKDApOyAvLyBAdHMtaWdub3JlXG5cbiAgICB0eC5zID0gbmV3IGV0aGVyZXVtanNVdGlsLkJOKDApO1xuICAgIHJldHVybiB0eC5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eCQxKSB7XG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpO1xuICAgIGNvbnN0IGNoYWluSWQgPSB0eCQxLmNvbW1vbi5jaGFpbklkKCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQmFzZUtleXJpbmcuc2VyaWFsaXplVHgodHgkMSksIGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50cmFuc2FjdGlvbiwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCBjaGFpbklkKTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsICdTY2FuIHdpdGggeW91ciBLZXlzdG9uZScsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eCQxLnRvSlNPTigpO1xuICAgIHJldHVybiB0eC5UcmFuc2FjdGlvbi5mcm9tVHhEYXRhKHtcbiAgICAgIHRvOiB0eEpzb25bJ3RvJ10sXG4gICAgICBnYXNMaW1pdDogdHhKc29uWydnYXNMaW1pdCddLFxuICAgICAgZ2FzUHJpY2U6IHR4SnNvblsnZ2FzUHJpY2UnXSxcbiAgICAgIGRhdGE6IHR4SnNvblsnZGF0YSddLFxuICAgICAgbm9uY2U6IHR4SnNvblsnbm9uY2UnXSxcbiAgICAgIHZhbHVlOiB0eEpzb25bJ3ZhbHVlJ10sXG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9LCB7XG4gICAgICBjb21tb246IHR4JDEuY29tbW9uXG4gICAgfSk7XG4gIH1cblxuICBzaWduTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpO1xuICB9XG5cbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZSh3aXRoQWNjb3VudCwgbWVzc2FnZUhleCkge1xuICAgIGNvbnN0IHVzaWduZWRIZXggPSBldGhlcmV1bWpzVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlSGV4KTtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHVzaWduZWRIZXgsICdoZXgnKSwgYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnBlcnNvbmFsTWVzc2FnZSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCB1bmRlZmluZWQsIHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsICdTY2FuIHdpdGggeW91ciBLZXlzdG9uZScsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gJzB4JyArIEJ1ZmZlci5jb25jYXQoW3IsIHMsIHZdKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhKHdpdGhBY2NvdW50LCB0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHR5cGVkRGF0YSksICd1dGYtOCcpLCBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHlwZWREYXRhLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIHVuZGVmaW5lZCwgd2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgJ1NjYW4gd2l0aCB5b3VyIEtleXN0b25lJywgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiAnMHgnICsgQnVmZmVyLmNvbmNhdChbciwgcywgdl0pLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIGFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aGVyZXVtanNVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleGVzW2NoZWNrc3VtbWVkQWRkcmVzc107XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hlY2tzdW1tZWRBZGRyZXNzID09PSAoYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpKSkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLmhkUGF0aH0vJHt0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKCcqJywgaW5kZXgudG9TdHJpbmcoKSkucmVwbGFjZUFsbCgnKicsICcwJyl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gZXRoZXJldW1qc1V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfVxuXG59XG5CYXNlS2V5cmluZy50eXBlID0ga2V5cmluZ1R5cGU7XG5cbmV4cG9ydHMuQmFzZUtleXJpbmcgPSBCYXNlS2V5cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtZXRoLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGUsdCxyLGk9KGU9cmVxdWlyZShcImhka2V5XCIpKSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZSxzPXJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIiksbj1yZXF1aXJlKFwiQGV0aGVyZXVtanMvdHhcIiksYT1yZXF1aXJlKFwiQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoXCIpLG89cmVxdWlyZShcInV1aWRcIik7IWZ1bmN0aW9uKGUpe2UuaGQ9XCJoZFwiLGUucHVia2V5PVwicHVia2V5XCJ9KHR8fCh0PXt9KSksZnVuY3Rpb24oZSl7ZS5zdGFuZGFyZD1cImFjY291bnQuc3RhbmRhcmRcIixlLmxlZGdlcl9saXZlPVwiYWNjb3VudC5sZWRnZXJfbGl2ZVwiLGUubGVkZ2VyX2xlZ2FjeT1cImFjY291bnQubGVkZ2VyX2xlZ2FjeVwifShyfHwocj17fSkpO2NsYXNzIGh7Y29uc3RydWN0b3IoZSl7dGhpcy52ZXJzaW9uPTEsdGhpcy5nZXRJbnRlcmFjdGlvbj0oKT0+e3Rocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9leHRlbmRzOiBtZXRob2QgZ2V0SW50ZXJhY3Rpb24gbm90IGltcGxlbWVudGVkLCBwbGVhc2UgZXh0ZW5kIEJhc2VLZXlyaW5nIGJ5IG92ZXJ3cml0aW5nIHRoaXMgbWV0aG9kLlwiKX0sdGhpcy50eXBlPVwiUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZVwiLHRoaXMucmVxdWVzdFNpZ25hdHVyZT1hc3luYyhlLHQscixpKT0+e2NvbnN0IHM9YXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlcXVlc3RTaWduYXR1cmUodCxyLGkpLG49cy5nZXRSZXF1ZXN0SWQoKSxhPXMuZ2V0U2lnbmF0dXJlKCk7aWYobiYmby5zdHJpbmdpZnkobikhPT1lKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiByZWFkIHNpZ25hdHVyZSBlcnJvcjogbWlzbWF0Y2hlZCByZXF1ZXN0SWRcIik7cmV0dXJue3I6YS5zbGljZSgwLDMyKSxzOmEuc2xpY2UoMzIsNjQpLHY6YS5zbGljZSg2NCl9fSx0aGlzLl9fcmVhZENyeXB0b0hES2V5PWU9Pnt2YXIgdCxpO2NvbnN0IHM9XCJtL1wiK2UuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpLG49bnVsbD09KHQ9ZS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKT92b2lkIDA6dC50b1N0cmluZyhcImhleFwiKSxhPShudWxsPT0oaT1lLmdldENoaWxkcmVuKCkpP3ZvaWQgMDppLmdldFBhdGgoKSl8fFwiMC8qXCIsbz1lLmdldE5hbWUoKTtpZihlLmdldE5vdGUoKT09PXIuc3RhbmRhcmQ/dGhpcy5rZXlyaW5nQWNjb3VudD1yLnN0YW5kYXJkOmUuZ2V0Tm90ZSgpPT09ci5sZWRnZXJfbGVnYWN5JiYodGhpcy5rZXlyaW5nQWNjb3VudD1yLmxlZGdlcl9sZWdhY3kpLCFuKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1oZGtleSwgY2Fubm90IGdldCBzb3VyY2UgZmluZ2VycHJpbnRcIik7Y29uc3QgaD1lLmdldEJpcDMyS2V5KCk7dGhpcy54ZnA9bix0aGlzLnhwdWI9aCx0aGlzLmhkUGF0aD1zLHRoaXMuY2hpbGRyZW5QYXRoPWEsdm9pZCAwIT09byYmXCJcIiE9PW8mJih0aGlzLm5hbWU9byksdGhpcy5pbml0aWFsaXplZD0hMH0sdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50PWU9Pnt2YXIgdCxpO2NvbnN0IG49bnVsbD09KHQ9ZS5nZXRNYXN0ZXJGaW5nZXJwcmludCgpKT92b2lkIDA6dC50b1N0cmluZyhcImhleFwiKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8tYWNjb3VudCwgY2Fubm90IGdldCBtYXN0ZXIgZmluZ2VycHJpbnRcIik7dGhpcy54ZnA9bix0aGlzLmluaXRpYWxpemVkPSEwO2xldCBhPSExO2NvbnN0IG89ZS5nZXRPdXRwdXREZXNjcmlwdG9ycygpO2lmKCFvfHwwPT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIG5vIGNyeXB0byBvdXRwdXQgZm91bmRcIik7aWYoby5sZW5ndGglNSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogb25seSBzdXBwb3J0IDV4IHB1YmtleSBhY2NvdW50cyBmb3Igbm93XCIpO3JldHVybiBudWxsPT0oaT1lLmdldE91dHB1dERlc2NyaXB0b3JzKCkpfHxpLmZvckVhY2goZT0+e3RyeXtjb25zdCB0PWUuZ2V0SERLZXkoKTtpZih0KXtjb25zdCBlPXQuZ2V0S2V5KCksaT1cIk0vXCIrdC5nZXRPcmlnaW4oKS5nZXRQYXRoKCksbj1cIjB4XCIrcy5wdWJsaWNUb0FkZHJlc3MoZSwhMCkudG9TdHJpbmcoXCJoZXhcIik7dGhpcy5uYW1lPXQuZ2V0TmFtZSgpLHQuZ2V0Tm90ZSgpPT09ci5sZWRnZXJfbGl2ZSYmKHRoaXMua2V5cmluZ0FjY291bnQ9ci5sZWRnZXJfbGl2ZSksdm9pZCAwPT09dGhpcy5wYXRoc1tzLnRvQ2hlY2tzdW1BZGRyZXNzKG4pXSYmKGE9ITApLHRoaXMucGF0aHNbcy50b0NoZWNrc3VtQWRkcmVzcyhuKV09aX19Y2F0Y2goZSl7dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IFwiK2UpfX0pLGF9LHRoaXMuZ2V0TmFtZT0oKT0+dGhpcy5uYW1lLHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrPWU9Pnt0aGlzLnVubG9ja2VkQWNjb3VudD1wYXJzZUludChlLDEwKX0sdGhpcy5fX2dldE5vcm1hbFBhZ2U9ZT0+KHRoaXMucGFnZSs9ZSx0aGlzLnBhZ2U8PTAmJih0aGlzLnBhZ2U9MSksbmV3IFByb21pc2UoYXN5bmMoZSx0KT0+e3RyeXtjb25zdCB0PSh0aGlzLnBhZ2UtMSkqdGhpcy5wZXJQYWdlLHI9dCt0aGlzLnBlclBhZ2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh7YWRkcmVzczp0LGJhbGFuY2U6bnVsbCxpbmRleDplfSksdGhpcy5pbmRleGVzW3MudG9DaGVja3N1bUFkZHJlc3ModCldPWV9ZShpKX1jYXRjaChlKXt0KGUpfX0pKSx0aGlzLl9fZ2V0TGVkZ2VyTGl2ZVBhZ2U9ZT0+e2NvbnN0IHQ9dGhpcy5wYWdlK2U7cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKHIsaSk9Pnt0cnl7Y29uc3QgaT0odC0xKSp0aGlzLnBlclBhZ2Uscz1pK3RoaXMucGVyUGFnZSxuPVtdO2ZvcihsZXQgZT1pO2U8cztlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7bi5wdXNoKHthZGRyZXNzOnQsYmFsYW5jZTpudWxsLGluZGV4OmV9KX10aGlzLnBhZ2UrPWUscihuKX1jYXRjaChlKXtpKGUpfX0pfSx0aGlzLl9fYWRkcmVzc0Zyb21JbmRleD1hc3luYyhlLHIpPT57aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe3RoaXMuY2hlY2tLZXlyaW5nKCksdGhpcy5oZGt8fCh0aGlzLmhkaz1pLmZyb21FeHRlbmRlZEtleSh0aGlzLnhwdWIpKTtjb25zdCB0PXRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoXCIqXCIsU3RyaW5nKHIpKS5yZXBsYWNlQWxsKFwiKlwiLFwiMFwiKSxuPXRoaXMuaGRrLmRlcml2ZShgJHtlfS8ke3R9YCksYT1cIjB4XCIrcy5wdWJsaWNUb0FkZHJlc3Mobi5wdWJsaWNLZXksITApLnRvU3RyaW5nKFwiaGV4XCIpO3JldHVybiBzLnRvQ2hlY2tzdW1BZGRyZXNzKGEpfXtjb25zdCBlPU9iamVjdC5rZXlzKHRoaXMucGF0aHMpW3JdO2lmKGUpcmV0dXJuIHMudG9DaGVja3N1bUFkZHJlc3MoZSk7dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50XCIpfX0sdGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy51bmxvY2tlZEFjY291bnQ9MCx0aGlzLm5hbWU9XCJRUiBIYXJkd2FyZVwiLHRoaXMua2V5cmluZ01vZGU9dC5oZCx0aGlzLmtleXJpbmdBY2NvdW50PXIuc3RhbmRhcmQsdGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLnhmcD1cIlwiLHRoaXMueHB1Yj1cIlwiLHRoaXMuaGRQYXRoPVwiXCIsdGhpcy5jaGlsZHJlblBhdGg9XCIwLypcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5wYXRocz17fSx0aGlzLmRlc2VyaWFsaXplKGUpfWFzeW5jIHJlYWRLZXlyaW5nKCl7Y29uc3QgZT1hd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50KCk7ZS5nZXRSZWdpc3RyeVR5cGUoKT09PWEuZXh0ZW5kLlJlZ2lzdHJ5VHlwZXMuQ1JZUFRPX0hES0VZPyh0aGlzLmtleXJpbmdNb2RlPXQuaGQsdGhpcy5fX3JlYWRDcnlwdG9IREtleShlKSk6KHRoaXMua2V5cmluZ01vZGU9dC5wdWJrZXksdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KGUpKX1jaGVja0tleXJpbmcoKXtpZighdGhpcy54ZnB8fCF0aGlzLnhwdWJ8fCF0aGlzLmhkUGF0aCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfa2V5cmluZzoga2V5cmluZyBub3QgZnVsZmlsbGVkLCBwbGVhc2UgY2FsbCBmdW5jdGlvbiBgcmVhZEtleXJpbmdgIGZpcnN0bHlcIil9c2VyaWFsaXplKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7aW5pdGlhbGl6ZWQ6dGhpcy5pbml0aWFsaXplZCxhY2NvdW50czp0aGlzLmFjY291bnRzLGN1cnJlbnRBY2NvdW50OnRoaXMuY3VycmVudEFjY291bnQscGFnZTp0aGlzLnBhZ2UscGVyUGFnZTp0aGlzLnBlclBhZ2Usa2V5cmluZ0FjY291bnQ6dGhpcy5rZXlyaW5nQWNjb3VudCxrZXlyaW5nTW9kZTp0aGlzLmtleXJpbmdNb2RlLG5hbWU6dGhpcy5uYW1lLHZlcnNpb246dGhpcy52ZXJzaW9uLHhmcDp0aGlzLnhmcCx4cHViOnRoaXMueHB1YixoZFBhdGg6dGhpcy5oZFBhdGgsY2hpbGRyZW5QYXRoOnRoaXMuY2hpbGRyZW5QYXRoLGluZGV4ZXM6dGhpcy5pbmRleGVzLHBhdGhzOnRoaXMucGF0aHN9KX1kZXNlcmlhbGl6ZShlKXtlJiYodGhpcy5hY2NvdW50cz1lLmFjY291bnRzLHRoaXMuY3VycmVudEFjY291bnQ9ZS5jdXJyZW50QWNjb3VudCx0aGlzLnBhZ2U9ZS5wYWdlLHRoaXMucGVyUGFnZT1lLnBlclBhZ2UsdGhpcy5uYW1lPWUubmFtZSx0aGlzLmluaXRpYWxpemVkPWUuaW5pdGlhbGl6ZWQsdGhpcy5rZXlyaW5nTW9kZT1lLmtleXJpbmdNb2RlfHx0LmhkLHRoaXMua2V5cmluZ0FjY291bnQ9ZS5rZXlyaW5nQWNjb3VudHx8ci5zdGFuZGFyZCx0aGlzLnhmcD1lLnhmcCx0aGlzLnhwdWI9ZS54cHViLHRoaXMuaGRQYXRoPWUuaGRQYXRoLHRoaXMuaW5kZXhlcz1lLmluZGV4ZXMsdGhpcy5wYXRocz1lLnBhdGhzLHRoaXMuY2hpbGRyZW5QYXRoPWUuY2hpbGRyZW5QYXRofHxcIjAvKlwiKX1zZXRDdXJyZW50QWNjb3VudChlKXt0aGlzLmN1cnJlbnRBY2NvdW50PWV9Z2V0Q3VycmVudEFjY291bnQoKXtyZXR1cm4gdGhpcy5jdXJyZW50QWNjb3VudH1nZXRDdXJyZW50QWRkcmVzcygpe3JldHVybiB0aGlzLmFjY291bnRzW3RoaXMuY3VycmVudEFjY291bnRdfWFkZEFjY291bnRzKGU9MSl7cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKHQscik9Pnt0cnl7Y29uc3Qgcj10aGlzLnVubG9ja2VkQWNjb3VudCxpPXIrZSxzPVtdO2ZvcihsZXQgZT1yO2U8aTtlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7cy5wdXNoKHQpLHRoaXMucGFnZT0wLHRoaXMudW5sb2NrZWRBY2NvdW50Kyt9dGhpcy5hY2NvdW50cz10aGlzLmFjY291bnRzLmNvbmNhdChzKSx0KHRoaXMuYWNjb3VudHMpfWNhdGNoKGUpe3IoZSl9fSl9Z2V0Rmlyc3RQYWdlKCl7cmV0dXJuIHRoaXMucGFnZT0wLHRoaXMuX19nZXRQYWdlKDEpfWdldE5leHRQYWdlKCl7cmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpfWdldFByZXZpb3VzUGFnZSgpe3JldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSl9YXN5bmMgX19nZXRQYWdlKGUpe3JldHVybiB0aGlzLmluaXRpYWxpemVkfHxhd2FpdCB0aGlzLnJlYWRLZXlyaW5nKCksdGhpcy5rZXlyaW5nTW9kZT09PXQuaGQ/dGhpcy5fX2dldE5vcm1hbFBhZ2UoZSk6dGhpcy5fX2dldExlZGdlckxpdmVQYWdlKGUpfWdldEFjY291bnRzKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzKX1yZW1vdmVBY2NvdW50KGUpe2lmKCF0aGlzLmFjY291bnRzLm1hcChlPT5lLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGUudG9Mb3dlckNhc2UoKSkpdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7ZX0gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO3RoaXMuYWNjb3VudHM9dGhpcy5hY2NvdW50cy5maWx0ZXIodD0+dC50b0xvd2VyQ2FzZSgpIT09ZS50b0xvd2VyQ2FzZSgpKX1zdGF0aWMgc2VyaWFsaXplVHgoZSl7cmV0dXJuIGUudj1uZXcgcy5CTihlLmNvbW1vbi5jaGFpbklkKCkpLGUucj1uZXcgcy5CTigwKSxlLnM9bmV3IHMuQk4oMCksZS5zZXJpYWxpemUoKX1hc3luYyBzaWduVHJhbnNhY3Rpb24oZSx0KXtjb25zdCByPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxpPXQuY29tbW9uLmNoYWluSWQoKSxzPW8udjQoKSxjPWEuRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChoLnNlcmlhbGl6ZVR4KHQpLGEuRGF0YVR5cGUudHJhbnNhY3Rpb24scix0aGlzLnhmcCxzLGkpLHtyOmQsczp1LHY6Z309YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHMsYyxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24sIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpLGw9dC50b0pTT04oKTtyZXR1cm4gbi5UcmFuc2FjdGlvbi5mcm9tVHhEYXRhKHt0bzpsLnRvLGdhc0xpbWl0OmwuZ2FzTGltaXQsZ2FzUHJpY2U6bC5nYXNQcmljZSxkYXRhOmwuZGF0YSxub25jZTpsLm5vbmNlLHZhbHVlOmwudmFsdWUscjpkLHM6dSx2Omd9LHtjb21tb246dC5jb21tb259KX1zaWduTWVzc2FnZShlLHQpe3JldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UoZSx0KX1hc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKGUsdCl7Y29uc3Qgcj1zLnN0cmlwSGV4UHJlZml4KHQpLGk9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLG49by52NCgpLGg9YS5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHIsXCJoZXhcIiksYS5EYXRhVHlwZS5wZXJzb25hbE1lc3NhZ2UsaSx0aGlzLnhmcCxuLHZvaWQgMCxlKSx7cjpjLHM6ZCx2OnV9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShuLGgsXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtyZXR1cm5cIjB4XCIrQnVmZmVyLmNvbmNhdChbYyxkLHVdKS50b1N0cmluZyhcImhleFwiKX1hc3luYyBzaWduVHlwZWREYXRhKGUsdCl7Y29uc3Qgcj1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksaT1vLnY0KCkscz1hLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodCksXCJ1dGYtOFwiKSxhLkRhdGFUeXBlLnR5cGVkRGF0YSxyLHRoaXMueGZwLGksdm9pZCAwLGUpLHtyOm4sczpoLHY6Y309YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKGkscyxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO3JldHVyblwiMHhcIitCdWZmZXIuY29uY2F0KFtuLGgsY10pLnRvU3RyaW5nKFwiaGV4XCIpfWFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoZSl7aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKTtsZXQgcj10aGlzLmluZGV4ZXNbdF07aWYodm9pZCAwPT09cilmb3IobGV0IGU9MDtlPDFlMztlKyspaWYodD09PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpKXtyPWU7YnJlYWt9aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuYCR7dGhpcy5oZFBhdGh9LyR7dGhpcy5jaGlsZHJlblBhdGgucmVwbGFjZShcIipcIixyLnRvU3RyaW5nKCkpLnJlcGxhY2VBbGwoXCIqXCIsXCIwXCIpfWB9e2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKSxyPXRoaXMucGF0aHNbdF07aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuIHJ9fX1oLnR5cGU9XCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCIsZXhwb3J0cy5CYXNlS2V5cmluZz1oO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1ldGgta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMubWFwXG4iLCJpbXBvcnQgeyBORVRXT1JLX1RPX05BTUVfTUFQIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5cbmV4cG9ydCBjb25zdCBnZXROZXR3b3JrRGlzcGxheU5hbWUgPSAoa2V5KSA9PiBORVRXT1JLX1RPX05BTUVfTUFQW2tleV07XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUeE1ldGFGb3JScGNSZXN1bHQodHhNZXRhKSB7XG4gIGNvbnN0IHsgciwgcywgdiwgaGFzaCwgdHhSZWNlaXB0LCB0eFBhcmFtcyB9ID0gdHhNZXRhO1xuICBjb25zdCB7XG4gICAgdG8sXG4gICAgZGF0YSxcbiAgICBub25jZSxcbiAgICBnYXMsXG4gICAgZnJvbSxcbiAgICB2YWx1ZSxcbiAgICBnYXNQcmljZSxcbiAgICBhY2Nlc3NMaXN0LFxuICAgIG1heEZlZVBlckdhcyxcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgfSA9IHR4UGFyYW1zO1xuXG4gIGNvbnN0IGZvcm1hdHRlZFR4TWV0YSA9IHtcbiAgICB2LFxuICAgIHIsXG4gICAgcyxcbiAgICB0byxcbiAgICBnYXMsXG4gICAgZnJvbSxcbiAgICBoYXNoLFxuICAgIG5vbmNlLFxuICAgIGlucHV0OiBkYXRhIHx8ICcweCcsXG4gICAgdmFsdWU6IHZhbHVlIHx8ICcweDAnLFxuICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3QgfHwgbnVsbCxcbiAgICBibG9ja0hhc2g6IHR4UmVjZWlwdD8uYmxvY2tIYXNoIHx8IG51bGwsXG4gICAgYmxvY2tOdW1iZXI6IHR4UmVjZWlwdD8uYmxvY2tOdW1iZXIgfHwgbnVsbCxcbiAgICB0cmFuc2FjdGlvbkluZGV4OiB0eFJlY2VpcHQ/LnRyYW5zYWN0aW9uSW5kZXggfHwgbnVsbCxcbiAgfTtcblxuICBpZiAobWF4RmVlUGVyR2FzICYmIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgZm9ybWF0dGVkVHhNZXRhLmdhc1ByaWNlID0gbWF4RmVlUGVyR2FzO1xuICAgIGZvcm1hdHRlZFR4TWV0YS5tYXhGZWVQZXJHYXMgPSBtYXhGZWVQZXJHYXM7XG4gICAgZm9ybWF0dGVkVHhNZXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID0gbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgZm9ybWF0dGVkVHhNZXRhLnR5cGUgPSBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUO1xuICB9IGVsc2Uge1xuICAgIGZvcm1hdHRlZFR4TWV0YS5nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgIGZvcm1hdHRlZFR4TWV0YS50eXBlID0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdHRlZFR4TWV0YTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2luZGV4JyksXG4gICAgdGhyb3dJZlVuZGVmaW5lZCA9IF9yZXF1aXJlLnRocm93SWZVbmRlZmluZWQsXG4gICAgdGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzID0gX3JlcXVpcmUudGhyb3dJZk5vdEVxdWFsTGVuQXJyYXlzO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIE9SQklUREJfT1BUUyA9IGNvbmZpZy5vcmJpdGRiX29wdGlvbnM7XG5cbnZhciBLZXlWYWx1ZVN0b3JlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFBsZWFzZSB1c2UgKipib3gucHVibGljKiogb3IgKipib3gucHJpdmF0ZSoqIHRvIGdldCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKi9cbiAgZnVuY3Rpb24gS2V5VmFsdWVTdG9yZShvcmJpdGRiLCBuYW1lLCBlbnN1cmVDb25uZWN0ZWQsIHRocmVlSWQpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMltcImRlZmF1bHRcIl0pKHRoaXMsIEtleVZhbHVlU3RvcmUpO1xuICAgIHRoaXMuX29yYml0ZGIgPSBvcmJpdGRiO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuXG4gICAgaWYgKHRoaXMuX25hbWUuc3RhcnRzV2l0aCgnM2JveC5zcGFjZS4nKSkge1xuICAgICAgdGhpcy5fc3BhY2UgPSB0aGlzLl9uYW1lLnNwbGl0KCcuJylbMl07XG4gICAgfVxuXG4gICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkID0gZW5zdXJlQ29ubmVjdGVkO1xuICAgIHRoaXMuXzNpZCA9IHRocmVlSWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgYW5kIG9wdGlvbmFsbHkgbWV0YWRhdGEgb2YgdGhlIGdpdmVuIGtleVxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGtleSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gICAgIHtCb29sZWFufSAgIG9wdHMubWV0YWRhdGEgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvdGggdmFsdWUgYW5kIG1ldGFkYXRhXG4gICAqIEByZXR1cm4gICAge1N0cmluZ3x7dmFsdWU6IFN0cmluZywgdGltZXN0YW1wOiBOdW1iZXJ9fSB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXksIHVuZGVmaW5lZCBpZiB0aGVyZSdzIG5vIHN1Y2gga2V5XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShLZXlWYWx1ZVN0b3JlLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXQyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5KSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0cyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDoge307XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChrZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB4ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgeCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGlmICghb3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHRoaXMuX2V4dHJhY3RNZXRhZGF0YSh4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9vYmplY3RTcHJlYWQoe30sIG1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogeC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB4LnZhbHVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXQoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogR2V0IG1ldGFkYXRhIGZvciBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEByZXR1cm4gICAge01ldGFkYXRhfSAgICAgICAgICAgICAgICAgICAgICAgICAgTWV0YWRhdGEgZm9yIHRoZSBrZXksIHVuZGVmaW5lZCBpZiB0aGVyZSdzIG5vIHN1Y2gga2V5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRNZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1ldGFkYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGtleSkge1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQoa2V5KTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgeCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLl9leHRyYWN0TWV0YWRhdGEoeCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRNZXRhZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0TWV0YWRhdGE7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogU2V0IGEgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgdmFsdWUgICAgICAgICAgICAgICAgICAgdGhlIHZhbHVlXG4gICAgICogQHJldHVybiAgICB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIHN1Y2Nlc3NmdWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0aW1lU3RhbXA7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKCk7XG5cbiAgICAgICAgICAgICAgICB0aW1lU3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLnB1dChrZXksIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXQoX3gzLCBfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9KClcbiAgICAvKipcbiAgICAqIFNldCBtdWx0aXBsZSB2YWx1ZXMgZm9yIG11bHRpcGxlIGtleXNcbiAgICAqXG4gICAgKiBAcGFyYW0gICAgIHtBcnJheTxTdHJpbmc+fSAgICBrZXlzICAgICAgICAgICAgICAgICAgICAgdGhlIGtleXNcbiAgICAqIEBwYXJhbSAgICAge0FycmF5PFN0cmluZz59ICAgIHZhbHVlcyAgICAgICAgICAgICAgICAgICB0aGUgdmFsdWVzXG4gICAgKiBAcmV0dXJuICAgIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIHN1Y2Nlc3NmdWwsIHRocm93IGVycm9yIGlmIG5vdFxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRNdWx0aXBsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldE11bHRpcGxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGtleXMsIHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZOb3RFcXVhbExlbkFycmF5cyhrZXlzLCB2YWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUNvbm5lY3RlZCgpO1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAzO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHByZXZpb3VzUHJvbWlzZSwgbmV4dEtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVTdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQobmV4dEtleSwgJ2tleScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF90aGlzLl9kYi5wdXQobmV4dEtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lU3RhbXA6IHRpbWVTdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU0KTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDcsIF94OCwgX3g5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSwgUHJvbWlzZS5yZXNvbHZlKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfY29udGV4dDUudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzMsIDldXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldE11bHRpcGxlKF94NSwgX3g2KSB7XG4gICAgICAgIHJldHVybiBfc2V0TXVsdGlwbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldE11bHRpcGxlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEByZXR1cm4gICAge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSBpZiBzdWNjZXNzZnVsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoa2V5KSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRocm93SWZVbmRlZmluZWQoa2V5LCAna2V5Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKCk7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLmRlbChrZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlKF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IG1ldGFkYXRhIGZyb20gc3RvcmUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geCB7T2JqZWN0fSBkYXRhIGZyb20gc3RvcmVcbiAgICAgKiBAcmV0dXJuIHtNZXRhZGF0YX0gc3RvcmUgbWV0YWRhdGFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9leHRyYWN0TWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhY3RNZXRhZGF0YSh4KSB7XG4gICAgICAvLyBtcyAtPiBzZWNvbmRzLCBzZWUgaXNzdWUgIzM5NiBmb3IgZGV0YWlsc1xuICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoeC50aW1lU3RhbXAgLyAxMDAwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJhdyB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAga2V5ICAgICAgICAgICAgICAgICAgICAgdGhlIGtleVxuICAgICAqIEByZXR1cm4gICAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0MyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLmdldChrZXkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX2dldChfeDExKSB7XG4gICAgICAgIHJldHVybiBfZ2V0My5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N5bmMyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KG51bVJlbW90ZUVudHJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG51bUVudHJpZXNEZWZpbmVkO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpOyAvLyBsZXQgdG9pZCA9IG51bGxcblxuXG4gICAgICAgICAgICAgICAgbnVtRW50cmllc0RlZmluZWQgPSAhKG51bVJlbW90ZUVudHJpZXMgPT09IG51bGwgfHwgbnVtUmVtb3RlRW50cmllcyA9PT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgICAgIGlmICghKG51bUVudHJpZXNEZWZpbmVkICYmIG51bVJlbW90ZUVudHJpZXMgPD0gdGhpcy5fZGIuX29wbG9nLnZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBQcm9taXNlLnJlc29sdmUoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFudW1SZW1vdGVFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5fZGIuZXZlbnRzLnJlbW92ZUFsbExpc3RlbmVycygncmVwbGljYXRlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl9kYi5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXBsaWNhdGUucHJvZ3Jlc3MnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtUmVtb3RlRW50cmllcyA8PSBfdGhpczIuX2RiLl9vcGxvZy52YWx1ZXMubGVuZ3RoKSByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kYi5ldmVudHMub24oJ3JlcGxpY2F0ZS5wcm9ncmVzcycsIChfeCwgX3ksIF96LCBudW0sIG1heCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0b2lkKVxuICAgICAgICAgICAgICAgICAgICAgIHRvaWQgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBudW1SZW1vdGVFbnRyaWVzIHx8IG1heFxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckFkZGVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5hZGRyZXNzLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfc3luYyhfeDEyKSB7XG4gICAgICAgIHJldHVybiBfc3luYzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zeW5jO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9hZDIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkob2RiQWRkcmVzcykge1xuICAgICAgICB2YXIga2V5LCBvcHRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLl8zaWQuZ2V0S2V5cmluZ0J5U3BhY2VOYW1lKHRoaXMuX25hbWUpLmdldFB1YmxpY0tleXModHJ1ZSkuc2lnbmluZ0tleTtcbiAgICAgICAgICAgICAgICBvcHRzID0gX29iamVjdFNwcmVhZCh7fSwgT1JCSVREQl9PUFRTLCB7XG4gICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdkYWctcGInLFxuICAgICAgICAgICAgICAgICAgYWNjZXNzQ29udHJvbGxlcjoge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZTogW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsZWdhY3ktaXBmcy0zYm94JyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcE1hbmlmZXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXzNpZC5nZXRPZGJJZCh0aGlzLl9zcGFjZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG9wdHMuaWRlbnRpdHkgPSBfY29udGV4dDkuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmJpdGRiLmtleXZhbHVlKG9kYkFkZHJlc3MgfHwgdGhpcy5fbmFtZSwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMuX2RiID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGIubG9hZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZGIuYWRkcmVzcy50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9sb2FkKF94MTMpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xvYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVpcmVMb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1aXJlTG9hZCgpIHtcbiAgICAgIGlmICghdGhpcy5fZGIpIHRocm93IG5ldyBFcnJvcignX2xvYWQgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGludGVyYWN0aW5nIHdpdGggdGhlIHN0b3JlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2xvc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdmFsdWVzIGFuZCBvcHRpb25hbGx5IG1ldGFkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLm1ldGFkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvdGggdmFsdWVzIGFuZCBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gICAge0FycmF5PFN0cmluZ3x7dmFsdWU6IFN0cmluZywgdGltZXN0YW1wOiBOdW1iZXJ9Pn0gIHRoZSB2YWx1ZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2FsbCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICAgIGFsbFNpbXBsZSxcbiAgICAgICAgICAgIF9hcmdzMTEgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3MxMS5sZW5ndGggPiAwICYmIF9hcmdzMTFbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMTFbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5fZGIuYWxsO1xuICAgICAgICAgICAgICAgIGFsbFNpbXBsZSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJpZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2tleV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvcHRzLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFNpbXBsZVtrZXldID0gX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLl9leHRyYWN0TWV0YWRhdGEoZW50cnkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsU2ltcGxlW2tleV0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgYWxsU2ltcGxlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBhbGwoKSB7XG4gICAgICAgIHJldHVybiBfYWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiB1bmRlcmx5aW5nIGxvZyBlbnRyaWVzLiBJbiBsaW5lYXJpemVkIG9yZGVyIGFjY29yZGluZyB0byB0aGVpciBMYW1wb3J0IGNsb2Nrcy5cbiAgICAgKiBVc2VmdWwgZm9yIGdlbmVyYXRpbmcgYSBjb21wbGV0ZSBoaXN0b3J5IG9mIGFsbCBvcGVyYXRpb25zIG9uIHN0b3JlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlXG4gICAgICogIGNvbnN0IGxvZyA9IHN0b3JlLmxvZ1xuICAgICAqICBjb25zdCBlbnRyeSA9IGxvZ1swXVxuICAgICAqICBjb25zb2xlLmxvZyhlbnRyeSlcbiAgICAgKiAgLy8geyBvcDogJ1BVVCcsIGtleTogJ05hbWUnLCB2YWx1ZTogJ0JvdGJvdCcsIHRpbWVTdGFtcDogJzE1Mzg1NzU0MTYwNjgnIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4gICAge0FycmF5PE9iamVjdD59ICAgICBBcnJheSBvZiBvcmRlcmVkIGxvZyBlbnRyeSBvYmplY3RzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2dcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYi5fb3Bsb2cudmFsdWVzLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IG9iai5wYXlsb2FkLm9wLFxuICAgICAgICAgIGtleTogb2JqLnBheWxvYWQua2V5LFxuICAgICAgICAgIHZhbHVlOiBvYmoucGF5bG9hZC52YWx1ZSA/IG9iai5wYXlsb2FkLnZhbHVlLnZhbHVlIDogbnVsbCxcbiAgICAgICAgICB0aW1lU3RhbXA6IG9iai5wYXlsb2FkLnZhbHVlID8gb2JqLnBheWxvYWQudmFsdWUudGltZVN0YW1wIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBLZXlWYWx1ZVN0b3JlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVZhbHVlU3RvcmU7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxudmFyIHNsaWNlID0gdXRpbC5zbGljZVxudmFyIHBsdWNrID0gdXRpbC5wbHVja1xudmFyIGVhY2ggPSB1dGlsLmVhY2hcbnZhciBiaW5kID0gdXRpbC5iaW5kXG52YXIgY3JlYXRlID0gdXRpbC5jcmVhdGVcbnZhciBpc0xpc3QgPSB1dGlsLmlzTGlzdFxudmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb25cbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3RcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZVN0b3JlOiBjcmVhdGVTdG9yZVxufVxuXG52YXIgc3RvcmVBUEkgPSB7XG5cdHZlcnNpb246ICcyLjAuMTInLFxuXHRlbmFibGVkOiBmYWxzZSxcblx0XG5cdC8vIGdldCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5LiBJZiB0aGF0IHZhbHVlXG5cdC8vIGlzIHVuZGVmaW5lZCwgaXQgcmV0dXJucyBvcHRpb25hbERlZmF1bHRWYWx1ZSBpbnN0ZWFkLlxuXHRnZXQ6IGZ1bmN0aW9uKGtleSwgb3B0aW9uYWxEZWZhdWx0VmFsdWUpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuc3RvcmFnZS5yZWFkKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSlcblx0XHRyZXR1cm4gdGhpcy5fZGVzZXJpYWxpemUoZGF0YSwgb3B0aW9uYWxEZWZhdWx0VmFsdWUpXG5cdH0sXG5cblx0Ly8gc2V0IHdpbGwgc3RvcmUgdGhlIGdpdmVuIHZhbHVlIGF0IGtleSBhbmQgcmV0dXJucyB2YWx1ZS5cblx0Ly8gQ2FsbGluZyBzZXQgd2l0aCB2YWx1ZSA9PT0gdW5kZWZpbmVkIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyByZW1vdmUuXG5cdHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoa2V5KVxuXHRcdH1cblx0XHR0aGlzLnN0b3JhZ2Uud3JpdGUodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5LCB0aGlzLl9zZXJpYWxpemUodmFsdWUpKVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXG5cdC8vIHJlbW92ZSBkZWxldGVzIHRoZSBrZXkgYW5kIHZhbHVlIHN0b3JlZCBhdCB0aGUgZ2l2ZW4ga2V5LlxuXHRyZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5KVxuXHR9LFxuXG5cdC8vIGVhY2ggd2lsbCBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyXG5cdC8vIGluIHRoaXMgc3RvcmUuXG5cdGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0dGhpcy5zdG9yYWdlLmVhY2goZnVuY3Rpb24odmFsLCBuYW1lc3BhY2VkS2V5KSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYsIHNlbGYuX2Rlc2VyaWFsaXplKHZhbCksIChuYW1lc3BhY2VkS2V5IHx8ICcnKS5yZXBsYWNlKHNlbGYuX25hbWVzcGFjZVJlZ2V4cCwgJycpKVxuXHRcdH0pXG5cdH0sXG5cblx0Ly8gY2xlYXJBbGwgd2lsbCByZW1vdmUgYWxsIHRoZSBzdG9yZWQga2V5LXZhbHVlIHBhaXJzIGluIHRoaXMgc3RvcmUuXG5cdGNsZWFyQWxsOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3JhZ2UuY2xlYXJBbGwoKVxuXHR9LFxuXG5cdC8vIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbid0IGxpdmUgaW4gcGx1Z2luc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQvLyBoYXNOYW1lc3BhY2UgcmV0dXJucyB0cnVlIGlmIHRoaXMgc3RvcmUgaW5zdGFuY2UgaGFzIHRoZSBnaXZlbiBuYW1lc3BhY2UuXG5cdGhhc05hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9uYW1lc3BhY2VQcmVmaXggPT0gJ19fc3RvcmVqc18nK25hbWVzcGFjZSsnXycpXG5cdH0sXG5cblx0Ly8gY3JlYXRlU3RvcmUgY3JlYXRlcyBhIHN0b3JlLmpzIGluc3RhbmNlIHdpdGggdGhlIGZpcnN0XG5cdC8vIGZ1bmN0aW9uaW5nIHN0b3JhZ2UgaW4gdGhlIGxpc3Qgb2Ygc3RvcmFnZSBjYW5kaWRhdGVzLFxuXHQvLyBhbmQgYXBwbGllcyB0aGUgdGhlIGdpdmVuIG1peGlucyB0byB0aGUgaW5zdGFuY2UuXG5cdGNyZWF0ZVN0b3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gY3JlYXRlU3RvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9LFxuXHRcblx0YWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHR0aGlzLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHR9LFxuXHRcblx0bmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gY3JlYXRlU3RvcmUodGhpcy5zdG9yYWdlLCB0aGlzLnBsdWdpbnMsIG5hbWVzcGFjZSlcblx0fVxufVxuXG5mdW5jdGlvbiBfd2FybigpIHtcblx0dmFyIF9jb25zb2xlID0gKHR5cGVvZiBjb25zb2xlID09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNvbnNvbGUpXG5cdGlmICghX2NvbnNvbGUpIHsgcmV0dXJuIH1cblx0dmFyIGZuID0gKF9jb25zb2xlLndhcm4gPyBfY29uc29sZS53YXJuIDogX2NvbnNvbGUubG9nKVxuXHRmbi5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShzdG9yYWdlcywgcGx1Z2lucywgbmFtZXNwYWNlKSB7XG5cdGlmICghbmFtZXNwYWNlKSB7XG5cdFx0bmFtZXNwYWNlID0gJydcblx0fVxuXHRpZiAoc3RvcmFnZXMgJiYgIWlzTGlzdChzdG9yYWdlcykpIHtcblx0XHRzdG9yYWdlcyA9IFtzdG9yYWdlc11cblx0fVxuXHRpZiAocGx1Z2lucyAmJiAhaXNMaXN0KHBsdWdpbnMpKSB7XG5cdFx0cGx1Z2lucyA9IFtwbHVnaW5zXVxuXHR9XG5cblx0dmFyIG5hbWVzcGFjZVByZWZpeCA9IChuYW1lc3BhY2UgPyAnX19zdG9yZWpzXycrbmFtZXNwYWNlKydfJyA6ICcnKVxuXHR2YXIgbmFtZXNwYWNlUmVnZXhwID0gKG5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoJ14nK25hbWVzcGFjZVByZWZpeCkgOiBudWxsKVxuXHR2YXIgbGVnYWxOYW1lc3BhY2VzID0gL15bYS16QS1aMC05X1xcLV0qJC8gLy8gYWxwaGEtbnVtZXJpYyArIHVuZGVyc2NvcmUgYW5kIGRhc2hcblx0aWYgKCFsZWdhbE5hbWVzcGFjZXMudGVzdChuYW1lc3BhY2UpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdzdG9yZS5qcyBuYW1lc3BhY2VzIGNhbiBvbmx5IGhhdmUgYWxwaGFudW1lcmljcyArIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMnKVxuXHR9XG5cdFxuXHR2YXIgX3ByaXZhdGVTdG9yZVByb3BzID0ge1xuXHRcdF9uYW1lc3BhY2VQcmVmaXg6IG5hbWVzcGFjZVByZWZpeCxcblx0XHRfbmFtZXNwYWNlUmVnZXhwOiBuYW1lc3BhY2VSZWdleHAsXG5cblx0XHRfdGVzdFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB0ZXN0U3RyID0gJ19fc3RvcmVqc19fdGVzdF9fJ1xuXHRcdFx0XHRzdG9yYWdlLndyaXRlKHRlc3RTdHIsIHRlc3RTdHIpXG5cdFx0XHRcdHZhciBvayA9IChzdG9yYWdlLnJlYWQodGVzdFN0cikgPT09IHRlc3RTdHIpXG5cdFx0XHRcdHN0b3JhZ2UucmVtb3ZlKHRlc3RTdHIpXG5cdFx0XHRcdHJldHVybiBva1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYXNzaWduUGx1Z2luRm5Qcm9wOiBmdW5jdGlvbihwbHVnaW5GblByb3AsIHByb3BOYW1lKSB7XG5cdFx0XHR2YXIgb2xkRm4gPSB0aGlzW3Byb3BOYW1lXVxuXHRcdFx0dGhpc1twcm9wTmFtZV0gPSBmdW5jdGlvbiBwbHVnaW5GbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDApXG5cdFx0XHRcdHZhciBzZWxmID0gdGhpc1xuXG5cdFx0XHRcdC8vIHN1cGVyX2ZuIGNhbGxzIHRoZSBvbGQgZnVuY3Rpb24gd2hpY2ggd2FzIG92ZXJ3cml0dGVuIGJ5XG5cdFx0XHRcdC8vIHRoaXMgbWl4aW4uXG5cdFx0XHRcdGZ1bmN0aW9uIHN1cGVyX2ZuKCkge1xuXHRcdFx0XHRcdGlmICghb2xkRm4pIHsgcmV0dXJuIH1cblx0XHRcdFx0XHRlYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnLCBpKSB7XG5cdFx0XHRcdFx0XHRhcmdzW2ldID0gYXJnXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm4gb2xkRm4uYXBwbHkoc2VsZiwgYXJncylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdpdmUgbWl4aW5nIGZ1bmN0aW9uIGFjY2VzcyB0byBzdXBlcl9mbiBieSBwcmVmaXhpbmcgYWxsIG1peGluIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGFyZ3VtZW50cyB3aXRoIHN1cGVyX2ZuLlxuXHRcdFx0XHR2YXIgbmV3Rm5BcmdzID0gW3N1cGVyX2ZuXS5jb25jYXQoYXJncylcblxuXHRcdFx0XHRyZXR1cm4gcGx1Z2luRm5Qcm9wLmFwcGx5KHNlbGYsIG5ld0ZuQXJncylcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKVxuXHRcdH0sXG5cblx0XHRfZGVzZXJpYWxpemU6IGZ1bmN0aW9uKHN0clZhbCwgZGVmYXVsdFZhbCkge1xuXHRcdFx0aWYgKCFzdHJWYWwpIHsgcmV0dXJuIGRlZmF1bHRWYWwgfVxuXHRcdFx0Ly8gSXQgaXMgcG9zc2libGUgdGhhdCBhIHJhdyBzdHJpbmcgdmFsdWUgaGFzIGJlZW4gcHJldmlvdXNseSBzdG9yZWRcblx0XHRcdC8vIGluIGEgc3RvcmFnZSB3aXRob3V0IHVzaW5nIHN0b3JlLmpzLCBtZWFuaW5nIGl0IHdpbGwgYmUgYSByYXdcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBpbnN0ZWFkIG9mIGEgSlNPTiBzZXJpYWxpemVkIHN0cmluZy4gQnkgZGVmYXVsdGluZ1xuXHRcdFx0Ly8gdG8gdGhlIHJhdyBzdHJpbmcgdmFsdWUgaW4gY2FzZSBvZiBhIEpTT04gcGFyc2UgZXJyb3IsIHdlIGFsbG93XG5cdFx0XHQvLyBmb3IgcGFzdCBzdG9yZWQgdmFsdWVzIHRvIGJlIGZvcndhcmRzLWNvbXBhdGlibGUgd2l0aCBzdG9yZS5qc1xuXHRcdFx0dmFyIHZhbCA9ICcnXG5cdFx0XHR0cnkgeyB2YWwgPSBKU09OLnBhcnNlKHN0clZhbCkgfVxuXHRcdFx0Y2F0Y2goZSkgeyB2YWwgPSBzdHJWYWwgfVxuXG5cdFx0XHRyZXR1cm4gKHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZGVmYXVsdFZhbClcblx0XHR9LFxuXHRcdFxuXHRcdF9hZGRTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHRpZiAodGhpcy5lbmFibGVkKSB7IHJldHVybiB9XG5cdFx0XHRpZiAodGhpcy5fdGVzdFN0b3JhZ2Uoc3RvcmFnZSkpIHtcblx0XHRcdFx0dGhpcy5zdG9yYWdlID0gc3RvcmFnZVxuXHRcdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9hZGRQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cblx0XHRcdC8vIElmIHRoZSBwbHVnaW4gaXMgYW4gYXJyYXksIHRoZW4gYWRkIGFsbCBwbHVnaW5zIGluIHRoZSBhcnJheS5cblx0XHRcdC8vIFRoaXMgYWxsb3dzIGZvciBhIHBsdWdpbiB0byBkZXBlbmQgb24gb3RoZXIgcGx1Z2lucy5cblx0XHRcdGlmIChpc0xpc3QocGx1Z2luKSkge1xuXHRcdFx0XHRlYWNoKHBsdWdpbiwgZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdFx0c2VsZi5fYWRkUGx1Z2luKHBsdWdpbilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgYWxsIHBsdWdpbnMgd2UndmUgc2VlbiBzbyBmYXIsIHNvIHRoYXQgd2Vcblx0XHRcdC8vIGRvbid0IGFkZCBhbnkgb2YgdGhlbSB0d2ljZS5cblx0XHRcdHZhciBzZWVuUGx1Z2luID0gcGx1Y2sodGhpcy5wbHVnaW5zLCBmdW5jdGlvbihzZWVuUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybiAocGx1Z2luID09PSBzZWVuUGx1Z2luKVxuXHRcdFx0fSlcblx0XHRcdGlmIChzZWVuUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKVxuXG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwbHVnaW4gaXMgcHJvcGVybHkgZm9ybWVkXG5cdFx0XHRpZiAoIWlzRnVuY3Rpb24ocGx1Z2luKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbnMgbXVzdCBiZSBmdW5jdGlvbiB2YWx1ZXMgdGhhdCByZXR1cm4gb2JqZWN0cycpXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwbHVnaW5Qcm9wZXJ0aWVzID0gcGx1Z2luLmNhbGwodGhpcylcblx0XHRcdGlmICghaXNPYmplY3QocGx1Z2luUHJvcGVydGllcykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW5zIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvZiBmdW5jdGlvbiBwcm9wZXJ0aWVzJylcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRoZSBwbHVnaW4gZnVuY3Rpb24gcHJvcGVydGllcyB0byB0aGlzIHN0b3JlIGluc3RhbmNlLlxuXHRcdFx0ZWFjaChwbHVnaW5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwbHVnaW5GblByb3AsIHByb3BOYW1lKSB7XG5cdFx0XHRcdGlmICghaXNGdW5jdGlvbihwbHVnaW5GblByb3ApKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgcGx1Z2luIHByb3BlcnR5OiAnK3Byb3BOYW1lKycgZnJvbSBwbHVnaW4gJytwbHVnaW4ubmFtZSsnLiBQbHVnaW5zIHNob3VsZCBvbmx5IHJldHVybiBmdW5jdGlvbnMuJylcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9hc3NpZ25QbHVnaW5GblByb3AocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSlcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRcblx0XHQvLyBQdXQgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGluIHRoZSBwcml2YXRlIEFQSSwgc28gYXMgdG8gbm90IGV4cG9zZSBpdCB0byBhY2NpZGVudGlhbFxuXHRcdC8vIGRpc2NvdmVyeSB0aHJvdWdoIGluc3BlY3Rpb24gb2YgdGhlIHN0b3JlIG9iamVjdC5cblx0XHRcblx0XHQvLyBEZXByZWNhdGVkOiBhZGRTdG9yYWdlXG5cdFx0YWRkU3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0X3dhcm4oJ3N0b3JlLmFkZFN0b3JhZ2Uoc3RvcmFnZSkgaXMgZGVwcmVjYXRlZC4gVXNlIGNyZWF0ZVN0b3JlKFtzdG9yYWdlc10pJylcblx0XHRcdHRoaXMuX2FkZFN0b3JhZ2Uoc3RvcmFnZSlcblx0XHR9XG5cdH1cblxuXHR2YXIgc3RvcmUgPSBjcmVhdGUoX3ByaXZhdGVTdG9yZVByb3BzLCBzdG9yZUFQSSwge1xuXHRcdHBsdWdpbnM6IFtdXG5cdH0pXG5cdHN0b3JlLnJhdyA9IHt9XG5cdGVhY2goc3RvcmUsIGZ1bmN0aW9uKHByb3AsIHByb3BOYW1lKSB7XG5cdFx0aWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcblx0XHRcdHN0b3JlLnJhd1twcm9wTmFtZV0gPSBiaW5kKHN0b3JlLCBwcm9wKVx0XHRcdFxuXHRcdH1cblx0fSlcblx0ZWFjaChzdG9yYWdlcywgZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdHN0b3JlLl9hZGRTdG9yYWdlKHN0b3JhZ2UpXG5cdH0pXG5cdGVhY2gocGx1Z2lucywgZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0c3RvcmUuX2FkZFBsdWdpbihwbHVnaW4pXG5cdH0pXG5cdHJldHVybiBzdG9yZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBqc29uMlBsdWdpblxuXG5mdW5jdGlvbiBqc29uMlBsdWdpbigpIHtcblx0cmVxdWlyZSgnLi9saWIvanNvbjInKVxuXHRyZXR1cm4ge31cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuXHQvLyBMaXN0ZWQgaW4gb3JkZXIgb2YgdXNhZ2UgcHJlZmVyZW5jZVxuXHRyZXF1aXJlKCcuL2xvY2FsU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL29sZEZGLWdsb2JhbFN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9vbGRJRS11c2VyRGF0YVN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9jb29raWVTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vc2Vzc2lvblN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9tZW1vcnlTdG9yYWdlJylcbl1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbXVsdGloYXNoID0gcmVxdWlyZSgnbXVsdGloYXNoZXMnKVxuY29uc3QgQ0lEID0gcmVxdWlyZSgnY2lkcycpXG5cbmNvbnN0IG5vdEVtcHR5ID0gZSA9PiBlICE9PSAnJyAmJiBlICE9PSAnICdcblxuY2xhc3MgT3JiaXREQkFkZHJlc3Mge1xuICBjb25zdHJ1Y3RvciAocm9vdCwgcGF0aCkge1xuICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICB0aGlzLnBhdGggPSBwYXRoXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbignL29yYml0ZGInLCB0aGlzLnJvb3QsIHRoaXMucGF0aClcbiAgfVxuXG4gIHN0YXRpYyBpc1ZhbGlkIChhZGRyZXNzKSB7XG4gICAgY29uc3QgY29udGFpbnNQcm90b2NvbFByZWZpeCA9IChlLCBpKSA9PiAhKChpID09PSAwIHx8IGkgPT09IDEpICYmIGFkZHJlc3MudG9TdHJpbmcoKS5pbmRleE9mKCcvb3JiaXQnKSA9PT0gMCAmJiBlID09PSAnb3JiaXRkYicpXG5cbiAgICBjb25zdCBwYXJ0cyA9IGFkZHJlc3MudG9TdHJpbmcoKVxuICAgICAgLnNwbGl0KCcvJylcbiAgICAgIC5maWx0ZXIoY29udGFpbnNQcm90b2NvbFByZWZpeClcbiAgICAgIC5maWx0ZXIobm90RW1wdHkpXG5cbiAgICBsZXQgYWNjZXNzQ29udHJvbGxlckhhc2hcblxuICAgIHRyeSB7XG4gICAgICBhY2Nlc3NDb250cm9sbGVySGFzaCA9IChwYXJ0c1swXS5pbmRleE9mKCd6ZCcpID4gLTEgfHwgcGFydHNbMF0uaW5kZXhPZignUW0nKSA+IC0xKVxuICAgICAgICA/IG5ldyBDSUQocGFydHNbMF0pLnRvQmFzZUVuY29kZWRTdHJpbmcoKVxuICAgICAgICA6IG51bGxcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXNzQ29udHJvbGxlckhhc2ggIT09IG51bGxcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZSAoYWRkcmVzcykge1xuICAgIGlmICghYWRkcmVzcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgT3JiaXREQiBhZGRyZXNzOiAke2FkZHJlc3N9YClcblxuICAgIGlmICghT3JiaXREQkFkZHJlc3MuaXNWYWxpZChhZGRyZXNzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgT3JiaXREQiBhZGRyZXNzOiAke2FkZHJlc3N9YClcblxuICAgIGNvbnN0IHBhcnRzID0gYWRkcmVzcy50b1N0cmluZygpXG4gICAgICAuc3BsaXQoJy8nKVxuICAgICAgLmZpbHRlcigoZSwgaSkgPT4gISgoaSA9PT0gMCB8fCBpID09PSAxKSAmJiBhZGRyZXNzLnRvU3RyaW5nKCkuaW5kZXhPZignL29yYml0JykgPT09IDAgJiYgZSA9PT0gJ29yYml0ZGInKSlcbiAgICAgIC5maWx0ZXIoZSA9PiBlICE9PSAnJyAmJiBlICE9PSAnICcpXG5cbiAgICByZXR1cm4gbmV3IE9yYml0REJBZGRyZXNzKHBhcnRzWzBdLCBwYXJ0cy5zbGljZSgxLCBwYXJ0cy5sZW5ndGgpLmpvaW4oJy8nKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9yYml0REJBZGRyZXNzXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIGlzSVBGUyA9IHJlcXVpcmUoJ2lzLWlwZnMnKTtcblxudmFyIEFQSSA9IHJlcXVpcmUoJy4vYXBpJyk7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgT1JCSVREQl9PUFRTID0gY29uZmlnLm9yYml0ZGJfb3B0aW9ucztcbnZhciBNT0RFUkFUT1IgPSAnTU9ERVJBVE9SJztcbnZhciBNRU1CRVIgPSAnTUVNQkVSJztcblxudmFyIGlzVmFsaWQzSUQgPSBmdW5jdGlvbiBpc1ZhbGlkM0lEKGRpZCkge1xuICB2YXIgcGFydHMgPSBkaWQuc3BsaXQoJzonKTtcbiAgaWYgKCFwYXJ0c1swXSA9PT0gJ2RpZCcgfHwgIXBhcnRzWzFdID09PSAnMycpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzSVBGUy5jaWQocGFydHNbMl0pO1xufTtcblxudmFyIFRocmVhZCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBQbGVhc2UgdXNlICoqc3BhY2Uuam9pblRocmVhZCoqIHRvIGdldCB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKi9cbiAgZnVuY3Rpb24gVGhyZWFkKG9yYml0ZGIsIG5hbWUsIHRocmVlSWQsIG1lbWJlcnMsIGZpcnN0TW9kZXJhdG9yLCBzdWJzY3JpYmUsIGVuc3VyZUNvbm5lY3RlZCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgVGhyZWFkKTtcbiAgICB0aGlzLl9vcmJpdGRiID0gb3JiaXRkYjtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9zcGFjZU5hbWUgPSBuYW1lLnNwbGl0KCcuJylbMl07XG4gICAgdGhpcy5fM2lkID0gdGhyZWVJZDtcbiAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkID0gZW5zdXJlQ29ubmVjdGVkO1xuICAgIHRoaXMuX3F1ZXVlZE5ld1Bvc3RzID0gW107XG4gICAgdGhpcy5fbWVtYmVycyA9IEJvb2xlYW4obWVtYmVycyk7XG4gICAgdGhpcy5fZmlyc3RNb2RlcmF0b3IgPSBmaXJzdE1vZGVyYXRvciB8fCB0aGlzLl8zaWQuZ2V0U3ViRElEKHRoaXMuX3NwYWNlTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBvc3QgYSBtZXNzYWdlIHRvIHRoZSB0aHJlYWRcbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBtZXNzYWdlICAgICAgICAgICAgICAgICBUaGUgbWVzc2FnZVxuICAgKiBAcmV0dXJuICAgIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBwb3N0SWQgb2YgdGhlIG5ldyBwb3N0XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShUaHJlYWQsIFt7XG4gICAga2V5OiBcInBvc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wb3N0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobWVzc2FnZSkge1xuICAgICAgICB2YXIgdGltZXN0YW1wO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUodGhpcy5fYWRkcmVzcywge1xuICAgICAgICAgICAgICAgICAgZmlyc3RNb2RlcmF0b3I6IHRoaXMuX2ZpcnN0TW9kZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgbWVtYmVyczogdGhpcy5fbWVtYmVycyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX25hbWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUNvbm5lY3RlZCh0aGlzLl9hZGRyZXNzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTsgLy8gc2Vjb25kc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5hZGQoe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcG9zdChfeCkge1xuICAgICAgICByZXR1cm4gX3Bvc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFRocmVhZEFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRUaHJlYWRBZGRyZXNzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIGFkZHJlc3M7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdENvbmZpZ3MoKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmJpdGRiLl9kZXRlcm1pbmVBZGRyZXNzKHRoaXMuX25hbWUsICdmZWVkJywge1xuICAgICAgICAgICAgICAgICAgYWNjZXNzQ29udHJvbGxlcjogdGhpcy5fYWNjZXNzQ29udHJvbGxlclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9jb250ZXh0Mi5zZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9nZXRUaHJlYWRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX2dldFRocmVhZEFkZHJlc3MyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0VGhyZWFkQWRkcmVzcztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBBZGQgYSBtb2RlcmF0b3IgdG8gdGhpcyB0aHJlYWQsIHRocm93cyBlcnJvciBpcyB1c2VyIGNhbiBub3QgYWRkIGEgbW9kZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGlkICAgICAgICAgICAgICAgICAgICAgIE1vZGVyYXRvciBJZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTW9kZXJhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWRkTW9kZXJhdG9yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGlkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gQVBJLmdldFNwYWNlRElEKGlkLCB0aGlzLl9zcGFjZU5hbWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZCA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZDNJRChpZCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWRkTW9kZXJhdG9yOiBtdXN0IHByb3ZpZGUgdmFsaWQgM0lEJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2RiLmFjY2Vzcy5ncmFudChNT0RFUkFUT1IsIGlkKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1vZGVyYXRvcihfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9hZGRNb2RlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZE1vZGVyYXRvcjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBMaXN0IG1vZGVyYXRvcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gICAge0FycmF5PFN0cmluZz59ICAgICAgQXJyYXkgb2YgbW9kZXJhdG9yIERJRHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxpc3RNb2RlcmF0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGlzdE1vZGVyYXRvcnMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5hY2Nlc3MuY2FwYWJpbGl0aWVzWydtb2RlcmF0b3JzJ10pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsaXN0TW9kZXJhdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIF9saXN0TW9kZXJhdG9ycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdE1vZGVyYXRvcnM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQWRkIGEgbWVtYmVyIHRvIHRoaXMgdGhyZWFkLCB0aHJvd3MgaWYgdXNlciBjYW4gbm90IGFkZCBtZW1iZXIsIHRocm93IGlzIG5vdCBtZW1iZXIgdGhyZWFkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIGlkICAgICAgICAgICAgICAgICAgICAgIE1lbWJlciBJZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTWVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYWRkTWVtYmVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGlkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0lmTm90TWVtYmVycygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFQSS5nZXRTcGFjZURJRChpZCwgdGhpcy5fc3BhY2VOYW1lKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWQgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQzSUQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZE1vZGVyYXRvcjogbXVzdCBwcm92aWRlIHZhbGlkIDNJRCcpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0lmTm90TWVtYmVycygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZGIuYWNjZXNzLmdyYW50KE1FTUJFUiwgaWQpKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1lbWJlcihfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9hZGRNZW1iZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZE1lbWJlcjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBMaXN0IG1lbWJlcnMsIHRocm93cyBpZiBub3QgbWVtYmVyIHRocmVhZFxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7QXJyYXk8U3RyaW5nPn0gICAgICBBcnJheSBvZiBtZW1iZXIgRElEc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdE1lbWJlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9saXN0TWVtYmVycyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dJZk5vdE1lbWJlcnMoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5hY2Nlc3MuY2FwYWJpbGl0aWVzWydtZW1iZXJzJ10pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsaXN0TWVtYmVycygpIHtcbiAgICAgICAgcmV0dXJuIF9saXN0TWVtYmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdE1lbWJlcnM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Rocm93SWZOb3RNZW1iZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmTm90TWVtYmVycygpIHtcbiAgICAgIGlmICghdGhpcy5fbWVtYmVycykgdGhyb3cgbmV3IEVycm9yKCdUaHJlYWQ6IE5vdCBhIG1lbWJlcnMgb25seSB0aHJlYWQsIGZ1bmN0aW9uIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHBvc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgaWQgICAgICAgICAgICAgICAgICAgICAgTW9kZXJhdG9yIElkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVQb3N0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGVsZXRlUG9zdCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhoYXNoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5yZW1vdmUoaGFzaCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBkZWxldGVQb3N0KF94NCkge1xuICAgICAgICByZXR1cm4gX2RlbGV0ZVBvc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlbGV0ZVBvc3Q7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwb3N0cywgYmFzZWQgb24gdGhlIG9wdGlvbnMuXG4gICAgICogSWYgaGFzaCBub3QgZm91bmQgd2hlbiBwYXNzaW5nIGd0LCBndGUsIGx0LCBvciBsdGUsXG4gICAgICogdGhlIGl0ZXJhdG9yIHdpbGwgcmV0dXJuIGFsbCBpdGVtcyAocmVzcGVjdGluZyBsaW1pdCBhbmQgcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgIG9wdHMgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMuZ3QgICAgICAgICAgICAgICAgIEdyZWF0ZXIgdGhhbiwgdGFrZXMgYW4gcG9zdElkXG4gICAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBvcHRzLmd0ZSAgICAgICAgICAgICAgICBHcmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8sIHRha2VzIGFuIHBvc3RJZFxuICAgICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgb3B0cy5sdCAgICAgICAgICAgICAgICAgTGVzcyB0aGFuLCB0YWtlcyBhbiBwb3N0SWRcbiAgICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgIG9wdHMubHRlICAgICAgICAgICAgICAgIExlc3MgdGhhbiBvciBlcXVhbCB0bywgdGFrZXMgYW4gcG9zdElkXG4gICAgICogQHBhcmFtICAgICB7SW50ZWdlcn0gICBvcHRzLmxpbWl0ICAgICAgICAgICAgICBMaW1pdGluZyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gcmVzdWx0LCBkZWZhdWx0cyB0byAtMSAobm8gbGltaXQpXG4gICAgICogQHBhcmFtICAgICB7Qm9vbGVhbn0gICBvcHRzLnJldmVyc2UgICAgICAgICAgICBJZiBzZXQgdG8gdHJ1ZSB3aWxsIHJlc3VsdCBpbiByZXZlcnNpbmcgdGhlIHJlc3VsdFxuICAgICAqXG4gICAgICogQHJldHVybiAgICB7QXJyYXk8T2JqZWN0Pn0gICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIHN1Y2Nlc3NmdWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0UG9zdHMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgoKSB7XG4gICAgICAgIHZhciBvcHRzLFxuICAgICAgICAgICAgX2FyZ3M4ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRzID0gX2FyZ3M4Lmxlbmd0aCA+IDAgJiYgX2FyZ3M4WzBdICE9PSB1bmRlZmluZWQgPyBfYXJnczhbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wdHMubGltaXQpIG9wdHMubGltaXQgPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9kYi5pdGVyYXRvcihvcHRzKS5jb2xsZWN0KCkubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBvc3QgPSBlbnRyeS5wYXlsb2FkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdmFyIG1ldGFEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0SWQ6IGVudHJ5Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcjogZW50cnkuaWRlbnRpdHkuaWRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtZXRhRGF0YSwgcG9zdCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQb3N0cygpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQb3N0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UG9zdHM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgbmV3IHVwZGF0ZXNcbiAgICAgKiBoYXZlIGJlZW4gcmVjZWl2ZWQgZnJvbSB0aGUgbmV0d29yayBvciBsb2NhbGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7RnVuY3Rpb259ICB1cGRhdGVGbiAgICAgICAgICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IGNhbGxlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25VcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vblVwZGF0ZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlOSh1cGRhdGVGbikge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlTG9hZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGIuZXZlbnRzLm9uKCdyZXBsaWNhdGVkJywgZnVuY3Rpb24gKGFkZHJlc3MsIGhhc2gsIGVudHJ5LCBwcm9nLCB0b3QpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUZuKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYi5ldmVudHMub24oJ3dyaXRlJywgZnVuY3Rpb24gKGRibmFtZSwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUZuKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uVXBkYXRlKF94NSkge1xuICAgICAgICByZXR1cm4gX29uVXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvblVwZGF0ZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZXZlcnkgbmV3XG4gICAgICogY2FwYWJpbGl0eSB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0aHJlYWQgYWNjZXNzIGNvbnRyb2xsZXIuXG4gICAgICogVGhpcyBpbmxjdWRlcyB3aGVuIGEgbW9kZXJhdG9yIG9yIG1lbWJlciBpcyBhZGRlZC5cbiAgICAgKiBUaGUgZnVuY3Rpb24gdGFrZXMgb25lIHBhcmFtZXRlciwgd2hpY2ggaXMgdGhlIGNhcGFiaWxpdGllcyBvYmosIG9yXG4gICAgICogeW91IGNhbiBjYWxsIGxpc3RNb2RlcmF0b3IgLyBsaXN0TWVtYmVycyBhZ2FpbiBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgICB7RnVuY3Rpb259ICB1cGRhdGVGbiAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBnZXQgY2FsbGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbk5ld0NhcGFiaWxpdGllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29uTmV3Q2FwYWJpbGl0aWVzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMCh1cGRhdGVGbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLl9kYi5hY2Nlc3Mub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUZuKF90aGlzLl9kYi5hY2Nlc3MuY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBvbk5ld0NhcGFiaWxpdGllcyhfeDYpIHtcbiAgICAgICAgcmV0dXJuIF9vbk5ld0NhcGFiaWxpdGllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb25OZXdDYXBhYmlsaXRpZXM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2FkMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEob2RiQWRkcmVzcykge1xuICAgICAgICB2YXIgaWRlbnRpdHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTExJChfY29udGV4dDExKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0Q29uZmlncygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZGVudGl0eSA9IHRoaXMuX2lkZW50aXR5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yYml0ZGIuZmVlZChvZGJBZGRyZXNzIHx8IHRoaXMuX25hbWUsIF9vYmplY3RTcHJlYWQoe30sIE9SQklUREJfT1BUUywge1xuICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IGlkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgYWNjZXNzQ29udHJvbGxlcjogdGhpcy5fYWNjZXNzQ29udHJvbGxlclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGIgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGIubG9hZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRyZXNzID0gdGhpcy5fZGIuYWRkcmVzcy50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlQ29ubmVjdGVkKHRoaXMuX2FkZHJlc3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2FkZHJlc3MpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfbG9hZChfeDcpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2xvYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlcXVpcmVMb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1aXJlTG9hZCgpIHtcbiAgICAgIGlmICghdGhpcy5fZGIpIHRocm93IG5ldyBFcnJvcignX2xvYWQgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGludGVyYWN0aW5nIHdpdGggdGhlIHN0b3JlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2xvc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEyKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUxvYWQoKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RiLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0Q29uZmlnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2luaXRDb25maWdzMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl8zaWQuZ2V0T2RiSWQodGhpcy5fc3BhY2VOYW1lKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5faWRlbnRpdHkgPSBfY29udGV4dDEzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZpcnN0TW9kZXJhdG9yLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiBBUEkuZ2V0U3BhY2VESUQodGhpcy5fZmlyc3RNb2RlcmF0b3IsIHRoaXMuX3NwYWNlTmFtZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcnN0TW9kZXJhdG9yID0gX2NvbnRleHQxMy5zZW50O1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB0aGlzLl9hY2Nlc3NDb250cm9sbGVyID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3RocmVhZC1hY2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgdGhyZWFkTmFtZTogdGhpcy5fbmFtZSxcbiAgICAgICAgICAgICAgICAgIG1lbWJlcnM6IHRoaXMuX21lbWJlcnMsXG4gICAgICAgICAgICAgICAgICBmaXJzdE1vZGVyYXRvcjogdGhpcy5fZmlyc3RNb2RlcmF0b3IsXG4gICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5faWRlbnRpdHlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfaW5pdENvbmZpZ3MoKSB7XG4gICAgICAgIHJldHVybiBfaW5pdENvbmZpZ3MyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfaW5pdENvbmZpZ3M7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkcmVzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RiID8gdGhpcy5fYWRkcmVzcyA6IG51bGw7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUaHJlYWQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGhyZWFkOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW5kZXgnKSxcbiAgICBmZXRjaFRleHQgPSBfcmVxdWlyZS5mZXRjaFRleHQsXG4gICAgZ2V0TWVzc2FnZUNvbnNlbnQgPSBfcmVxdWlyZS5nZXRNZXNzYWdlQ29uc2VudDtcblxudmFyIGRpZEpXVCA9IHJlcXVpcmUoJ2RpZC1qd3QnKTtcblxudmFyIGV0aGVycyA9IHJlcXVpcmUoJ2V0aGVycycpO1xuXG5yZXF1aXJlKCdodHRwcy1kaWQtcmVzb2x2ZXInKVtcImRlZmF1bHRcIl0oKTtcblxucmVxdWlyZSgnbXVwb3J0LWRpZC1yZXNvbHZlcicpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgZ2lzdCBjb250YWlucyB0aGUgZ2l2ZW4gbXVwb3J0RElEIGFuZCByZXR1cm5zIHRoZSB1c2VycyBnaXRodWIgdXNlcm5hbWUuXG4gICAqIFRocm93cyBhbiBlcnJvciBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBkaWQgICAgICAgICAgICAgICAgICAgICBUaGUgbXVwb3J0IERJRCBvZiB0aGUgdXNlclxuICAgKiBAcGFyYW0gICAgIHtPYmplY3R9ICAgICAgICAgICAgZ2lzdFVybCAgICAgICAgICAgICAgICAgVVJMIG9mIHRoZSBwcm9vZlxuICAgKiBAcmV0dXJuICAgIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdXNlcm5hbWUsIGFuZCBwcm9vZlxuICAgKi9cbiAgdmVyaWZ5R2l0aHViOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlHaXRodWIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoXG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRpZCwgZ2lzdFVybCkge1xuICAgICAgdmFyIGdpc3RGaWxlQ29udGVudCwgdXNlcm5hbWU7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISghZ2lzdFVybCB8fCBnaXN0VXJsLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hUZXh0KGdpc3RVcmwpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGdpc3RGaWxlQ29udGVudCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEoZ2lzdEZpbGVDb250ZW50LmluZGV4T2YoZGlkKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpc3QgRmlsZSBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIHRoZSBjb3JyZWN0IERJRCBvZiB0aGUgdXNlcicpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHVzZXJuYW1lID0gZ2lzdFVybC5zcGxpdCgnLycpWzNdO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGdpc3RVcmxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHZlcmlmeUdpdGh1YihfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3ZlcmlmeUdpdGh1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJpZnlHaXRodWI7XG4gIH0oKSxcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgdHdlZXQgY29udGFpbnMgdGhlIGdpdmVuIG11cG9ydERJRCBhbmQgcmV0dXJucyB0aGUgdXNlcnMgdHdpdHRlciB1c2VybmFtZS5cbiAgICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIGRpZCAgICAgICAgICAgICBUaGUgbXVwb3J0IERJRCBvZiB0aGUgdXNlclxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgY2xhaW0gICAgICAgICAgIEEgZGlkLUpXVCB3aXRoIGNsYWltXG4gICAqIEByZXR1cm4gICAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgdXNlcm5hbWUsIHByb29mLCBhbmQgdGhlIHZlcmlmaWVyXG4gICAqL1xuICB2ZXJpZnlUd2l0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlUd2l0dGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZGlkLCBjbGFpbSkge1xuICAgICAgdmFyIHZlcmlmaWVkLCBjbGFpbURhdGE7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKGNsYWltKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gZGlkSldULnZlcmlmeUpXVChjbGFpbSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdmVyaWZpZWQgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoISh2ZXJpZmllZC5wYXlsb2FkLnN1YiAhPT0gZGlkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVyaWZpY2F0aW9uIG5vdCB2YWxpZCBmb3IgZ2l2ZW4gdXNlcicpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNsYWltRGF0YSA9IHZlcmlmaWVkLnBheWxvYWQuY2xhaW07XG5cbiAgICAgICAgICAgICAgaWYgKCEoIWNsYWltRGF0YS50d2l0dGVyX2hhbmRsZSB8fCAhY2xhaW1EYXRhLnR3aXR0ZXJfcHJvb2YpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsYWltIGZvciB5b3VyIHR3aXR0ZXIgaXMgbm90IGNvcnJlY3QnKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBjbGFpbURhdGEudHdpdHRlcl9oYW5kbGUsXG4gICAgICAgICAgICAgICAgcHJvb2Y6IGNsYWltRGF0YS50d2l0dGVyX3Byb29mLFxuICAgICAgICAgICAgICAgIHZlcmlmaWVkQnk6IHZlcmlmaWVkLnBheWxvYWQuaXNzXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiB2ZXJpZnlUd2l0dGVyKF94MywgX3g0KSB7XG4gICAgICByZXR1cm4gX3ZlcmlmeVR3aXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZ5VHdpdHRlcjtcbiAgfSgpLFxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjb2RlIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgdGhlIHNhbWUgb25lIHRoYXQgd2FzIHNlbnQgdmlhIGVtYWlsLlxuICAgKiBUaHJvd3MgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0gICAgIHtTdHJpbmd9ICAgICAgICAgICAgZGlkICAgICAgICAgICAgIFRoZSBtdXBvcnQgRElEIG9mIHRoZSB1c2VyXG4gICAqIEBwYXJhbSAgICAge1N0cmluZ30gICAgICAgICAgICBjbGFpbSAgICAgICAgICAgQSBkaWQtSldUIHdpdGggY2xhaW1cbiAgICogQHJldHVybiAgICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB1c2VybmFtZSwgcHJvb2YsIGFuZCB0aGUgdmVyaWZpZXJcbiAgICovXG4gIHZlcmlmeUVtYWlsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlFbWFpbCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGRpZCwgY2xhaW0pIHtcbiAgICAgIHZhciB2ZXJpZmllZCwgY2xhaW1EYXRhO1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmIChjbGFpbSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIGRpZEpXVC52ZXJpZnlKV1QoY2xhaW0pO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHZlcmlmaWVkID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEodmVyaWZpZWQucGF5bG9hZC5zdWIgIT09IGRpZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcmlmaWNhdGlvbiBub3QgdmFsaWQgZm9yIGdpdmVuIHVzZXInKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjbGFpbURhdGEgPSB2ZXJpZmllZC5wYXlsb2FkLmNsYWltO1xuXG4gICAgICAgICAgICAgIGlmIChjbGFpbURhdGEuZW1haWxfYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGFpbSBmb3IgeW91ciBlbWFpbCBhZGRyZXNzIGlzIG5vdCBjb3JyZWN0Jyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBlbWFpbF9hZGRyZXNzOiBjbGFpbURhdGEuZW1haWxfYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB2ZXJpZmllZEJ5OiB2ZXJpZmllZC5wYXlsb2FkLmlzc1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gdmVyaWZ5RW1haWwoX3g1LCBfeDYpIHtcbiAgICAgIHJldHVybiBfdmVyaWZ5RW1haWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZ5RW1haWw7XG4gIH0oKSxcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgcHJvb2YgZm9yIGEgZGlkIGlzIGNvcnJlY3RcbiAgICpcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICAgICAgICAgIGNsYWltICAgICAgICAgICBBIGRpZC1KV1Qgd2l0aCBjbGFpbVxuICAgKiBAcmV0dXJuICAgIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBESUQgb2YgdGhlIHVzZXJcbiAgICovXG4gIHZlcmlmeURJRDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdmVyaWZ5RElEID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoY2xhaW0pIHtcbiAgICAgIHZhciB2ZXJpZmllZDtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBkaWRKV1QudmVyaWZ5SldUKGNsYWltKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB2ZXJpZmllZCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCB2ZXJpZmllZC5wYXlsb2FkLmlzcyk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gdmVyaWZ5RElEKF94Nykge1xuICAgICAgcmV0dXJuIF92ZXJpZnlESUQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmVyaWZ5RElEO1xuICB9KCksXG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoYXQgdGhlIHByb29mIGZvciBhbiBldGhlcmV1bSBhZGRyZXNzIGlzIGNvcnJlY3RcbiAgICpcbiAgICogQHBhcmFtICAgICB7T2JqZWN0fSAgICBldGhQcm9vZiAgICAgICAgICAgICAgICAgICAgICBUaGUgY2xhaW0gZ2VuZXJhdGVkIGJ5IGdldExpbmtDb25zZW50XG4gICAqIEBwYXJhbSAgICAge3N0cmluZ30gICAgZXRoUHJvb2YuY29uc2VudF9tc2dcbiAgICogQHBhcmFtICAgICB7c3RyaW5nfSAgICBldGhQcm9vZi5jb25zZW50X3NpZ25hdHVyZVxuICAgKiBAcGFyYW0gICAgIHtzdHJpbmd9ICAgIGV0aFByb29mLmxpbmtlZF9kaWRcbiAgICogQHBhcmFtICAgICB7U3RyaW5nfSAgICBkaWQgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYm94JyBkaWRcbiAgICogQHJldHVybiAgICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZXRoZXJldW0gYWRkcmVzcyB1c2VkIHRvIHNpZ24gdGhlIG1lc3NhZ2VcbiAgICovXG4gIHZlcmlmeUV0aGVyZXVtOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF92ZXJpZnlFdGhlcmV1bSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKShcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGV0aFByb29mLCBkaWQpIHtcbiAgICAgIHZhciBjb25zZW50TXNnLCBjb25zZW50U2lnLCBleHBlY3RlZDtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjb25zZW50TXNnID0gZXRoUHJvb2YudmVyc2lvbiA/IGV0aFByb29mLm1lc3NhZ2UgOiBldGhQcm9vZlsnY29uc2VudF9tc2cnXTtcbiAgICAgICAgICAgICAgY29uc2VudFNpZyA9IGV0aFByb29mLnZlcnNpb24gPyBldGhQcm9vZi5zaWduYXR1cmUgOiBldGhQcm9vZlsnY29uc2VudF9zaWduYXR1cmUnXTsgLy8gTWFrZSBzdXJlIHRoZSBtZXNzYWdlIG1hdGNoZXMgb3VyIGV4cGVjdGF0aW9uXG5cbiAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBnZXRNZXNzYWdlQ29uc2VudChkaWQpO1xuXG4gICAgICAgICAgICAgIGlmICghKGNvbnNlbnRNc2cgIT09IGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uc2VudCBtZXNzYWdlLCBnb3Q6IFxcXCJcIi5jb25jYXQoY29uc2VudE1zZywgXCJcXFwiLCBleHBlY3RlZDogXFxcIlwiKS5jb25jYXQoZXhwZWN0ZWQsIFwiXFxcIlwiKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgZXRoZXJzLnV0aWxzLnZlcmlmeU1lc3NhZ2UoY29uc2VudE1zZywgY29uc2VudFNpZykpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHZlcmlmeUV0aGVyZXVtKF94OCwgX3g5KSB7XG4gICAgICByZXR1cm4gX3ZlcmlmeUV0aGVyZXVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcmlmeUV0aGVyZXVtO1xuICB9KClcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIHR5cGVzXzIgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuQ2xpZW50RXJyb3IgPSB0eXBlc18yLkNsaWVudEVycm9yO1xucmVxdWlyZShcImNyb3NzLWZldGNoL3BvbHlmaWxsXCIpO1xudmFyIEdyYXBoUUxDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhRTENsaWVudCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIEdyYXBoUUxDbGllbnQucHJvdG90eXBlLnJhd1JlcXVlc3QgPSBmdW5jdGlvbiAocXVlcnksIHZhcmlhYmxlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGhlYWRlcnMsIG90aGVycywgYm9keSwgcmVzcG9uc2UsIHJlc3VsdCwgaGVhZGVyc18xLCBzdGF0dXNfMSwgZXJyb3JSZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMub3B0aW9ucywgaGVhZGVycyA9IF9hLmhlYWRlcnMsIG90aGVycyA9IF9fcmVzdChfYSwgW1wiaGVhZGVyc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyA/IHZhcmlhYmxlcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2godGhpcy51cmwsIF9fYXNzaWduKHsgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sIGhlYWRlcnMpLCBib2R5OiBib2R5IH0sIG90aGVycykpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRSZXN1bHQocmVzcG9uc2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmICFyZXN1bHQuZXJyb3JzICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc18xID0gcmVzcG9uc2UuaGVhZGVycywgc3RhdHVzXzEgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9fYXNzaWduKHt9LCByZXN1bHQsIHsgaGVhZGVyczogaGVhZGVyc18xLCBzdGF0dXM6IHN0YXR1c18xIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVzdWx0ID0gdHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgPyB7IGVycm9yOiByZXN1bHQgfSA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5DbGllbnRFcnJvcihfX2Fzc2lnbih7fSwgZXJyb3JSZXN1bHQsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMgfSksIHsgcXVlcnk6IHF1ZXJ5LCB2YXJpYWJsZXM6IHZhcmlhYmxlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaFFMQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHF1ZXJ5LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBoZWFkZXJzLCBvdGhlcnMsIGJvZHksIHJlc3BvbnNlLCByZXN1bHQsIGVycm9yUmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLm9wdGlvbnMsIGhlYWRlcnMgPSBfYS5oZWFkZXJzLCBvdGhlcnMgPSBfX3Jlc3QoX2EsIFtcImhlYWRlcnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMgPyB2YXJpYWJsZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHRoaXMudXJsLCBfX2Fzc2lnbih7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCBoZWFkZXJzKSwgYm9keTogYm9keSB9LCBvdGhlcnMpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0UmVzdWx0KHJlc3BvbnNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAhcmVzdWx0LmVycm9ycyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuZGF0YV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnID8geyBlcnJvcjogcmVzdWx0IH0gOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuQ2xpZW50RXJyb3IoX19hc3NpZ24oe30sIGVycm9yUmVzdWx0LCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH0pLCB7IHF1ZXJ5OiBxdWVyeSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhRTENsaWVudC5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBHcmFwaFFMQ2xpZW50LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMub3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVycyA9IChfYSA9IHt9LCBfYVtrZXldID0gdmFsdWUsIF9hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoUUxDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5HcmFwaFFMQ2xpZW50ID0gR3JhcGhRTENsaWVudDtcbmZ1bmN0aW9uIHJhd1JlcXVlc3QodXJsLCBxdWVyeSwgdmFyaWFibGVzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xpZW50O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgR3JhcGhRTENsaWVudCh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNsaWVudC5yYXdSZXF1ZXN0KHF1ZXJ5LCB2YXJpYWJsZXMpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJhd1JlcXVlc3QgPSByYXdSZXF1ZXN0O1xuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIHF1ZXJ5LCB2YXJpYWJsZXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbGllbnQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyBHcmFwaFFMQ2xpZW50KHVybCk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2xpZW50LnJlcXVlc3QocXVlcnksIHZhcmlhYmxlcyldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0O1xuZnVuY3Rpb24gZ2V0UmVzdWx0KHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGVudFR5cGU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlLnRleHQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiIWZ1bmN0aW9uKGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGUpOihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMpLmV0aGVycz1lKCl9KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIG8ocyxhLHUpe2Z1bmN0aW9uIGwodCxlKXtpZighYVt0XSl7aWYoIXNbdF0pe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWUmJnIpcmV0dXJuIHIodCwhMCk7aWYoaClyZXR1cm4gaCh0LCEwKTt2YXIgbj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK3QrXCInXCIpO3Rocm93IG4uY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixufXZhciBpPWFbdF09e2V4cG9ydHM6e319O3NbdF1bMF0uY2FsbChpLmV4cG9ydHMsZnVuY3Rpb24oZSl7cmV0dXJuIGwoc1t0XVsxXVtlXXx8ZSl9LGksaS5leHBvcnRzLG8scyxhLHUpfXJldHVybiBhW3RdLmV4cG9ydHN9Zm9yKHZhciBoPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsZT0wO2U8dS5sZW5ndGg7ZSsrKWwodVtlXSk7cmV0dXJuIGx9KHsxOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci52ZXJzaW9uPVwiNC4wLjQ4XCJ9LHt9XSwyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vdXRpbHMvcHJvcGVydGllc1wiKSxpPShvLmlzU2lnbmVyPWZ1bmN0aW9uKGUpe3JldHVybiBuLmlzVHlwZShlLFwiU2lnbmVyXCIpfSxvKTtmdW5jdGlvbiBvKCl7bi5zZXRUeXBlKHRoaXMsXCJTaWduZXJcIil9ci5TaWduZXI9aX0se1wiLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSwzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vdXRpbHMvYmlnbnVtYmVyXCIpO3IuQWRkcmVzc1plcm89XCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtyLkhhc2haZXJvPVwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7ci5FdGhlclN5bWJvbD1cIlxcdTAzOWVcIjt2YXIgaT1uLmJpZ051bWJlcmlmeSgtMSk7ci5OZWdhdGl2ZU9uZT1pO3ZhciBvPW4uYmlnTnVtYmVyaWZ5KDApO3IuWmVybz1vO3ZhciBzPW4uYmlnTnVtYmVyaWZ5KDEpO3IuT25lPXM7dmFyIGE9bi5iaWdOdW1iZXJpZnkoMik7ci5Ud289YTt2YXIgdT1uLmJpZ051bWJlcmlmeShcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIik7ci5XZWlQZXJFdGhlcj11O3ZhciBsPW4uYmlnTnVtYmVyaWZ5KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO3IuTWF4VWludDI1Nj1sfSx7XCIuL3V0aWxzL2JpZ251bWJlclwiOjYzfV0sNDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyx1PWUoXCIuL2NvbnN0YW50c1wiKSxsPW8oZShcIi4vZXJyb3JzXCIpKSxoPWUoXCIuL3V0aWxzL2FiaS1jb2RlclwiKSxhPWUoXCIuL3V0aWxzL2FkZHJlc3NcIiksZj1lKFwiLi91dGlscy9iaWdudW1iZXJcIiksYz1lKFwiLi91dGlscy9ieXRlc1wiKSxkPWUoXCIuL3V0aWxzL2ludGVyZmFjZVwiKSxwPWUoXCIuL3V0aWxzL3Byb3BlcnRpZXNcIiksdj1lKFwiLi9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcIikseT1lKFwiLi9hYnN0cmFjdC1zaWduZXJcIiksbT0ocz15LlNpZ25lcixpKGcscyksZy5wcm90b3R5cGUuZ2V0QWRkcmVzcz1mdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKX0sZy5wcm90b3R5cGUuX2ZhaWw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe2wudGhyb3dFcnJvcihlLGwuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246dH0pfSl9LGcucHJvdG90eXBlLnNpZ25NZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiBtZXNzYWdlc1wiLFwic2lnbk1lc3NhZ2VcIil9LGcucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHJhbnNhY3Rpb25zXCIsXCJzZW5kVHJhbnNhY3Rpb25cIil9LGcucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBnKHRoaXMuYWRkcmVzcyxlKX0sZyk7ZnVuY3Rpb24gZyhlLHQpe3ZhciByPXMuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gcC5kZWZpbmVSZWFkT25seShyLFwiYWRkcmVzc1wiLGUpLHAuZGVmaW5lUmVhZE9ubHkocixcInByb3ZpZGVyXCIsdCkscn1yLlZvaWRTaWduZXI9bTt2YXIgYj17Y2hhaW5JZDohMCxkYXRhOiEwLGZyb206ITAsZ2FzTGltaXQ6ITAsZ2FzUHJpY2U6ITAsbm9uY2U6ITAsdG86ITAsdmFsdWU6ITB9O2Z1bmN0aW9uIHcobyxlLHMpe3ZhciBhPW8uaW50ZXJmYWNlLmZ1bmN0aW9uc1tlXTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dmFyIGk9e30scj1udWxsO2lmKGUubGVuZ3RoPT09YS5pbnB1dHMubGVuZ3RoKzEmJlwib2JqZWN0XCI9PXR5cGVvZiBlW2UubGVuZ3RoLTFdKWZvcih2YXIgbiBpbiBudWxsIT0oaT1wLnNoYWxsb3dDb3B5KGUucG9wKCkpKS5ibG9ja1RhZyYmKHI9aS5ibG9ja1RhZyksZGVsZXRlIGkuYmxvY2tUYWcsaSlpZighYltuXSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiK24pO2lmKGUubGVuZ3RoIT1hLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIik7cmV0dXJuW1wiZGF0YVwiLFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbihlKXtudWxsIT1pW2VdJiZsLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIrZSxsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOmV9KX0pLGkudG89by5fZGVwbG95ZWQocikudGhlbihmdW5jdGlvbigpe3JldHVybiBvLmFkZHJlc3NQcm9taXNlfSksZnVuY3Rpb24gbihpLG8sZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIHM9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlLHQpe3ZhciByPW51bGwscj1BcnJheS5pc0FycmF5KG8pP29bdF06b1tlLm5hbWVdO3MucHVzaChuKGkscixlKSl9KSxQcm9taXNlLmFsbChzKX1pZihcImFkZHJlc3NcIj09PWUudHlwZSlyZXR1cm4gaS5yZXNvbHZlTmFtZShvKTtpZihcInR1cGxlXCI9PT1lLnR5cGUpcmV0dXJuIG4oaSxvLGUuY29tcG9uZW50cyk7dmFyIHQ9ZS50eXBlLm1hdGNoKC8oLiopKFxcW1swLTldKlxcXSQpLyk7aWYodCl7aWYoIUFycmF5LmlzQXJyYXkobykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIik7dmFyIHI9W10sYT17Y29tcG9uZW50czplLmNvbXBvbmVudHMsdHlwZTp0WzFdfTtyZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IucHVzaChuKGksZSxhKSl9KSxQcm9taXNlLmFsbChyKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG8pfShvLnByb3ZpZGVyLGUsYS5pbnB1dHMpLnRoZW4oZnVuY3Rpb24obil7aWYoaS5kYXRhPWEuZW5jb2RlKG4pLFwiY2FsbFwiPT09YS50eXBlKXJldHVybiBzP1Byb21pc2UucmVzb2x2ZSh1Llplcm8pOihvLnByb3ZpZGVyfHxsLnRocm93RXJyb3IoXCJjYWxsIChjb25zdGFudCBmdW5jdGlvbnMpIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiY2FsbFwifSksW1wiZ2FzTGltaXRcIixcImdhc1ByaWNlXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKG51bGwhPWlbZV0pdGhyb3cgbmV3IEVycm9yKFwiY2FsbCBjYW5ub3Qgb3ZlcnJpZGUgXCIrZSl9KSxudWxsPT1pLmZyb20mJm8uc2lnbmVyJiYoaS5mcm9tPW8uc2lnbmVyLmdldEFkZHJlc3MoKSksby5wcm92aWRlci5jYWxsKGkscikudGhlbihmdW5jdGlvbih0KXt2YXIgZTtjLmhleERhdGFMZW5ndGgodCklMzI9PTQmJlwiMHgwOGMzNzlhMFwiPT09Yy5oZXhEYXRhU2xpY2UodCwwLDQpJiYoZT1oLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLGMuaGV4RGF0YVNsaWNlKHQsNCkpLGwudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiLGwuQ0FMTF9FWENFUFRJT04se2FkZHJlc3M6by5hZGRyZXNzLGFyZ3M6bixtZXRob2Q6YS5zaWduYXR1cmUsZXJyb3JTaWduYXR1cmU6XCJFcnJvcihzdHJpbmcpXCIsZXJyb3JBcmdzOltlXSxyZWFzb246ZSx0cmFuc2FjdGlvbjppfSkpO3RyeXt2YXIgcj1hLmRlY29kZSh0KTtyZXR1cm4gMT09PWEub3V0cHV0cy5sZW5ndGgmJihyPXJbMF0pLHJ9Y2F0Y2goZSl7dGhyb3dcIjB4XCI9PT10JiYwPGEub3V0cHV0cy5sZW5ndGgmJmwudGhyb3dFcnJvcihcImNhbGwgZXhjZXB0aW9uXCIsbC5DQUxMX0VYQ0VQVElPTix7YWRkcmVzczpvLmFkZHJlc3MsbWV0aG9kOmEuc2lnbmF0dXJlLGFyZ3M6bn0pLGV9fSkpO2lmKFwidHJhbnNhY3Rpb25cIj09PWEudHlwZSlyZXR1cm4gcz8oby5wcm92aWRlcnx8bC50aHJvd0Vycm9yKFwiZXN0aW1hdGUgZ2FzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiZXN0aW1hdGVHYXNcIn0pLG51bGw9PWkuZnJvbSYmby5zaWduZXImJihpLmZyb209by5zaWduZXIuZ2V0QWRkcmVzcygpKSxvLnByb3ZpZGVyLmVzdGltYXRlR2FzKGkpKToobnVsbD09aS5nYXNMaW1pdCYmbnVsbCE9YS5nYXMmJihpLmdhc0xpbWl0PWYuYmlnTnVtYmVyaWZ5KGEuZ2FzKS5hZGQoMjFlMykpLG8uc2lnbmVyfHxsLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VuZFRyYW5zYWN0aW9uXCJ9KSxudWxsIT1pLmZyb20mJmwudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBmcm9tIGluIGEgdHJhbnNhY3Rpb25cIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2VuZFRyYW5zYWN0aW9uXCJ9KSxvLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24oaSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLndhaXQuYmluZChlKTtyZXR1cm4gZS53YWl0PWZ1bmN0aW9uKGUpe3JldHVybiB0KGUpLnRoZW4oZnVuY3Rpb24obil7cmV0dXJuIG4uZXZlbnRzPW4ubG9ncy5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9cC5kZWVwQ29weShlKSxyPW8uaW50ZXJmYWNlLnBhcnNlTG9nKGUpO3JldHVybiByJiYodC5hcmdzPXIudmFsdWVzLHQuZGVjb2RlPXIuZGVjb2RlLHQuZXZlbnQ9ci5uYW1lLHQuZXZlbnRTaWduYXR1cmU9ci5zaWduYXR1cmUpLHQucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oKXtyZXR1cm4gby5wcm92aWRlcn0sdC5nZXRCbG9jaz1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldEJsb2NrKG4uYmxvY2tIYXNoKX0sdC5nZXRUcmFuc2FjdGlvbj1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKG4udHJhbnNhY3Rpb25IYXNoKX0sdC5nZXRUcmFuc2FjdGlvblJlY2VpcHQ9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4pfSx0fSksbn0pfSxlfSkpO3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZSAtIFwiK2EudHlwZSl9KX19ZnVuY3Rpb24gXyhlKXtyZXR1cm4hZS5hZGRyZXNzfHxudWxsIT1lLnRvcGljcyYmMCE9PWUudG9waWNzLmxlbmd0aD8oZS5hZGRyZXNzfHxcIipcIikrXCJAXCIrKGUudG9waWNzP2UudG9waWNzLmpvaW4oXCI6XCIpOlwiXCIpOlwiKlwifXZhciBNPShBLnByb3RvdHlwZS5kZXBsb3llZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kZXBsb3llZCgpfSxBLnByb3RvdHlwZS5fZGVwbG95ZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5fZGVwbG95ZWRQcm9taXNlfHwodGhpcy5kZXBsb3lUcmFuc2FjdGlvbj90aGlzLl9kZXBsb3llZFByb21pc2U9dGhpcy5kZXBsb3lUcmFuc2FjdGlvbi53YWl0KCkudGhlbihmdW5jdGlvbigpe3JldHVybiB0fSk6dGhpcy5fZGVwbG95ZWRQcm9taXNlPXRoaXMucHJvdmlkZXIuZ2V0Q29kZSh0aGlzLmFkZHJlc3MsZSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm5cIjB4XCI9PT1lJiZsLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIixsLlVOU1VQUE9SVEVEX09QRVJBVElPTix7Y29udHJhY3RBZGRyZXNzOnQuYWRkcmVzcyxvcGVyYXRpb246XCJnZXREZXBsb3llZFwifSksdH0pKSx0aGlzLl9kZXBsb3llZFByb21pc2V9LEEucHJvdG90eXBlLmZhbGxiYWNrPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5zaWduZXJ8fGwudGhyb3dFcnJvcihcInNlbmRpbmcgYSB0cmFuc2FjdGlvbiByZXF1aXJlcyBhIHNpZ25lclwiLGwuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCJ9KTt2YXIgcj1wLnNoYWxsb3dDb3B5KGV8fHt9KTtyZXR1cm5bXCJmcm9tXCIsXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGwhPXJbZV0mJmwudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIitlLGwuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246ZX0pfSksci50bz10aGlzLmFkZHJlc3NQcm9taXNlLHRoaXMuZGVwbG95ZWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2lnbmVyLnNlbmRUcmFuc2FjdGlvbihyKX0pfSxBLnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1uZXcgbShlLHRoaXMucHJvdmlkZXIpKTt2YXIgdD1uZXcgQSh0aGlzLmFkZHJlc3MsdGhpcy5pbnRlcmZhY2UsZSk7cmV0dXJuIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24mJnAuZGVmaW5lUmVhZE9ubHkodCxcImRlcGxveVRyYW5zYWN0aW9uXCIsdGhpcy5kZXBsb3lUcmFuc2FjdGlvbiksdH0sQS5wcm90b3R5cGUuYXR0YWNoPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgQShlLHRoaXMuaW50ZXJmYWNlLHRoaXMuc2lnbmVyfHx0aGlzLnByb3ZpZGVyKX0sQS5pc0luZGV4ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGQuSW50ZXJmYWNlLmlzSW5kZXhlZChlKX0sQS5wcm90b3R5cGUuX2dldEV2ZW50RmlsdGVyPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXM7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKFwiKlwiPT09ZSlyZXR1cm57cHJlcGFyZUV2ZW50OmZ1bmN0aW9uKGUpe3ZhciB0PXIuaW50ZXJmYWNlLnBhcnNlTG9nKGUpO3JldHVybiB0JiYoZS5hcmdzPXQudmFsdWVzLGUuZGVjb2RlPXQuZGVjb2RlLGUuZXZlbnQ9dC5uYW1lLGUuZXZlbnRTaWduYXR1cmU9dC5zaWduYXR1cmUpLFtlXX0sZXZlbnRUYWc6XCIqXCIsZmlsdGVyOnthZGRyZXNzOnRoaXMuYWRkcmVzc319Oy0xIT09ZS5pbmRleE9mKFwiKFwiKSYmKGU9aC5mb3JtYXRTaWduYXR1cmUoaC5wYXJzZVNpZ25hdHVyZShcImV2ZW50IFwiK2UpKSk7dmFyIG49dGhpcy5pbnRlcmZhY2UuZXZlbnRzW2VdO258fGwudGhyb3dFcnJvcihcInVua25vd24gZXZlbnQgLSBcIitlLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1uZXQ6XCJldmVudE5hbWVcIix2YWx1ZTplfSk7dmFyIHQ9e2FkZHJlc3M6dGhpcy5hZGRyZXNzLHRvcGljczpbbi50b3BpY119O3JldHVybntwcmVwYXJlRXZlbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bi5kZWNvZGUoZS5kYXRhLGUudG9waWNzKTtlLmFyZ3M9dDt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KTtyZXR1cm4gci5wdXNoKGUpLHJ9LGV2ZW50Om4sZXZlbnRUYWc6Xyh0KSxmaWx0ZXI6dH19dmFyIGk9e2FkZHJlc3M6dGhpcy5hZGRyZXNzfSxvPW51bGw7aWYoZS50b3BpY3MmJmUudG9waWNzWzBdKWZvcih2YXIgcyBpbiBpLnRvcGljcz1lLnRvcGljcyx0aGlzLmludGVyZmFjZS5ldmVudHMpaWYoLTEhPT1zLmluZGV4T2YoXCIoXCIpKXt2YXIgYT10aGlzLmludGVyZmFjZS5ldmVudHNbc107aWYoYS50b3BpYz09PWUudG9waWNzWzBdLnRvTG93ZXJDYXNlKCkpe289YTticmVha319cmV0dXJue3ByZXBhcmVFdmVudDpmdW5jdGlvbihlKXtpZighbylyZXR1cm5bZV07dmFyIHQ9by5kZWNvZGUoZS5kYXRhLGUudG9waWNzKTtlLmFyZ3M9dDt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KTtyZXR1cm4gci5wdXNoKGUpLHJ9LGV2ZW50Om8sZXZlbnRUYWc6XyhpKSxmaWx0ZXI6aX19LEEucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKG4saSxlKXt2YXIgbz10aGlzO3RoaXMucHJvdmlkZXJ8fGwudGhyb3dFcnJvcihcImV2ZW50cyByZXF1aXJlIGEgcHJvdmlkZXIgb3IgYSBzaWduZXIgd2l0aCBhIHByb3ZpZGVyXCIsbC5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIm9uY2VcIn0pO2Z1bmN0aW9uIHQoZSl7dmFyIHQ9cC5kZWVwQ29weShlKSxyPW4ucHJlcGFyZUV2ZW50KHQpO24uZXZlbnQmJih0LmRlY29kZT1uLmV2ZW50LmRlY29kZSx0LmV2ZW50PW4uZXZlbnQubmFtZSx0LmV2ZW50U2lnbmF0dXJlPW4uZXZlbnQuc2lnbmF0dXJlKSx0LnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKCl7by5yZW1vdmVMaXN0ZW5lcihuLmZpbHRlcixpKX0sdC5nZXRCbG9jaz1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldEJsb2NrKGUuYmxvY2tIYXNoKX0sdC5nZXRUcmFuc2FjdGlvbj1mdW5jdGlvbigpe3JldHVybiBvLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGUudHJhbnNhY3Rpb25IYXNoKX0sdC5nZXRUcmFuc2FjdGlvblJlY2VpcHQ9ZnVuY3Rpb24oKXtyZXR1cm4gby5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoZS50cmFuc2FjdGlvbkhhc2gpfSxvLmVtaXQuYXBwbHkobyxbbi5maWx0ZXJdLmNvbmNhdChyKSl9dGhpcy5wcm92aWRlci5vbihuLmZpbHRlcix0KSx0aGlzLl9ldmVudHMucHVzaCh7ZXZlbnRGaWx0ZXI6bixsaXN0ZW5lcjppLHdyYXBwZWRMaXN0ZW5lcjp0LG9uY2U6ZX0pfSxBLnByb3RvdHlwZS5vbj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRoaXMuX2dldEV2ZW50RmlsdGVyKGUpLHQsITEpLHRoaXN9LEEucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRFdmVudEZpbHRlcihlKSx0LCEwKSx0aGlzfSxBLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm9uKGUsdCl9LEEucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMscj1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKylyW24tMV09YXJndW1lbnRzW25dO2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiExO3ZhciBpPSExLG89dGhpcy5fZ2V0RXZlbnRGaWx0ZXIoZSk7cmV0dXJuIHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnIT09by5ldmVudFRhZ3x8KHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmxpc3RlbmVyLmFwcGx5KHQscil9LDApLGk9ITAsIWUub25jZSl9KSxpfSxBLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiAwO3ZhciB0PXRoaXMuX2dldEV2ZW50RmlsdGVyKGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnPT09dC5ldmVudFRhZ30pLmxlbmd0aH0sQS5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybltdO3ZhciB0PXRoaXMuX2dldEV2ZW50RmlsdGVyKGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnPT09dC5ldmVudFRhZ30pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5saXN0ZW5lcn0pfSxBLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdGhpcy5wcm92aWRlcilyZXR1cm4gdGhpczt2YXIgcj10aGlzLl9nZXRFdmVudEZpbHRlcihlKTtyZXR1cm4gdGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZXZlbnRGaWx0ZXIuZXZlbnRUYWchPT1yLmV2ZW50VGFnfHwodC5wcm92aWRlci5yZW1vdmVMaXN0ZW5lcihlLmV2ZW50RmlsdGVyLmZpbHRlcixlLndyYXBwZWRMaXN0ZW5lciksITEpfSksdGhpc30sQS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiB0aGlzO3ZhciBuPSExLGk9dGhpcy5fZ2V0RXZlbnRGaWx0ZXIoZSk7cmV0dXJuIHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50RmlsdGVyLmV2ZW50VGFnIT09aS5ldmVudFRhZ3x8KGUubGlzdGVuZXIhPT10fHwoci5wcm92aWRlci5yZW1vdmVMaXN0ZW5lcihlLmV2ZW50RmlsdGVyLmZpbHRlcixlLndyYXBwZWRMaXN0ZW5lciksISFufHwhKG49ITApKSl9KSx0aGlzfSxBKTtmdW5jdGlvbiBBKHQsZSxyKXt2YXIgbj10aGlzO2lmKGwuY2hlY2tOZXcodGhpcyxBKSxkLkludGVyZmFjZS5pc0ludGVyZmFjZShlKT9wLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJpbnRlcmZhY2VcIixlKTpwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJpbnRlcmZhY2VcIixuZXcgZC5JbnRlcmZhY2UoZSkpLHkuU2lnbmVyLmlzU2lnbmVyKHIpPyhwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcm92aWRlclwiLHIucHJvdmlkZXIpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInNpZ25lclwiLHIpKTp2LlByb3ZpZGVyLmlzUHJvdmlkZXIocik/KHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInByb3ZpZGVyXCIscikscC5kZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIsbnVsbCkpOmwudGhyb3dFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJzaWduZXJPclByb3ZpZGVyXCIsdmFsdWU6cn0pLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImVzdGltYXRlXCIse30pLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImZ1bmN0aW9uc1wiLHt9KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJmaWx0ZXJzXCIse30pLE9iamVjdC5rZXlzKHRoaXMuaW50ZXJmYWNlLmV2ZW50cykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcj1uLmludGVyZmFjZS5ldmVudHNbZV07cC5kZWZpbmVSZWFkT25seShuLmZpbHRlcnMsZSxmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtyZXR1cm57YWRkcmVzczpuLmFkZHJlc3MsdG9waWNzOnIuZW5jb2RlVG9waWNzKGUpfX0pfSksdGhpcy5fZXZlbnRzPVtdLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIix0KSx0aGlzLnByb3ZpZGVyKXAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NQcm9taXNlXCIsdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZSh0KS50aGVuKGZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwibmFtZSBub3QgZm91bmRcIik7cmV0dXJuIGV9KS5jYXRjaChmdW5jdGlvbihlKXt0aHJvdyBlfSkpO2Vsc2UgdHJ5e3AuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NQcm9taXNlXCIsUHJvbWlzZS5yZXNvbHZlKGEuZ2V0QWRkcmVzcyh0KSkpfWNhdGNoKGUpe2wudGhyb3dFcnJvcihcInByb3ZpZGVyIGlzIHJlcXVpcmVkIHRvIHVzZSBub24tYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcImFkZHJlc3NPck5hbWVcIix2YWx1ZTp0fSl9T2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXcobixlLCExKTtudWxsPT1uW2VdP3AuZGVmaW5lUmVhZE9ubHkobixlLHQpOmwud2FybihcIldBUk5JTkc6IE11bHRpcGxlIGRlZmluaXRpb25zIGZvciBcIitlKSxudWxsPT1uLmZ1bmN0aW9uc1tlXSYmKHAuZGVmaW5lUmVhZE9ubHkobi5mdW5jdGlvbnMsZSx0KSxwLmRlZmluZVJlYWRPbmx5KG4uZXN0aW1hdGUsZSx3KG4sZSwhMCkpKX0pfXIuQ29udHJhY3Q9TTt2YXIgRT0oUy5wcm90b3R5cGUuZ2V0RGVwbG95VHJhbnNhY3Rpb249ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07dmFyIHI9e307aWYoZS5sZW5ndGg9PT10aGlzLmludGVyZmFjZS5kZXBsb3lGdW5jdGlvbi5pbnB1dHMubGVuZ3RoKzEpZm9yKHZhciBuIGluIHI9cC5zaGFsbG93Q29weShlLnBvcCgpKSlpZighYltuXSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiK24pO3JldHVybltcImRhdGFcIixcImZyb21cIixcInRvXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9cltlXSYmbC50aHJvd0Vycm9yKFwiY2Fubm90IG92ZXJyaWRlIFwiK2UsbC5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjplfSl9KSxsLmNoZWNrQXJndW1lbnRDb3VudChlLmxlbmd0aCx0aGlzLmludGVyZmFjZS5kZXBsb3lGdW5jdGlvbi5pbnB1dHMubGVuZ3RoLFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpLHIuZGF0YT10aGlzLmludGVyZmFjZS5kZXBsb3lGdW5jdGlvbi5lbmNvZGUodGhpcy5ieXRlY29kZSxlKSxyfSxTLnByb3RvdHlwZS5kZXBsb3k9ZnVuY3Rpb24oKXtmb3IodmFyIHI9dGhpcyxlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO3ZhciBuPXRoaXMuZ2V0RGVwbG95VHJhbnNhY3Rpb24uYXBwbHkodGhpcyxlKTtyZXR1cm4gdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKG4pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IE0oYS5nZXRDb250cmFjdEFkZHJlc3MoZSksci5pbnRlcmZhY2Usci5zaWduZXIpO3JldHVybiBwLmRlZmluZVJlYWRPbmx5KHQsXCJkZXBsb3lUcmFuc2FjdGlvblwiLGUpLHR9KX0sUy5wcm90b3R5cGUuYXR0YWNoPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgTShlLHRoaXMuaW50ZXJmYWNlLHRoaXMuc2lnbmVyKX0sUy5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFModGhpcy5pbnRlcmZhY2UsdGhpcy5ieXRlY29kZSxlKX0sUy5mcm9tU29saWRpdHk9ZnVuY3Rpb24oZSx0KXtudWxsPT1lJiZsLnRocm93RXJyb3IoXCJtaXNzaW5nIGNvbXBpbGVyIG91dHB1dFwiLGwuTUlTU0lOR19BUkdVTUVOVCx7YXJndW1lbnQ6XCJjb21waWxlck91dHB1dFwifSksXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPUpTT04ucGFyc2UoZSkpO3ZhciByPWUuYWJpLG49bnVsbDtyZXR1cm4gZS5ieXRlY29kZT9uPWUuYnl0ZWNvZGU6ZS5ldm0mJmUuZXZtLmJ5dGVjb2RlJiYobj1lLmV2bS5ieXRlY29kZSksbmV3IFMocixuLHQpfSxTKTtmdW5jdGlvbiBTKGUsdCxyKXt2YXIgbj1udWxsO1wic3RyaW5nXCI9PXR5cGVvZiB0P249dDpjLmlzQXJyYXlpc2godCk/bj1jLmhleGxpZnkodCk6XCJzdHJpbmdcIj09dHlwZW9mIHQub2JqZWN0P249dC5vYmplY3Q6bC50aHJvd0Vycm9yKFwiYnl0ZWNvZGUgbXVzdCBiZSBhIHZhbGlkIGhleCBzdHJpbmdcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpcImJ5dGVjb2RlXCIsdmFsdWU6dH0pLFwiMHhcIiE9PW4uc3Vic3RyaW5nKDAsMikmJihuPVwiMHhcIituKSxjLmlzSGV4U3RyaW5nKG4pfHxsLnRocm93RXJyb3IoXCJieXRlY29kZSBtdXN0IGJlIGEgdmFsaWQgaGV4IHN0cmluZ1wiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiYnl0ZWNvZGVcIix2YWx1ZTp0fSksbi5sZW5ndGglMiE9MCYmbC50aHJvd0Vycm9yKFwiYnl0ZWNvZGUgbXVzdCBiZSB2YWxpZCBkYXRhIChldmVuIGxlbmd0aClcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpcImJ5dGVjb2RlXCIsdmFsdWU6dH0pLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImJ5dGVjb2RlXCIsbiksZC5JbnRlcmZhY2UuaXNJbnRlcmZhY2UoZSk/cC5kZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsZSk6cC5kZWZpbmVSZWFkT25seSh0aGlzLFwiaW50ZXJmYWNlXCIsbmV3IGQuSW50ZXJmYWNlKGUpKSxyJiYheS5TaWduZXIuaXNTaWduZXIocikmJmwudGhyb3dFcnJvcihcImludmFsaWQgc2lnbmVyXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJzaWduZXJcIix2YWx1ZTpudWxsfSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwic2lnbmVyXCIscnx8bnVsbCl9ci5Db250cmFjdEZhY3Rvcnk9RX0se1wiLi9hYnN0cmFjdC1zaWduZXJcIjoyLFwiLi9jb25zdGFudHNcIjozLFwiLi9lcnJvcnNcIjo1LFwiLi9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcIjo1MCxcIi4vdXRpbHMvYWJpLWNvZGVyXCI6NTksXCIuL3V0aWxzL2FkZHJlc3NcIjo2MCxcIi4vdXRpbHMvYmlnbnVtYmVyXCI6NjMsXCIuL3V0aWxzL2J5dGVzXCI6NjQsXCIuL3V0aWxzL2ludGVyZmFjZVwiOjY5LFwiLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSw1OltmdW5jdGlvbihlLHQscyl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9ZShcIi4vX3ZlcnNpb25cIik7cy5VTktOT1dOX0VSUk9SPVwiVU5LTk9XTl9FUlJPUlwiLHMuTk9UX0lNUExFTUVOVEVEPVwiTk9UX0lNUExFTUVOVEVEXCIscy5NSVNTSU5HX05FVz1cIk1JU1NJTkdfTkVXXCIscy5DQUxMX0VYQ0VQVElPTj1cIkNBTExfRVhDRVBUSU9OXCIscy5JTlZBTElEX0FSR1VNRU5UPVwiSU5WQUxJRF9BUkdVTUVOVFwiLHMuTUlTU0lOR19BUkdVTUVOVD1cIk1JU1NJTkdfQVJHVU1FTlRcIixzLlVORVhQRUNURURfQVJHVU1FTlQ9XCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIscy5OVU1FUklDX0ZBVUxUPVwiTlVNRVJJQ19GQVVMVFwiLHMuSU5TVUZGSUNJRU5UX0ZVTkRTPVwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIscy5OT05DRV9FWFBJUkVEPVwiTk9OQ0VfRVhQSVJFRFwiLHMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQ9XCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO3ZhciByPSEocy5VTlNVUFBPUlRFRF9PUEVSQVRJT049XCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiksdT0hMTtmdW5jdGlvbiBuKGUsdCxyKXtpZih1KXRocm93IG5ldyBFcnJvcihcInVua25vd24gZXJyb3JcIik7dD10fHxzLlVOS05PV05fRVJST1Iscj1yfHx7fTt2YXIgbj1bXTtPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3RyeXtuLnB1c2godCtcIj1cIitKU09OLnN0cmluZ2lmeShyW3RdKSl9Y2F0Y2goZSl7bi5wdXNoKHQrXCI9XCIrSlNPTi5zdHJpbmdpZnkoclt0XS50b1N0cmluZygpKSl9fSksbi5wdXNoKFwidmVyc2lvbj1cIithLnZlcnNpb24pO3ZhciBpPWU7bi5sZW5ndGgmJihlKz1cIiAoXCIrbi5qb2luKFwiLCBcIikrXCIpXCIpO3ZhciBvPW5ldyBFcnJvcihlKTt0aHJvdyBvLnJlYXNvbj1pLG8uY29kZT10LE9iamVjdC5rZXlzKHIpLmZvckVhY2goZnVuY3Rpb24oZSl7b1tlXT1yW2VdfSksb31zLnRocm93RXJyb3I9bixzLmNoZWNrTmV3PWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHR8fG4oXCJtaXNzaW5nIG5ld1wiLHMuTUlTU0lOR19ORVcse25hbWU6dC5uYW1lfSl9LHMuY2hlY2tBcmd1bWVudENvdW50PWZ1bmN0aW9uKGUsdCxyKXtyPXJ8fFwiXCIsZTx0JiZuKFwibWlzc2luZyBhcmd1bWVudFwiK3Iscy5NSVNTSU5HX0FSR1VNRU5ULHtjb3VudDplLGV4cGVjdGVkQ291bnQ6dH0pLHQ8ZSYmbihcInRvbyBtYW55IGFyZ3VtZW50c1wiK3Iscy5VTkVYUEVDVEVEX0FSR1VNRU5ULHtjb3VudDplLGV4cGVjdGVkQ291bnQ6dH0pfSxzLnNldENlbnNvcnNoaXA9ZnVuY3Rpb24oZSx0KXtyJiZuKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIixzLlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwic2V0Q2Vuc29yc2hpcFwifSksdT0hIWUscj0hIXR9LHMuY2hlY2tOb3JtYWxpemU9ZnVuY3Rpb24oKXt0cnl7aWYoW1wiTkZEXCIsXCJORkNcIixcIk5GS0RcIixcIk5GS0NcIl0uZm9yRWFjaChmdW5jdGlvbih0KXt0cnl7XCJ0ZXN0XCIubm9ybWFsaXplKHQpfWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIrdCl9fSksU3RyaW5nLmZyb21DaGFyQ29kZSgyMzMpLm5vcm1hbGl6ZShcIk5GRFwiKSE9PVN0cmluZy5mcm9tQ2hhckNvZGUoMTAxLDc2OSkpdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpfWNhdGNoKGUpe24oXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIscy5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsZm9ybTplLm1lc3NhZ2V9KX19O3ZhciBpPXtkZWJ1ZzoxLGRlZmF1bHQ6MixpbmZvOjIsd2FybjozLGVycm9yOjQsb2ZmOjV9LG89aS5kZWZhdWx0O2Z1bmN0aW9uIGwoZSx0KXtvPmlbZV18fGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsdCl9ZnVuY3Rpb24gaCgpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllW3RdPWFyZ3VtZW50c1t0XTtsKFwid2FyblwiLGUpfXMuc2V0TG9nTGV2ZWw9ZnVuY3Rpb24oZSl7dmFyIHQ9aVtlXTtudWxsIT10P289dDpoKFwiaW52bGlhZCBsb2cgbGV2ZWwgLSBcIitlKX0scy53YXJuPWgscy5pbmZvPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO2woXCJpbmZvXCIsZSl9fSx7XCIuL192ZXJzaW9uXCI6MX1dLDY6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPWUoXCIuL2NvbnRyYWN0XCIpO3IuQ29udHJhY3Q9aS5Db250cmFjdCxyLkNvbnRyYWN0RmFjdG9yeT1pLkNvbnRyYWN0RmFjdG9yeSxyLlZvaWRTaWduZXI9aS5Wb2lkU2lnbmVyO3ZhciBvPWUoXCIuL2Fic3RyYWN0LXNpZ25lclwiKTtyLlNpZ25lcj1vLlNpZ25lcjt2YXIgcz1lKFwiLi93YWxsZXRcIik7ci5XYWxsZXQ9cy5XYWxsZXQ7dmFyIGE9bihlKFwiLi9jb25zdGFudHNcIikpO3IuY29uc3RhbnRzPWE7dmFyIHU9bihlKFwiLi9lcnJvcnNcIikpO3IuZXJyb3JzPXU7dmFyIGw9bihlKFwiLi9wcm92aWRlcnNcIikpO3IucHJvdmlkZXJzPWw7dmFyIGg9bihlKFwiLi91dGlsc1wiKSk7ci51dGlscz1oO3ZhciBmPW4oZShcIi4vd29yZGxpc3RzXCIpKTtyLndvcmRsaXN0cz1mO3ZhciBjPWUoXCIuL3V0aWxzL3NoaW1zXCIpO3IucGxhdGZvcm09Yy5wbGF0Zm9ybTt2YXIgZD1lKFwiLi9fdmVyc2lvblwiKTtyLnZlcnNpb249ZC52ZXJzaW9uLHIuZ2V0RGVmYXVsdFByb3ZpZGVyPWZ1bmN0aW9uKGUpe251bGw9PWUmJihlPVwiaG9tZXN0ZWFkXCIpO3ZhciB0PWguZ2V0TmV0d29yayhlKTtyZXR1cm4gdCYmdC5fZGVmYXVsdFByb3ZpZGVyfHx1LnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLHUuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXREZWZhdWx0UHJvdmlkZXJcIixuZXR3b3JrOmV9KSx0Ll9kZWZhdWx0UHJvdmlkZXIobCl9fSx7XCIuL192ZXJzaW9uXCI6MSxcIi4vYWJzdHJhY3Qtc2lnbmVyXCI6MixcIi4vY29uc3RhbnRzXCI6MyxcIi4vY29udHJhY3RcIjo0LFwiLi9lcnJvcnNcIjo1LFwiLi9wcm92aWRlcnNcIjo1NCxcIi4vdXRpbHNcIjo2OCxcIi4vdXRpbHMvc2hpbXNcIjo4MCxcIi4vd2FsbGV0XCI6ODgsXCIuL3dvcmRsaXN0c1wiOjg5fV0sNzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9bihlKFwiLi9ldGhlcnNcIikpO3IuZXRoZXJzPWksZnVuY3Rpb24oZSl7Zm9yKHZhciB0IGluIGUpci5oYXNPd25Qcm9wZXJ0eSh0KXx8KHJbdF09ZVt0XSl9KGUoXCIuL2V0aGVyc1wiKSl9LHtcIi4vZXRoZXJzXCI6Nn1dLDg6W2Z1bmN0aW9uKGUsQyxMKXtcInVzZSBzdHJpY3RcIjshZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihlKXtyZXR1cm4gcGFyc2VJbnQoZSk9PT1lfWZ1bmN0aW9uIG4oZSl7aWYocihlLmxlbmd0aCkpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKWlmKCFyKGVbdF0pfHxlW3RdPDB8fDI1NTxlW3RdKXJldHVybjtyZXR1cm4gMX19ZnVuY3Rpb24gbyhlLHQpe2lmKGUuYnVmZmVyJiZBcnJheUJ1ZmZlci5pc1ZpZXcoZSkmJlwiVWludDhBcnJheVwiPT09ZS5uYW1lKXJldHVybiB0JiYoZT1lLnNsaWNlP2Uuc2xpY2UoKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSksZTtpZihBcnJheS5pc0FycmF5KGUpKXtpZighbihlKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheSBjb250YWlucyBpbnZhbGlkIHZhbHVlOiBcIitlKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZSl9aWYocihlLmxlbmd0aCkmJm4oZSkpcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO3Rocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFycmF5LWxpa2Ugb2JqZWN0XCIpfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGUpfWZ1bmN0aW9uIHMoZSx0LHIsbixpKXtudWxsPT1uJiZudWxsPT1pfHwoZT1lLnNsaWNlP2Uuc2xpY2UobixpKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLG4saSkpLHQuc2V0KGUscil9dmFyIGksdD17dG9CeXRlczpmdW5jdGlvbihlKXt2YXIgdD1bXSxyPTA7Zm9yKGU9ZW5jb2RlVVJJKGUpO3I8ZS5sZW5ndGg7KXt2YXIgbj1lLmNoYXJDb2RlQXQocisrKTszNz09PW4/KHQucHVzaChwYXJzZUludChlLnN1YnN0cihyLDIpLDE2KSkscis9Mik6dC5wdXNoKG4pfXJldHVybiBvKHQpfSxmcm9tQnl0ZXM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoOyl7dmFyIG49ZVtyXTtuPDEyOD8odC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUobikpLHIrKyk6MTkxPG4mJm48MjI0Pyh0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbik8PDZ8NjMmZVtyKzFdKSkscis9Mik6KHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgxNSZuKTw8MTJ8KDYzJmVbcisxXSk8PDZ8NjMmZVtyKzJdKSkscis9Myl9cmV0dXJuIHQuam9pbihcIlwiKX19LGE9KGk9XCIwMTIzNDU2Nzg5YWJjZGVmXCIse3RvQnl0ZXM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrPTIpdC5wdXNoKHBhcnNlSW50KGUuc3Vic3RyKHIsMiksMTYpKTtyZXR1cm4gdH0sZnJvbUJ5dGVzOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPWVbcl07dC5wdXNoKGlbKDI0MCZuKT4+NF0raVsxNSZuXSl9cmV0dXJuIHQuam9pbihcIlwiKX19KSxmPXsxNjoxMCwyNDoxMiwzMjoxNH0sYz1bMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDVdLGQ9Wzk5LDEyNCwxMTksMTIzLDI0MiwxMDcsMTExLDE5Nyw0OCwxLDEwMyw0MywyNTQsMjE1LDE3MSwxMTgsMjAyLDEzMCwyMDEsMTI1LDI1MCw4OSw3MSwyNDAsMTczLDIxMiwxNjIsMTc1LDE1NiwxNjQsMTE0LDE5MiwxODMsMjUzLDE0NywzOCw1NCw2MywyNDcsMjA0LDUyLDE2NSwyMjksMjQxLDExMywyMTYsNDksMjEsNCwxOTksMzUsMTk1LDI0LDE1MCw1LDE1NCw3LDE4LDEyOCwyMjYsMjM1LDM5LDE3OCwxMTcsOSwxMzEsNDQsMjYsMjcsMTEwLDkwLDE2MCw4Miw1OSwyMTQsMTc5LDQxLDIyNyw0NywxMzIsODMsMjA5LDAsMjM3LDMyLDI1MiwxNzcsOTEsMTA2LDIwMywxOTAsNTcsNzQsNzYsODgsMjA3LDIwOCwyMzksMTcwLDI1MSw2Nyw3Nyw1MSwxMzMsNjksMjQ5LDIsMTI3LDgwLDYwLDE1OSwxNjgsODEsMTYzLDY0LDE0MywxNDYsMTU3LDU2LDI0NSwxODgsMTgyLDIxOCwzMywxNiwyNTUsMjQzLDIxMCwyMDUsMTIsMTksMjM2LDk1LDE1MSw2OCwyMywxOTYsMTY3LDEyNiw2MSwxMDAsOTMsMjUsMTE1LDk2LDEyOSw3OSwyMjAsMzQsNDIsMTQ0LDEzNiw3MCwyMzgsMTg0LDIwLDIyMiw5NCwxMSwyMTksMjI0LDUwLDU4LDEwLDczLDYsMzYsOTIsMTk0LDIxMSwxNzIsOTgsMTQ1LDE0OSwyMjgsMTIxLDIzMSwyMDAsNTUsMTA5LDE0MSwyMTMsNzgsMTY5LDEwOCw4NiwyNDQsMjM0LDEwMSwxMjIsMTc0LDgsMTg2LDEyMCwzNyw0NiwyOCwxNjYsMTgwLDE5OCwyMzIsMjIxLDExNiwzMSw3NSwxODksMTM5LDEzOCwxMTIsNjIsMTgxLDEwMiw3MiwzLDI0NiwxNCw5Nyw1Myw4NywxODUsMTM0LDE5MywyOSwxNTgsMjI1LDI0OCwxNTIsMTcsMTA1LDIxNywxNDIsMTQ4LDE1NSwzMCwxMzUsMjMzLDIwNiw4NSw0MCwyMjMsMTQwLDE2MSwxMzcsMTMsMTkxLDIzMCw2NiwxMDQsNjUsMTUzLDQ1LDE1LDE3Niw4NCwxODcsMjJdLGw9WzgyLDksMTA2LDIxMyw0OCw1NCwxNjUsNTYsMTkxLDY0LDE2MywxNTgsMTI5LDI0MywyMTUsMjUxLDEyNCwyMjcsNTcsMTMwLDE1NSw0NywyNTUsMTM1LDUyLDE0Miw2Nyw2OCwxOTYsMjIyLDIzMywyMDMsODQsMTIzLDE0OCw1MCwxNjYsMTk0LDM1LDYxLDIzOCw3NiwxNDksMTEsNjYsMjUwLDE5NSw3OCw4LDQ2LDE2MSwxMDIsNDAsMjE3LDM2LDE3OCwxMTgsOTEsMTYyLDczLDEwOSwxMzksMjA5LDM3LDExNCwyNDgsMjQ2LDEwMCwxMzQsMTA0LDE1MiwyMiwyMTIsMTY0LDkyLDIwNCw5MywxMDEsMTgyLDE0NiwxMDgsMTEyLDcyLDgwLDI1MywyMzcsMTg1LDIxOCw5NCwyMSw3MCw4NywxNjcsMTQxLDE1NywxMzIsMTQ0LDIxNiwxNzEsMCwxNDAsMTg4LDIxMSwxMCwyNDcsMjI4LDg4LDUsMTg0LDE3OSw2OSw2LDIwOCw0NCwzMCwxNDMsMjAyLDYzLDE1LDIsMTkzLDE3NSwxODksMywxLDE5LDEzOCwxMDcsNTgsMTQ1LDE3LDY1LDc5LDEwMywyMjAsMjM0LDE1MSwyNDIsMjA3LDIwNiwyNDAsMTgwLDIzMCwxMTUsMTUwLDE3MiwxMTYsMzQsMjMxLDE3Myw1MywxMzMsMjI2LDI0OSw1NSwyMzIsMjgsMTE3LDIyMywxMTAsNzEsMjQxLDI2LDExMywyOSw0MSwxOTcsMTM3LDExMSwxODMsOTgsMTQsMTcwLDI0LDE5MCwyNywyNTIsODYsNjIsNzUsMTk4LDIxMCwxMjEsMzIsMTU0LDIxOSwxOTIsMjU0LDEyMCwyMDUsOTAsMjQ0LDMxLDIyMSwxNjgsNTEsMTM2LDcsMTk5LDQ5LDE3NywxOCwxNiw4OSwzOSwxMjgsMjM2LDk1LDk2LDgxLDEyNywxNjksMjUsMTgxLDc0LDEzLDQ1LDIyOSwxMjIsMTU5LDE0NywyMDEsMTU2LDIzOSwxNjAsMjI0LDU5LDc3LDE3NCw0MiwyNDUsMTc2LDIwMCwyMzUsMTg3LDYwLDEzMSw4MywxNTMsOTcsMjMsNDMsNCwxMjYsMTg2LDExOSwyMTQsMzgsMjI1LDEwNSwyMCw5OSw4NSwzMywxMiwxMjVdLGg9WzMzMjg0MDIzNDEsNDE2ODkwNzkwOCw0MDAwODA2ODA5LDQxMzUyODc2OTMsNDI5NDExMTc1NywzNTk3MzY0MTU3LDM3MzE4NDUwNDEsMjQ0NTY1NzQyOCwxNjEzNzcwODMyLDMzNjIwMjI3LDM0NjI4ODMyNDEsMTQ0NTY2OTc1NywzODkyMjQ4MDg5LDMwNTA4MjE0NzQsMTMwMzA5NjI5NCwzOTY3MTg2NTg2LDI0MTI0MzE5NDEsNTI4NjQ2ODEzLDIzMTE3MDI4NDgsNDIwMjUyODEzNSw0MDI2MjAyNjQ1LDI5OTIyMDAxNzEsMjM4NzAzNjEwNSw0MjI2ODcxMzA3LDExMDE5MDEyOTIsMzAxNzA2OTY3MSwxNjA0NDk0MDc3LDExNjkxNDE3MzgsNTk3NDY2MzAzLDE0MDMyOTkwNjMsMzgzMjcwNTY4NiwyNjEzMTAwNjM1LDE5NzQ5NzQ0MDIsMzc5MTUxOTAwNCwxMDMzMDgxNzc0LDEyNzc1Njg2MTgsMTgxNTQ5MjE4NiwyMTE4MDc0MTc3LDQxMjY2Njg1NDYsMjIxMTIzNjk0MywxNzQ4MjUxNzQwLDEzNjk4MTA0MjAsMzUyMTUwNDU2NCw0MTkzMzgyNjY0LDM3OTkwODU0NTksMjg4MzExNTEyMywxNjQ3MzkxMDU5LDcwNjAyNDc2NywxMzQ0ODA5MDgsMjUxMjg5Nzg3NCwxMTc2NzA3OTQxLDI2NDY4NTI0NDYsODA2ODg1NDE2LDkzMjYxNTg0MSwxNjgxMDExMzUsNzk4NjYxMzAxLDIzNTM0MTU3Nyw2MDUxNjQwODYsNDYxNDA2MzYzLDM3NTYxODgyMjEsMzQ1NDc5MDQzOCwxMzExMTg4ODQxLDIxNDI0MTc2MTMsMzkzMzU2NjM2NywzMDI1ODIwNDMsNDk1MTU4MTc0LDE0NzkyODk5NzIsODc0MTI1ODcwLDkwNzc0NjA5MywzNjk4MjI0ODE4LDMwMjU4MjAzOTgsMTUzNzI1MzYyNywyNzU2ODU4NjE0LDE5ODM1OTMyOTMsMzA4NDMxMDExMywyMTA4OTI4OTc0LDEzNzg0MjkzMDcsMzcyMjY5OTU4MiwxNTgwMTUwNjQxLDMyNzQ1MTc5OSwyNzkwNDc4ODM3LDMxMTc1MzU1OTIsMCwzMjUzNTk1NDM2LDEwNzU4NDcyNjQsMzgyNTAwNzY0NywyMDQxNjg4NTIwLDMwNTk0NDA2MjEsMzU2Mzc0MzkzNCwyMzc4OTQzMzAyLDE3NDA1NTM5NDUsMTkxNjM1Mjg0MywyNDg3ODk2Nzk4LDI1NTUxMzcyMzYsMjk1ODU3OTk0NCwyMjQ0OTg4NzQ2LDMxNTEwMjQyMzUsMzMyMDgzNTg4MiwxMzM2NTg0OTMzLDM5OTI3MTQwMDYsMjI1MjU1NTIwNSwyNTg4NzU3NDYzLDE3MTQ2MzE1MDksMjkzOTYzMTU2LDIzMTk3OTU2NjMsMzkyNTQ3MzU1Miw2NzI0MDQ1NCw0MjY5NzY4NTc3LDI2ODk2MTgxNjAsMjAxNzIxMzUwOCw2MzEyMTgxMDYsMTI2OTM0NDQ4MywyNzIzMjM4Mzg3LDE1NzEwMDU0MzgsMjE1MTY5NDUyOCw5MzI5NDQ3NCwxMDY2NTcwNDEzLDU2Mzk3NzY2MCwxODgyNzMyNjE2LDQwNTk0MjgxMDAsMTY3MzMxMzUwMywyMDA4NDYzMDQxLDI5NTAzNTU1NzMsMTEwOTQ2NzQ5MSw1Mzc5MjM2MzIsMzg1ODc1OTQ1MCw0MjYwNjIzMTE4LDMyMTgyNjQ2ODUsMjE3Nzc0ODMwMCw0MDM0NDI3MDgsNjM4Nzg0MzA5LDMyODcwODQwNzksMzE5MzkyMTUwNSw4OTkxMjcyMDIsMjI4NjE3NTQzNiw3NzMyNjUyMDksMjQ3OTE0NjA3MSwxNDM3MDUwODY2LDQyMzYxNDgzNTQsMjA1MDgzMzczNSwzMzYyMDIyNTcyLDMxMjY2ODEwNjMsODQwNTA1NjQzLDM4NjYzMjU5MDksMzIyNzU0MTY2NCw0Mjc5MTc3MjAsMjY1NTk5NzkwNSwyNzQ5MTYwNTc1LDExNDMwODc3MTgsMTQxMjA0OTUzNCw5OTkzMjk5NjMsMTkzNDk3MjE5LDIzNTM0MTU4ODIsMzM1NDMyNDUyMSwxODA3MjY4MDUxLDY3MjQwNDU0MCwyODE2NDAxMDE3LDMxNjAzMDEyODIsMzY5ODIyNDkzLDI5MTY4NjY5MzQsMzY4ODk0Nzc3MSwxNjgxMDExMjg2LDE5NDk5NzMwNzAsMzM2MjAyMjcwLDI0NTQyNzY1NzEsMjAxNzIxMzU0LDEyMTAzMjgxNzIsMzA5MzA2MDgzNiwyNjgwMzQxMDg1LDMxODQ3NzYwNDYsMTEzNTM4OTkzNSwzMjk0NzgyMTE4LDk2NTg0MTMyMCw4MzE4ODY3NTYsMzU1NDk5MzIwNyw0MDY4MDQ3MjQzLDM1ODg3NDUwMTAsMjM0NTE5MTQ5MSwxODQ5MTEyNDA5LDM2NjQ2MDQ1OTksMjYwNTQwMjgsMjk4MzU4MTAyOCwyNjIyMzc3NjgyLDEyMzU4NTU4NDAsMzYzMDk4NDM3MiwyODkxMzM5NTE0LDQwOTI5MTY3NDMsMzQ4ODI3OTA3NywzMzk1NjQyNzk5LDQxMDE2Njc0NzAsMTIwMjYzMDM3NywyNjg5NjE4MTYsMTg3NDUwODUwMSw0MDM0NDI3MDE2LDEyNDM5NDgzOTksMTU0NjUzMDQxOCw5NDEzNjYzMDgsMTQ3MDUzOTUwNSwxOTQxMjIyNTk5LDI1NDYzODY1MTMsMzQyMTAzODYyNywyNzE1NjcxOTMyLDM4OTk5NDYxNDAsMTA0MjIyNjk3NywyNTIxNTE3MDIxLDE2Mzk4MjQ4NjAsMjI3MjQ5MDMwLDI2MDczNzY2OSwzNzY1NDY1MjMyLDIwODQ0NTM5NTQsMTkwNzczMzk1NiwzNDI5MjYzMDE4LDI0MjA2NTYzNDQsMTAwODYwNjc3LDQxNjAxNTcxODUsNDcwNjgzMTU0LDMyNjExNjE4OTEsMTc4MTg3MTk2NywyOTI0OTU5NzM3LDE3NzM3Nzk0MDgsMzk0NjkyMjQxLDI1Nzk2MTE5OTIsOTc0OTg2NTM1LDY2NDcwNjc0NSwzNjU1NDU5MTI4LDM5NTg5NjIxOTUsNzMxNDIwODUxLDU3MTU0Mzg1OSwzNTMwMTIzNzA3LDI4NDk2MjY0ODAsMTI2NzgzMTEzLDg2NTM3NTM5OSw3NjUxNzI2NjIsMTAwODYwNjc1NCwzNjEyMDM2MDIsMzM4NzU0OTk4NCwyMjc4NDc3Mzg1LDI4NTc3MTkyOTUsMTM0NDgwOTA4MCwyNzgyOTEyMzc4LDU5NTQyNjcxLDE1MDM3NjQ5ODQsMTYwMDA4NTc2LDQzNzA2MjkzNSwxNzA3MDY1MzA2LDM2MjIyMzM2NDksMjIxODkzNDk4MiwzNDk2NTAzNDgwLDIxODUzMTQ3NTUsNjk3OTMyMjA4LDE1MTI5MTAxOTksNTA0MzAzMzc3LDIwNzUxNzcxNjMsMjgyNDA5OTA2OCwxODQxMDE5ODYyLDczOTY0NDk4Nl0scD1bMjc4MTI0MjIxMSwyMjMwODc3MzA4LDI1ODI1NDIxOTksMjM4MTc0MDkyMywyMzQ4Nzc2ODIsMzE4NDk0NjAyNywyOTg0MTQ0NzUxLDE0MTg4Mzk0OTMsMTM0ODQ4MTA3Miw1MDQ2Mjk3NywyODQ4ODc2MzkxLDIxMDI3OTkxNDcsNDM0NjM0NDk0LDE2NTYwODQ0MzksMzg2Mzg0OTg5OSwyNTk5MTg4MDg2LDExNjcwNTE0NjYsMjYzNjA4NzkzOCwxMDgyNzcxOTEzLDIyODEzNDAyODUsMzY4MDQ4ODkwLDM5NTQzMzQwNDEsMzM4MTU0NDc3NSwyMDEwNjA1OTIsMzk2MzcyNzI3NywxNzM5ODM4Njc2LDQyNTA5MDMyMDIsMzkzMDQzNTUwMywzMjA2NzgyMTA4LDQxNDk0NTM5ODgsMjUzMTU1MzkwNiwxNTM2OTM0MDgwLDMyNjI0OTQ2NDcsNDg0NTcyNjY5LDI5MjMyNzEwNTksMTc4MzM3NTM5OCwxNTE3MDQxMjA2LDEwOTg3OTI3NjcsNDk2NzQyMzEsMTMzNDAzNzcwOCwxNTUwMzMyOTgwLDQwOTg5OTE1MjUsODg2MTcxMTA5LDE1MDU5ODEyOSwyNDgxMDkwOTI5LDE5NDA2NDIwMDgsMTM5ODk0NDA0OSwxMDU5NzIyNTE3LDIwMTg1MTkwOCwxMzg1NTQ3NzE5LDE2OTkwOTUzMzEsMTU4NzM5NzU3MSw2NzQyNDA1MzYsMjcwNDc3NDgwNiwyNTIzMTQ4ODUsMzAzOTc5NTg2NiwxNTE5MTQyNDcsOTA4MzMzNTg2LDI2MDIyNzA4NDgsMTAzODA4Mjc4Niw2NTEwMjk0ODMsMTc2NjcyOTUxMSwzNDQ3Njk4MDk4LDI2ODI5NDI4MzcsNDU0MTY2NzkzLDI2NTI3MzQzMzksMTk1MTkzNTUzMiw3NzUxNjY0OTAsNzU4NTIwNjAzLDMwMDA3OTA2MzgsNDAwNDc5NzAxOCw0MjE3MDg2MTEyLDQxMzc5NjQxMTQsMTI5OTU5NDA0MywxNjM5NDM4MDM4LDM0NjQzNDQ0OTksMjA2ODk4MjA1NywxMDU0NzI5MTg3LDE5MDE5OTc4NzEsMjUzNDYzODcyNCw0MTIxMzE4MjI3LDE3NTcwMDgzMzcsMCw3NTA5MDY4NjEsMTYxNDgxNTI2NCw1MzUwMzUxMzIsMzM2MzQxODU0NSwzOTg4MTUxMTMxLDMyMDE1OTE5MTQsMTE4MzY5Nzg2NywzNjQ3NDU0OTEwLDEyNjU3NzY5NTMsMzczNDI2MDI5OCwzNTY2NzUwNzk2LDM5MDM4NzEwNjQsMTI1MDI4MzQ3MSwxODA3NDcwODAwLDcxNzYxNTA4NywzODQ3MjAzNDk4LDM4NDY5NTI5MSwzMzEzOTEwNTk1LDM2MTcyMTM3NzMsMTQzMjc2MTEzOSwyNDg0MTc2MjYxLDM0ODE5NDU0MTMsMjgzNzY5MzM3LDEwMDkyNTk1NCwyMTgwOTM5NjQ3LDQwMzcwMzgxNjAsMTE0ODczMDQyOCwzMTIzMDI3ODcxLDM4MTMzODY0MDgsNDA4NzUwMTEzNyw0MjY3NTQ5NjAzLDMyMjk2MzA1MjgsMjMxNTYyMDIzOSwyOTA2NjI0NjU4LDMxNTYzMTk2NDUsMTIxNTMxMzk3Niw4Mjk2NjAwNSwzNzQ3ODU1NTQ4LDMyNDU4NDgyNDYsMTk3NDQ1OTA5OCwxNjY1Mjc4MjQxLDgwNzQwNzYzMiw0NTEyODA4OTUsMjUxNTI0MDgzLDE4NDEyODc4OTAsMTI4MzU3NTI0NSwzMzcxMjAyNjgsODkxNjg3Njk5LDgwMTM2OTMyNCwzNzg3MzQ5ODU1LDI3MjE0MjEyMDcsMzQzMTQ4MjQzNiw5NTkzMjE4NzksMTQ2OTMwMTk1Niw0MDY1Njk5NzUxLDIxOTc1ODU1MzQsMTE5OTE5MzQwNSwyODk4ODE0MDUyLDM4ODc3NTA0OTMsNzI0NzAzNTEzLDI1MTQ5MDgwMTksMjY5Njk2MjE0NCwyNTUxODA4Mzg1LDM1MTY4MTMxMzUsMjE0MTQ0NTM0MCwxNzE1NzQxMjE4LDIxMTk0NDUwMzQsMjg3MjgwNzU2OCwyMTk4NTcxMTQ0LDMzOTgxOTA2NjIsNzAwOTY4Njg2LDM1NDcwNTIyMTYsMTAwOTI1OTU0MCwyMDQxMDQ0NzAyLDM4MDM5OTU3NDIsNDg3OTgzODgzLDE5OTExMDU0OTksMTAwNDI2NTY5NiwxNDQ5NDA3MDI2LDEzMTYyMzk5MzAsNTA0NjI5NzcwLDM2ODM3OTczMjEsMTY4NTYwMTM0LDE4MTY2NjcxNzIsMzgzNzI4NzUxNiwxNTcwNzUxMTcwLDE4NTc5MzQyOTEsNDAxNDE4OTc0MCwyNzk3ODg4MDk4LDI4MjIzNDUxMDUsMjc1NDcxMjk4MSw5MzY2MzM1NzIsMjM0NzkyMzgzMyw4NTI4NzkzMzUsMTEzMzIzNDM3NiwxNTAwMzk1MzE5LDMwODQ1NDUzODksMjM0ODkxMjAxMywxNjg5Mzc2MjEzLDM1MzM0NTkwMjIsMzc2MjkyMzk0NSwzMDM0MDgyNDEyLDQyMDU1OTgyOTQsMTMzNDI4NDY4LDYzNDM4MzA4MiwyOTQ5Mjc3MDI5LDIzOTgzODY4MTAsMzkxMzc4OTEwMiw0MDM3MDM4MTYsMzU4MDg2OTMwNiwyMjk3NDYwODU2LDE4NjcxMzAxNDksMTkxODY0Mzc1OCw2MDc2NTY5ODgsNDA0OTA1MzM1MCwzMzQ2MjQ4ODg0LDEzNjg5MDEzMTgsNjAwNTY1OTkyLDIwOTA5ODI4NzcsMjYzMjQ3OTg2MCw1NTc3MTkzMjcsMzcxNzYxNDQxMSwzNjk3MzkzMDg1LDIyNDkwMzQ2MzUsMjIzMjM4ODIzNCwyNDMwNjI3OTUyLDExMTU0Mzg2NTQsMzI5NTc4NjQyMSwyODY1NTIyMjc4LDM2MzMzMzQzNDQsODQyODAwNjcsMzMwMjc4MzAsMzAzODI4NDk0LDI3NDc0MjUxMjEsMTYwMDc5NTk1Nyw0MTg4OTUyNDA3LDM0OTY1ODk3NTMsMjQzNDIzODA4NiwxNDg2NDcxNjE3LDY1ODExOTk2NSwzMTA2MzgxNDcwLDk1MzgwMzIzMywzMzQyMzE4MDAsMzAwNTk3ODc3Niw4NTc4NzA2MDksMzE1MTEyODkzNywxODkwMTc5NTQ1LDIyOTg5NzM4MzgsMjgwNTE3NTQ0NCwzMDU2NDQyMjY3LDU3NDM2NTIxNCwyNDUwODg0NDg3LDU1MDEwMzUyOSwxMjMzNjM3MDcwLDQyODkzNTMwNDUsMjAxODUxOTA4MCwyMDU3NjkxMTAzLDIzOTkzNzQ0NzYsNDE2NjYyMzY0OSwyMTQ4MTA4NjgxLDM4NzU4MzI0NSwzNjY0MTAxMzExLDgzNjIzMjkzNCwzMzMwNTU2NDgyLDMxMDA2NjU5NjAsMzI4MDA5MzUwNSwyOTU1NTE2MzEzLDIwMDIzOTg1MDksMjg3MTgyNjA3LDM0MTM4ODEwMDgsNDIzODg5MDA2OCwzNTk3NTE1NzA3LDk3NTk2Nzc2Nl0sdj1bMTY3MTgwODYxMSwyMDg5MDg5MTQ4LDIwMDY1NzY3NTksMjA3MjkwMTI0Myw0MDYxMDAzNzYyLDE4MDc2MDMzMDcsMTg3MzkyNzc5MSwzMzEwNjUzODkzLDgxMDU3Mzg3MiwxNjk3NDMzNywxNzM5MTgxNjcxLDcyOTYzNDM0Nyw0MjYzMTEwNjU0LDM2MTM1NzA1MTksMjg4Mzk5NzA5OSwxOTg5ODY0NTY2LDMzOTM1NTY0MjYsMjE5MTMzNTI5OCwzMzc2NDQ5OTkzLDIxMDYwNjM0ODUsNDE5NTc0MTY5MCwxNTA4NjE4ODQxLDEyMDQzOTE0OTUsNDAyNzMxNzIzMiwyOTE3OTQxNjc3LDM1NjM1NjYwMzYsMjczNDUxNDA4MiwyOTUxMzY2MDYzLDI2Mjk3NzIxODgsMjc2NzY3MjIyOCwxOTIyNDkxNTA2LDMyMjcyMjkxMjAsMzA4Mjk3NDY0Nyw0MjQ2NTI4NTA5LDI0Nzc2Njk3NzksNjQ0NTAwNTE4LDkxMTg5NTYwNiwxMDYxMjU2NzY3LDQxNDQxNjYzOTEsMzQyNzc2MzE0OCw4Nzg0NzEyMjAsMjc4NDI1MjMyNSwzODQ1NDQ0MDY5LDQwNDM4OTczMjksMTkwNTUxNzE2OSwzNjMxNDU5Mjg4LDgyNzU0ODIwOSwzNTY0NjEwNzcsNjc4OTczNDgsMzM0NDA3ODI3OSw1OTM4Mzk2NTEsMzI3Nzc1Nzg5MSw0MDUyODY5MzYsMjUyNzE0NzkyNiw4NDg3MTY4NSwyNTk1NTY1NDY2LDExODAzMzkyNywzMDU1MzgwNjYsMjE1NzY0ODc2OCwzNzk1NzA1ODI2LDM5NDUxODg4NDMsNjYxMjEyNzExLDI5OTk4MTIwMTgsMTk3MzQxNDUxNywxNTI3NjkwMzMsMjIwODE3NzUzOSw3NDU4MjIyNTIsNDM5MjM1NjEwLDQ1NTk0NzgwMywxODU3MjE1NTk4LDE1MjU1OTMxNzgsMjcwMDgyNzU1MiwxMzkxODk1NjM0LDk5NDkzMjI4MywzNTk2NzI4Mjc4LDMwMTY2NTQyNTksNjk1OTQ3ODE3LDM4MTI1NDgwNjcsNzk1OTU4ODMxLDIyMjQ0OTM0NDQsMTQwODYwNzgyNywzNTEzMzAxNDU3LDAsMzk3OTEzMzQyMSw1NDMxNzg3ODQsNDIyOTk0ODQxMiwyOTgyNzA1NTg1LDE1NDIzMDUzNzEsMTc5MDg5MTExNCwzNDEwMzk4NjY3LDMyMDE5MTg5MTAsOTYxMjQ1NzUzLDEyNTYxMDA5MzgsMTI4OTAwMTAzNiwxNDkxNjQ0NTA0LDM0Nzc3Njc2MzEsMzQ5NjcyMTM2MCw0MDEyNTU3ODA3LDI4NjcxNTQ4NTgsNDIxMjU4MzkzMSwxMTM3MDE4NDM1LDEzMDU5NzUzNzMsODYxMjM0NzM5LDIyNDEwNzM1NDEsMTE3MTIyOTI1Myw0MTc4NjM1MjU3LDMzOTQ4Njc0LDIxMzkyMjU3MjcsMTM1Nzk0Njk2MCwxMDExMTIwMTg4LDI2Nzk3NzY2NzEsMjgzMzQ2ODMyOCwxMzc0OTIxMjk3LDI3NTEzNTYzMjMsMTA4NjM1NzU2OCwyNDA4MTg3Mjc5LDI0NjA4Mjc1MzgsMjY0NjM1MjI4NSw5NDQyNzE0MTYsNDExMDc0MjAwNSwzMTY4NzU2NjY4LDMwNjYxMzI0MDYsMzY2NTE0NTgxOCw1NjAxNTMxMjEsMjcxNTg5MzkyLDQyNzk5NTI4OTUsNDA3Nzg0NjAwMywzNTMwNDA3ODkwLDM0NDQzNDMyNDUsMjAyNjQzNDY4LDMyMjI1MDI1OSwzOTYyNTUzMzI0LDE2MDg2Mjk4NTUsMjU0Mzk5MDE2NywxMTU0MjU0OTE2LDM4OTYyMzMxOSwzMjk0MDczNzk2LDI4MTc2NzY3MTEsMjEyMjUxMzUzNCwxMDI4MDk0NTI1LDE2ODkwNDUwOTIsMTU3NTQ2NzYxMyw0MjIyNjEyNzMsMTkzOTIwMzY5OSwxNjIxMTQ3NzQ0LDIxNzQyMjg4NjUsMTMzOTEzNzYxNSwzNjk5MzUyNTQwLDU3NzEyNzQ1OCw3MTI5MjIxNTQsMjQyNzE0MTAwOCwyMjkwMjg5NTQ0LDExODc2NzkzMDIsMzk5NTcxNTU2NiwzMTAwODYzNDE2LDMzOTQ4Njc0MCwzNzMyNTE0NzgyLDE1OTE5MTc2NjIsMTg2NDU1NTYzLDM2ODE5ODgwNTksMzc2MjAxOTI5Niw4NDQ1MjI1NDYsOTc4MjIwMDkwLDE2OTc0MzM3MCwxMjM5MTI2NjAxLDEwMTMyMTczNCw2MTEwNzYxMzIsMTU1ODQ5MzI3NiwzMjYwOTE1NjUwLDM1NDcyNTAxMzEsMjkwMTM2MTU4MCwxNjU1MDk2NDE4LDI0NDM3MjExMDUsMjUxMDU2NTc4MSwzODI4ODYzOTcyLDIwMzkyMTQ3MTMsMzg3ODg2ODQ1NSwzMzU5ODY5ODk2LDkyODYwNzc5OSwxODQwNzY1NTQ5LDIzNzQ3NjI4OTMsMzU4MDE0NjEzMywxMzIyNDI1NDIyLDI4NTAwNDg0MjUsMTgyMzc5MTIxMiwxNDU5MjY4Njk0LDQwOTQxNjE5MDgsMzkyODM0NjYwMiwxNzA2MDE5NDI5LDIwNTYxODkwNTAsMjkzNDUyMzgyMiwxMzU3OTQ2OTYsMzEzNDU0OTk0NiwyMDIyMjQwMzc2LDYyODA1MDQ2OSw3NzkyNDY2MzgsNDcyMTM1NzA4LDI4MDA4MzQ0NzAsMzAzMjk3MDE2NCwzMzI3MjM2MDM4LDM4OTQ2NjAwNzIsMzcxNTkzMjYzNywxOTU2NDQwMTgwLDUyMjI3MjI4NywxMjcyODEzMTMxLDMxODUzMzY3NjUsMjM0MDgxODMxNSwyMzIzOTc2MDc0LDE4ODg1NDI4MzIsMTA0NDU0NDU3NCwzMDQ5NTUwMjYxLDE3MjI0Njk0NzgsMTIyMjE1MjI2NCw1MDY2MDg2Nyw0MTI3MzI0MTUwLDIzNjA2Nzg1NCwxNjM4MTIyMDgxLDg5NTQ0NTU1NywxNDc1OTgwODg3LDMxMTc0NDM1MTMsMjI1NzY1NTY4NiwzMjQzODA5MjE3LDQ4OTExMDA0NSwyNjYyOTM0NDMwLDM3Nzg1OTkzOTMsNDE2MjA1NTE2MCwyNTYxODc4OTM2LDI4ODU2MzcyOSwxNzczOTE2Nzc3LDM2NDgwMzkzODUsMjM5MTM0NTAzOCwyNDkzOTg1Njg0LDI2MTI0MDc3MDcsNTA1NTYwMDk0LDIyNzQ0OTc5MjcsMzkxMTI0MDE2OSwzNDYwOTI1MzkwLDE0NDI4MTg2NDUsNjc4OTczNDgwLDM3NDkzNTcwMjMsMjM1ODE4Mjc5NiwyNzE3NDA3NjQ5LDIzMDY4Njk2NDEsMjE5NjE3ODA1LDMyMTg3NjExNTEsMzg2MjAyNjIxNCwxMTIwMzA2MjQyLDE3NTY5NDI0NDAsMTEwMzMzMTkwNSwyNTc4NDU5MDMzLDc2Mjc5NjU4OSwyNTI3ODAwNDcsMjk2NjEyNTQ4OCwxNDI1ODQ0MzA4LDMxNTEzOTIxODcsMzcyOTExMTI2XSx5PVsxNjY3NDc0ODg2LDIwODg1MzUyODgsMjAwNDMyNjg5NCwyMDcxNjk0ODM4LDQwNzU5NDk1NjcsMTgwMjIyMzA2MiwxODY5NTkxMDA2LDMzMTgwNDM3OTMsODA4NDcyNjcyLDE2ODQzNTIyLDE3MzQ4NDY5MjYsNzI0MjcwNDIyLDQyNzgwNjU2MzksMzYyMTIxNjk0OSwyODgwMTY5NTQ5LDE5ODc0ODQzOTYsMzQwMjI1MzcxMSwyMTg5NTk3OTgzLDMzODU0MDk2NzMsMjEwNTM3ODgxMCw0MjEwNjkzNjE1LDE0OTkwNjUyNjYsMTE5NTg4Njk5MCw0MDQyMjYzNTQ3LDI5MTM4NTY1NzcsMzU3MDY4OTk3MSwyNzI4NTkwNjg3LDI5NDc1NDE1NzMsMjYyNzUxODI0MywyNzYyMjc0NjQzLDE5MjAxMTIzNTYsMzIzMzgzMTgzNSwzMDgyMjczMzk3LDQyNjEyMjM2NDksMjQ3NTkyOTE0OSw2NDAwNTE3ODgsOTA5NTMxNzU2LDEwNjExMTAxNDIsNDE2MDE2MDUwMSwzNDM1OTQxNzYzLDg3NTg0Njc2MCwyNzc5MTE2NjI1LDM4NTcwMDM3MjksNDA1OTEwNTUyOSwxOTAzMjY4ODM0LDM2MzgwNjQwNDMsODI1MzE2MTk0LDM1MzcxMzk2Miw2NzM3NDA4OCwzMzUxNzI4Nzg5LDU4OTUyMjI0NiwzMjg0MzYwODYxLDQwNDIzNjMzNiwyNTI2NDU0MDcxLDg0MjE3NjEwLDI1OTM4MzAxOTEsMTE3OTAxNTgyLDMwMzE4MzM5NiwyMTU1OTExOTYzLDM4MDY0Nzc3OTEsMzk1ODA1NjY1Myw2NTY4OTQyODYsMjk5ODA2MjQ2MywxOTcwNjQyOTIyLDE1MTU5MTY5OCwyMjA2NDQwOTg5LDc0MTExMDg3Miw0Mzc5MjMzODAsNDU0NzY1ODc4LDE4NTI3NDg1MDgsMTUxNTkwODc4OCwyNjk0OTA0NjY3LDEzODExNjg4MDQsOTkzNzQyMTk4LDM2MDQzNzM5NDMsMzAxNDkwNTQ2OSw2OTA1ODQ0MDIsMzgyMzMyMDc5Nyw3OTE2MzgzNjYsMjIyMzI4MTkzOSwxMzk4MDExMzAyLDM1MjAxNjE5NzcsMCwzOTkxNzQzNjgxLDUzODk5MjcwNCw0MjQ0MzgxNjY3LDI5ODEyMTg0MjUsMTUzMjc1MTI4NiwxNzg1MzgwNTY0LDM0MTkwOTY3MTcsMzIwMDE3ODUzNSw5NjAwNTYxNzgsMTI0NjQyMDYyOCwxMjgwMTAzNTc2LDE0ODIyMjE3NDQsMzQ4NjQ2ODc0MSwzNTAzMzE5OTk1LDQwMjU0Mjg2NzcsMjg2MzMyNjU0Myw0MjI3NTM2NjIxLDExMjg1MTQ5NTAsMTI5Njk0NzA5OCw4NTkwMDIyMTQsMjI0MDEyMzkyMSwxMTYyMjAzMDE4LDQxOTM4NDk1NzcsMzM2ODcwNDQsMjEzOTA2Mjc4MiwxMzQ3NDgxNzYwLDEwMTA1ODI2NDgsMjY3ODA0NTIyMSwyODI5NjQwNTIzLDEzNjQzMjUyODIsMjc0NTQzMzY5MywxMDc3OTg1NDA4LDI0MDg1NDg4NjksMjQ1OTA4NjE0MywyNjQ0MzYwMjI1LDk0MzIxMjY1Niw0MTI2NDc1NTA1LDMxNjY0OTQ1NjMsMzA2NTQzMDM5MSwzNjcxNzUwMDYzLDU1NTgzNjIyNiwyNjk0OTYzNTIsNDI5NDkwODY0NSw0MDkyNzkyNTczLDM1MzcwMDYwMTUsMzQ1Mjc4Mzc0NSwyMDIxMTgxNjgsMzIwMDI1ODk0LDM5NzQ5MDE2OTksMTYwMDExOTIzMCwyNTQzMjk3MDc3LDExNDUzNTk0OTYsMzg3Mzk3OTM0LDMzMDEyMDE4MTEsMjgxMjgwMTYyMSwyMTIyMjIwMjg0LDEwMjc0MjYxNzAsMTY4NDMxOTQzMiwxNTY2NDM1MjU4LDQyMTA3OTg1OCwxOTM2OTU0ODU0LDE2MTY5NDUzNDQsMjE3Mjc1Mzk0NSwxMzMwNjMxMDcwLDM3MDU0MzgxMTUsNTcyNjc5NzQ4LDcwNzQyNzkyNCwyNDI1NDAwMTIzLDIyOTA2NDc4MTksMTE3OTA0NDQ5Miw0MDA4NTg1NjcxLDMwOTkxMjA0OTEsMzM2ODcwNDQwLDM3MzkxMjIwODcsMTU4MzI3NjczMiwxODUyNzc3MTgsMzY4ODU5MzA2OSwzNzcyNzkxNzcxLDg0MjE1OTcxNiw5NzY4OTk3MDAsMTY4NDM1MjIwLDEyMjk1NzcxMDYsMTAxMDU5MDg0LDYwNjM2Njc5MiwxNTQ5NTkxNzM2LDMyNjc1MTc4NTUsMzU1Mzg0OTAyMSwyODk3MDE0NTk1LDE2NTA2MzIzODgsMjQ0MjI0MjEwNSwyNTA5NjEyMDgxLDM4NDAxNjE3NDcsMjAzODAwODgxOCwzODkwNjg4NzI1LDMzNjg1Njc2OTEsOTI2Mzc0MjU0LDE4MzU5MDcwMzQsMjM3NDg2Mzg3MywzNTg3NTMxOTUzLDEzMTM3ODg1NzIsMjg0NjQ4MjUwNSwxODE5MDYzNTEyLDE0NDg1NDA4NDQsNDEwOTYzMzUyMywzOTQxMjEzNjQ3LDE3MDExNjI5NTQsMjA1NDg1MjM0MCwyOTMwNjk4NTY3LDEzNDc0ODE3NiwzMTMyODA2NTExLDIwMjExNjUyOTYsNjIzMjEwMzE0LDc3NDc5NTg2OCw0NzE2MDYzMjgsMjc5NTk1ODYxNSwzMDMxNzQ2NDE5LDMzMzQ4ODU3ODMsMzkwNzUyNzYyNywzNzIyMjgwMDk3LDE5NTM3OTk0MDAsNTIyMTMzODIyLDEyNjMyNjMxMjYsMzE4MzMzNjU0NSwyMzQxMTc2ODQ1LDIzMjQzMzM4MzksMTg4NjQyNTMxMiwxMDQ0MjY3NjQ0LDMwNDg1ODg0MDEsMTcxODAwNDQyOCwxMjEyNzMzNTg0LDUwNTI5NTQyLDQxNDMzMTc0OTUsMjM1ODAzMTY0LDE2MzM3ODg4NjYsODkyNjkwMjgyLDE0NjUzODMzNDIsMzExNTk2MjQ3MywyMjU2OTY1OTExLDMyNTA2NzM4MTcsNDg4NDQ5ODUwLDI2NjEyMDIyMTUsMzc4OTYzMzc1Myw0MTc3MDA3NTk1LDI1NjAxNDQxNzEsMjg2MzM5ODc0LDE3Njg1MzcwNDIsMzY1NDkwNjAyNSwyMzkxNzA1ODYzLDI0OTI3NzAwOTksMjYxMDY3MzE5Nyw1MDUyOTEzMjQsMjI3MzgwODkxNywzOTI0MzY5NjA5LDM0Njk2MjU3MzUsMTQzMTY5OTM3MCw2NzM3NDA4ODAsMzc1NTk2NTA5MywyMzU4MDIxODkxLDI3MTE3NDY2NDksMjMwNzQ4OTgwMSwyMTg5NjE2OTAsMzIxNzAyMTU0MSwzODczODQ1NzE5LDExMTE2NzI0NTIsMTc1MTY5MzUyMCwxMDk0ODI4OTMwLDI1NzY5ODYxNTMsNzU3OTU0Mzk0LDI1MjY0NTY2MiwyOTY0Mzc2NDQzLDE0MTQ4NTU4NDgsMzE0OTY0OTUxNywzNzA1NTU0MzZdLG09WzEzNzQ5ODgxMTIsMjExODIxNDk5NSw0Mzc3NTcxMjMsOTc1NjU4NjQ2LDEwMDEwODk5OTUsNTMwNDAwNzUzLDI5MDIwODc4NTEsMTI3MzE2ODc4Nyw1NDAwODA3MjUsMjkxMDIxOTc2NiwyMjk1MTAxMDczLDQxMTA1Njg0ODUsMTM0MDQ2MzEwMCwzMzA3OTE2MjQ3LDY0MTAyNTE1MiwzMDQzMTQwNDk1LDM3MzYxNjQ5MzcsNjMyOTUzNzAzLDExNzI5NjcwNjQsMTU3Njk3NjYwOSwzMjc0NjY3MjY2LDIxNjkzMDMwNTgsMjM3MDIxMzc5NSwxODA5MDU0MTUwLDU5NzI3ODQ3LDM2MTkyOTg3NywzMjExNjIzMTQ3LDI1MDUyMDIxMzgsMzU2OTI1NTIxMywxNDg0MDA1ODQzLDEyMzk0NDM3NTMsMjM5NTU4ODY3NiwxOTc1NjgzNDM0LDQxMDI5Nzc5MTIsMjU3MjY5NzE5NSw2NjY0NjQ3MzMsMzIwMjQzNzA0Niw0MDM1NDg5MDQ3LDMzNzQzNjE3MDIsMjExMDY2NzQ0NCwxNjc1NTc3ODgwLDM4NDM2OTkwNzQsMjUzODY4MTE4NCwxNjQ5NjM5MjM3LDI5NzYxNTE1MjAsMzE0NDM5NjQyMCw0MjY5OTA3OTk2LDQxNzgwNjIyMjgsMTg4Mzc5MzQ5NiwyNDAzNzI4NjY1LDI0OTc2MDQ3NDMsMTM4Mzg1NjMxMSwyODc2NDk0NjI3LDE5MTc1MTg1NjIsMzgxMDQ5NjM0MywxNzE2ODkwNDEwLDMwMDE3NTU2NTUsODAwNDQwODM1LDIyNjEwODkxNzgsMzU0MzU5OTI2OSw4MDc5NjI2MTAsNTk5NzYyMzU0LDMzNzc4MzYyLDM5Nzc2NzUzNTYsMjMyODgyODk3MSwyODA5NzcxMTU0LDQwNzczODQ0MzIsMTMxNTU2MjE0NSwxNzA4ODQ4MzMzLDEwMTAzOTgyOSwzNTA5ODcxMTM1LDMyOTkyNzg0NzQsODc1NDUxMjkzLDI3MzM4NTYxNjAsOTI5ODc2OTgsMjc2NzY0NTU1NywxOTMxOTUwNjUsMTA4MDA5NDYzNCwxNTg0NTA0NTgyLDMxNzgxMDY5NjEsMTA0MjM4NTY1NywyNTMxMDY3NDUzLDM3MTE4Mjk0MjIsMTMwNjk2NzM2NiwyNDM4MjM3NjIxLDE5MDg2OTQyNzcsNjc1NTY0NjMsMTYxNTg2MTI0Nyw0Mjk0NTYxNjQsMzYwMjc3MDMyNywyMzAyNjkwMjUyLDE3NDIzMTUxMjcsMjk2ODAxMTQ1MywxMjY0NTQ2NjQsMzg3NzE5ODY0OCwyMDQzMjExNDgzLDI3MDkyNjA4NzEsMjA4NDcwNDIzMyw0MTY5NDA4MjAxLDAsMTU5NDE3OTg3LDg0MTczOTU5Miw1MDQ0NTk0MzYsMTgxNzg2NjgzMCw0MjQ1NjE4NjgzLDI2MDM4ODk1MCwxMDM0ODY3OTk4LDkwODkzMzQxNSwxNjg4MTA4NTIsMTc1MDkwMjMwNSwyNjA2NDUzOTY5LDYwNzUzMDU1NCwyMDIwMDg0OTcsMjQ3MjAxMTUzNSwzMDM1NTM1MDU4LDQ2MzE4MDE5MCwyMTYwMTE3MDcxLDE2NDE4MTYyMjYsMTUxNzc2NzUyOSw0NzA5NDgzNzQsMzgwMTMzMjIzNCwzMjMxNzIyMjEzLDEwMDg5MTg1OTUsMzAzNzY1Mjc3LDIzNTQ3NDE4Nyw0MDY5MjQ2ODkzLDc2Njk0NTQ2NSwzMzc1NTM4NjQsMTQ3NTQxODUwMSwyOTQzNjgyMzgwLDQwMDMwNjExNzksMjc0MzAzNDEwOSw0MTQ0MDQ3Nzc1LDE1NTEwMzc4ODQsMTE0NzU1MDY2MSwxNTQzMjA4NTAwLDIzMzY0MzQ1NTAsMzQwODExOTUxNiwzMDY5MDQ5OTYwLDMxMDIwMTE3NDcsMzYxMDM2OTIyNiwxMTEzODE4Mzg0LDMyODY3MTgwOCwyMjI3NTczMDI0LDIyMzYyMjg3MzMsMzUzNTQ4NjQ1NiwyOTM1NTY2ODY1LDMzNDEzOTQyODUsNDk2OTA2MDU5LDM3MDI2NjU0NTksMjI2OTA2ODYwLDIwMDkxOTU0NzIsNzMzMTU2OTcyLDI4NDI3MzcwNDksMjk0OTMwNjgyLDEyMDY0Nzc4NTgsMjgzNTEyMzM5NiwyNzAwMDk5MzU0LDE0NTEwNDQwNTYsNTczODA0NzgzLDIyNjk3Mjg0NTUsMzY0NDM3OTU4NSwyMzYyMDkwMjM4LDI1NjQwMzMzMzQsMjgwMTEwNzQwNywyNzc2MjkyOTA0LDM2Njk0NjI1NjYsMTA2ODM1MTM5Niw3NDIwMzkwMTIsMTM1MDA3ODk4OSwxNzg0NjYzMTk1LDE0MTc1NjE2OTgsNDEzNjQ0MDc3MCwyNDMwMTIyMjE2LDc3NTU1MDgxNCwyMTkzODYyNjQ1LDI2NzM3MDUxNTAsMTc3NTI3NjkyNCwxODc2MjQxODMzLDM0NzUzMTMzMzEsMzM2Njc1NDYxOSwyNzAwNDA0ODcsMzkwMjU2MzE4MiwzNjc4MTI0OTIzLDM0NDE4NTAzNzcsMTg1MTMzMjg1MiwzOTY5NTYyMzY5LDIyMDMwMzIyMzIsMzg2ODU1MjgwNSwyODY4ODk3NDA2LDU2NjAyMTg5Niw0MDExMTkwNTAyLDMxMzU3NDA4ODksMTI0ODgwMjUxMCwzOTM2MjkxMjg0LDY5OTQzMjE1MCw4MzI4NzcyMzEsNzA4NzgwODQ5LDMzMzI3NDAxNDQsODk5ODM1NTg0LDE5NTEzMTcwNDcsNDIzNjQyOTk5MCwzNzY3NTg2OTkyLDg2NjYzNzg0NSw0MDQzNjEwMTg2LDExMDYwNDE1OTEsMjE0NDE2MTgwNiwzOTU0NDE3MTEsMTk4NDgxMjY4NSwxMTM5NzgxNzA5LDM0MzM3MTI5ODAsMzgzNTAzNjg5NSwyNjY0NTQzNzE1LDEyODIwNTAwNzUsMzI0MDg5NDM5MiwxMTgxMDQ1MTE5LDI2NDAyNDMyMDQsMjU5NjU5MTcsNDIwMzE4MTE3MSw0MjExODE4Nzk4LDMwMDk4NzkzODYsMjQ2Mzg3OTc2MiwzOTEwMTYxOTcxLDE4NDI3NTk0NDMsMjU5NzgwNjQ3Niw5MzMzMDEzNzAsMTUwOTQzMDQxNCwzOTQzOTA2NDQxLDM0NjcxOTIzMDIsMzA3NjYzOTAyOSwzNzc2NzY3NDY5LDIwNTE1MTg3ODAsMjYzMTA2NTQzMywxNDQxOTUyNTc1LDQwNDAxNjc2MSwxOTQyNDM1Nzc1LDE0MDg3NDkwMzQsMTYxMDQ1OTczOSwzNzQ1MzQ1MzAwLDIwMTc3Nzg1NjYsMzQwMDUyODc2OSwzMTEwNjUwOTQyLDk0MTg5Njc0OCwzMjY1NDc4NzUxLDM3MTA0OTMzMCwzMTY4OTM3MjI4LDY3NTAzOTYyNyw0Mjc5MDgwMjU3LDk2NzMxMTcyOSwxMzUwNTAyMDYsMzYzNTczMzY2MCwxNjgzNDA3MjQ4LDIwNzY5MzUyNjUsMzU3Njg3MDUxMiwxMjE1MDYxMTA4LDM1MDE3NDE4OTBdLGc9WzEzNDc1NDgzMjcsMTQwMDc4MzIwNSwzMjczMjY3MTA4LDI1MjAzOTM1NjYsMzQwOTY4NTM1NSw0MDQ1MzgwOTMzLDI4ODAyNDAyMTYsMjQ3MTIyNDA2NywxNDI4MTczMDUwLDQxMzg1NjMxODEsMjQ0MTY2MTU1OCw2MzY4MTM5MDAsNDIzMzA5NDYxNSwzNjIwMDIyOTg3LDIxNDk5ODc2NTIsMjQxMTAyOTE1NSwxMjM5MzMxMTYyLDE3MzA1MjU3MjMsMjU1NDcxODczNCwzNzgxMDMzNjY0LDQ2MzQ2MTAxLDMxMDQ2MzcyOCwyNzQzOTQ0ODU1LDMzMjg5NTUzODUsMzg3NTc3MDIwNywyNTAxMjE4OTcyLDM5NTUxOTExNjIsMzY2NzIxOTAzMyw3Njg5MTcxMjMsMzU0NTc4OTQ3Myw2OTI3MDc0MzMsMTE1MDIwODQ1NiwxNzg2MTAyNDA5LDIwMjkyOTMxNzcsMTgwNTIxMTcxMCwzNzEwMzY4MTEzLDMwNjU5NjI4MzEsNDAxNjM5NTk3LDE3MjQ0NTcxMzIsMzAyODE0MzY3NCw0MDkxOTg0MTAsMjE5NjA1MjUyOSwxNjIwNTI5NDU5LDExNjQwNzE4MDcsMzc2OTcyMTk3NSwyMjI2ODc1MzEwLDQ4NjQ0MTM3NiwyNDk5MzQ4NTIzLDE0ODM3NTM1NzYsNDI4ODE5OTY1LDIyNzQ2ODA0MjgsMzA3NTYzNjIxNiw1OTg0Mzg4NjcsMzc5OTE0MTEyMiwxNDc0NTAyNTQzLDcxMTM0OTY3NSwxMjkxNjYxMjAsNTM0NTgzNzAsMjU5MjUyMzY0MywyNzgyMDgyODI0LDQwNjMyNDIzNzUsMjk4ODY4NzI2OSwzMTIwNjk0MTIyLDE1NTkwNDE2NjYsNzMwNTE3Mjc2LDI0NjA0NDkyMDQsNDA0MjQ1OTEyMiwyNzA2MjcwNjkwLDM0NDYwMDQ0NjgsMzU3Mzk0MTY5NCw1MzM4MDQxMzAsMjMyODE0MzYxNCwyNjM3NDQyNjQzLDI2OTUwMzM2ODUsODM5MjI0MDMzLDE5NzM3NDUzODcsOTU3MDU1OTgwLDI4NTYzNDU4MzksMTA2ODUyNzY3LDEzNzEzNjg5NzYsNDE4MTU5ODYwMiwxMDMzMjk3MTU4LDI5MzM3MzQ5MTcsMTE3OTUxMDQ2MSwzMDQ2MjAwNDYxLDkxMzQxOTE3LDE4NjI1MzQ4NjgsNDI4NDUwMjAzNyw2MDU2NTczMzksMjU0NzQzMjkzNywzNDMxNTQ2OTQ3LDIwMDMyOTQ2MjIsMzE4MjQ4NzYxOCwyMjgyMTk1MzM5LDk1NDY2OTQwMywzNjgyMTkxNTk4LDEyMDE3NjUzODYsMzkxNzIzNDcwMywzMzg4NTA3MTY2LDAsMjE5ODQzODAyMiwxMjExMjQ3NTk3LDI4ODc2NTE2OTYsMTMxNTcyMzg5MCw0MjI3NjY1NjYzLDE0NDM4NTc3MjAsNTA3MzU4OTMzLDY1Nzg2MTk0NSwxNjc4MzgxMDE3LDU2MDQ4NzU5MCwzNTE2NjE5NjA0LDk3NTQ1MTY5NCwyOTcwMzU2MzI3LDI2MTMxNDUzNSwzNTM1MDcyOTE4LDI2NTI2MDk0MjUsMTMzMzgzODAyMSwyNzI0MzIyMzM2LDE3Njc1MzY0NTksMzcwOTM4Mzk0LDE4MjYyMTExNCwzODU0NjA2Mzc4LDExMjgwMTQ1NjAsNDg3NzI1ODQ3LDE4NTQ2OTE5NywyOTE4MzUzODYzLDMxMDY3ODA4NDAsMzM1Njc2MTc2OSwyMjM3MTMzMDgxLDEyODY1NjcxNzUsMzE1Mjk3NjM0OSw0MjU1MzUwNjI0LDI2ODM3NjUwMzAsMzE2MDE3NTM0OSwzMzA5NTk0MTcxLDg3ODQ0MzM5MCwxOTg4ODM4MTg1LDM3MDQzMDA0ODYsMTc1NjgxODk0MCwxNjczMDYxNjE3LDM0MDMxMDA2MzYsMjcyNzg2MzA5LDEwNzUwMjU2OTgsNTQ1NTcyMzY5LDIxMDU4ODcyNjgsNDE3NDU2MDA2MSwyOTY2Nzk3MzAsMTg0MTc2ODg2NSwxMjYwMjMyMjM5LDQwOTEzMjcwMjQsMzk2MDMwOTMzMCwzNDk3NTA5MzQ3LDE4MTQ4MDMyMjIsMjU3ODAxODQ4OSw0MTk1NDU2MDcyLDU3NTEzODE0OCwzMjk5NDA5MDM2LDQ0Njc1NDg3OSwzNjI5NTQ2Nzk2LDQwMTE5OTYwNDgsMzM0NzUzMjExMCwzMjUyMjM4NTQ1LDQyNzA2Mzk3NzgsOTE1OTg1NDE5LDM0ODM4MjU1MzcsNjgxOTMzNTM0LDY1MTg2ODA0NiwyNzU1NjM2NjcxLDM4MjgxMDM4MzcsMjIzMzc3NTU0LDI2MDc0Mzk4MjAsMTY0OTcwNDUxOCwzMjcwOTM3ODc1LDM5MDE4MDY3NzYsMTU4MDA4Nzc5OSw0MTE4OTg3Njk1LDMxOTgxMTUyMDAsMjA4NzMwOTQ1OSwyODQyNjc4NTczLDMwMTY2OTcxMDYsMTAwMzAwNzEyOSwyODAyODQ5OTE3LDE4NjA3MzgxNDcsMjA3Nzk2NTI0MywxNjQ0Mzk2NzIsNDEwMDg3MjQ3MiwzMjI4MzMxOSwyODI3MTc3ODgyLDE3MDk2MTAzNTAsMjEyNTEzNTg0NiwxMzY0Mjg3NTEsMzg3NDQyODM5MiwzNjUyOTA0ODU5LDM0NjA5ODQ2MzAsMzU3MjE0NTkyOSwzNTkzMDU2MzgwLDI5MzkyNjYyMjYsODI0ODUyMjU5LDgxODMyNDg4NCwzMjI0NzQwNDU0LDkzMDM2OTIxMiwyODAxNTY2NDEwLDI5Njc1MDcxNTIsMzU1NzA2ODQwLDEyNTczMDkzMzYsNDE0ODI5MjgyNiwyNDMyNTY2NTYsNzkwMDczODQ2LDIzNzMzNDA2MzAsMTI5NjI5NzkwNCwxNDIyNjk5MDg1LDM3NTYyOTk3ODAsMzgxODgzNjQwNSw0NTc5OTI4NDAsMzA5OTY2NzQ4NywyMTM1MzE5ODg5LDc3NDIyMzE0LDE1NjAzODI1MTcsMTk0NTc5ODUxNiw3ODgyMDQzNTMsMTUyMTcwNjc4MSwxMzg1MzU2MjQyLDg3MDkxMjA4NiwzMjU5NjUzODMsMjM1ODk1NzkyMSwyMDUwNDY2MDYwLDIzODgyNjA4ODQsMjMxMzg4NDQ3Niw0MDA2NTIxMTI3LDkwMTIxMDU2OSwzOTkwOTUzMTg5LDEwMTQ2NDY3MDUsMTUwMzQ0OTgyMywxMDYyNTk3MjM1LDIwMzE2MjEzMjYsMzIxMjAzNTg5NSwzOTMxMzcxNDY5LDE1MzMwMTc1MTQsMzUwMTc0NTc1LDIyNTYwMjg4OTEsMjE3NzU0NDE3OSwxMDUyMzM4MzcyLDc0MTg3Njc4OCwxNjA2NTkxMjk2LDE5MTQwNTIwMzUsMjEzNzA1MjUzLDIzMzQ2Njk4OTcsMTEwNzIzNDE5NywxODk5NjAzOTY5LDM3MjUwNjk0OTEsMjYzMTQ0Nzc4MCwyNDIyNDk0OTEzLDE2MzU1MDI5ODAsMTg5MzAyMDM0MiwxOTUwOTAzMzg4LDExMjA5NzQ5MzVdLGI9WzI4MDcwNTg5MzIsMTY5OTk3MDYyNSwyNzY0MjQ5NjIzLDE1ODY5MDM1OTEsMTgwODQ4MTE5NSwxMTczNDMwMTczLDE0ODc2NDU5NDYsNTk5ODQ4NjcsNDE5OTg4MjgwMCwxODQ0ODgyODA2LDE5ODkyNDkyMjgsMTI3NzU1NTk3MCwzNjIzNjM2OTY1LDM0MTk5MTU1NjIsMTE0OTI0OTA3NywyNzQ0MTA0MjkwLDE1MTQ3OTA1NzcsNDU5NzQ0Njk4LDI0NDg2MDM5NCwzMjM1OTk1MTM0LDE5NjMxMTUzMTEsNDAyNzc0NDU4OCwyNTQ0MDc4MTUwLDQxOTA1MzA1MTUsMTYwODk3NTI0NywyNjI3MDE2MDgyLDIwNjIyNzAzMTcsMTUwNzQ5NzI5OCwyMjAwODE4ODc4LDU2NzQ5ODg2OCwxNzY0MzEzNTY4LDMzNTk5MzYyMDEsMjMwNTQ1NTU1NCwyMDM3OTcwMDYyLDEwNDcyMzllMywxOTEwMzE5MDMzLDEzMzczNzY0ODEsMjkwNDAyNzI3MiwyODkyNDE3MzEyLDk4NDkwNzIxNCwxMjQzMTEyNDE1LDgzMDY2MTkxNCw4NjE5NjgyMDksMjEzNTI1MzU4NywyMDExMjE0MTgwLDI5Mjc5MzQzMTUsMjY4NjI1NDcyMSw3MzExODMzNjgsMTc1MDYyNjM3Niw0MjQ2MzEwNzI1LDE4MjA4MjQ3OTgsNDE3Mjc2Mzc3MSwzNTQyMzMwMjI3LDQ4Mzk0ODI3LDI0MDQ5MDE2NjMsMjg3MTY4MjY0NSw2NzE1OTMxOTUsMzI1NDk4ODcyNSwyMDczNzI0NjEzLDE0NTA4NTIzOSwyMjgwNzk2MjAwLDI3Nzk5MTUxOTksMTc5MDU3NTEwNywyMTg3MTI4MDg2LDQ3MjYxNTYzMSwzMDI5NTEwMDA5LDQwNzU4NzcxMjcsMzgwMjIyMjE4NSw0MTA3MTAxNjU4LDMyMDE2MzE3NDksMTY0NjI1MjM0MCw0MjcwNTA3MTc0LDE0MDI4MTE0MzgsMTQzNjU5MDgzNSwzNzc4MTUxODE4LDM5NTAzNTU3MDIsMzk2MzE2MTQ3NSw0MDIwOTEyMjI0LDI2Njc5OTQ3MzcsMjczNzkyMzY2LDIzMzE1OTAxNzcsMTA0Njk5NjEzLDk1MzQ1OTgyLDMxNzU1MDEyODYsMjM3NzQ4NjY3NiwxNTYwNjM3ODkyLDM1NjQwNDUzMTgsMzY5MDU3ODcyLDQyMTM0NDcwNjQsMzkxOTA0MjIzNywxMTM3NDc3OTUyLDI2NTg2MjU0OTcsMTExOTcyNzg0OCwyMzQwOTQ3ODQ5LDE1MzA0NTU4MzMsNDAwNzM2MDk2OCwxNzI0NjY1NTYsMjY2OTU5OTM4LDUxNjU1MjgzNiwwLDIyNTY3MzQ1OTIsMzk4MDkzMTYyNywxODkwMzI4MDgxLDE5MTc3NDIxNzAsNDI5NDcwNDM5OCw5NDUxNjQxNjUsMzU3NTUyODg3OCw5NTg4NzEwODUsMzY0NzIxMjA0NywyNzg3MjA3MjYwLDE0MjMwMjI5MzksNzc1NTYyMjk0LDE3Mzk2NTYyMDIsMzg3NjU1NzY1NSwyNTMwMzkxMjc4LDI0NDMwNTgwNzUsMzMxMDMyMTg1Niw1NDc1MTI3OTYsMTI2NTE5NTYzOSw0Mzc2NTY1OTQsMzEyMTI3NTUzOSw3MTk3MDAxMjgsMzc2MjUwMjY5MCwzODc3ODExNDcsMjE4ODI4Mjk3LDMzNTAwNjU4MDMsMjgzMDcwODE1MCwyODQ4NDYxODU0LDQyODE2OTIwMSwxMjI0NjYxNjUsMzcyMDA4MTA0OSwxNjI3MjM1MTk5LDY0ODAxNzY2NSw0MTIyNzYyMzU0LDEwMDI3ODM4NDYsMjExNzM2MDYzNSw2OTU2MzQ3NTUsMzMzNjM1ODY5MSw0MjM0NzIxMDA1LDQwNDk4NDQ0NTIsMzcwNDI4MDg4MSwyMjMyNDM1Mjk5LDU3NDYyNDY2MywyODczNDM4MTQsNjEyMjA1ODk4LDEwMzk3MTcwNTEsODQwMDE5NzA1LDI3MDgzMjYxODUsNzkzNDUxOTM0LDgyMTI4ODExNCwxMzkxMjAxNjcwLDM4MjIwOTAxNzcsMzc2MTg3ODI3LDMxMTM4NTUzNDQsMTIyNDM0ODA1MiwxNjc5OTY4MjMzLDIzNjE2OTg1NTYsMTA1ODcwOTc0NCw3NTIzNzU0MjEsMjQzMTU5MDk2MywxMzIxNjk5MTQ1LDM1MTkxNDIyMDAsMjczNDU5MTE3OCwxODgxMjc0NDQsMjE3Nzg2OTU1NywzNzI3MjA1NzU0LDIzODQ5MTEwMzEsMzIxNTIxMjQ2MSwyNjQ4OTc2NDQyLDI0NTAzNDYxMDQsMzQzMjczNzM3NSwxMTgwODQ5Mjc4LDMzMTU0NDIwNSwzMTAyMjQ5MTc2LDQxNTAxNDQ1NjksMjk1MjEwMjU5NSwyMTU5OTc2Mjg1LDI0NzQ0MDQzMDQsNzY2MDc4OTMzLDMxMzc3Mzg2MSwyNTcwODMyMDQ0LDIxMDgxMDA2MzIsMTY2ODIxMjg5MiwzMTQ1NDU2NDQzLDIwMTM5MDgyNjIsNDE4NjcyMjE3LDMwNzAzNTY2MzQsMjU5NDczNDkyNywxODUyMTcxOTI1LDM4NjcwNjA5OTEsMzQ3MzQxNjYzNiwzOTA3NDQ4NTk3LDI2MTQ3Mzc2MzksOTE5NDg5MTM1LDE2NDk0ODYzOSwyMDk0NDEwMTYwLDI5OTc4MjU5NTYsNTkwNDI0NjM5LDI0ODYyMjQ1NDksMTcyMzg3MjY3NCwzMTU3NzUwODYyLDMzOTk5NDEyNTAsMzUwMTI1Mjc1MiwzNjI1MjY4MTM1LDI1NTUwNDgxOTYsMzY3MzYzNzM1NiwxMzQzMTI3NTAxLDQxMzAyODEzNjEsMzU5OTU5NTA4NSwyOTU3ODUzNjc5LDEyOTc0MDMwNTAsODE3ODE5MTAsMzA1MTU5MzQyNSwyMjgzNDkwNDEwLDUzMjIwMTc3MiwxMzY3Mjk1NTg5LDM5MjYxNzA5NzQsODk1Mjg3NjkyLDE5NTM3NTc4MzEsMTA5MzU5Nzk2Myw0OTI0ODM0MzEsMzUyODYyNjkwNywxNDQ2MjQyNTc2LDExOTI0NTU2MzgsMTYzNjYwNDYzMSwyMDkzMzYyMjUsMzQ0ODczNDY0LDEwMTU2NzE1NzEsNjY5OTYxODk3LDMzNzU3NDA3NjksMzg1NzU3MjEyNCwyOTczNTMwNjk1LDM3NDcxOTIwMTgsMTkzMzUzMDYxMCwzNDY0MDQyNTE2LDkzNTI5Mzg5NSwzNDU0Njg2MTk5LDI4NTgxMTUwNjksMTg2MzYzODg0NSwzNjgzMDIyOTE2LDQwODUzNjk1MTksMzI5MjQ0NTAzMiw4NzUzMTMxODgsMTA4MDAxNzU3MSwzMjc5MDMzODg1LDYyMTU5MTc3OCwxMjMzODU2NTcyLDI1MDQxMzAzMTcsMjQxOTc1NDQsMzAxNzY3MjcxNiwzODM1NDg0MzQwLDMyNDc0NjU1NTgsMjIyMDk4MTE5NSwzMDYwODQ3OTIyLDE1NTExMjQ1ODgsMTQ2Mzk5NjYwMF0sdz1bNDEwNDYwNTc3NywxMDk3MTU5NTUwLDM5NjY3MzgxOCw2NjA1MTAyNjYsMjg3NTk2ODMxNSwyNjM4NjA2NjIzLDQyMDAxMTUxMTYsMzgwODY2MjM0Nyw4MjE3MTIxNjAsMTk4NjkxODA2MSwzNDMwMzIyNTY4LDM4NTQ0ODg1LDM4NTYxMzcyOTUsNzE4MDAyMTE3LDg5MzY4MTcwMiwxNjU0ODg2MzI1LDI5NzU0ODQzODIsMzEyMjM1ODA1MywzOTI2ODI1MDI5LDQyNzQwNTM0NjksNzk2MTk3NTcxLDEyOTA4MDE3OTMsMTE4NDM0MjkyNSwzNTU2MzYxODM1LDI0MDU0MjY5NDcsMjQ1OTczNTMxNywxODM2NzcyMjg3LDEzODE2MjAzNzMsMzE5NjI2Nzk4OCwxOTQ4MzczODQ4LDM3NjQ5ODgyMzMsMzM4NTM0NTE2NiwzMjYzNzg1NTg5LDIzOTAzMjU0OTIsMTQ4MDQ4NTc4NSwzMTExMjQ3MTQzLDM3ODAwOTc3MjYsMjI5MzA0NTIzMiw1NDgxNjk0MTcsMzQ1OTk1Mzc4OSwzNzQ2MTc1MDc1LDQzOTQ1MjM4OSwxMzYyMzIxNTU5LDE0MDA4NDk3NjIsMTY4NTU3NzkwNSwxODA2NTk5MzU1LDIxNzQ3NTQwNDYsMTM3MDczOTEzLDEyMTQ3OTc5MzYsMTE3NDIxNTA1NSwzNzMxNjU0NTQ4LDIwNzk4OTc0MjYsMTk0MzIxNzA2NywxMjU4NDgwMjQyLDUyOTQ4Nzg0MywxNDM3MjgwODcwLDM5NDUyNjkxNzAsMzA0OTM5MDg5NSwzMzEzMjEyMDM4LDkyMzMxMzYxOSw2Nzk5OThlMywzMjE1MzA3Mjk5LDU3MzI2MDgyLDM3NzY0MjIyMSwzNDc0NzI5ODY2LDIwNDE4NzcxNTksMTMzMzYxOTA3LDE3NzY0NjAxMTAsMzY3MzQ3NjQ1Myw5NjM5MjQ1NCw4Nzg4NDU5MDUsMjgwMTY5OTUyNCw3NzcyMzE2NjgsNDA4MjQ3NTE3MCwyMzMwMDE0MjEzLDQxNDI2MjYyMTIsMjIxMzI5NjM5NSwxNjI2MzE5NDI0LDE5MDYyNDcyNjIsMTg0NjU2MzI2MSw1NjI3NTU5MDIsMzcwODE3MzcxOCwxMDQwNTU5ODM3LDM4NzExNjM5ODEsMTQxODU3MzIwMSwzMjk0NDMwNTc3LDExNDU4NTM0OCwxMzQzNjE4OTEyLDI1NjY1OTU2MDksMzE4NjIwMjU4MiwxMDc4MTg1MDk3LDM2NTEwNDExMjcsMzg5NjY4ODA0OCwyMzA3NjIyOTE5LDQyNTQwODc0MywzMzcxMDk2OTUzLDIwODEwNDg0ODEsMTEwODMzOTA2OCwyMjE2NjEwMjk2LDAsMjE1NjI5OTAxNyw3MzY5NzA4MDIsMjkyNTk2NzY2LDE1MTc0NDA2MjAsMjUxNjU3MjEzLDIyMzUwNjE3NzUsMjkzMzIwMjQ5Myw3NTg3MjAzMTAsMjY1OTA1MTYyLDE1NTQzOTE0MDAsMTUzMjI4NTMzOSw5MDg5OTkyMDQsMTc0NTY3NjkyLDE0NzQ3NjA1OTUsNDAwMjg2MTc0OCwyNjEwMDExNjc1LDMyMzQxNTY0MTYsMzY5MzEyNjI0MSwyMDAxNDMwODc0LDMwMzY5OTQ4NCwyNDc4NDQzMjM0LDI2ODcxNjU4ODgsNTg1MTIyNjIwLDQ1NDQ5OTYwMiwxNTE4NDk3NDIsMjM0NTExOTIxOCwzMDY0NTEwNzY1LDUxNDQ0MzI4NCw0MDQ0OTgxNTkxLDE5NjM0MTI2NTUsMjU4MTQ0NTYxNCwyMTM3MDYyODE5LDE5MzA4NTM1LDE5Mjg3MDcxNjQsMTcxNTE5MzE1Niw0MjE5MzUyMTU1LDExMjY3OTA3OTUsNjAwMjM1MjExLDM5OTI3NDIwNzAsMzg0MTAyNDk1Miw4MzY1NTM0MzEsMTY2OTY2NDgzNCwyNTM1NjA0MjQzLDMzMjMwMTEyMDQsMTI0MzkwNTQxMywzMTQxNDAwNzg2LDQxODA4MDgxMTAsNjk4NDQ1MjU1LDI2NTM4OTk1NDksMjk4OTU1MjYwNCwyMjUzNTgxMzI1LDMyNTI5MzI3MjcsMzAwNDU5MTE0NywxODkxMjExNjg5LDI0ODc4MTA1NzcsMzkxNTY1MzcwMyw0MjM3MDgzODE2LDQwMzA2Njc0MjQsMjEwMDA5MDk2Niw4NjUxMzY0MTgsMTIyOTg5OTY1NSw5NTMyNzA3NDUsMzM5OTY3OTYyOCwzNTU3NTA0NjY0LDQxMTg5MjUyMjIsMjA2MTM3OTc0OSwzMDc5NTQ2NTg2LDI5MTUwMTc3OTEsOTgzNDI2MDkyLDIwMjI4Mzc1ODQsMTYwNzI0NDY1MCwyMTE4NTQxOTA4LDIzNjY4ODI1NTAsMzYzNTk5NjgxNiw5NzI1MTI4MTQsMzI4MzA4ODc3MCwxNTY4NzE4NDk1LDM0OTkzMjY1NjksMzU3NjUzOTUwMyw2MjE5ODI2NzEsMjg5NTcyMzQ2NCw0MTA4ODc5NTIsMjYyMzc2MjE1MiwxMDAyMTQyNjgzLDY0NTQwMTAzNywxNDk0ODA3NjYyLDI1OTU2ODQ4NDQsMTMzNTUzNTc0NywyNTA3MDQwMjMwLDQyOTMyOTU3ODYsMzE2NzY4NDY0MSwzNjc1ODUwMDcsMzg4NTc1MDcxNCwxODY1ODYyNzMwLDI2NjgyMjE2NzQsMjk2MDk3MTMwNSwyNzYzMTczNjgxLDEwNTkyNzA5NTQsMjc3Nzk1MjQ1NCwyNzI0NjQyODY5LDEzMjA5NTc4MTIsMjE5NDMxOTEwMCwyNDI5NTk1ODcyLDI4MTU5NTYyNzUsNzcwODk1MjEsMzk3Mzc3MzEyMSwzNDQ0NTc1ODcxLDI0NDg4MzAyMzEsMTMwNTkwNjU1MCw0MDIxMzA4NzM5LDI4NTcxOTQ3MDAsMjUxNjkwMTg2MCwzNTE4MzU4NDMwLDE3ODczMDQ3ODAsNzQwMjc2NDE3LDE2OTk4Mzk4MTQsMTU5MjM5NDkwOSwyMzUyMzA3NDU3LDIyNzI1NTYwMjYsMTg4ODIxMjQzLDE3Mjk5NzcwMTEsMzY4Nzk5NDAwMiwyNzQwODQ4NDEsMzU5NDk4MjI1MywzNjEzNDk0NDI2LDI3MDE5NDk0OTUsNDE2MjA5NjcyOSwzMjI3MzQ1NzEsMjgzNzk2NjU0MiwxNjQwNTc2NDM5LDQ4NDgzMDY4OSwxMjAyNzk3NjkwLDM1Mzc4NTI4MjgsNDA2NzYzOTEyNSwzNDkwNzU3MzYsMzM0MjMxOTQ3NSw0MTU3NDY3MjE5LDQyNTU4MDAxNTksMTAzMDY5MDAxNSwxMTU1MjM3NDk2LDI5NTE5NzEyNzQsMTc1NzY5MTU3Nyw2MDczOTg5NjgsMjczODkwNTAyNiw0OTkzNDc5OTAsMzc5NDA3ODkwOCwxMDExNDUyNzEyLDIyNzg4NTU2NywyODE4NjY2ODA5LDIxMzExNDM3NiwzMDM0ODgxMjQwLDE0NTU1MjU5ODgsMzQxNDQ1MDU1NSw4NTA4MTcyMzcsMTgxNzk5ODQwOCwzMDkyNzI2NDgwXSxfPVswLDIzNTQ3NDE4Nyw0NzA5NDgzNzQsMzAzNzY1Mjc3LDk0MTg5Njc0OCw5MDg5MzM0MTUsNjA3NTMwNTU0LDcwODc4MDg0OSwxODgzNzkzNDk2LDIxMTgyMTQ5OTUsMTgxNzg2NjgzMCwxNjQ5NjM5MjM3LDEyMTUwNjExMDgsMTE4MTA0NTExOSwxNDE3NTYxNjk4LDE1MTc3Njc1MjksMzc2NzU4Njk5Miw0MDAzMDYxMTc5LDQyMzY0Mjk5OTAsNDA2OTI0Njg5MywzNjM1NzMzNjYwLDM2MDI3NzAzMjcsMzI5OTI3ODQ3NCwzNDAwNTI4NzY5LDI0MzAxMjIyMTYsMjY2NDU0MzcxNSwyMzYyMDkwMjM4LDIxOTM4NjI2NDUsMjgzNTEyMzM5NiwyODAxMTA3NDA3LDMwMzU1MzUwNTgsMzEzNTc0MDg4OSwzNjc4MTI0OTIzLDM1NzY4NzA1MTIsMzM0MTM5NDI4NSwzMzc0MzYxNzAyLDM4MTA0OTYzNDMsMzk3NzY3NTM1Niw0Mjc5MDgwMjU3LDQwNDM2MTAxODYsMjg3NjQ5NDYyNywyNzc2MjkyOTA0LDMwNzY2MzkwMjksMzExMDY1MDk0MiwyNDcyMDExNTM1LDI2NDAyNDMyMDQsMjQwMzcyODY2NSwyMTY5MzAzMDU4LDEwMDEwODk5OTUsODk5ODM1NTg0LDY2NjQ2NDczMyw2OTk0MzIxNTAsNTk3Mjc4NDcsMjI2OTA2ODYwLDUzMDQwMDc1MywyOTQ5MzA2ODIsMTI3MzE2ODc4NywxMTcyOTY3MDY0LDE0NzU0MTg1MDEsMTUwOTQzMDQxNCwxOTQyNDM1Nzc1LDIxMTA2Njc0NDQsMTg3NjI0MTgzMywxNjQxODE2MjI2LDI5MTAyMTk3NjYsMjc0MzAzNDEwOSwyOTc2MTUxNTIwLDMyMTE2MjMxNDcsMjUwNTIwMjEzOCwyNjA2NDUzOTY5LDIzMDI2OTAyNTIsMjI2OTcyODQ1NSwzNzExODI5NDIyLDM1NDM1OTkyNjksMzI0MDg5NDM5MiwzNDc1MzEzMzMxLDM4NDM2OTkwNzQsMzk0MzkwNjQ0MSw0MTc4MDYyMjI4LDQxNDQwNDc3NzUsMTMwNjk2NzM2NiwxMTM5NzgxNzA5LDEzNzQ5ODgxMTIsMTYxMDQ1OTczOSwxOTc1NjgzNDM0LDIwNzY5MzUyNjUsMTc3NTI3NjkyNCwxNzQyMzE1MTI3LDEwMzQ4Njc5OTgsODY2NjM3ODQ1LDU2NjAyMTg5Niw4MDA0NDA4MzUsOTI5ODc2OTgsMTkzMTk1MDY1LDQyOTQ1NjE2NCwzOTU0NDE3MTEsMTk4NDgxMjY4NSwyMDE3Nzc4NTY2LDE3ODQ2NjMxOTUsMTY4MzQwNzI0OCwxMzE1NTYyMTQ1LDEwODAwOTQ2MzQsMTM4Mzg1NjMxMSwxNTUxMDM3ODg0LDEwMTAzOTgyOSwxMzUwNTAyMDYsNDM3NzU3MTIzLDMzNzU1Mzg2NCwxMDQyMzg1NjU3LDgwNzk2MjYxMCw1NzM4MDQ3ODMsNzQyMDM5MDEyLDI1MzEwNjc0NTMsMjU2NDAzMzMzNCwyMzI4ODI4OTcxLDIyMjc1NzMwMjQsMjkzNTU2Njg2NSwyNzAwMDk5MzU0LDMwMDE3NTU2NTUsMzE2ODkzNzIyOCwzODY4NTUyODA1LDM5MDI1NjMxODIsNDIwMzE4MTE3MSw0MTAyOTc3OTEyLDM3MzYxNjQ5MzcsMzUwMTc0MTg5MCwzMjY1NDc4NzUxLDM0MzM3MTI5ODAsMTEwNjA0MTU5MSwxMzQwNDYzMTAwLDE1NzY5NzY2MDksMTQwODc0OTAzNCwyMDQzMjExNDgzLDIwMDkxOTU0NzIsMTcwODg0ODMzMywxODA5MDU0MTUwLDgzMjg3NzIzMSwxMDY4MzUxMzk2LDc2Njk0NTQ2NSw1OTk3NjIzNTQsMTU5NDE3OTg3LDEyNjQ1NDY2NCwzNjE5Mjk4NzcsNDYzMTgwMTkwLDI3MDkyNjA4NzEsMjk0MzY4MjM4MCwzMTc4MTA2OTYxLDMwMDk4NzkzODYsMjU3MjY5NzE5NSwyNTM4NjgxMTg0LDIyMzYyMjg3MzMsMjMzNjQzNDU1MCwzNTA5ODcxMTM1LDM3NDUzNDUzMDAsMzQ0MTg1MDM3NywzMjc0NjY3MjY2LDM5MTAxNjE5NzEsMzg3NzE5ODY0OCw0MTEwNTY4NDg1LDQyMTE4MTg3OTgsMjU5NzgwNjQ3NiwyNDk3NjA0NzQzLDIyNjEwODkxNzgsMjI5NTEwMTA3MywyNzMzODU2MTYwLDI5MDIwODc4NTEsMzIwMjQzNzA0NiwyOTY4MDExNDUzLDM5MzYyOTEyODQsMzgzNTAzNjg5NSw0MTM2NDQwNzcwLDQxNjk0MDgyMDEsMzUzNTQ4NjQ1NiwzNzAyNjY1NDU5LDM0NjcxOTIzMDIsMzIzMTcyMjIxMywyMDUxNTE4NzgwLDE5NTEzMTcwNDcsMTcxNjg5MDQxMCwxNzUwOTAyMzA1LDExMTM4MTgzODQsMTI4MjA1MDA3NSwxNTg0NTA0NTgyLDEzNTAwNzg5ODksMTY4ODEwODUyLDY3NTU2NDYzLDM3MTA0OTMzMCw0MDQwMTY3NjEsODQxNzM5NTkyLDEwMDg5MTg1OTUsNzc1NTUwODE0LDU0MDA4MDcyNSwzOTY5NTYyMzY5LDM4MDEzMzIyMzQsNDAzNTQ4OTA0Nyw0MjY5OTA3OTk2LDM1NjkyNTUyMTMsMzY2OTQ2MjU2NiwzMzY2NzU0NjE5LDMzMzI3NDAxNDQsMjYzMTA2NTQzMywyNDYzODc5NzYyLDIxNjAxMTcwNzEsMjM5NTU4ODY3NiwyNzY3NjQ1NTU3LDI4Njg4OTc0MDYsMzEwMjAxMTc0NywzMDY5MDQ5OTYwLDIwMjAwODQ5NywzMzc3ODM2MiwyNzAwNDA0ODcsNTA0NDU5NDM2LDg3NTQ1MTI5Myw5NzU2NTg2NDYsNjc1MDM5NjI3LDY0MTAyNTE1MiwyMDg0NzA0MjMzLDE5MTc1MTg1NjIsMTYxNTg2MTI0NywxODUxMzMyODUyLDExNDc1NTA2NjEsMTI0ODgwMjUxMCwxNDg0MDA1ODQzLDE0NTEwNDQwNTYsOTMzMzAxMzcwLDk2NzMxMTcyOSw3MzMxNTY5NzIsNjMyOTUzNzAzLDI2MDM4ODk1MCwyNTk2NTkxNywzMjg2NzE4MDgsNDk2OTA2MDU5LDEyMDY0Nzc4NTgsMTIzOTQ0Mzc1MywxNTQzMjA4NTAwLDE0NDE5NTI1NzUsMjE0NDE2MTgwNiwxOTA4Njk0Mjc3LDE2NzU1Nzc4ODAsMTg0Mjc1OTQ0MywzNjEwMzY5MjI2LDM2NDQzNzk1ODUsMzQwODExOTUxNiwzMzA3OTE2MjQ3LDQwMTExOTA1MDIsMzc3Njc2NzQ2OSw0MDc3Mzg0NDMyLDQyNDU2MTg2ODMsMjgwOTc3MTE1NCwyODQyNzM3MDQ5LDMxNDQzOTY0MjAsMzA0MzE0MDQ5NSwyNjczNzA1MTUwLDI0MzgyMzc2MjEsMjIwMzAzMjIzMiwyMzcwMjEzNzk1XSxNPVswLDE4NTQ2OTE5NywzNzA5MzgzOTQsNDg3NzI1ODQ3LDc0MTg3Njc4OCw2NTc4NjE5NDUsOTc1NDUxNjk0LDgyNDg1MjI1OSwxNDgzNzUzNTc2LDE0MDA3ODMyMDUsMTMxNTcyMzg5MCwxMTY0MDcxODA3LDE5NTA5MDMzODgsMjEzNTMxOTg4OSwxNjQ5NzA0NTE4LDE3Njc1MzY0NTksMjk2NzUwNzE1MiwzMTUyOTc2MzQ5LDI4MDE1NjY0MTAsMjkxODM1Mzg2MywyNjMxNDQ3NzgwLDI1NDc0MzI5MzcsMjMyODE0MzYxNCwyMTc3NTQ0MTc5LDM5MDE4MDY3NzYsMzgxODgzNjQwNSw0MjcwNjM5Nzc4LDQxMTg5ODc2OTUsMzI5OTQwOTAzNiwzNDgzODI1NTM3LDM1MzUwNzI5MTgsMzY1MjkwNDg1OSwyMDc3OTY1MjQzLDE4OTMwMjAzNDIsMTg0MTc2ODg2NSwxNzI0NDU3MTMyLDE0NzQ1MDI1NDMsMTU1OTA0MTY2NiwxMTA3MjM0MTk3LDEyNTczMDkzMzYsNTk4NDM4ODY3LDY4MTkzMzUzNCw5MDEyMTA1NjksMTA1MjMzODM3MiwyNjEzMTQ1MzUsNzc0MjIzMTQsNDI4ODE5OTY1LDMxMDQ2MzcyOCwzNDA5Njg1MzU1LDMyMjQ3NDA0NTQsMzcxMDM2ODExMywzNTkzMDU2MzgwLDM4NzU3NzAyMDcsMzk2MDMwOTMzMCw0MDQ1MzgwOTMzLDQxOTU0NTYwNzIsMjQ3MTIyNDA2NywyNTU0NzE4NzM0LDIyMzcxMzMwODEsMjM4ODI2MDg4NCwzMjEyMDM1ODk1LDMwMjgxNDM2NzQsMjg0MjY3ODU3MywyNzI0MzIyMzM2LDQxMzg1NjMxODEsNDI1NTM1MDYyNCwzNzY5NzIxOTc1LDM5NTUxOTExNjIsMzY2NzIxOTAzMywzNTE2NjE5NjA0LDM0MzE1NDY5NDcsMzM0NzUzMjExMCwyOTMzNzM0OTE3LDI3ODIwODI4MjQsMzA5OTY2NzQ4NywzMDE2Njk3MTA2LDIxOTYwNTI1MjksMjMxMzg4NDQ3NiwyNDk5MzQ4NTIzLDI2ODM3NjUwMzAsMTE3OTUxMDQ2MSwxMjk2Mjk3OTA0LDEzNDc1NDgzMjcsMTUzMzAxNzUxNCwxNzg2MTAyNDA5LDE2MzU1MDI5ODAsMjA4NzMwOTQ1OSwyMDAzMjk0NjIyLDUwNzM1ODkzMywzNTU3MDY4NDAsMTM2NDI4NzUxLDUzNDU4MzcwLDgzOTIyNDAzMyw5NTcwNTU5ODAsNjA1NjU3MzM5LDc5MDA3Mzg0NiwyMzczMzQwNjMwLDIyNTYwMjg4OTEsMjYwNzQzOTgyMCwyNDIyNDk0OTEzLDI3MDYyNzA2OTAsMjg1NjM0NTgzOSwzMDc1NjM2MjE2LDMxNjAxNzUzNDksMzU3Mzk0MTY5NCwzNzI1MDY5NDkxLDMyNzMyNjcxMDgsMzM1Njc2MTc2OSw0MTgxNTk4NjAyLDQwNjMyNDIzNzUsNDAxMTk5NjA0OCwzODI4MTAzODM3LDEwMzMyOTcxNTgsOTE1OTg1NDE5LDczMDUxNzI3Niw1NDU1NzIzNjksMjk2Njc5NzMwLDQ0Njc1NDg3OSwxMjkxNjYxMjAsMjEzNzA1MjUzLDE3MDk2MTAzNTAsMTg2MDczODE0NywxOTQ1Nzk4NTE2LDIwMjkyOTMxNzcsMTIzOTMzMTE2MiwxMTIwOTc0OTM1LDE2MDY1OTEyOTYsMTQyMjY5OTA4NSw0MTQ4MjkyODI2LDQyMzMwOTQ2MTUsMzc4MTAzMzY2NCwzOTMxMzcxNDY5LDM2ODIxOTE1OTgsMzQ5NzUwOTM0NywzNDQ2MDA0NDY4LDMzMjg5NTUzODUsMjkzOTI2NjIyNiwyNzU1NjM2NjcxLDMxMDY3ODA4NDAsMjk4ODY4NzI2OSwyMTk4NDM4MDIyLDIyODIxOTUzMzksMjUwMTIxODk3MiwyNjUyNjA5NDI1LDEyMDE3NjUzODYsMTI4NjU2NzE3NSwxMzcxMzY4OTc2LDE1MjE3MDY3ODEsMTgwNTIxMTcxMCwxNjIwNTI5NDU5LDIxMDU4ODcyNjgsMTk4ODgzODE4NSw1MzM4MDQxMzAsMzUwMTc0NTc1LDE2NDQzOTY3Miw0NjM0NjEwMSw4NzA5MTIwODYsOTU0NjY5NDAzLDYzNjgxMzkwMCw3ODgyMDQzNTMsMjM1ODk1NzkyMSwyMjc0NjgwNDI4LDI1OTI1MjM2NDMsMjQ0MTY2MTU1OCwyNjk1MDMzNjg1LDI4ODAyNDAyMTYsMzA2NTk2MjgzMSwzMTgyNDg3NjE4LDM1NzIxNDU5MjksMzc1NjI5OTc4MCwzMjcwOTM3ODc1LDMzODg1MDcxNjYsNDE3NDU2MDA2MSw0MDkxMzI3MDI0LDQwMDY1MjExMjcsMzg1NDYwNjM3OCwxMDE0NjQ2NzA1LDkzMDM2OTIxMiw3MTEzNDk2NzUsNTYwNDg3NTkwLDI3Mjc4NjMwOSw0NTc5OTI4NDAsMTA2ODUyNzY3LDIyMzM3NzU1NCwxNjc4MzgxMDE3LDE4NjI1MzQ4NjgsMTkxNDA1MjAzNSwyMDMxNjIxMzI2LDEyMTEyNDc1OTcsMTEyODAxNDU2MCwxNTgwMDg3Nzk5LDE0MjgxNzMwNTAsMzIyODMzMTksMTgyNjIxMTE0LDQwMTYzOTU5Nyw0ODY0NDEzNzYsNzY4OTE3MTIzLDY1MTg2ODA0NiwxMDAzMDA3MTI5LDgxODMyNDg4NCwxNTAzNDQ5ODIzLDEzODUzNTYyNDIsMTMzMzgzODAyMSwxMTUwMjA4NDU2LDE5NzM3NDUzODcsMjEyNTEzNTg0NiwxNjczMDYxNjE3LDE3NTY4MTg5NDAsMjk3MDM1NjMyNywzMTIwNjk0MTIyLDI4MDI4NDk5MTcsMjg4NzY1MTY5NiwyNjM3NDQyNjQzLDI1MjAzOTM1NjYsMjMzNDY2OTg5NywyMTQ5OTg3NjUyLDM5MTcyMzQ3MDMsMzc5OTE0MTEyMiw0Mjg0NTAyMDM3LDQxMDA4NzI0NzIsMzMwOTU5NDE3MSwzNDYwOTg0NjMwLDM1NDU3ODk0NzMsMzYyOTU0Njc5NiwyMDUwNDY2MDYwLDE4OTk2MDM5NjksMTgxNDgwMzIyMiwxNzMwNTI1NzIzLDE0NDM4NTc3MjAsMTU2MDM4MjUxNywxMDc1MDI1Njk4LDEyNjAyMzIyMzksNTc1MTM4MTQ4LDY5MjcwNzQzMyw4Nzg0NDMzOTAsMTA2MjU5NzIzNSwyNDMyNTY2NTYsOTEzNDE5MTcsNDA5MTk4NDEwLDMyNTk2NTM4MywzNDAzMTAwNjM2LDMyNTIyMzg1NDUsMzcwNDMwMDQ4NiwzNjIwMDIyOTg3LDM4NzQ0MjgzOTIsMzk5MDk1MzE4OSw0MDQyNDU5MTIyLDQyMjc2NjU2NjMsMjQ2MDQ0OTIwNCwyNTc4MDE4NDg5LDIyMjY4NzUzMTAsMjQxMTAyOTE1NSwzMTk4MTE1MjAwLDMwNDYyMDA0NjEsMjgyNzE3Nzg4MiwyNzQzOTQ0ODU1XSxBPVswLDIxODgyODI5Nyw0Mzc2NTY1OTQsMzg3NzgxMTQ3LDg3NTMxMzE4OCw5NTg4NzEwODUsNzc1NTYyMjk0LDU5MDQyNDYzOSwxNzUwNjI2Mzc2LDE2OTk5NzA2MjUsMTkxNzc0MjE3MCwyMTM1MjUzNTg3LDE1NTExMjQ1ODgsMTM2NzI5NTU4OSwxMTgwODQ5Mjc4LDEyNjUxOTU2MzksMzUwMTI1Mjc1MiwzNzIwMDgxMDQ5LDMzOTk5NDEyNTAsMzM1MDA2NTgwMywzODM1NDg0MzQwLDM5MTkwNDIyMzcsNDI3MDUwNzE3NCw0MDg1MzY5NTE5LDMxMDIyNDkxNzYsMzA1MTU5MzQyNSwyNzM0NTkxMTc4LDI5NTIxMDI1OTUsMjM2MTY5ODU1NiwyMTc3ODY5NTU3LDI1MzAzOTEyNzgsMjYxNDczNzYzOSwzMTQ1NDU2NDQzLDMwNjA4NDc5MjIsMjcwODMyNjE4NSwyODkyNDE3MzEyLDI0MDQ5MDE2NjMsMjE4NzEyODA4NiwyNTA0MTMwMzE3LDI1NTUwNDgxOTYsMzU0MjMzMDIyNywzNzI3MjA1NzU0LDMzNzU3NDA3NjksMzI5MjQ0NTAzMiwzODc2NTU3NjU1LDM5MjYxNzA5NzQsNDI0NjMxMDcyNSw0MDI3NzQ0NTg4LDE4MDg0ODExOTUsMTcyMzg3MjY3NCwxOTEwMzE5MDMzLDIwOTQ0MTAxNjAsMTYwODk3NTI0NywxMzkxMjAxNjcwLDExNzM0MzAxNzMsMTIyNDM0ODA1Miw1OTk4NDg2NywyNDQ4NjAzOTQsNDI4MTY5MjAxLDM0NDg3MzQ2NCw5MzUyOTM4OTUsOTg0OTA3MjE0LDc2NjA3ODkzMyw1NDc1MTI3OTYsMTg0NDg4MjgwNiwxNjI3MjM1MTk5LDIwMTEyMTQxODAsMjA2MjI3MDMxNywxNTA3NDk3Mjk4LDE0MjMwMjI5MzksMTEzNzQ3Nzk1MiwxMzIxNjk5MTQ1LDk1MzQ1OTgyLDE0NTA4NTIzOSw1MzIyMDE3NzIsMzEzNzczODYxLDgzMDY2MTkxNCwxMDE1NjcxNTcxLDczMTE4MzM2OCw2NDgwMTc2NjUsMzE3NTUwMTI4NiwyOTU3ODUzNjc5LDI4MDcwNTg5MzIsMjg1ODExNTA2OSwyMzA1NDU1NTU0LDIyMjA5ODExOTUsMjQ3NDQwNDMwNCwyNjU4NjI1NDk3LDM1NzU1Mjg4NzgsMzYyNTI2ODEzNSwzNDczNDE2NjM2LDMyNTQ5ODg3MjUsMzc3ODE1MTgxOCwzOTYzMTYxNDc1LDQyMTM0NDcwNjQsNDEzMDI4MTM2MSwzNTk5NTk1MDg1LDM2ODMwMjI5MTYsMzQzMjczNzM3NSwzMjQ3NDY1NTU4LDM4MDIyMjIxODUsNDAyMDkxMjIyNCw0MTcyNzYzNzcxLDQxMjI3NjIzNTQsMzIwMTYzMTc0OSwzMDE3NjcyNzE2LDI3NjQyNDk2MjMsMjg0ODQ2MTg1NCwyMzMxNTkwMTc3LDIyODA3OTYyMDAsMjQzMTU5MDk2MywyNjQ4OTc2NDQyLDEwNDY5OTYxMywxODgxMjc0NDQsNDcyNjE1NjMxLDI4NzM0MzgxNCw4NDAwMTk3MDUsMTA1ODcwOTc0NCw2NzE1OTMxOTUsNjIxNTkxNzc4LDE4NTIxNzE5MjUsMTY2ODIxMjg5MiwxOTUzNzU3ODMxLDIwMzc5NzAwNjIsMTUxNDc5MDU3NywxNDYzOTk2NjAwLDEwODAwMTc1NzEsMTI5NzQwMzA1MCwzNjczNjM3MzU2LDM2MjM2MzY5NjUsMzIzNTk5NTEzNCwzNDU0Njg2MTk5LDQwMDczNjA5NjgsMzgyMjA5MDE3Nyw0MTA3MTAxNjU4LDQxOTA1MzA1MTUsMjk5NzgyNTk1NiwzMjE1MjEyNDYxLDI4MzA3MDgxNTAsMjc3OTkxNTE5OSwyMjU2NzM0NTkyLDIzNDA5NDc4NDksMjYyNzAxNjA4MiwyNDQzMDU4MDc1LDE3MjQ2NjU1NiwxMjI0NjYxNjUsMjczNzkyMzY2LDQ5MjQ4MzQzMSwxMDQ3MjM5ZTMsODYxOTY4MjA5LDYxMjIwNTg5OCw2OTU2MzQ3NTUsMTY0NjI1MjM0MCwxODYzNjM4ODQ1LDIwMTM5MDgyNjIsMTk2MzExNTMxMSwxNDQ2MjQyNTc2LDE1MzA0NTU4MzMsMTI3NzU1NTk3MCwxMDkzNTk3OTYzLDE2MzY2MDQ2MzEsMTgyMDgyNDc5OCwyMDczNzI0NjEzLDE5ODkyNDkyMjgsMTQzNjU5MDgzNSwxNDg3NjQ1OTQ2LDEzMzczNzY0ODEsMTExOTcyNzg0OCwxNjQ5NDg2MzksODE3ODE5MTAsMzMxNTQ0MjA1LDUxNjU1MjgzNiwxMDM5NzE3MDUxLDgyMTI4ODExNCw2Njk5NjE4OTcsNzE5NzAwMTI4LDI5NzM1MzA2OTUsMzE1Nzc1MDg2MiwyODcxNjgyNjQ1LDI3ODcyMDcyNjAsMjIzMjQzNTI5OSwyMjgzNDkwNDEwLDI2Njc5OTQ3MzcsMjQ1MDM0NjEwNCwzNjQ3MjEyMDQ3LDM1NjQwNDUzMTgsMzI3OTAzMzg4NSwzNDY0MDQyNTE2LDM5ODA5MzE2MjcsMzc2MjUwMjY5MCw0MTUwMTQ0NTY5LDQxOTk4ODI4MDAsMzA3MDM1NjYzNCwzMTIxMjc1NTM5LDI5MDQwMjcyNzIsMjY4NjI1NDcyMSwyMjAwODE4ODc4LDIzODQ5MTEwMzEsMjU3MDgzMjA0NCwyNDg2MjI0NTQ5LDM3NDcxOTIwMTgsMzUyODYyNjkwNywzMzEwMzIxODU2LDMzNTk5MzYyMDEsMzk1MDM1NTcwMiwzODY3MDYwOTkxLDQwNDk4NDQ0NTIsNDIzNDcyMTAwNSwxNzM5NjU2MjAyLDE3OTA1NzUxMDcsMjEwODEwMDYzMiwxODkwMzI4MDgxLDE0MDI4MTE0MzgsMTU4NjkwMzU5MSwxMjMzODU2NTcyLDExNDkyNDkwNzcsMjY2OTU5OTM4LDQ4Mzk0ODI3LDM2OTA1Nzg3Miw0MTg2NzIyMTcsMTAwMjc4Mzg0Niw5MTk0ODkxMzUsNTY3NDk4ODY4LDc1MjM3NTQyMSwyMDkzMzYyMjUsMjQxOTc1NDQsMzc2MTg3ODI3LDQ1OTc0NDY5OCw5NDUxNjQxNjUsODk1Mjg3NjkyLDU3NDYyNDY2Myw3OTM0NTE5MzQsMTY3OTk2ODIzMywxNzY0MzEzNTY4LDIxMTczNjA2MzUsMTkzMzUzMDYxMCwxMzQzMTI3NTAxLDE1NjA2Mzc4OTIsMTI0MzExMjQxNSwxMTkyNDU1NjM4LDM3MDQyODA4ODEsMzUxOTE0MjIwMCwzMzM2MzU4NjkxLDM0MTk5MTU1NjIsMzkwNzQ0ODU5NywzODU3NTcyMTI0LDQwNzU4NzcxMjcsNDI5NDcwNDM5OCwzMDI5NTEwMDA5LDMxMTM4NTUzNDQsMjkyNzkzNDMxNSwyNzQ0MTA0MjkwLDIxNTk5NzYyODUsMjM3NzQ4NjY3NiwyNTk0NzM0OTI3LDI1NDQwNzgxNTBdLEU9WzAsMTUxODQ5NzQyLDMwMzY5OTQ4NCw0NTQ0OTk2MDIsNjA3Mzk4OTY4LDc1ODcyMDMxMCw5MDg5OTkyMDQsMTA1OTI3MDk1NCwxMjE0Nzk3OTM2LDEwOTcxNTk1NTAsMTUxNzQ0MDYyMCwxNDAwODQ5NzYyLDE4MTc5OTg0MDgsMTY5OTgzOTgxNCwyMTE4NTQxOTA4LDIwMDE0MzA4NzQsMjQyOTU5NTg3MiwyNTgxNDQ1NjE0LDIxOTQzMTkxMDAsMjM0NTExOTIxOCwzMDM0ODgxMjQwLDMxODYyMDI1ODIsMjgwMTY5OTUyNCwyOTUxOTcxMjc0LDM2MzU5OTY4MTYsMzUxODM1ODQzMCwzMzk5Njc5NjI4LDMyODMwODg3NzAsNDIzNzA4MzgxNiw0MTE4OTI1MjIyLDQwMDI4NjE3NDgsMzg4NTc1MDcxNCwxMDAyMTQyNjgzLDg1MDgxNzIzNyw2OTg0NDUyNTUsNTQ4MTY5NDE3LDUyOTQ4Nzg0MywzNzc2NDIyMjEsMjI3ODg1NTY3LDc3MDg5NTIxLDE5NDMyMTcwNjcsMjA2MTM3OTc0OSwxNjQwNTc2NDM5LDE3NTc2OTE1NzcsMTQ3NDc2MDU5NSwxNTkyMzk0OTA5LDExNzQyMTUwNTUsMTI5MDgwMTc5MywyODc1OTY4MzE1LDI3MjQ2NDI4NjksMzExMTI0NzE0MywyOTYwOTcxMzA1LDI0MDU0MjY5NDcsMjI1MzU4MTMyNSwyNjM4NjA2NjIzLDI0ODc4MTA1NzcsMzgwODY2MjM0NywzOTI2ODI1MDI5LDQwNDQ5ODE1OTEsNDE2MjA5NjcyOSwzMzQyMzE5NDc1LDM0NTk5NTM3ODksMzU3NjUzOTUwMywzNjkzMTI2MjQxLDE5ODY5MTgwNjEsMjEzNzA2MjgxOSwxNjg1NTc3OTA1LDE4MzY3NzIyODcsMTM4MTYyMDM3MywxNTMyMjg1MzM5LDEwNzgxODUwOTcsMTIyOTg5OTY1NSwxMDQwNTU5ODM3LDkyMzMxMzYxOSw3NDAyNzY0MTcsNjIxOTgyNjcxLDQzOTQ1MjM4OSwzMjI3MzQ1NzEsMTM3MDczOTEzLDE5MzA4NTM1LDM4NzExNjM5ODEsNDAyMTMwODczOSw0MTA0NjA1Nzc3LDQyNTU4MDAxNTksMzI2Mzc4NTU4OSwzNDE0NDUwNTU1LDM0OTkzMjY1NjksMzY1MTA0MTEyNywyOTMzMjAyNDkzLDI4MTU5NTYyNzUsMzE2NzY4NDY0MSwzMDQ5MzkwODk1LDIzMzAwMTQyMTMsMjIxMzI5NjM5NSwyNTY2NTk1NjA5LDI0NDg4MzAyMzEsMTMwNTkwNjU1MCwxMTU1MjM3NDk2LDE2MDcyNDQ2NTAsMTQ1NTUyNTk4OCwxNzc2NDYwMTEwLDE2MjYzMTk0MjQsMjA3OTg5NzQyNiwxOTI4NzA3MTY0LDk2MzkyNDU0LDIxMzExNDM3NiwzOTY2NzM4MTgsNTE0NDQzMjg0LDU2Mjc1NTkwMiw2Nzk5OThlMyw4NjUxMzY0MTgsOTgzNDI2MDkyLDM3MDgxNzM3MTgsMzU1NzUwNDY2NCwzNDc0NzI5ODY2LDMzMjMwMTEyMDQsNDE4MDgwODExMCw0MDMwNjY3NDI0LDM5NDUyNjkxNzAsMzc5NDA3ODkwOCwyNTA3MDQwMjMwLDI2MjM3NjIxNTIsMjI3MjU1NjAyNiwyMzkwMzI1NDkyLDI5NzU0ODQzODIsMzA5MjcyNjQ4MCwyNzM4OTA1MDI2LDI4NTcxOTQ3MDAsMzk3Mzc3MzEyMSwzODU2MTM3Mjk1LDQyNzQwNTM0NjksNDE1NzQ2NzIxOSwzMzcxMDk2OTUzLDMyNTI5MzI3MjcsMzY3MzQ3NjQ1MywzNTU2MzYxODM1LDI3NjMxNzM2ODEsMjkxNTAxNzc5MSwzMDY0NTEwNzY1LDMyMTUzMDcyOTksMjE1NjI5OTAxNywyMzA3NjIyOTE5LDI0NTk3MzUzMTcsMjYxMDAxMTY3NSwyMDgxMDQ4NDgxLDE5NjM0MTI2NTUsMTg0NjU2MzI2MSwxNzI5OTc3MDExLDE0ODA0ODU3ODUsMTM2MjMyMTU1OSwxMjQzOTA1NDEzLDExMjY3OTA3OTUsODc4ODQ1OTA1LDEwMzA2OTAwMTUsNjQ1NDAxMDM3LDc5NjE5NzU3MSwyNzQwODQ4NDEsNDI1NDA4NzQzLDM4NTQ0ODg1LDE4ODgyMTI0MywzNjEzNDk0NDI2LDM3MzE2NTQ1NDgsMzMxMzIxMjAzOCwzNDMwMzIyNTY4LDQwODI0NzUxNzAsNDIwMDExNTExNiwzNzgwMDk3NzI2LDM4OTY2ODgwNDgsMjY2ODIyMTY3NCwyNTE2OTAxODYwLDIzNjY4ODI1NTAsMjIxNjYxMDI5NiwzMTQxNDAwNzg2LDI5ODk1NTI2MDQsMjgzNzk2NjU0MiwyNjg3MTY1ODg4LDEyMDI3OTc2OTAsMTMyMDk1NzgxMiwxNDM3MjgwODcwLDE1NTQzOTE0MDAsMTY2OTY2NDgzNCwxNzg3MzA0NzgwLDE5MDYyNDcyNjIsMjAyMjgzNzU4NCwyNjU5MDUxNjIsMTE0NTg1MzQ4LDQ5OTM0Nzk5MCwzNDkwNzU3MzYsNzM2OTcwODAyLDU4NTEyMjYyMCw5NzI1MTI4MTQsODIxNzEyMTYwLDI1OTU2ODQ4NDQsMjQ3ODQ0MzIzNCwyMjkzMDQ1MjMyLDIxNzQ3NTQwNDYsMzE5NjI2Nzk4OCwzMDc5NTQ2NTg2LDI4OTU3MjM0NjQsMjc3Nzk1MjQ1NCwzNTM3ODUyODI4LDM2ODc5OTQwMDIsMzIzNDE1NjQxNiwzMzg1MzQ1MTY2LDQxNDI2MjYyMTIsNDI5MzI5NTc4NiwzODQxMDI0OTUyLDM5OTI3NDIwNzAsMTc0NTY3NjkyLDU3MzI2MDgyLDQxMDg4Nzk1MiwyOTI1OTY3NjYsNzc3MjMxNjY4LDY2MDUxMDI2NiwxMDExNDUyNzEyLDg5MzY4MTcwMiwxMTA4MzM5MDY4LDEyNTg0ODAyNDIsMTM0MzYxODkxMiwxNDk0ODA3NjYyLDE3MTUxOTMxNTYsMTg2NTg2MjczMCwxOTQ4MzczODQ4LDIxMDAwOTA5NjYsMjcwMTk0OTQ5NSwyODE4NjY2ODA5LDMwMDQ1OTExNDcsMzEyMjM1ODA1MywyMjM1MDYxNzc1LDIzNTIzMDc0NTcsMjUzNTYwNDI0MywyNjUzODk5NTQ5LDM5MTU2NTM3MDMsMzc2NDk4ODIzMyw0MjE5MzUyMTU1LDQwNjc2MzkxMjUsMzQ0NDU3NTg3MSwzMjk0NDMwNTc3LDM3NDYxNzUwNzUsMzU5NDk4MjI1Myw4MzY1NTM0MzEsOTUzMjcwNzQ1LDYwMDIzNTIxMSw3MTgwMDIxMTcsMzY3NTg1MDA3LDQ4NDgzMDY4OSwxMzMzNjE5MDcsMjUxNjU3MjEzLDIwNDE4NzcxNTksMTg5MTIxMTY4OSwxODA2NTk5MzU1LDE2NTQ4ODYzMjUsMTU2ODcxODQ5NSwxNDE4NTczMjAxLDEzMzU1MzU3NDcsMTE4NDM0MjkyNV07ZnVuY3Rpb24gUyhlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cis9NCl0LnB1c2goZVtyXTw8MjR8ZVtyKzFdPDwxNnxlW3IrMl08PDh8ZVtyKzNdKTtyZXR1cm4gdH12YXIgaz1mdW5jdGlvbihlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBrKSl0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwia2V5XCIse3ZhbHVlOm8oZSwhMCl9KSx0aGlzLl9wcmVwYXJlKCl9O2sucHJvdG90eXBlLl9wcmVwYXJlPWZ1bmN0aW9uKCl7dmFyIGU9Zlt0aGlzLmtleS5sZW5ndGhdO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpXCIpO3RoaXMuX0tlPVtdLHRoaXMuX0tkPVtdO2Zvcih2YXIgdD0wO3Q8PWU7dCsrKXRoaXMuX0tlLnB1c2goWzAsMCwwLDBdKSx0aGlzLl9LZC5wdXNoKFswLDAsMCwwXSk7Zm9yKHZhciByLG49NCooZSsxKSxpPXRoaXMua2V5Lmxlbmd0aC80LG89Uyh0aGlzLmtleSksdD0wO3Q8aTt0Kyspcj10Pj4yLHRoaXMuX0tlW3JdW3QlNF09b1t0XSx0aGlzLl9LZFtlLXJdW3QlNF09b1t0XTtmb3IodmFyIHMsYT0wLHU9aTt1PG47KXtpZihzPW9baS0xXSxvWzBdXj1kW3M+PjE2JjI1NV08PDI0XmRbcz4+OCYyNTVdPDwxNl5kWzI1NSZzXTw8OF5kW3M+PjI0JjI1NV1eY1thXTw8MjQsYSs9MSw4IT1pKWZvcih0PTE7dDxpO3QrKylvW3RdXj1vW3QtMV07ZWxzZXtmb3IodD0xO3Q8aS8yO3QrKylvW3RdXj1vW3QtMV07cz1vW2kvMi0xXSxvW2kvMl1ePWRbMjU1JnNdXmRbcz4+OCYyNTVdPDw4XmRbcz4+MTYmMjU1XTw8MTZeZFtzPj4yNCYyNTVdPDwyNDtmb3IodD1pLzIrMTt0PGk7dCsrKW9bdF1ePW9bdC0xXX1mb3IodD0wO3Q8aSYmdTxuOylsPXU+PjIsaD11JTQsdGhpcy5fS2VbbF1baF09b1t0XSx0aGlzLl9LZFtlLWxdW2hdPW9bdCsrXSx1Kyt9Zm9yKHZhciBsPTE7bDxlO2wrKylmb3IodmFyIGg9MDtoPDQ7aCsrKXM9dGhpcy5fS2RbbF1baF0sdGhpcy5fS2RbbF1baF09X1tzPj4yNCYyNTVdXk1bcz4+MTYmMjU1XV5BW3M+PjgmMjU1XV5FWzI1NSZzXX0say5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihlKXtpZigxNiE9ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7Zm9yKHZhciB0PXRoaXMuX0tlLmxlbmd0aC0xLHI9WzAsMCwwLDBdLG49UyhlKSxpPTA7aTw0O2krKyluW2ldXj10aGlzLl9LZVswXVtpXTtmb3IodmFyIG89MTtvPHQ7bysrKXtmb3IoaT0wO2k8NDtpKyspcltpXT1oW25baV0+PjI0JjI1NV1ecFtuWyhpKzEpJTRdPj4xNiYyNTVdXnZbblsoaSsyKSU0XT4+OCYyNTVdXnlbMjU1Jm5bKGkrMyklNF1dXnRoaXMuX0tlW29dW2ldO249ci5zbGljZSgpfWZvcih2YXIgcyxhPXUoMTYpLGk9MDtpPDQ7aSsrKXM9dGhpcy5fS2VbdF1baV0sYVs0KmldPTI1NSYoZFtuW2ldPj4yNCYyNTVdXnM+PjI0KSxhWzQqaSsxXT0yNTUmKGRbblsoaSsxKSU0XT4+MTYmMjU1XV5zPj4xNiksYVs0KmkrMl09MjU1JihkW25bKGkrMiklNF0+PjgmMjU1XV5zPj44KSxhWzQqaSszXT0yNTUmKGRbMjU1Jm5bKGkrMyklNF1dXnMpO3JldHVybiBhfSxrLnByb3RvdHlwZS5kZWNyeXB0PWZ1bmN0aW9uKGUpe2lmKDE2IT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7Zm9yKHZhciB0PXRoaXMuX0tkLmxlbmd0aC0xLHI9WzAsMCwwLDBdLG49UyhlKSxpPTA7aTw0O2krKyluW2ldXj10aGlzLl9LZFswXVtpXTtmb3IodmFyIG89MTtvPHQ7bysrKXtmb3IoaT0wO2k8NDtpKyspcltpXT1tW25baV0+PjI0JjI1NV1eZ1tuWyhpKzMpJTRdPj4xNiYyNTVdXmJbblsoaSsyKSU0XT4+OCYyNTVdXndbMjU1Jm5bKGkrMSklNF1dXnRoaXMuX0tkW29dW2ldO249ci5zbGljZSgpfWZvcih2YXIgcyxhPXUoMTYpLGk9MDtpPDQ7aSsrKXM9dGhpcy5fS2RbdF1baV0sYVs0KmldPTI1NSYobFtuW2ldPj4yNCYyNTVdXnM+PjI0KSxhWzQqaSsxXT0yNTUmKGxbblsoaSszKSU0XT4+MTYmMjU1XV5zPj4xNiksYVs0KmkrMl09MjU1JihsW25bKGkrMiklNF0+PjgmMjU1XV5zPj44KSxhWzQqaSszXT0yNTUmKGxbMjU1Jm5bKGkrMSklNF1dXnMpO3JldHVybiBhfTt2YXIgTj1mdW5jdGlvbihlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBOKSl0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpO3RoaXMuZGVzY3JpcHRpb249XCJFbGVjdHJvbmljIENvZGUgQmxvY2tcIix0aGlzLm5hbWU9XCJlY2JcIix0aGlzLl9hZXM9bmV3IGsoZSl9O04ucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSl7aWYoKGU9byhlKSkubGVuZ3RoJTE2IT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO2Zvcih2YXIgdD11KGUubGVuZ3RoKSxyPXUoMTYpLG49MDtuPGUubGVuZ3RoO24rPTE2KXMoZSxyLDAsbixuKzE2KSxzKHI9dGhpcy5fYWVzLmVuY3J5cHQociksdCxuKTtyZXR1cm4gdH0sTi5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihlKXtpZigoZT1vKGUpKS5sZW5ndGglMTYhPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO2Zvcih2YXIgdD11KGUubGVuZ3RoKSxyPXUoMTYpLG49MDtuPGUubGVuZ3RoO24rPTE2KXMoZSxyLDAsbixuKzE2KSxzKHI9dGhpcy5fYWVzLmRlY3J5cHQociksdCxuKTtyZXR1cm4gdH07dmFyIHg9ZnVuY3Rpb24oZSx0KXtpZighKHRoaXMgaW5zdGFuY2VvZiB4KSl0aHJvdyBFcnJvcihcIkFFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgXCIpO2lmKHRoaXMuZGVzY3JpcHRpb249XCJDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcIix0aGlzLm5hbWU9XCJjYmNcIix0KXtpZigxNiE9dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpXCIpfWVsc2UgdD11KDE2KTt0aGlzLl9sYXN0Q2lwaGVyYmxvY2s9byh0LCEwKSx0aGlzLl9hZXM9bmV3IGsoZSl9O3gucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSl7aWYoKGU9byhlKSkubGVuZ3RoJTE2IT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO2Zvcih2YXIgdD11KGUubGVuZ3RoKSxyPXUoMTYpLG49MDtuPGUubGVuZ3RoO24rPTE2KXtzKGUsciwwLG4sbisxNik7Zm9yKHZhciBpPTA7aTwxNjtpKyspcltpXV49dGhpcy5fbGFzdENpcGhlcmJsb2NrW2ldO3RoaXMuX2xhc3RDaXBoZXJibG9jaz10aGlzLl9hZXMuZW5jcnlwdChyKSxzKHRoaXMuX2xhc3RDaXBoZXJibG9jayx0LG4pfXJldHVybiB0fSx4LnByb3RvdHlwZS5kZWNyeXB0PWZ1bmN0aW9uKGUpe2lmKChlPW8oZSkpLmxlbmd0aCUxNiE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7Zm9yKHZhciB0PXUoZS5sZW5ndGgpLHI9dSgxNiksbj0wO248ZS5sZW5ndGg7bis9MTYpe3MoZSxyLDAsbixuKzE2KSxyPXRoaXMuX2Flcy5kZWNyeXB0KHIpO2Zvcih2YXIgaT0wO2k8MTY7aSsrKXRbbitpXT1yW2ldXnRoaXMuX2xhc3RDaXBoZXJibG9ja1tpXTtzKGUsdGhpcy5fbGFzdENpcGhlcmJsb2NrLDAsbixuKzE2KX1yZXR1cm4gdH07dmFyIFA9ZnVuY3Rpb24oZSx0LHIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFApKXRocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIik7aWYodGhpcy5kZXNjcmlwdGlvbj1cIkNpcGhlciBGZWVkYmFja1wiLHRoaXMubmFtZT1cImNmYlwiLHQpe2lmKDE2IT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBzaXplKVwiKX1lbHNlIHQ9dSgxNik7cj1yfHwxLHRoaXMuc2VnbWVudFNpemU9cix0aGlzLl9zaGlmdFJlZ2lzdGVyPW8odCwhMCksdGhpcy5fYWVzPW5ldyBrKGUpfTtQLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKGUpe2lmKGUubGVuZ3RoJXRoaXMuc2VnbWVudFNpemUhPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcylcIik7Zm9yKHZhciB0LHI9byhlLCEwKSxuPTA7bjxyLmxlbmd0aDtuKz10aGlzLnNlZ21lbnRTaXplKXt0PXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO2Zvcih2YXIgaT0wO2k8dGhpcy5zZWdtZW50U2l6ZTtpKyspcltuK2ldXj10W2ldO3ModGhpcy5fc2hpZnRSZWdpc3Rlcix0aGlzLl9zaGlmdFJlZ2lzdGVyLDAsdGhpcy5zZWdtZW50U2l6ZSkscyhyLHRoaXMuX3NoaWZ0UmVnaXN0ZXIsMTYtdGhpcy5zZWdtZW50U2l6ZSxuLG4rdGhpcy5zZWdtZW50U2l6ZSl9cmV0dXJuIHJ9LFAucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24oZSl7aWYoZS5sZW5ndGgldGhpcy5zZWdtZW50U2l6ZSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcylcIik7Zm9yKHZhciB0LHI9byhlLCEwKSxuPTA7bjxyLmxlbmd0aDtuKz10aGlzLnNlZ21lbnRTaXplKXt0PXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO2Zvcih2YXIgaT0wO2k8dGhpcy5zZWdtZW50U2l6ZTtpKyspcltuK2ldXj10W2ldO3ModGhpcy5fc2hpZnRSZWdpc3Rlcix0aGlzLl9zaGlmdFJlZ2lzdGVyLDAsdGhpcy5zZWdtZW50U2l6ZSkscyhlLHRoaXMuX3NoaWZ0UmVnaXN0ZXIsMTYtdGhpcy5zZWdtZW50U2l6ZSxuLG4rdGhpcy5zZWdtZW50U2l6ZSl9cmV0dXJuIHJ9O3ZhciBJPWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2YgSSkpdGhyb3cgRXJyb3IoXCJBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKTtpZih0aGlzLmRlc2NyaXB0aW9uPVwiT3V0cHV0IEZlZWRiYWNrXCIsdGhpcy5uYW1lPVwib2ZiXCIsdCl7aWYoMTYhPXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKX1lbHNlIHQ9dSgxNik7dGhpcy5fbGFzdFByZWNpcGhlcj1vKHQsITApLHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleD0xNix0aGlzLl9hZXM9bmV3IGsoZSl9O0kucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW8oZSwhMCkscj0wO3I8dC5sZW5ndGg7cisrKTE2PT09dGhpcy5fbGFzdFByZWNpcGhlckluZGV4JiYodGhpcy5fbGFzdFByZWNpcGhlcj10aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKSx0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXg9MCksdFtyXV49dGhpcy5fbGFzdFByZWNpcGhlclt0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXgrK107cmV0dXJuIHR9LEkucHJvdG90eXBlLmRlY3J5cHQ9SS5wcm90b3R5cGUuZW5jcnlwdDt2YXIgVD1mdW5jdGlvbihlKXtpZighKHRoaXMgaW5zdGFuY2VvZiBUKSl0aHJvdyBFcnJvcihcIkNvdW50ZXIgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YFwiKTswPT09ZXx8ZXx8KGU9MSksXCJudW1iZXJcIj09dHlwZW9mIGU/KHRoaXMuX2NvdW50ZXI9dSgxNiksdGhpcy5zZXRWYWx1ZShlKSk6dGhpcy5zZXRCeXRlcyhlKX07VC5wcm90b3R5cGUuc2V0VmFsdWU9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fHBhcnNlSW50KGUpIT1lKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgY291bnRlciB2YWx1ZSAobXVzdCBiZSBhbiBpbnRlZ2VyKVwiKTtmb3IodmFyIHQ9MTU7MDw9dDstLXQpdGhpcy5fY291bnRlclt0XT1lJTI1NixlPj49OH0sVC5wcm90b3R5cGUuc2V0Qnl0ZXM9ZnVuY3Rpb24oZSl7aWYoMTYhPShlPW8oZSwhMCkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNvdW50ZXIgYnl0ZXMgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7dGhpcy5fY291bnRlcj1lfSxULnByb3RvdHlwZS5pbmNyZW1lbnQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9MTU7MDw9ZTtlLS0pe2lmKDI1NSE9PXRoaXMuX2NvdW50ZXJbZV0pe3RoaXMuX2NvdW50ZXJbZV0rKzticmVha310aGlzLl9jb3VudGVyW2VdPTB9fTt2YXIgUj1mdW5jdGlvbihlLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFIpKXRocm93IEVycm9yKFwiQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2BcIik7dGhpcy5kZXNjcmlwdGlvbj1cIkNvdW50ZXJcIix0aGlzLm5hbWU9XCJjdHJcIix0IGluc3RhbmNlb2YgVHx8KHQ9bmV3IFQodCkpLHRoaXMuX2NvdW50ZXI9dCx0aGlzLl9yZW1haW5pbmdDb3VudGVyPW51bGwsdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4PTE2LHRoaXMuX2Flcz1uZXcgayhlKX07Ui5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9byhlLCEwKSxyPTA7cjx0Lmxlbmd0aDtyKyspMTY9PT10aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXgmJih0aGlzLl9yZW1haW5pbmdDb3VudGVyPXRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX2NvdW50ZXIuX2NvdW50ZXIpLHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleD0wLHRoaXMuX2NvdW50ZXIuaW5jcmVtZW50KCkpLHRbcl1ePXRoaXMuX3JlbWFpbmluZ0NvdW50ZXJbdGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4KytdO3JldHVybiB0fSxSLnByb3RvdHlwZS5kZWNyeXB0PVIucHJvdG90eXBlLmVuY3J5cHQ7dmFyIE89e0FFUzprLENvdW50ZXI6VCxNb2RlT2ZPcGVyYXRpb246e2VjYjpOLGNiYzp4LGNmYjpQLG9mYjpJLGN0cjpSfSx1dGlsczp7aGV4OmEsdXRmODp0fSxwYWRkaW5nOntwa2NzNzp7cGFkOmZ1bmN0aW9uKGUpe3ZhciB0PTE2LShlPW8oZSwhMCkpLmxlbmd0aCUxNixyPXUoZS5sZW5ndGgrdCk7cyhlLHIpO2Zvcih2YXIgbj1lLmxlbmd0aDtuPHIubGVuZ3RoO24rKylyW25dPXQ7cmV0dXJuIHJ9LHN0cmlwOmZ1bmN0aW9uKGUpe2lmKChlPW8oZSwhMCkpLmxlbmd0aDwxNil0aHJvdyBuZXcgRXJyb3IoXCJQS0NTIzcgaW52YWxpZCBsZW5ndGhcIik7dmFyIHQ9ZVtlLmxlbmd0aC0xXTtpZigxNjx0KXRocm93IG5ldyBFcnJvcihcIlBLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlXCIpO2Zvcih2YXIgcj1lLmxlbmd0aC10LG49MDtuPHQ7bisrKWlmKGVbcituXSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiUEtDUyM3IGludmFsaWQgcGFkZGluZyBieXRlXCIpO3ZhciBpPXUocik7cmV0dXJuIHMoZSxpLDAsMCxyKSxpfX19LF9hcnJheVRlc3Q6e2NvZXJjZUFycmF5Om8sY3JlYXRlQXJyYXk6dSxjb3B5QXJyYXk6c319O3ZvaWQgMCE9PUw/Qy5leHBvcnRzPU86KGUuYWVzanMmJihPLl9hZXNqcz1lLmFlc2pzKSxlLmFlc2pzPU8pfSh0aGlzKX0se31dLDk6W2Z1bmN0aW9uKEEsZSx0KXshZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB5KGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKHR8fFwiQXNzZXJ0aW9uIGZhaWxlZFwiKX1mdW5jdGlvbiByKGUsdCl7ZS5zdXBlcl89dDtmdW5jdGlvbiByKCl7fXIucHJvdG90eXBlPXQucHJvdG90eXBlLGUucHJvdG90eXBlPW5ldyByLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV9ZnVuY3Rpb24gbShlLHQscil7aWYobS5pc0JOKGUpKXJldHVybiBlO3RoaXMubmVnYXRpdmU9MCx0aGlzLndvcmRzPW51bGwsdGhpcy5sZW5ndGg9MCwodGhpcy5yZWQ9bnVsbCkhPT1lJiYoXCJsZVwiIT09dCYmXCJiZVwiIT09dHx8KHI9dCx0PTEwKSx0aGlzLl9pbml0KGV8fDAsdHx8MTAscnx8XCJiZVwiKSl9dmFyIG47XCJvYmplY3RcIj09dHlwZW9mIGU/ZS5leHBvcnRzPW06dC5CTj1tLChtLkJOPW0pLndvcmRTaXplPTI2O3RyeXtuPUEoXCJidWZmZXJcIikuQnVmZmVyfWNhdGNoKGUpe31mdW5jdGlvbiBzKGUsdCxyKXtmb3IodmFyIG49MCxpPU1hdGgubWluKGUubGVuZ3RoLHIpLG89dDtvPGk7bysrKXt2YXIgcz1lLmNoYXJDb2RlQXQobyktNDg7bjw8PTQsbnw9NDk8PXMmJnM8PTU0P3MtNDkrMTA6MTc8PXMmJnM8PTIyP3MtMTcrMTA6MTUmc31yZXR1cm4gbn1mdW5jdGlvbiBmKGUsdCxyLG4pe2Zvcih2YXIgaT0wLG89TWF0aC5taW4oZS5sZW5ndGgscikscz10O3M8bztzKyspe3ZhciBhPWUuY2hhckNvZGVBdChzKS00ODtpKj1uLGkrPTQ5PD1hP2EtNDkrMTA6MTc8PWE/YS0xNysxMDphfXJldHVybiBpfW0uaXNCTj1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIG18fG51bGwhPT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZS5jb25zdHJ1Y3Rvci53b3JkU2l6ZT09PW0ud29yZFNpemUmJkFycmF5LmlzQXJyYXkoZS53b3Jkcyl9LG0ubWF4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA8ZS5jbXAodCk/ZTp0fSxtLm1pbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLmNtcCh0KTwwP2U6dH0sbS5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oZSx0LHIpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXJldHVybiB0aGlzLl9pbml0TnVtYmVyKGUsdCxyKTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSlyZXR1cm4gdGhpcy5faW5pdEFycmF5KGUsdCxyKTtcImhleFwiPT09dCYmKHQ9MTYpLHkodD09PSgwfHQpJiYyPD10JiZ0PD0zNik7dmFyIG49MDtcIi1cIj09PShlPWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csXCJcIikpWzBdJiZuKyssMTY9PT10P3RoaXMuX3BhcnNlSGV4KGUsbik6dGhpcy5fcGFyc2VCYXNlKGUsdCxuKSxcIi1cIj09PWVbMF0mJih0aGlzLm5lZ2F0aXZlPTEpLHRoaXMuc3RyaXAoKSxcImxlXCI9PT1yJiZ0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksdCxyKX0sbS5wcm90b3R5cGUuX2luaXROdW1iZXI9ZnVuY3Rpb24oZSx0LHIpe2U8MCYmKHRoaXMubmVnYXRpdmU9MSxlPS1lKSxlPDY3MTA4ODY0Pyh0aGlzLndvcmRzPVs2NzEwODg2MyZlXSx0aGlzLmxlbmd0aD0xKTplPDQ1MDM1OTk2MjczNzA0OTY/KHRoaXMud29yZHM9WzY3MTA4ODYzJmUsZS82NzEwODg2NCY2NzEwODg2M10sdGhpcy5sZW5ndGg9Mik6KHkoZTw5MDA3MTk5MjU0NzQwOTkyKSx0aGlzLndvcmRzPVs2NzEwODg2MyZlLGUvNjcxMDg4NjQmNjcxMDg4NjMsMV0sdGhpcy5sZW5ndGg9MyksXCJsZVwiPT09ciYmdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLHQscil9LG0ucHJvdG90eXBlLl9pbml0QXJyYXk9ZnVuY3Rpb24oZSx0LHIpe2lmKHkoXCJudW1iZXJcIj09dHlwZW9mIGUubGVuZ3RoKSxlLmxlbmd0aDw9MClyZXR1cm4gdGhpcy53b3Jkcz1bMF0sdGhpcy5sZW5ndGg9MSx0aGlzO3RoaXMubGVuZ3RoPU1hdGguY2VpbChlLmxlbmd0aC8zKSx0aGlzLndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciBuLGksbz0wO288dGhpcy5sZW5ndGg7bysrKXRoaXMud29yZHNbb109MDt2YXIgcz0wO2lmKFwiYmVcIj09PXIpZm9yKG89ZS5sZW5ndGgtMSxuPTA7MDw9bztvLT0zKWk9ZVtvXXxlW28tMV08PDh8ZVtvLTJdPDwxNix0aGlzLndvcmRzW25dfD1pPDxzJjY3MTA4ODYzLHRoaXMud29yZHNbbisxXT1pPj4+MjYtcyY2NzEwODg2MywyNjw9KHMrPTI0KSYmKHMtPTI2LG4rKyk7ZWxzZSBpZihcImxlXCI9PT1yKWZvcihuPW89MDtvPGUubGVuZ3RoO28rPTMpaT1lW29dfGVbbysxXTw8OHxlW28rMl08PDE2LHRoaXMud29yZHNbbl18PWk8PHMmNjcxMDg4NjMsdGhpcy53b3Jkc1tuKzFdPWk+Pj4yNi1zJjY3MTA4ODYzLDI2PD0ocys9MjQpJiYocy09MjYsbisrKTtyZXR1cm4gdGhpcy5zdHJpcCgpfSxtLnByb3RvdHlwZS5fcGFyc2VIZXg9ZnVuY3Rpb24oZSx0KXt0aGlzLmxlbmd0aD1NYXRoLmNlaWwoKGUubGVuZ3RoLXQpLzYpLHRoaXMud29yZHM9bmV3IEFycmF5KHRoaXMubGVuZ3RoKTtmb3IodmFyIHIsbj0wO248dGhpcy5sZW5ndGg7bisrKXRoaXMud29yZHNbbl09MDtmb3IodmFyIGk9MCxuPWUubGVuZ3RoLTYsbz0wO3Q8PW47bi09NilyPXMoZSxuLG4rNiksdGhpcy53b3Jkc1tvXXw9cjw8aSY2NzEwODg2Myx0aGlzLndvcmRzW28rMV18PXI+Pj4yNi1pJjQxOTQzMDMsMjY8PShpKz0yNCkmJihpLT0yNixvKyspO24rNiE9PXQmJihyPXMoZSx0LG4rNiksdGhpcy53b3Jkc1tvXXw9cjw8aSY2NzEwODg2Myx0aGlzLndvcmRzW28rMV18PXI+Pj4yNi1pJjQxOTQzMDMpLHRoaXMuc3RyaXAoKX0sbS5wcm90b3R5cGUuX3BhcnNlQmFzZT1mdW5jdGlvbihlLHQscil7dGhpcy53b3Jkcz1bMF07Zm9yKHZhciBuPTAsaT10aGlzLmxlbmd0aD0xO2k8PTY3MTA4ODYzO2kqPXQpbisrO24tLSxpPWkvdHwwO2Zvcih2YXIgbz1lLmxlbmd0aC1yLHM9byVuLGE9TWF0aC5taW4obyxvLXMpK3IsdT0wLGw9cjtsPGE7bCs9bil1PWYoZSxsLGwrbix0KSx0aGlzLmltdWxuKGkpLHRoaXMud29yZHNbMF0rdTw2NzEwODg2ND90aGlzLndvcmRzWzBdKz11OnRoaXMuX2lhZGRuKHUpO2lmKDAhPXMpe2Zvcih2YXIgaD0xLHU9ZihlLGwsZS5sZW5ndGgsdCksbD0wO2w8cztsKyspaCo9dDt0aGlzLmltdWxuKGgpLHRoaXMud29yZHNbMF0rdTw2NzEwODg2ND90aGlzLndvcmRzWzBdKz11OnRoaXMuX2lhZGRuKHUpfX0sbS5wcm90b3R5cGUuY29weT1mdW5jdGlvbihlKXtlLndvcmRzPW5ldyBBcnJheSh0aGlzLmxlbmd0aCk7Zm9yKHZhciB0PTA7dDx0aGlzLmxlbmd0aDt0KyspZS53b3Jkc1t0XT10aGlzLndvcmRzW3RdO2UubGVuZ3RoPXRoaXMubGVuZ3RoLGUubmVnYXRpdmU9dGhpcy5uZWdhdGl2ZSxlLnJlZD10aGlzLnJlZH0sbS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgbShudWxsKTtyZXR1cm4gdGhpcy5jb3B5KGUpLGV9LG0ucHJvdG90eXBlLl9leHBhbmQ9ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLmxlbmd0aDxlOyl0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdPTA7cmV0dXJuIHRoaXN9LG0ucHJvdG90eXBlLnN0cmlwPWZ1bmN0aW9uKCl7Zm9yKDsxPHRoaXMubGVuZ3RoJiYwPT09dGhpcy53b3Jkc1t0aGlzLmxlbmd0aC0xXTspdGhpcy5sZW5ndGgtLTtyZXR1cm4gdGhpcy5fbm9ybVNpZ24oKX0sbS5wcm90b3R5cGUuX25vcm1TaWduPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLmxlbmd0aCYmMD09PXRoaXMud29yZHNbMF0mJih0aGlzLm5lZ2F0aXZlPTApLHRoaXN9LG0ucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5yZWQ/XCI8Qk4tUjogXCI6XCI8Qk46IFwiKSt0aGlzLnRvU3RyaW5nKDE2KStcIj5cIn07dmFyIGM9W1wiXCIsXCIwXCIsXCIwMFwiLFwiMDAwXCIsXCIwMDAwXCIsXCIwMDAwMFwiLFwiMDAwMDAwXCIsXCIwMDAwMDAwXCIsXCIwMDAwMDAwMFwiLFwiMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJdLGQ9WzAsMCwyNSwxNiwxMiwxMSwxMCw5LDgsOCw3LDcsNyw3LDYsNiw2LDYsNiw2LDYsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNV0scD1bMCwwLDMzNTU0NDMyLDQzMDQ2NzIxLDE2Nzc3MjE2LDQ4ODI4MTI1LDYwNDY2MTc2LDQwMzUzNjA3LDE2Nzc3MjE2LDQzMDQ2NzIxLDFlNywxOTQ4NzE3MSwzNTgzMTgwOCw2Mjc0ODUxNyw3NTI5NTM2LDExMzkwNjI1LDE2Nzc3MjE2LDI0MTM3NTY5LDM0MDEyMjI0LDQ3MDQ1ODgxLDY0ZTYsNDA4NDEwMSw1MTUzNjMyLDY0MzYzNDMsNzk2MjYyNCw5NzY1NjI1LDExODgxMzc2LDE0MzQ4OTA3LDE3MjEwMzY4LDIwNTExMTQ5LDI0M2U1LDI4NjI5MTUxLDMzNTU0NDMyLDM5MTM1MzkzLDQ1NDM1NDI0LDUyNTIxODc1LDYwNDY2MTc2XTtmdW5jdGlvbiBpKGUsdCxyKXtyLm5lZ2F0aXZlPXQubmVnYXRpdmVeZS5uZWdhdGl2ZTt2YXIgbj1lLmxlbmd0aCt0Lmxlbmd0aHwwLG49KHIubGVuZ3RoPW4pLTF8MCxpPTY3MTA4ODYzJihmPSgwfGUud29yZHNbMF0pKigwfHQud29yZHNbMF0pKSxvPWYvNjcxMDg4NjR8MDtyLndvcmRzWzBdPWk7Zm9yKHZhciBzPTE7czxuO3MrKyl7Zm9yKHZhciBhPW8+Pj4yNix1PTY3MTA4ODYzJm8sbD1NYXRoLm1pbihzLHQubGVuZ3RoLTEpLGg9TWF0aC5tYXgoMCxzLWUubGVuZ3RoKzEpO2g8PWw7aCsrKXt2YXIgZixjPXMtaHwwO2ErPShmPSgwfGUud29yZHNbY10pKigwfHQud29yZHNbaF0pK3UpLzY3MTA4ODY0fDAsdT02NzEwODg2MyZmfXIud29yZHNbc109MHx1LG89MHxhfXJldHVybiAwIT09bz9yLndvcmRzW3NdPTB8bzpyLmxlbmd0aC0tLHIuc3RyaXAoKX1tLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlLHQpe2lmKHQ9MHx0fHwxLDE2PT09KGU9ZXx8MTApfHxcImhleFwiPT09ZSl7YT1cIlwiO2Zvcih2YXIgcj0wLG49MCxpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciBvPXRoaXMud29yZHNbaV0scz0oMTY3NzcyMTUmKG88PHJ8bikpLnRvU3RyaW5nKDE2KSxhPTAhPT0obj1vPj4+MjQtciYxNjc3NzIxNSl8fGkhPT10aGlzLmxlbmd0aC0xP2NbNi1zLmxlbmd0aF0rcythOnMrYTsyNjw9KHIrPTIpJiYoci09MjYsaS0tKX1mb3IoMCE9PW4mJihhPW4udG9TdHJpbmcoMTYpK2EpO2EubGVuZ3RoJXQhPTA7KWE9XCIwXCIrYTtyZXR1cm4gMCE9PXRoaXMubmVnYXRpdmUmJihhPVwiLVwiK2EpLGF9aWYoZT09PSgwfGUpJiYyPD1lJiZlPD0zNil7dmFyIHU9ZFtlXSxsPXBbZV07Zm9yKGE9XCJcIiwoaD10aGlzLmNsb25lKCkpLm5lZ2F0aXZlPTA7IWguaXNaZXJvKCk7KXt2YXIgaCxmPWgubW9kbihsKS50b1N0cmluZyhlKTthPShoPWguaWRpdm4obCkpLmlzWmVybygpP2YrYTpjW3UtZi5sZW5ndGhdK2YrYX1mb3IodGhpcy5pc1plcm8oKSYmKGE9XCIwXCIrYSk7YS5sZW5ndGgldCE9MDspYT1cIjBcIithO3JldHVybiAwIT09dGhpcy5uZWdhdGl2ZSYmKGE9XCItXCIrYSksYX15KCExLFwiQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNlwiKX0sbS5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndvcmRzWzBdO3JldHVybiAyPT09dGhpcy5sZW5ndGg/ZSs9NjcxMDg4NjQqdGhpcy53b3Jkc1sxXTozPT09dGhpcy5sZW5ndGgmJjE9PT10aGlzLndvcmRzWzJdP2UrPTQ1MDM1OTk2MjczNzA0OTYrNjcxMDg4NjQqdGhpcy53b3Jkc1sxXToyPHRoaXMubGVuZ3RoJiZ5KCExLFwiTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzXCIpLDAhPT10aGlzLm5lZ2F0aXZlPy1lOmV9LG0ucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvU3RyaW5nKDE2KX0sbS5wcm90b3R5cGUudG9CdWZmZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4geSh2b2lkIDAhPT1uKSx0aGlzLnRvQXJyYXlMaWtlKG4sZSx0KX0sbS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LGUsdCl9LG0ucHJvdG90eXBlLnRvQXJyYXlMaWtlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10aGlzLmJ5dGVMZW5ndGgoKSxpPXJ8fE1hdGgubWF4KDEsbik7eShuPD1pLFwiYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aFwiKSx5KDA8aSxcIlJlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMFwiKSx0aGlzLnN0cmlwKCk7dmFyIG8scyxhPVwibGVcIj09PXQsdT1uZXcgZShpKSxsPXRoaXMuY2xvbmUoKTtpZihhKXtmb3Iocz0wOyFsLmlzWmVybygpO3MrKylvPWwuYW5kbG4oMjU1KSxsLml1c2hybig4KSx1W3NdPW87Zm9yKDtzPGk7cysrKXVbc109MH1lbHNle2ZvcihzPTA7czxpLW47cysrKXVbc109MDtmb3Iocz0wOyFsLmlzWmVybygpO3MrKylvPWwuYW5kbG4oMjU1KSxsLml1c2hybig4KSx1W2ktcy0xXT1vfXJldHVybiB1fSxNYXRoLmNsejMyP20ucHJvdG90eXBlLl9jb3VudEJpdHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDMyLU1hdGguY2x6MzIoZSl9Om0ucHJvdG90eXBlLl9jb3VudEJpdHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZSxyPTA7cmV0dXJuIDQwOTY8PXQmJihyKz0xMyx0Pj4+PTEzKSw2NDw9dCYmKHIrPTcsdD4+Pj03KSw4PD10JiYocis9NCx0Pj4+PTQpLDI8PXQmJihyKz0yLHQ+Pj49Mikscit0fSxtLnByb3RvdHlwZS5femVyb0JpdHM9ZnVuY3Rpb24oZSl7aWYoMD09PWUpcmV0dXJuIDI2O3ZhciB0PWUscj0wO3JldHVybiAwPT0oODE5MSZ0KSYmKHIrPTEzLHQ+Pj49MTMpLDA9PSgxMjcmdCkmJihyKz03LHQ+Pj49NyksMD09KDE1JnQpJiYocis9NCx0Pj4+PTQpLDA9PSgzJnQpJiYocis9Mix0Pj4+PTIpLDA9PSgxJnQpJiZyKysscn0sbS5wcm90b3R5cGUuYml0TGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy53b3Jkc1t0aGlzLmxlbmd0aC0xXSx0PXRoaXMuX2NvdW50Qml0cyhlKTtyZXR1cm4gMjYqKHRoaXMubGVuZ3RoLTEpK3R9LG0ucHJvdG90eXBlLnplcm9CaXRzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gMDtmb3IodmFyIGU9MCx0PTA7dDx0aGlzLmxlbmd0aDt0Kyspe3ZhciByPXRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbdF0pO2lmKGUrPXIsMjYhPT1yKWJyZWFrfXJldHVybiBlfSxtLnByb3RvdHlwZS5ieXRlTGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpLzgpfSxtLnByb3RvdHlwZS50b1R3b3M9ZnVuY3Rpb24oZSl7cmV0dXJuIDAhPT10aGlzLm5lZ2F0aXZlP3RoaXMuYWJzKCkuaW5vdG4oZSkuaWFkZG4oMSk6dGhpcy5jbG9uZSgpfSxtLnByb3RvdHlwZS5mcm9tVHdvcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50ZXN0bihlLTEpP3RoaXMubm90bihlKS5pYWRkbigxKS5pbmVnKCk6dGhpcy5jbG9uZSgpfSxtLnByb3RvdHlwZS5pc05lZz1mdW5jdGlvbigpe3JldHVybiAwIT09dGhpcy5uZWdhdGl2ZX0sbS5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCl9LG0ucHJvdG90eXBlLmluZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1plcm8oKXx8KHRoaXMubmVnYXRpdmVePTEpLHRoaXN9LG0ucHJvdG90eXBlLml1b3I9ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLmxlbmd0aDxlLmxlbmd0aDspdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXT0wO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXRoaXMud29yZHNbdF09dGhpcy53b3Jkc1t0XXxlLndvcmRzW3RdO3JldHVybiB0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmlvcj1mdW5jdGlvbihlKXtyZXR1cm4geSgwPT0odGhpcy5uZWdhdGl2ZXxlLm5lZ2F0aXZlKSksdGhpcy5pdW9yKGUpfSxtLnByb3RvdHlwZS5vcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sZW5ndGg+ZS5sZW5ndGg/dGhpcy5jbG9uZSgpLmlvcihlKTplLmNsb25lKCkuaW9yKHRoaXMpfSxtLnByb3RvdHlwZS51b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pdW9yKGUpOmUuY2xvbmUoKS5pdW9yKHRoaXMpfSxtLnByb3RvdHlwZS5pdWFuZD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5sZW5ndGg+ZS5sZW5ndGg/ZTp0aGlzLHI9MDtyPHQubGVuZ3RoO3IrKyl0aGlzLndvcmRzW3JdPXRoaXMud29yZHNbcl0mZS53b3Jkc1tyXTtyZXR1cm4gdGhpcy5sZW5ndGg9dC5sZW5ndGgsdGhpcy5zdHJpcCgpfSxtLnByb3RvdHlwZS5pYW5kPWZ1bmN0aW9uKGUpe3JldHVybiB5KDA9PSh0aGlzLm5lZ2F0aXZlfGUubmVnYXRpdmUpKSx0aGlzLml1YW5kKGUpfSxtLnByb3RvdHlwZS5hbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pYW5kKGUpOmUuY2xvbmUoKS5pYW5kKHRoaXMpfSxtLnByb3RvdHlwZS51YW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlbmd0aD5lLmxlbmd0aD90aGlzLmNsb25lKCkuaXVhbmQoZSk6ZS5jbG9uZSgpLml1YW5kKHRoaXMpfSxtLnByb3RvdHlwZS5pdXhvcj1mdW5jdGlvbihlKXtmb3IodmFyIHQscj10aGlzLmxlbmd0aD5lLmxlbmd0aD8odD10aGlzLGUpOih0PWUsdGhpcyksbj0wO248ci5sZW5ndGg7bisrKXRoaXMud29yZHNbbl09dC53b3Jkc1tuXV5yLndvcmRzW25dO2lmKHRoaXMhPT10KWZvcig7bjx0Lmxlbmd0aDtuKyspdGhpcy53b3Jkc1tuXT10LndvcmRzW25dO3JldHVybiB0aGlzLmxlbmd0aD10Lmxlbmd0aCx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLml4b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHkoMD09KHRoaXMubmVnYXRpdmV8ZS5uZWdhdGl2ZSkpLHRoaXMuaXV4b3IoZSl9LG0ucHJvdG90eXBlLnhvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sZW5ndGg+ZS5sZW5ndGg/dGhpcy5jbG9uZSgpLml4b3IoZSk6ZS5jbG9uZSgpLml4b3IodGhpcyl9LG0ucHJvdG90eXBlLnV4b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pdXhvcihlKTplLmNsb25lKCkuaXV4b3IodGhpcyl9LG0ucHJvdG90eXBlLmlub3RuPWZ1bmN0aW9uKGUpe3koXCJudW1iZXJcIj09dHlwZW9mIGUmJjA8PWUpO3ZhciB0PTB8TWF0aC5jZWlsKGUvMjYpLHI9ZSUyNjt0aGlzLl9leHBhbmQodCksMDxyJiZ0LS07Zm9yKHZhciBuPTA7bjx0O24rKyl0aGlzLndvcmRzW25dPTY3MTA4ODYzJn50aGlzLndvcmRzW25dO3JldHVybiAwPHImJih0aGlzLndvcmRzW25dPX50aGlzLndvcmRzW25dJjY3MTA4ODYzPj4yNi1yKSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLm5vdG49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bihlKX0sbS5wcm90b3R5cGUuc2V0bj1mdW5jdGlvbihlLHQpe3koXCJudW1iZXJcIj09dHlwZW9mIGUmJjA8PWUpO3ZhciByPWUvMjZ8MCxuPWUlMjY7cmV0dXJuIHRoaXMuX2V4cGFuZCgxK3IpLHRoaXMud29yZHNbcl09dD90aGlzLndvcmRzW3JdfDE8PG46dGhpcy53b3Jkc1tyXSZ+KDE8PG4pLHRoaXMuc3RyaXAoKX0sbS5wcm90b3R5cGUuaWFkZD1mdW5jdGlvbihlKXt2YXIgdCxyLG47aWYoMCE9PXRoaXMubmVnYXRpdmUmJjA9PT1lLm5lZ2F0aXZlKXJldHVybiB0aGlzLm5lZ2F0aXZlPTAsdD10aGlzLmlzdWIoZSksdGhpcy5uZWdhdGl2ZV49MSx0aGlzLl9ub3JtU2lnbigpO2lmKDA9PT10aGlzLm5lZ2F0aXZlJiYwIT09ZS5uZWdhdGl2ZSlyZXR1cm4gZS5uZWdhdGl2ZT0wLHQ9dGhpcy5pc3ViKGUpLGUubmVnYXRpdmU9MSx0Ll9ub3JtU2lnbigpO249dGhpcy5sZW5ndGg+ZS5sZW5ndGg/KHI9dGhpcyxlKToocj1lLHRoaXMpO2Zvcih2YXIgaT0wLG89MDtvPG4ubGVuZ3RoO28rKyl0PSgwfHIud29yZHNbb10pKygwfG4ud29yZHNbb10pK2ksdGhpcy53b3Jkc1tvXT02NzEwODg2MyZ0LGk9dD4+PjI2O2Zvcig7MCE9PWkmJm88ci5sZW5ndGg7bysrKXQ9KDB8ci53b3Jkc1tvXSkraSx0aGlzLndvcmRzW29dPTY3MTA4ODYzJnQsaT10Pj4+MjY7aWYodGhpcy5sZW5ndGg9ci5sZW5ndGgsMCE9PWkpdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF09aSx0aGlzLmxlbmd0aCsrO2Vsc2UgaWYociE9PXRoaXMpZm9yKDtvPHIubGVuZ3RoO28rKyl0aGlzLndvcmRzW29dPXIud29yZHNbb107cmV0dXJuIHRoaXN9LG0ucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gMCE9PWUubmVnYXRpdmUmJjA9PT10aGlzLm5lZ2F0aXZlPyhlLm5lZ2F0aXZlPTAsdD10aGlzLnN1YihlKSxlLm5lZ2F0aXZlXj0xLHQpOjA9PT1lLm5lZ2F0aXZlJiYwIT09dGhpcy5uZWdhdGl2ZT8odGhpcy5uZWdhdGl2ZT0wLHQ9ZS5zdWIodGhpcyksdGhpcy5uZWdhdGl2ZT0xLHQpOnRoaXMubGVuZ3RoPmUubGVuZ3RoP3RoaXMuY2xvbmUoKS5pYWRkKGUpOmUuY2xvbmUoKS5pYWRkKHRoaXMpfSxtLnByb3RvdHlwZS5pc3ViPWZ1bmN0aW9uKGUpe2lmKDAhPT1lLm5lZ2F0aXZlKXtlLm5lZ2F0aXZlPTA7dmFyIHQ9dGhpcy5pYWRkKGUpO3JldHVybiBlLm5lZ2F0aXZlPTEsdC5fbm9ybVNpZ24oKX1pZigwIT09dGhpcy5uZWdhdGl2ZSlyZXR1cm4gdGhpcy5uZWdhdGl2ZT0wLHRoaXMuaWFkZChlKSx0aGlzLm5lZ2F0aXZlPTEsdGhpcy5fbm9ybVNpZ24oKTt2YXIgcixuLGk9dGhpcy5jbXAoZSk7aWYoMD09PWkpcmV0dXJuIHRoaXMubmVnYXRpdmU9MCx0aGlzLmxlbmd0aD0xLHRoaXMud29yZHNbMF09MCx0aGlzO249MDxpPyhyPXRoaXMsZSk6KHI9ZSx0aGlzKTtmb3IodmFyIG89MCxzPTA7czxuLmxlbmd0aDtzKyspbz0odD0oMHxyLndvcmRzW3NdKS0oMHxuLndvcmRzW3NdKStvKT4+MjYsdGhpcy53b3Jkc1tzXT02NzEwODg2MyZ0O2Zvcig7MCE9PW8mJnM8ci5sZW5ndGg7cysrKW89KHQ9KDB8ci53b3Jkc1tzXSkrbyk+PjI2LHRoaXMud29yZHNbc109NjcxMDg4NjMmdDtpZigwPT09byYmczxyLmxlbmd0aCYmciE9PXRoaXMpZm9yKDtzPHIubGVuZ3RoO3MrKyl0aGlzLndvcmRzW3NdPXIud29yZHNbc107cmV0dXJuIHRoaXMubGVuZ3RoPU1hdGgubWF4KHRoaXMubGVuZ3RoLHMpLHIhPT10aGlzJiYodGhpcy5uZWdhdGl2ZT0xKSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIoZSl9O3ZhciBvPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbixpLG8scz1lLndvcmRzLGE9dC53b3Jkcyx1PXIud29yZHMsbD0wfHNbMF0saD04MTkxJmwsZj1sPj4+MTMsYz0wfHNbMV0sZD04MTkxJmMscD1jPj4+MTMsdj0wfHNbMl0seT04MTkxJnYsbT12Pj4+MTMsZz0wfHNbM10sYj04MTkxJmcsdz1nPj4+MTMsXz0wfHNbNF0sTT04MTkxJl8sQT1fPj4+MTMsRT0wfHNbNV0sUz04MTkxJkUsaz1FPj4+MTMsTj0wfHNbNl0seD04MTkxJk4sUD1OPj4+MTMsST0wfHNbN10sVD04MTkxJkksUj1JPj4+MTMsTz0wfHNbOF0sQz04MTkxJk8sTD1PPj4+MTMsQj0wfHNbOV0sRD04MTkxJkIsVT1CPj4+MTMsRj0wfGFbMF0saj04MTkxJkYsRz1GPj4+MTMsSD0wfGFbMV0sej04MTkxJkgsVj1IPj4+MTMsSz0wfGFbMl0scT04MTkxJkssVz1LPj4+MTMsWj0wfGFbM10sSj04MTkxJlosWD1aPj4+MTMsJD0wfGFbNF0sUT04MTkxJiQsWT0kPj4+MTMsZWU9MHxhWzVdLHRlPTgxOTEmZWUscmU9ZWU+Pj4xMyxuZT0wfGFbNl0saWU9ODE5MSZuZSxvZT1uZT4+PjEzLHNlPTB8YVs3XSxhZT04MTkxJnNlLHVlPXNlPj4+MTMsbGU9MHxhWzhdLGhlPTgxOTEmbGUsZmU9bGU+Pj4xMyxjZT0wfGFbOV0sZGU9ODE5MSZjZSxwZT1jZT4+PjEzO3IubmVnYXRpdmU9ZS5uZWdhdGl2ZV50Lm5lZ2F0aXZlLHIubGVuZ3RoPTE5O3ZhciB2ZT0oMCtNYXRoLmltdWwoaCxqKXwwKSsoKDgxOTEmKGk9TWF0aC5pbXVsKGgsRykrTWF0aC5pbXVsKGYsail8MCkpPDwxMyl8MCx5ZT0oTWF0aC5pbXVsKGYsRykrKGk+Pj4xMyl8MCkrKHZlPj4+MjYpfDA7dmUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKGQsaiksaT1NYXRoLmltdWwoZCxHKStNYXRoLmltdWwocCxqKXwwLG89TWF0aC5pbXVsKHAsRyk7dmFyIG1lPSh5ZSsobitNYXRoLmltdWwoaCx6KXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsVil8MCkrTWF0aC5pbXVsKGYseil8MCkpPDwxMyl8MDt5ZT0oKG8rTWF0aC5pbXVsKGYsVil8MCkrKGk+Pj4xMyl8MCkrKG1lPj4+MjYpfDAsbWUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKHksaiksaT1NYXRoLmltdWwoeSxHKStNYXRoLmltdWwobSxqKXwwLG89TWF0aC5pbXVsKG0sRyksbj1uK01hdGguaW11bChkLHopfDAsaT0oaStNYXRoLmltdWwoZCxWKXwwKStNYXRoLmltdWwocCx6KXwwLG89bytNYXRoLmltdWwocCxWKXwwO3ZhciBnZT0oeWUrKG4rTWF0aC5pbXVsKGgscSl8MCl8MCkrKCg4MTkxJihpPShpK01hdGguaW11bChoLFcpfDApK01hdGguaW11bChmLHEpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChmLFcpfDApKyhpPj4+MTMpfDApKyhnZT4+PjI2KXwwLGdlJj02NzEwODg2MyxuPU1hdGguaW11bChiLGopLGk9TWF0aC5pbXVsKGIsRykrTWF0aC5pbXVsKHcsail8MCxvPU1hdGguaW11bCh3LEcpLG49bitNYXRoLmltdWwoeSx6KXwwLGk9KGkrTWF0aC5pbXVsKHksVil8MCkrTWF0aC5pbXVsKG0seil8MCxvPW8rTWF0aC5pbXVsKG0sVil8MCxuPW4rTWF0aC5pbXVsKGQscSl8MCxpPShpK01hdGguaW11bChkLFcpfDApK01hdGguaW11bChwLHEpfDAsbz1vK01hdGguaW11bChwLFcpfDA7dmFyIGJlPSh5ZSsobitNYXRoLmltdWwoaCxKKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsWCl8MCkrTWF0aC5pbXVsKGYsSil8MCkpPDwxMyl8MDt5ZT0oKG8rTWF0aC5pbXVsKGYsWCl8MCkrKGk+Pj4xMyl8MCkrKGJlPj4+MjYpfDAsYmUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKE0saiksaT1NYXRoLmltdWwoTSxHKStNYXRoLmltdWwoQSxqKXwwLG89TWF0aC5pbXVsKEEsRyksbj1uK01hdGguaW11bChiLHopfDAsaT0oaStNYXRoLmltdWwoYixWKXwwKStNYXRoLmltdWwodyx6KXwwLG89bytNYXRoLmltdWwodyxWKXwwLG49bitNYXRoLmltdWwoeSxxKXwwLGk9KGkrTWF0aC5pbXVsKHksVyl8MCkrTWF0aC5pbXVsKG0scSl8MCxvPW8rTWF0aC5pbXVsKG0sVyl8MCxuPW4rTWF0aC5pbXVsKGQsSil8MCxpPShpK01hdGguaW11bChkLFgpfDApK01hdGguaW11bChwLEopfDAsbz1vK01hdGguaW11bChwLFgpfDA7dmFyIHdlPSh5ZSsobitNYXRoLmltdWwoaCxRKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsWSl8MCkrTWF0aC5pbXVsKGYsUSl8MCkpPDwxMyl8MDt5ZT0oKG8rTWF0aC5pbXVsKGYsWSl8MCkrKGk+Pj4xMyl8MCkrKHdlPj4+MjYpfDAsd2UmPTY3MTA4ODYzLG49TWF0aC5pbXVsKFMsaiksaT1NYXRoLmltdWwoUyxHKStNYXRoLmltdWwoayxqKXwwLG89TWF0aC5pbXVsKGssRyksbj1uK01hdGguaW11bChNLHopfDAsaT0oaStNYXRoLmltdWwoTSxWKXwwKStNYXRoLmltdWwoQSx6KXwwLG89bytNYXRoLmltdWwoQSxWKXwwLG49bitNYXRoLmltdWwoYixxKXwwLGk9KGkrTWF0aC5pbXVsKGIsVyl8MCkrTWF0aC5pbXVsKHcscSl8MCxvPW8rTWF0aC5pbXVsKHcsVyl8MCxuPW4rTWF0aC5pbXVsKHksSil8MCxpPShpK01hdGguaW11bCh5LFgpfDApK01hdGguaW11bChtLEopfDAsbz1vK01hdGguaW11bChtLFgpfDAsbj1uK01hdGguaW11bChkLFEpfDAsaT0oaStNYXRoLmltdWwoZCxZKXwwKStNYXRoLmltdWwocCxRKXwwLG89bytNYXRoLmltdWwocCxZKXwwO3ZhciBfZT0oeWUrKG4rTWF0aC5pbXVsKGgsdGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoaCxyZSl8MCkrTWF0aC5pbXVsKGYsdGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChmLHJlKXwwKSsoaT4+PjEzKXwwKSsoX2U+Pj4yNil8MCxfZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoeCxqKSxpPU1hdGguaW11bCh4LEcpK01hdGguaW11bChQLGopfDAsbz1NYXRoLmltdWwoUCxHKSxuPW4rTWF0aC5pbXVsKFMseil8MCxpPShpK01hdGguaW11bChTLFYpfDApK01hdGguaW11bChrLHopfDAsbz1vK01hdGguaW11bChrLFYpfDAsbj1uK01hdGguaW11bChNLHEpfDAsaT0oaStNYXRoLmltdWwoTSxXKXwwKStNYXRoLmltdWwoQSxxKXwwLG89bytNYXRoLmltdWwoQSxXKXwwLG49bitNYXRoLmltdWwoYixKKXwwLGk9KGkrTWF0aC5pbXVsKGIsWCl8MCkrTWF0aC5pbXVsKHcsSil8MCxvPW8rTWF0aC5pbXVsKHcsWCl8MCxuPW4rTWF0aC5pbXVsKHksUSl8MCxpPShpK01hdGguaW11bCh5LFkpfDApK01hdGguaW11bChtLFEpfDAsbz1vK01hdGguaW11bChtLFkpfDAsbj1uK01hdGguaW11bChkLHRlKXwwLGk9KGkrTWF0aC5pbXVsKGQscmUpfDApK01hdGguaW11bChwLHRlKXwwLG89bytNYXRoLmltdWwocCxyZSl8MDt2YXIgTWU9KHllKyhuK01hdGguaW11bChoLGllKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsb2UpfDApK01hdGguaW11bChmLGllKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoZixvZSl8MCkrKGk+Pj4xMyl8MCkrKE1lPj4+MjYpfDAsTWUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKFQsaiksaT1NYXRoLmltdWwoVCxHKStNYXRoLmltdWwoUixqKXwwLG89TWF0aC5pbXVsKFIsRyksbj1uK01hdGguaW11bCh4LHopfDAsaT0oaStNYXRoLmltdWwoeCxWKXwwKStNYXRoLmltdWwoUCx6KXwwLG89bytNYXRoLmltdWwoUCxWKXwwLG49bitNYXRoLmltdWwoUyxxKXwwLGk9KGkrTWF0aC5pbXVsKFMsVyl8MCkrTWF0aC5pbXVsKGsscSl8MCxvPW8rTWF0aC5pbXVsKGssVyl8MCxuPW4rTWF0aC5pbXVsKE0sSil8MCxpPShpK01hdGguaW11bChNLFgpfDApK01hdGguaW11bChBLEopfDAsbz1vK01hdGguaW11bChBLFgpfDAsbj1uK01hdGguaW11bChiLFEpfDAsaT0oaStNYXRoLmltdWwoYixZKXwwKStNYXRoLmltdWwodyxRKXwwLG89bytNYXRoLmltdWwodyxZKXwwLG49bitNYXRoLmltdWwoeSx0ZSl8MCxpPShpK01hdGguaW11bCh5LHJlKXwwKStNYXRoLmltdWwobSx0ZSl8MCxvPW8rTWF0aC5pbXVsKG0scmUpfDAsbj1uK01hdGguaW11bChkLGllKXwwLGk9KGkrTWF0aC5pbXVsKGQsb2UpfDApK01hdGguaW11bChwLGllKXwwLG89bytNYXRoLmltdWwocCxvZSl8MDt2YXIgQWU9KHllKyhuK01hdGguaW11bChoLGFlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgsdWUpfDApK01hdGguaW11bChmLGFlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoZix1ZSl8MCkrKGk+Pj4xMyl8MCkrKEFlPj4+MjYpfDAsQWUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEMsaiksaT1NYXRoLmltdWwoQyxHKStNYXRoLmltdWwoTCxqKXwwLG89TWF0aC5pbXVsKEwsRyksbj1uK01hdGguaW11bChULHopfDAsaT0oaStNYXRoLmltdWwoVCxWKXwwKStNYXRoLmltdWwoUix6KXwwLG89bytNYXRoLmltdWwoUixWKXwwLG49bitNYXRoLmltdWwoeCxxKXwwLGk9KGkrTWF0aC5pbXVsKHgsVyl8MCkrTWF0aC5pbXVsKFAscSl8MCxvPW8rTWF0aC5pbXVsKFAsVyl8MCxuPW4rTWF0aC5pbXVsKFMsSil8MCxpPShpK01hdGguaW11bChTLFgpfDApK01hdGguaW11bChrLEopfDAsbz1vK01hdGguaW11bChrLFgpfDAsbj1uK01hdGguaW11bChNLFEpfDAsaT0oaStNYXRoLmltdWwoTSxZKXwwKStNYXRoLmltdWwoQSxRKXwwLG89bytNYXRoLmltdWwoQSxZKXwwLG49bitNYXRoLmltdWwoYix0ZSl8MCxpPShpK01hdGguaW11bChiLHJlKXwwKStNYXRoLmltdWwodyx0ZSl8MCxvPW8rTWF0aC5pbXVsKHcscmUpfDAsbj1uK01hdGguaW11bCh5LGllKXwwLGk9KGkrTWF0aC5pbXVsKHksb2UpfDApK01hdGguaW11bChtLGllKXwwLG89bytNYXRoLmltdWwobSxvZSl8MCxuPW4rTWF0aC5pbXVsKGQsYWUpfDAsaT0oaStNYXRoLmltdWwoZCx1ZSl8MCkrTWF0aC5pbXVsKHAsYWUpfDAsbz1vK01hdGguaW11bChwLHVlKXwwO3ZhciBFZT0oeWUrKG4rTWF0aC5pbXVsKGgsaGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoaCxmZSl8MCkrTWF0aC5pbXVsKGYsaGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChmLGZlKXwwKSsoaT4+PjEzKXwwKSsoRWU+Pj4yNil8MCxFZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxqKSxpPU1hdGguaW11bChELEcpK01hdGguaW11bChVLGopfDAsbz1NYXRoLmltdWwoVSxHKSxuPW4rTWF0aC5pbXVsKEMseil8MCxpPShpK01hdGguaW11bChDLFYpfDApK01hdGguaW11bChMLHopfDAsbz1vK01hdGguaW11bChMLFYpfDAsbj1uK01hdGguaW11bChULHEpfDAsaT0oaStNYXRoLmltdWwoVCxXKXwwKStNYXRoLmltdWwoUixxKXwwLG89bytNYXRoLmltdWwoUixXKXwwLG49bitNYXRoLmltdWwoeCxKKXwwLGk9KGkrTWF0aC5pbXVsKHgsWCl8MCkrTWF0aC5pbXVsKFAsSil8MCxvPW8rTWF0aC5pbXVsKFAsWCl8MCxuPW4rTWF0aC5pbXVsKFMsUSl8MCxpPShpK01hdGguaW11bChTLFkpfDApK01hdGguaW11bChrLFEpfDAsbz1vK01hdGguaW11bChrLFkpfDAsbj1uK01hdGguaW11bChNLHRlKXwwLGk9KGkrTWF0aC5pbXVsKE0scmUpfDApK01hdGguaW11bChBLHRlKXwwLG89bytNYXRoLmltdWwoQSxyZSl8MCxuPW4rTWF0aC5pbXVsKGIsaWUpfDAsaT0oaStNYXRoLmltdWwoYixvZSl8MCkrTWF0aC5pbXVsKHcsaWUpfDAsbz1vK01hdGguaW11bCh3LG9lKXwwLG49bitNYXRoLmltdWwoeSxhZSl8MCxpPShpK01hdGguaW11bCh5LHVlKXwwKStNYXRoLmltdWwobSxhZSl8MCxvPW8rTWF0aC5pbXVsKG0sdWUpfDAsbj1uK01hdGguaW11bChkLGhlKXwwLGk9KGkrTWF0aC5pbXVsKGQsZmUpfDApK01hdGguaW11bChwLGhlKXwwLG89bytNYXRoLmltdWwocCxmZSl8MDt2YXIgU2U9KHllKyhuK01hdGguaW11bChoLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGgscGUpfDApK01hdGguaW11bChmLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoZixwZSl8MCkrKGk+Pj4xMyl8MCkrKFNlPj4+MjYpfDAsU2UmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQseiksaT1NYXRoLmltdWwoRCxWKStNYXRoLmltdWwoVSx6KXwwLG89TWF0aC5pbXVsKFUsViksbj1uK01hdGguaW11bChDLHEpfDAsaT0oaStNYXRoLmltdWwoQyxXKXwwKStNYXRoLmltdWwoTCxxKXwwLG89bytNYXRoLmltdWwoTCxXKXwwLG49bitNYXRoLmltdWwoVCxKKXwwLGk9KGkrTWF0aC5pbXVsKFQsWCl8MCkrTWF0aC5pbXVsKFIsSil8MCxvPW8rTWF0aC5pbXVsKFIsWCl8MCxuPW4rTWF0aC5pbXVsKHgsUSl8MCxpPShpK01hdGguaW11bCh4LFkpfDApK01hdGguaW11bChQLFEpfDAsbz1vK01hdGguaW11bChQLFkpfDAsbj1uK01hdGguaW11bChTLHRlKXwwLGk9KGkrTWF0aC5pbXVsKFMscmUpfDApK01hdGguaW11bChrLHRlKXwwLG89bytNYXRoLmltdWwoayxyZSl8MCxuPW4rTWF0aC5pbXVsKE0saWUpfDAsaT0oaStNYXRoLmltdWwoTSxvZSl8MCkrTWF0aC5pbXVsKEEsaWUpfDAsbz1vK01hdGguaW11bChBLG9lKXwwLG49bitNYXRoLmltdWwoYixhZSl8MCxpPShpK01hdGguaW11bChiLHVlKXwwKStNYXRoLmltdWwodyxhZSl8MCxvPW8rTWF0aC5pbXVsKHcsdWUpfDAsbj1uK01hdGguaW11bCh5LGhlKXwwLGk9KGkrTWF0aC5pbXVsKHksZmUpfDApK01hdGguaW11bChtLGhlKXwwLG89bytNYXRoLmltdWwobSxmZSl8MDt2YXIga2U9KHllKyhuK01hdGguaW11bChkLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGQscGUpfDApK01hdGguaW11bChwLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwocCxwZSl8MCkrKGk+Pj4xMyl8MCkrKGtlPj4+MjYpfDAsa2UmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQscSksaT1NYXRoLmltdWwoRCxXKStNYXRoLmltdWwoVSxxKXwwLG89TWF0aC5pbXVsKFUsVyksbj1uK01hdGguaW11bChDLEopfDAsaT0oaStNYXRoLmltdWwoQyxYKXwwKStNYXRoLmltdWwoTCxKKXwwLG89bytNYXRoLmltdWwoTCxYKXwwLG49bitNYXRoLmltdWwoVCxRKXwwLGk9KGkrTWF0aC5pbXVsKFQsWSl8MCkrTWF0aC5pbXVsKFIsUSl8MCxvPW8rTWF0aC5pbXVsKFIsWSl8MCxuPW4rTWF0aC5pbXVsKHgsdGUpfDAsaT0oaStNYXRoLmltdWwoeCxyZSl8MCkrTWF0aC5pbXVsKFAsdGUpfDAsbz1vK01hdGguaW11bChQLHJlKXwwLG49bitNYXRoLmltdWwoUyxpZSl8MCxpPShpK01hdGguaW11bChTLG9lKXwwKStNYXRoLmltdWwoayxpZSl8MCxvPW8rTWF0aC5pbXVsKGssb2UpfDAsbj1uK01hdGguaW11bChNLGFlKXwwLGk9KGkrTWF0aC5pbXVsKE0sdWUpfDApK01hdGguaW11bChBLGFlKXwwLG89bytNYXRoLmltdWwoQSx1ZSl8MCxuPW4rTWF0aC5pbXVsKGIsaGUpfDAsaT0oaStNYXRoLmltdWwoYixmZSl8MCkrTWF0aC5pbXVsKHcsaGUpfDAsbz1vK01hdGguaW11bCh3LGZlKXwwO3ZhciBOZT0oeWUrKG4rTWF0aC5pbXVsKHksZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoeSxwZSl8MCkrTWF0aC5pbXVsKG0sZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChtLHBlKXwwKSsoaT4+PjEzKXwwKSsoTmU+Pj4yNil8MCxOZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxKKSxpPU1hdGguaW11bChELFgpK01hdGguaW11bChVLEopfDAsbz1NYXRoLmltdWwoVSxYKSxuPW4rTWF0aC5pbXVsKEMsUSl8MCxpPShpK01hdGguaW11bChDLFkpfDApK01hdGguaW11bChMLFEpfDAsbz1vK01hdGguaW11bChMLFkpfDAsbj1uK01hdGguaW11bChULHRlKXwwLGk9KGkrTWF0aC5pbXVsKFQscmUpfDApK01hdGguaW11bChSLHRlKXwwLG89bytNYXRoLmltdWwoUixyZSl8MCxuPW4rTWF0aC5pbXVsKHgsaWUpfDAsaT0oaStNYXRoLmltdWwoeCxvZSl8MCkrTWF0aC5pbXVsKFAsaWUpfDAsbz1vK01hdGguaW11bChQLG9lKXwwLG49bitNYXRoLmltdWwoUyxhZSl8MCxpPShpK01hdGguaW11bChTLHVlKXwwKStNYXRoLmltdWwoayxhZSl8MCxvPW8rTWF0aC5pbXVsKGssdWUpfDAsbj1uK01hdGguaW11bChNLGhlKXwwLGk9KGkrTWF0aC5pbXVsKE0sZmUpfDApK01hdGguaW11bChBLGhlKXwwLG89bytNYXRoLmltdWwoQSxmZSl8MDt2YXIgeGU9KHllKyhuK01hdGguaW11bChiLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKGIscGUpfDApK01hdGguaW11bCh3LGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwodyxwZSl8MCkrKGk+Pj4xMyl8MCkrKHhlPj4+MjYpfDAseGUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQsUSksaT1NYXRoLmltdWwoRCxZKStNYXRoLmltdWwoVSxRKXwwLG89TWF0aC5pbXVsKFUsWSksbj1uK01hdGguaW11bChDLHRlKXwwLGk9KGkrTWF0aC5pbXVsKEMscmUpfDApK01hdGguaW11bChMLHRlKXwwLG89bytNYXRoLmltdWwoTCxyZSl8MCxuPW4rTWF0aC5pbXVsKFQsaWUpfDAsaT0oaStNYXRoLmltdWwoVCxvZSl8MCkrTWF0aC5pbXVsKFIsaWUpfDAsbz1vK01hdGguaW11bChSLG9lKXwwLG49bitNYXRoLmltdWwoeCxhZSl8MCxpPShpK01hdGguaW11bCh4LHVlKXwwKStNYXRoLmltdWwoUCxhZSl8MCxvPW8rTWF0aC5pbXVsKFAsdWUpfDAsbj1uK01hdGguaW11bChTLGhlKXwwLGk9KGkrTWF0aC5pbXVsKFMsZmUpfDApK01hdGguaW11bChrLGhlKXwwLG89bytNYXRoLmltdWwoayxmZSl8MDt2YXIgUGU9KHllKyhuK01hdGguaW11bChNLGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKE0scGUpfDApK01hdGguaW11bChBLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoQSxwZSl8MCkrKGk+Pj4xMyl8MCkrKFBlPj4+MjYpfDAsUGUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQsdGUpLGk9TWF0aC5pbXVsKEQscmUpK01hdGguaW11bChVLHRlKXwwLG89TWF0aC5pbXVsKFUscmUpLG49bitNYXRoLmltdWwoQyxpZSl8MCxpPShpK01hdGguaW11bChDLG9lKXwwKStNYXRoLmltdWwoTCxpZSl8MCxvPW8rTWF0aC5pbXVsKEwsb2UpfDAsbj1uK01hdGguaW11bChULGFlKXwwLGk9KGkrTWF0aC5pbXVsKFQsdWUpfDApK01hdGguaW11bChSLGFlKXwwLG89bytNYXRoLmltdWwoUix1ZSl8MCxuPW4rTWF0aC5pbXVsKHgsaGUpfDAsaT0oaStNYXRoLmltdWwoeCxmZSl8MCkrTWF0aC5pbXVsKFAsaGUpfDAsbz1vK01hdGguaW11bChQLGZlKXwwO3ZhciBJZT0oeWUrKG4rTWF0aC5pbXVsKFMsZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoUyxwZSl8MCkrTWF0aC5pbXVsKGssZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChrLHBlKXwwKSsoaT4+PjEzKXwwKSsoSWU+Pj4yNil8MCxJZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxpZSksaT1NYXRoLmltdWwoRCxvZSkrTWF0aC5pbXVsKFUsaWUpfDAsbz1NYXRoLmltdWwoVSxvZSksbj1uK01hdGguaW11bChDLGFlKXwwLGk9KGkrTWF0aC5pbXVsKEMsdWUpfDApK01hdGguaW11bChMLGFlKXwwLG89bytNYXRoLmltdWwoTCx1ZSl8MCxuPW4rTWF0aC5pbXVsKFQsaGUpfDAsaT0oaStNYXRoLmltdWwoVCxmZSl8MCkrTWF0aC5pbXVsKFIsaGUpfDAsbz1vK01hdGguaW11bChSLGZlKXwwO3ZhciBUZT0oeWUrKG4rTWF0aC5pbXVsKHgsZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoeCxwZSl8MCkrTWF0aC5pbXVsKFAsZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChQLHBlKXwwKSsoaT4+PjEzKXwwKSsoVGU+Pj4yNil8MCxUZSY9NjcxMDg4NjMsbj1NYXRoLmltdWwoRCxhZSksaT1NYXRoLmltdWwoRCx1ZSkrTWF0aC5pbXVsKFUsYWUpfDAsbz1NYXRoLmltdWwoVSx1ZSksbj1uK01hdGguaW11bChDLGhlKXwwLGk9KGkrTWF0aC5pbXVsKEMsZmUpfDApK01hdGguaW11bChMLGhlKXwwLG89bytNYXRoLmltdWwoTCxmZSl8MDt2YXIgUmU9KHllKyhuK01hdGguaW11bChULGRlKXwwKXwwKSsoKDgxOTEmKGk9KGkrTWF0aC5pbXVsKFQscGUpfDApK01hdGguaW11bChSLGRlKXwwKSk8PDEzKXwwO3llPSgobytNYXRoLmltdWwoUixwZSl8MCkrKGk+Pj4xMyl8MCkrKFJlPj4+MjYpfDAsUmUmPTY3MTA4ODYzLG49TWF0aC5pbXVsKEQsaGUpLGk9TWF0aC5pbXVsKEQsZmUpK01hdGguaW11bChVLGhlKXwwLG89TWF0aC5pbXVsKFUsZmUpO3ZhciBPZT0oeWUrKG4rTWF0aC5pbXVsKEMsZGUpfDApfDApKygoODE5MSYoaT0oaStNYXRoLmltdWwoQyxwZSl8MCkrTWF0aC5pbXVsKEwsZGUpfDApKTw8MTMpfDA7eWU9KChvK01hdGguaW11bChMLHBlKXwwKSsoaT4+PjEzKXwwKSsoT2U+Pj4yNil8MCxPZSY9NjcxMDg4NjM7dmFyIENlPSh5ZStNYXRoLmltdWwoRCxkZSl8MCkrKCg4MTkxJihpPU1hdGguaW11bChELHBlKStNYXRoLmltdWwoVSxkZSl8MCkpPDwxMyl8MDtyZXR1cm4geWU9KE1hdGguaW11bChVLHBlKSsoaT4+PjEzKXwwKSsoQ2U+Pj4yNil8MCxDZSY9NjcxMDg4NjMsdVswXT12ZSx1WzFdPW1lLHVbMl09Z2UsdVszXT1iZSx1WzRdPXdlLHVbNV09X2UsdVs2XT1NZSx1WzddPUFlLHVbOF09RWUsdVs5XT1TZSx1WzEwXT1rZSx1WzExXT1OZSx1WzEyXT14ZSx1WzEzXT1QZSx1WzE0XT1JZSx1WzE1XT1UZSx1WzE2XT1SZSx1WzE3XT1PZSx1WzE4XT1DZSwwIT15ZSYmKHVbMTldPXllLHIubGVuZ3RoKyspLHJ9O2Z1bmN0aW9uIGEoZSx0LHIpe3JldHVybihuZXcgdSkubXVscChlLHQscil9ZnVuY3Rpb24gdShlLHQpe3RoaXMueD1lLHRoaXMueT10fU1hdGguaW11bHx8KG89aSksbS5wcm90b3R5cGUubXVsVG89ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmxlbmd0aCtlLmxlbmd0aCxuPSgxMD09PXRoaXMubGVuZ3RoJiYxMD09PWUubGVuZ3RoP286cjw2Mz9pOnI8MTAyND9mdW5jdGlvbihlLHQscil7ci5uZWdhdGl2ZT10Lm5lZ2F0aXZlXmUubmVnYXRpdmUsci5sZW5ndGg9ZS5sZW5ndGgrdC5sZW5ndGg7Zm9yKHZhciBuPTAsaT0wLG89MDtvPHIubGVuZ3RoLTE7bysrKXtmb3IodmFyIHM9aSxpPTAsYT02NzEwODg2MyZuLHU9TWF0aC5taW4obyx0Lmxlbmd0aC0xKSxsPU1hdGgubWF4KDAsby1lLmxlbmd0aCsxKTtsPD11O2wrKyl7dmFyIGg9by1sLGY9KDB8ZS53b3Jkc1toXSkqKDB8dC53b3Jkc1tsXSksYz02NzEwODg2MyZmLGE9NjcxMDg4NjMmKGM9YythfDApO2krPShzPShzPXMrKGYvNjcxMDg4NjR8MCl8MCkrKGM+Pj4yNil8MCk+Pj4yNixzJj02NzEwODg2M31yLndvcmRzW29dPWEsbj1zLHM9aX1yZXR1cm4gMCE9PW4/ci53b3Jkc1tvXT1uOnIubGVuZ3RoLS0sci5zdHJpcCgpfTphKSh0aGlzLGUsdCk7cmV0dXJuIG59LHUucHJvdG90eXBlLm1ha2VSQlQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW5ldyBBcnJheShlKSxyPW0ucHJvdG90eXBlLl9jb3VudEJpdHMoZSktMSxuPTA7bjxlO24rKyl0W25dPXRoaXMucmV2QmluKG4scixlKTtyZXR1cm4gdH0sdS5wcm90b3R5cGUucmV2QmluPWZ1bmN0aW9uKGUsdCxyKXtpZigwPT09ZXx8ZT09PXItMSlyZXR1cm4gZTtmb3IodmFyIG49MCxpPTA7aTx0O2krKylufD0oMSZlKTw8dC1pLTEsZT4+PTE7cmV0dXJuIG59LHUucHJvdG90eXBlLnBlcm11dGU9ZnVuY3Rpb24oZSx0LHIsbixpLG8pe2Zvcih2YXIgcz0wO3M8bztzKyspbltzXT10W2Vbc11dLGlbc109cltlW3NdXX0sdS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKGUsdCxyLG4saSxvKXt0aGlzLnBlcm11dGUobyxlLHQscixuLGkpO2Zvcih2YXIgcz0xO3M8aTtzPDw9MSlmb3IodmFyIGE9czw8MSx1PU1hdGguY29zKDIqTWF0aC5QSS9hKSxsPU1hdGguc2luKDIqTWF0aC5QSS9hKSxoPTA7aDxpO2grPWEpZm9yKHZhciBmPXUsYz1sLGQ9MDtkPHM7ZCsrKXt2YXIgcD1yW2grZF0sdj1uW2grZF0seT1mKihnPXJbaCtkK3NdKS1jKihtPW5baCtkK3NdKSxtPWYqbStjKmcsZz15O3JbaCtkXT1wK2csbltoK2RdPXYrbSxyW2grZCtzXT1wLWcsbltoK2Qrc109di1tLGQhPT1hJiYoeT11KmYtbCpjLGM9dSpjK2wqZixmPXkpfX0sdS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2I9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9MSYoaT0xfE1hdGgubWF4KHQsZSkpLG49MCxpPWkvMnwwO2k7aT4+Pj0xKW4rKztyZXR1cm4gMTw8bisxK3J9LHUucHJvdG90eXBlLmNvbmp1Z2F0ZT1mdW5jdGlvbihlLHQscil7aWYoIShyPD0xKSlmb3IodmFyIG49MDtuPHIvMjtuKyspe3ZhciBpPWVbbl07ZVtuXT1lW3Itbi0xXSxlW3Itbi0xXT1pLGk9dFtuXSx0W25dPS10W3Itbi0xXSx0W3Itbi0xXT0taX19LHUucHJvdG90eXBlLm5vcm1hbGl6ZTEzYj1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0wLG49MDtuPHQvMjtuKyspe3ZhciBpPTgxOTIqTWF0aC5yb3VuZChlWzIqbisxXS90KStNYXRoLnJvdW5kKGVbMipuXS90KStyO2Vbbl09NjcxMDg4NjMmaSxyPWk8NjcxMDg4NjQ/MDppLzY3MTA4ODY0fDB9cmV0dXJuIGV9LHUucHJvdG90eXBlLmNvbnZlcnQxM2I9ZnVuY3Rpb24oZSx0LHIsbil7Zm9yKHZhciBpPTAsbz0wO288dDtvKyspaSs9MHxlW29dLHJbMipvXT04MTkxJmksaT4+Pj0xMyxyWzIqbysxXT04MTkxJmksaT4+Pj0xMztmb3Iobz0yKnQ7bzxuOysrbylyW29dPTA7eSgwPT09aSkseSgwPT0oLTgxOTImaSkpfSx1LnByb3RvdHlwZS5zdHViPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgQXJyYXkoZSkscj0wO3I8ZTtyKyspdFtyXT0wO3JldHVybiB0fSx1LnByb3RvdHlwZS5tdWxwPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj0yKnRoaXMuZ3Vlc3NMZW4xM2IoZS5sZW5ndGgsdC5sZW5ndGgpLGk9dGhpcy5tYWtlUkJUKG4pLG89dGhpcy5zdHViKG4pLHM9bmV3IEFycmF5KG4pLGE9bmV3IEFycmF5KG4pLHU9bmV3IEFycmF5KG4pLGw9bmV3IEFycmF5KG4pLGg9bmV3IEFycmF5KG4pLGY9bmV3IEFycmF5KG4pLGM9ci53b3JkcztjLmxlbmd0aD1uLHRoaXMuY29udmVydDEzYihlLndvcmRzLGUubGVuZ3RoLHMsbiksdGhpcy5jb252ZXJ0MTNiKHQud29yZHMsdC5sZW5ndGgsbCxuKSx0aGlzLnRyYW5zZm9ybShzLG8sYSx1LG4saSksdGhpcy50cmFuc2Zvcm0obCxvLGgsZixuLGkpO2Zvcih2YXIgZD0wO2Q8bjtkKyspe3ZhciBwPWFbZF0qaFtkXS11W2RdKmZbZF07dVtkXT1hW2RdKmZbZF0rdVtkXSpoW2RdLGFbZF09cH1yZXR1cm4gdGhpcy5jb25qdWdhdGUoYSx1LG4pLHRoaXMudHJhbnNmb3JtKGEsdSxjLG8sbixpKSx0aGlzLmNvbmp1Z2F0ZShjLG8sbiksdGhpcy5ub3JtYWxpemUxM2IoYyxuKSxyLm5lZ2F0aXZlPWUubmVnYXRpdmVedC5uZWdhdGl2ZSxyLmxlbmd0aD1lLmxlbmd0aCt0Lmxlbmd0aCxyLnN0cmlwKCl9LG0ucHJvdG90eXBlLm11bD1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbShudWxsKTtyZXR1cm4gdC53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgrZS5sZW5ndGgpLHRoaXMubXVsVG8oZSx0KX0sbS5wcm90b3R5cGUubXVsZj1mdW5jdGlvbihlKXt2YXIgdD1uZXcgbShudWxsKTtyZXR1cm4gdC53b3Jkcz1uZXcgQXJyYXkodGhpcy5sZW5ndGgrZS5sZW5ndGgpLGEodGhpcyxlLHQpfSxtLnByb3RvdHlwZS5pbXVsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkubXVsVG8oZSx0aGlzKX0sbS5wcm90b3R5cGUuaW11bG49ZnVuY3Rpb24oZSl7eShcIm51bWJlclwiPT10eXBlb2YgZSkseShlPDY3MTA4ODY0KTtmb3IodmFyIHQ9MCxyPTA7cjx0aGlzLmxlbmd0aDtyKyspe3ZhciBuPSgwfHRoaXMud29yZHNbcl0pKmUsaT0oNjcxMDg4NjMmbikrKDY3MTA4ODYzJnQpO3Q+Pj0yNix0Kz1uLzY3MTA4ODY0fDAsdCs9aT4+PjI2LHRoaXMud29yZHNbcl09NjcxMDg4NjMmaX1yZXR1cm4gMCE9PXQmJih0aGlzLndvcmRzW3JdPXQsdGhpcy5sZW5ndGgrKyksdGhpc30sbS5wcm90b3R5cGUubXVsbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKGUpfSxtLnByb3RvdHlwZS5zcXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWwodGhpcyl9LG0ucHJvdG90eXBlLmlzcXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSl9LG0ucHJvdG90eXBlLnBvdz1mdW5jdGlvbihlKXt2YXIgdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9bmV3IEFycmF5KGUuYml0TGVuZ3RoKCkpLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49ci8yNnwwLGk9ciUyNjt0W3JdPShlLndvcmRzW25dJjE8PGkpPj4+aX1yZXR1cm4gdH0oZSk7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuZXcgbSgxKTtmb3IodmFyIHI9dGhpcyxuPTA7bjx0Lmxlbmd0aCYmMD09PXRbbl07bisrLHI9ci5zcXIoKSk7aWYoKytuPHQubGVuZ3RoKWZvcih2YXIgaT1yLnNxcigpO248dC5sZW5ndGg7bisrLGk9aS5zcXIoKSkwIT09dFtuXSYmKHI9ci5tdWwoaSkpO3JldHVybiByfSxtLnByb3RvdHlwZS5pdXNobG49ZnVuY3Rpb24oZSl7eShcIm51bWJlclwiPT10eXBlb2YgZSYmMDw9ZSk7dmFyIHQ9ZSUyNixyPShlLXQpLzI2LG49NjcxMDg4NjM+Pj4yNi10PDwyNi10O2lmKDAhPXQpe2Zvcih2YXIgaT0wLG89MDtvPHRoaXMubGVuZ3RoO28rKyl7dmFyIHM9dGhpcy53b3Jkc1tvXSZuLGE9KDB8dGhpcy53b3Jkc1tvXSktczw8dDt0aGlzLndvcmRzW29dPWF8aSxpPXM+Pj4yNi10fWkmJih0aGlzLndvcmRzW29dPWksdGhpcy5sZW5ndGgrKyl9aWYoMCE9cil7Zm9yKG89dGhpcy5sZW5ndGgtMTswPD1vO28tLSl0aGlzLndvcmRzW28rcl09dGhpcy53b3Jkc1tvXTtmb3Iobz0wO288cjtvKyspdGhpcy53b3Jkc1tvXT0wO3RoaXMubGVuZ3RoKz1yfXJldHVybiB0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmlzaGxuPWZ1bmN0aW9uKGUpe3JldHVybiB5KDA9PT10aGlzLm5lZ2F0aXZlKSx0aGlzLml1c2hsbihlKX0sbS5wcm90b3R5cGUuaXVzaHJuPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbjt5KFwibnVtYmVyXCI9PXR5cGVvZiBlJiYwPD1lKSxuPXQ/KHQtdCUyNikvMjY6MDt2YXIgaT1lJTI2LG89TWF0aC5taW4oKGUtaSkvMjYsdGhpcy5sZW5ndGgpLHM9NjcxMDg4NjNeNjcxMDg4NjM+Pj5pPDxpLGE9cjtpZihuLT1vLG49TWF0aC5tYXgoMCxuKSxhKXtmb3IodmFyIHU9MDt1PG87dSsrKWEud29yZHNbdV09dGhpcy53b3Jkc1t1XTthLmxlbmd0aD1vfWlmKDAhPT1vKWlmKHRoaXMubGVuZ3RoPm8pZm9yKHRoaXMubGVuZ3RoLT1vLHU9MDt1PHRoaXMubGVuZ3RoO3UrKyl0aGlzLndvcmRzW3VdPXRoaXMud29yZHNbdStvXTtlbHNlIHRoaXMud29yZHNbMF09MCx0aGlzLmxlbmd0aD0xO2Zvcih2YXIgbD0wLHU9dGhpcy5sZW5ndGgtMTswPD11JiYoMCE9PWx8fG48PXUpO3UtLSl7dmFyIGg9MHx0aGlzLndvcmRzW3VdO3RoaXMud29yZHNbdV09bDw8MjYtaXxoPj4+aSxsPWgmc31yZXR1cm4gYSYmMCE9PWwmJihhLndvcmRzW2EubGVuZ3RoKytdPWwpLDA9PT10aGlzLmxlbmd0aCYmKHRoaXMud29yZHNbMF09MCx0aGlzLmxlbmd0aD0xKSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmlzaHJuPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4geSgwPT09dGhpcy5uZWdhdGl2ZSksdGhpcy5pdXNocm4oZSx0LHIpfSxtLnByb3RvdHlwZS5zaGxuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXNobG4oZSl9LG0ucHJvdG90eXBlLnVzaGxuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGUpfSxtLnByb3RvdHlwZS5zaHJuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXNocm4oZSl9LG0ucHJvdG90eXBlLnVzaHJuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGUpfSxtLnByb3RvdHlwZS50ZXN0bj1mdW5jdGlvbihlKXt5KFwibnVtYmVyXCI9PXR5cGVvZiBlJiYwPD1lKTt2YXIgdD1lJTI2LHI9KGUtdCkvMjYsbj0xPDx0O3JldHVybiEodGhpcy5sZW5ndGg8PXIpJiYhISh0aGlzLndvcmRzW3JdJm4pfSxtLnByb3RvdHlwZS5pbWFza249ZnVuY3Rpb24oZSl7eShcIm51bWJlclwiPT10eXBlb2YgZSYmMDw9ZSk7dmFyIHQscj1lJTI2LG49KGUtcikvMjY7cmV0dXJuIHkoMD09PXRoaXMubmVnYXRpdmUsXCJpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnNcIiksdGhpcy5sZW5ndGg8PW4/dGhpczooMCE9ciYmbisrLHRoaXMubGVuZ3RoPU1hdGgubWluKG4sdGhpcy5sZW5ndGgpLDAhPXImJih0PTY3MTA4ODYzXjY3MTA4ODYzPj4+cjw8cix0aGlzLndvcmRzW3RoaXMubGVuZ3RoLTFdJj10KSx0aGlzLnN0cmlwKCkpfSxtLnByb3RvdHlwZS5tYXNrbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihlKX0sbS5wcm90b3R5cGUuaWFkZG49ZnVuY3Rpb24oZSl7cmV0dXJuIHkoXCJudW1iZXJcIj09dHlwZW9mIGUpLHkoZTw2NzEwODg2NCksZTwwP3RoaXMuaXN1Ym4oLWUpOjAhPT10aGlzLm5lZ2F0aXZlPygxPT09dGhpcy5sZW5ndGgmJigwfHRoaXMud29yZHNbMF0pPGU/KHRoaXMud29yZHNbMF09ZS0oMHx0aGlzLndvcmRzWzBdKSx0aGlzLm5lZ2F0aXZlPTApOih0aGlzLm5lZ2F0aXZlPTAsdGhpcy5pc3VibihlKSx0aGlzLm5lZ2F0aXZlPTEpLHRoaXMpOnRoaXMuX2lhZGRuKGUpfSxtLnByb3RvdHlwZS5faWFkZG49ZnVuY3Rpb24oZSl7dGhpcy53b3Jkc1swXSs9ZTtmb3IodmFyIHQ9MDt0PHRoaXMubGVuZ3RoJiY2NzEwODg2NDw9dGhpcy53b3Jkc1t0XTt0KyspdGhpcy53b3Jkc1t0XS09NjcxMDg4NjQsdD09PXRoaXMubGVuZ3RoLTE/dGhpcy53b3Jkc1t0KzFdPTE6dGhpcy53b3Jkc1t0KzFdKys7cmV0dXJuIHRoaXMubGVuZ3RoPU1hdGgubWF4KHRoaXMubGVuZ3RoLHQrMSksdGhpc30sbS5wcm90b3R5cGUuaXN1Ym49ZnVuY3Rpb24oZSl7aWYoeShcIm51bWJlclwiPT10eXBlb2YgZSkseShlPDY3MTA4ODY0KSxlPDApcmV0dXJuIHRoaXMuaWFkZG4oLWUpO2lmKDAhPT10aGlzLm5lZ2F0aXZlKXJldHVybiB0aGlzLm5lZ2F0aXZlPTAsdGhpcy5pYWRkbihlKSx0aGlzLm5lZ2F0aXZlPTEsdGhpcztpZih0aGlzLndvcmRzWzBdLT1lLDE9PT10aGlzLmxlbmd0aCYmdGhpcy53b3Jkc1swXTwwKXRoaXMud29yZHNbMF09LXRoaXMud29yZHNbMF0sdGhpcy5uZWdhdGl2ZT0xO2Vsc2UgZm9yKHZhciB0PTA7dDx0aGlzLmxlbmd0aCYmdGhpcy53b3Jkc1t0XTwwO3QrKyl0aGlzLndvcmRzW3RdKz02NzEwODg2NCwtLXRoaXMud29yZHNbdCsxXTtyZXR1cm4gdGhpcy5zdHJpcCgpfSxtLnByb3RvdHlwZS5hZGRuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNsb25lKCkuaWFkZG4oZSl9LG0ucHJvdG90eXBlLnN1Ym49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihlKX0sbS5wcm90b3R5cGUuaWFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5lZ2F0aXZlPTAsdGhpc30sbS5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCl9LG0ucHJvdG90eXBlLl9pc2hsbnN1Ym11bD1mdW5jdGlvbihlLHQscil7dmFyIG4saT1lLmxlbmd0aCtyO3RoaXMuX2V4cGFuZChpKTtmb3IodmFyIG89MCxzPTA7czxlLmxlbmd0aDtzKyspe249KDB8dGhpcy53b3Jkc1tzK3JdKStvO3ZhciBhPSgwfGUud29yZHNbc10pKnQsbz0oKG4tPTY3MTA4ODYzJmEpPj4yNiktKGEvNjcxMDg4NjR8MCk7dGhpcy53b3Jkc1tzK3JdPTY3MTA4ODYzJm59Zm9yKDtzPHRoaXMubGVuZ3RoLXI7cysrKW89KG49KDB8dGhpcy53b3Jkc1tzK3JdKStvKT4+MjYsdGhpcy53b3Jkc1tzK3JdPTY3MTA4ODYzJm47aWYoMD09PW8pcmV0dXJuIHRoaXMuc3RyaXAoKTtmb3IoeSgtMT09PW8pLHM9bz0wO3M8dGhpcy5sZW5ndGg7cysrKW89KG49LSgwfHRoaXMud29yZHNbc10pK28pPj4yNix0aGlzLndvcmRzW3NdPTY3MTA4ODYzJm47cmV0dXJuIHRoaXMubmVnYXRpdmU9MSx0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLl93b3JkRGl2PWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5sZW5ndGgtZS5sZW5ndGgsbj10aGlzLmNsb25lKCksaT1lLG89MHxpLndvcmRzW2kubGVuZ3RoLTFdOzAhPShyPTI2LXRoaXMuX2NvdW50Qml0cyhvKSkmJihpPWkudXNobG4ociksbi5pdXNobG4ociksbz0wfGkud29yZHNbaS5sZW5ndGgtMV0pO3ZhciBzLGE9bi5sZW5ndGgtaS5sZW5ndGg7aWYoXCJtb2RcIiE9PXQpeyhzPW5ldyBtKG51bGwpKS5sZW5ndGg9MSthLHMud29yZHM9bmV3IEFycmF5KHMubGVuZ3RoKTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKylzLndvcmRzW3VdPTB9dmFyIGw9bi5jbG9uZSgpLl9pc2hsbnN1Ym11bChpLDEsYSk7MD09PWwubmVnYXRpdmUmJihuPWwscyYmKHMud29yZHNbYV09MSkpO2Zvcih2YXIgaD1hLTE7MDw9aDtoLS0pe3ZhciBmPTY3MTA4ODY0KigwfG4ud29yZHNbaS5sZW5ndGgraF0pKygwfG4ud29yZHNbaS5sZW5ndGgraC0xXSksZj1NYXRoLm1pbihmL298MCw2NzEwODg2Myk7Zm9yKG4uX2lzaGxuc3VibXVsKGksZixoKTswIT09bi5uZWdhdGl2ZTspZi0tLG4ubmVnYXRpdmU9MCxuLl9pc2hsbnN1Ym11bChpLDEsaCksbi5pc1plcm8oKXx8KG4ubmVnYXRpdmVePTEpO3MmJihzLndvcmRzW2hdPWYpfXJldHVybiBzJiZzLnN0cmlwKCksbi5zdHJpcCgpLFwiZGl2XCIhPT10JiYwIT1yJiZuLml1c2hybihyKSx7ZGl2OnN8fG51bGwsbW9kOm59fSxtLnByb3RvdHlwZS5kaXZtb2Q9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB5KCFlLmlzWmVybygpKSx0aGlzLmlzWmVybygpP3tkaXY6bmV3IG0oMCksbW9kOm5ldyBtKDApfTowIT09dGhpcy5uZWdhdGl2ZSYmMD09PWUubmVnYXRpdmU/KG89dGhpcy5uZWcoKS5kaXZtb2QoZSx0KSxcIm1vZFwiIT09dCYmKG49by5kaXYubmVnKCkpLFwiZGl2XCIhPT10JiYoaT1vLm1vZC5uZWcoKSxyJiYwIT09aS5uZWdhdGl2ZSYmaS5pYWRkKGUpKSx7ZGl2Om4sbW9kOml9KTowPT09dGhpcy5uZWdhdGl2ZSYmMCE9PWUubmVnYXRpdmU/KG89dGhpcy5kaXZtb2QoZS5uZWcoKSx0KSxcIm1vZFwiIT09dCYmKG49by5kaXYubmVnKCkpLHtkaXY6bixtb2Q6by5tb2R9KTowIT0odGhpcy5uZWdhdGl2ZSZlLm5lZ2F0aXZlKT8obz10aGlzLm5lZygpLmRpdm1vZChlLm5lZygpLHQpLFwiZGl2XCIhPT10JiYoaT1vLm1vZC5uZWcoKSxyJiYwIT09aS5uZWdhdGl2ZSYmaS5pc3ViKGUpKSx7ZGl2Om8uZGl2LG1vZDppfSk6ZS5sZW5ndGg+dGhpcy5sZW5ndGh8fHRoaXMuY21wKGUpPDA/e2RpdjpuZXcgbSgwKSxtb2Q6dGhpc306MT09PWUubGVuZ3RoP1wiZGl2XCI9PT10P3tkaXY6dGhpcy5kaXZuKGUud29yZHNbMF0pLG1vZDpudWxsfTpcIm1vZFwiPT09dD97ZGl2Om51bGwsbW9kOm5ldyBtKHRoaXMubW9kbihlLndvcmRzWzBdKSl9OntkaXY6dGhpcy5kaXZuKGUud29yZHNbMF0pLG1vZDpuZXcgbSh0aGlzLm1vZG4oZS53b3Jkc1swXSkpfTp0aGlzLl93b3JkRGl2KGUsdCk7dmFyIG4saSxvfSxtLnByb3RvdHlwZS5kaXY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGl2bW9kKGUsXCJkaXZcIiwhMSkuZGl2fSxtLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZGl2bW9kKGUsXCJtb2RcIiwhMSkubW9kfSxtLnByb3RvdHlwZS51bW9kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRpdm1vZChlLFwibW9kXCIsITApLm1vZH0sbS5wcm90b3R5cGUuZGl2Um91bmQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5kaXZtb2QoZSk7aWYodC5tb2QuaXNaZXJvKCkpcmV0dXJuIHQuZGl2O3ZhciByPTAhPT10LmRpdi5uZWdhdGl2ZT90Lm1vZC5pc3ViKGUpOnQubW9kLG49ZS51c2hybigxKSxpPWUuYW5kbG4oMSksbz1yLmNtcChuKTtyZXR1cm4gbzwwfHwxPT09aSYmMD09PW8/dC5kaXY6MCE9PXQuZGl2Lm5lZ2F0aXZlP3QuZGl2LmlzdWJuKDEpOnQuZGl2LmlhZGRuKDEpfSxtLnByb3RvdHlwZS5tb2RuPWZ1bmN0aW9uKGUpe3koZTw9NjcxMDg4NjMpO2Zvcih2YXIgdD0oMTw8MjYpJWUscj0wLG49dGhpcy5sZW5ndGgtMTswPD1uO24tLSlyPSh0KnIrKDB8dGhpcy53b3Jkc1tuXSkpJWU7cmV0dXJuIHJ9LG0ucHJvdG90eXBlLmlkaXZuPWZ1bmN0aW9uKGUpe3koZTw9NjcxMDg4NjMpO2Zvcih2YXIgdD0wLHI9dGhpcy5sZW5ndGgtMTswPD1yO3ItLSl7dmFyIG49KDB8dGhpcy53b3Jkc1tyXSkrNjcxMDg4NjQqdDt0aGlzLndvcmRzW3JdPW4vZXwwLHQ9biVlfXJldHVybiB0aGlzLnN0cmlwKCl9LG0ucHJvdG90eXBlLmRpdm49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihlKX0sbS5wcm90b3R5cGUuZWdjZD1mdW5jdGlvbihlKXt5KDA9PT1lLm5lZ2F0aXZlKSx5KCFlLmlzWmVybygpKTtmb3IodmFyIHQ9dGhpcyxyPWUuY2xvbmUoKSx0PTAhPT10Lm5lZ2F0aXZlP3QudW1vZChlKTp0LmNsb25lKCksbj1uZXcgbSgxKSxpPW5ldyBtKDApLG89bmV3IG0oMCkscz1uZXcgbSgxKSxhPTA7dC5pc0V2ZW4oKSYmci5pc0V2ZW4oKTspdC5pdXNocm4oMSksci5pdXNocm4oMSksKythO2Zvcih2YXIgdT1yLmNsb25lKCksbD10LmNsb25lKCk7IXQuaXNaZXJvKCk7KXtmb3IodmFyIGg9MCxmPTE7MD09KHQud29yZHNbMF0mZikmJmg8MjY7KytoLGY8PD0xKTtpZigwPGgpZm9yKHQuaXVzaHJuKGgpOzA8aC0tOykobi5pc09kZCgpfHxpLmlzT2RkKCkpJiYobi5pYWRkKHUpLGkuaXN1YihsKSksbi5pdXNocm4oMSksaS5pdXNocm4oMSk7Zm9yKHZhciBjPTAsZD0xOzA9PShyLndvcmRzWzBdJmQpJiZjPDI2OysrYyxkPDw9MSk7aWYoMDxjKWZvcihyLml1c2hybihjKTswPGMtLTspKG8uaXNPZGQoKXx8cy5pc09kZCgpKSYmKG8uaWFkZCh1KSxzLmlzdWIobCkpLG8uaXVzaHJuKDEpLHMuaXVzaHJuKDEpOzA8PXQuY21wKHIpPyh0LmlzdWIociksbi5pc3ViKG8pLGkuaXN1YihzKSk6KHIuaXN1Yih0KSxvLmlzdWIobikscy5pc3ViKGkpKX1yZXR1cm57YTpvLGI6cyxnY2Q6ci5pdXNobG4oYSl9fSxtLnByb3RvdHlwZS5faW52bXA9ZnVuY3Rpb24oZSl7eSgwPT09ZS5uZWdhdGl2ZSkseSghZS5pc1plcm8oKSk7Zm9yKHZhciB0LHI9dGhpcyxuPWUuY2xvbmUoKSxyPTAhPT1yLm5lZ2F0aXZlP3IudW1vZChlKTpyLmNsb25lKCksaT1uZXcgbSgxKSxvPW5ldyBtKDApLHM9bi5jbG9uZSgpOzA8ci5jbXBuKDEpJiYwPG4uY21wbigxKTspe2Zvcih2YXIgYT0wLHU9MTswPT0oci53b3Jkc1swXSZ1KSYmYTwyNjsrK2EsdTw8PTEpO2lmKDA8YSlmb3Ioci5pdXNocm4oYSk7MDxhLS07KWkuaXNPZGQoKSYmaS5pYWRkKHMpLGkuaXVzaHJuKDEpO2Zvcih2YXIgbD0wLGg9MTswPT0obi53b3Jkc1swXSZoKSYmbDwyNjsrK2wsaDw8PTEpO2lmKDA8bClmb3Iobi5pdXNocm4obCk7MDxsLS07KW8uaXNPZGQoKSYmby5pYWRkKHMpLG8uaXVzaHJuKDEpOzA8PXIuY21wKG4pPyhyLmlzdWIobiksaS5pc3ViKG8pKToobi5pc3ViKHIpLG8uaXN1YihpKSl9cmV0dXJuKHQ9MD09PXIuY21wbigxKT9pOm8pLmNtcG4oMCk8MCYmdC5pYWRkKGUpLHR9LG0ucHJvdG90eXBlLmdjZD1mdW5jdGlvbihlKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBlLmFicygpO2lmKGUuaXNaZXJvKCkpcmV0dXJuIHRoaXMuYWJzKCk7dmFyIHQ9dGhpcy5jbG9uZSgpLHI9ZS5jbG9uZSgpO3QubmVnYXRpdmU9MDtmb3IodmFyIG49ci5uZWdhdGl2ZT0wO3QuaXNFdmVuKCkmJnIuaXNFdmVuKCk7bisrKXQuaXVzaHJuKDEpLHIuaXVzaHJuKDEpO2Zvcig7Oyl7Zm9yKDt0LmlzRXZlbigpOyl0Lml1c2hybigxKTtmb3IoO3IuaXNFdmVuKCk7KXIuaXVzaHJuKDEpO3ZhciBpPXQuY21wKHIpO2lmKGk8MCl2YXIgbz10LHQ9cixyPW87ZWxzZSBpZigwPT09aXx8MD09PXIuY21wbigxKSlicmVhazt0LmlzdWIocil9cmV0dXJuIHIuaXVzaGxuKG4pfSxtLnByb3RvdHlwZS5pbnZtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVnY2QoZSkuYS51bW9kKGUpfSxtLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4gMD09KDEmdGhpcy53b3Jkc1swXSl9LG0ucHJvdG90eXBlLmlzT2RkPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PSgxJnRoaXMud29yZHNbMF0pfSxtLnByb3RvdHlwZS5hbmRsbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy53b3Jkc1swXSZlfSxtLnByb3RvdHlwZS5iaW5jbj1mdW5jdGlvbihlKXt5KFwibnVtYmVyXCI9PXR5cGVvZiBlKTt2YXIgdD1lJTI2LHI9KGUtdCkvMjYsbj0xPDx0O2lmKHRoaXMubGVuZ3RoPD1yKXJldHVybiB0aGlzLl9leHBhbmQoMStyKSx0aGlzLndvcmRzW3JdfD1uLHRoaXM7Zm9yKHZhciBpPW4sbz1yOzAhPT1pJiZvPHRoaXMubGVuZ3RoO28rKyl7dmFyIHM9MHx0aGlzLndvcmRzW29dLGk9KHMrPWkpPj4+MjY7cyY9NjcxMDg4NjMsdGhpcy53b3Jkc1tvXT1zfXJldHVybiAwIT09aSYmKHRoaXMud29yZHNbb109aSx0aGlzLmxlbmd0aCsrKSx0aGlzfSxtLnByb3RvdHlwZS5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGVuZ3RoJiYwPT09dGhpcy53b3Jkc1swXX0sbS5wcm90b3R5cGUuY21wbj1mdW5jdGlvbihlKXt2YXIgdCxyLG49ZTwwO3JldHVybiAwPT09dGhpcy5uZWdhdGl2ZXx8bj8wPT09dGhpcy5uZWdhdGl2ZSYmbj8xOih0aGlzLnN0cmlwKCkscj0xPHRoaXMubGVuZ3RoPzE6KG4mJihlPS1lKSx5KGU8PTY3MTA4ODYzLFwiTnVtYmVyIGlzIHRvbyBiaWdcIiksKHQ9MHx0aGlzLndvcmRzWzBdKT09PWU/MDp0PGU/LTE6MSksMCE9PXRoaXMubmVnYXRpdmU/MHwtcjpyKTotMX0sbS5wcm90b3R5cGUuY21wPWZ1bmN0aW9uKGUpe2lmKDAhPT10aGlzLm5lZ2F0aXZlJiYwPT09ZS5uZWdhdGl2ZSlyZXR1cm4tMTtpZigwPT09dGhpcy5uZWdhdGl2ZSYmMCE9PWUubmVnYXRpdmUpcmV0dXJuIDE7dmFyIHQ9dGhpcy51Y21wKGUpO3JldHVybiAwIT09dGhpcy5uZWdhdGl2ZT8wfC10OnR9LG0ucHJvdG90eXBlLnVjbXA9ZnVuY3Rpb24oZSl7aWYodGhpcy5sZW5ndGg+ZS5sZW5ndGgpcmV0dXJuIDE7aWYodGhpcy5sZW5ndGg8ZS5sZW5ndGgpcmV0dXJuLTE7Zm9yKHZhciB0PTAscj10aGlzLmxlbmd0aC0xOzA8PXI7ci0tKXt2YXIgbj0wfHRoaXMud29yZHNbcl0saT0wfGUud29yZHNbcl07aWYobiE9aSl7bjxpP3Q9LTE6aTxuJiYodD0xKTticmVha319cmV0dXJuIHR9LG0ucHJvdG90eXBlLmd0bj1mdW5jdGlvbihlKXtyZXR1cm4gMT09PXRoaXMuY21wbihlKX0sbS5wcm90b3R5cGUuZ3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT10aGlzLmNtcChlKX0sbS5wcm90b3R5cGUuZ3Rlbj1mdW5jdGlvbihlKXtyZXR1cm4gMDw9dGhpcy5jbXBuKGUpfSxtLnByb3RvdHlwZS5ndGU9ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PXRoaXMuY21wKGUpfSxtLnByb3RvdHlwZS5sdG49ZnVuY3Rpb24oZSl7cmV0dXJuLTE9PT10aGlzLmNtcG4oZSl9LG0ucHJvdG90eXBlLmx0PWZ1bmN0aW9uKGUpe3JldHVybi0xPT09dGhpcy5jbXAoZSl9LG0ucHJvdG90eXBlLmx0ZW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY21wbihlKTw9MH0sbS5wcm90b3R5cGUubHRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNtcChlKTw9MH0sbS5wcm90b3R5cGUuZXFuPWZ1bmN0aW9uKGUpe3JldHVybiAwPT09dGhpcy5jbXBuKGUpfSxtLnByb3RvdHlwZS5lcT1mdW5jdGlvbihlKXtyZXR1cm4gMD09PXRoaXMuY21wKGUpfSxtLnJlZD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IF8oZSl9LG0ucHJvdG90eXBlLnRvUmVkPWZ1bmN0aW9uKGUpe3JldHVybiB5KCF0aGlzLnJlZCxcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIikseSgwPT09dGhpcy5uZWdhdGl2ZSxcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLGUuY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChlKX0sbS5wcm90b3R5cGUuZnJvbVJlZD1mdW5jdGlvbigpe3JldHVybiB5KHRoaXMucmVkLFwiZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dFwiKSx0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKX0sbS5wcm90b3R5cGUuX2ZvcmNlUmVkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlZD1lLHRoaXN9LG0ucHJvdG90eXBlLmZvcmNlUmVkPWZ1bmN0aW9uKGUpe3JldHVybiB5KCF0aGlzLnJlZCxcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksdGhpcy5fZm9yY2VSZWQoZSl9LG0ucHJvdG90eXBlLnJlZEFkZD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuYWRkKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZElBZGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHkodGhpcy5yZWQsXCJyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5pYWRkKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZFN1Yj1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuc3ViKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZElTdWI9ZnVuY3Rpb24oZSl7cmV0dXJuIHkodGhpcy5yZWQsXCJyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5pc3ViKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZFNobD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuc2hsKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZE11bD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuX3ZlcmlmeTIodGhpcyxlKSx0aGlzLnJlZC5tdWwodGhpcyxlKX0sbS5wcm90b3R5cGUucmVkSU11bD1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksdGhpcy5yZWQuX3ZlcmlmeTIodGhpcyxlKSx0aGlzLnJlZC5pbXVsKHRoaXMsZSl9LG0ucHJvdG90eXBlLnJlZFNxcj1mdW5jdGlvbigpe3JldHVybiB5KHRoaXMucmVkLFwicmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSx0aGlzLnJlZC5zcXIodGhpcyl9LG0ucHJvdG90eXBlLnJlZElTcXI9ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLHRoaXMucmVkLmlzcXIodGhpcyl9LG0ucHJvdG90eXBlLnJlZFNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLHRoaXMucmVkLnNxcnQodGhpcyl9LG0ucHJvdG90eXBlLnJlZEludm09ZnVuY3Rpb24oKXtyZXR1cm4geSh0aGlzLnJlZCxcInJlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLHRoaXMucmVkLmludm0odGhpcyl9LG0ucHJvdG90eXBlLnJlZE5lZz1mdW5jdGlvbigpe3JldHVybiB5KHRoaXMucmVkLFwicmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSx0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSx0aGlzLnJlZC5uZWcodGhpcyl9LG0ucHJvdG90eXBlLnJlZFBvdz1mdW5jdGlvbihlKXtyZXR1cm4geSh0aGlzLnJlZCYmIWUucmVkLFwicmVkUG93KG5vcm1hbE51bSlcIiksdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksdGhpcy5yZWQucG93KHRoaXMsZSl9O3ZhciBsPXtrMjU2Om51bGwscDIyNDpudWxsLHAxOTI6bnVsbCxwMjU1MTk6bnVsbH07ZnVuY3Rpb24gaChlLHQpe3RoaXMubmFtZT1lLHRoaXMucD1uZXcgbSh0LDE2KSx0aGlzLm49dGhpcy5wLmJpdExlbmd0aCgpLHRoaXMuaz1uZXcgbSgxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCksdGhpcy50bXA9dGhpcy5fdG1wKCl9ZnVuY3Rpb24gdigpe2guY2FsbCh0aGlzLFwiazI1NlwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIil9ZnVuY3Rpb24gZygpe2guY2FsbCh0aGlzLFwicDIyNFwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDFcIil9ZnVuY3Rpb24gYigpe2guY2FsbCh0aGlzLFwicDE5MlwiLFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmZcIil9ZnVuY3Rpb24gdygpe2guY2FsbCh0aGlzLFwiMjU1MTlcIixcIjdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWRcIil9ZnVuY3Rpb24gXyhlKXt2YXIgdDtcInN0cmluZ1wiPT10eXBlb2YgZT8odD1tLl9wcmltZShlKSx0aGlzLm09dC5wLHRoaXMucHJpbWU9dCk6KHkoZS5ndG4oMSksXCJtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5tPWUsdGhpcy5wcmltZT1udWxsKX1mdW5jdGlvbiBNKGUpe18uY2FsbCh0aGlzLGUpLHRoaXMuc2hpZnQ9dGhpcy5tLmJpdExlbmd0aCgpLHRoaXMuc2hpZnQlMjYhPTAmJih0aGlzLnNoaWZ0Kz0yNi10aGlzLnNoaWZ0JTI2KSx0aGlzLnI9bmV3IG0oMSkuaXVzaGxuKHRoaXMuc2hpZnQpLHRoaXMucjI9dGhpcy5pbW9kKHRoaXMuci5zcXIoKSksdGhpcy5yaW52PXRoaXMuci5faW52bXAodGhpcy5tKSx0aGlzLm1pbnY9dGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pLHRoaXMubWludj10aGlzLm1pbnYudW1vZCh0aGlzLnIpLHRoaXMubWludj10aGlzLnIuc3ViKHRoaXMubWludil9aC5wcm90b3R5cGUuX3RtcD1mdW5jdGlvbigpe3ZhciBlPW5ldyBtKG51bGwpO3JldHVybiBlLndvcmRzPW5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uLzEzKSksZX0saC5wcm90b3R5cGUuaXJlZHVjZT1mdW5jdGlvbihlKXtmb3IodmFyIHQscj1lO3RoaXMuc3BsaXQocix0aGlzLnRtcCksKHQ9KHI9KHI9dGhpcy5pbXVsSyhyKSkuaWFkZCh0aGlzLnRtcCkpLmJpdExlbmd0aCgpKT50aGlzLm47KTt2YXIgbj10PHRoaXMubj8tMTpyLnVjbXAodGhpcy5wKTtyZXR1cm4gMD09PW4/KHIud29yZHNbMF09MCxyLmxlbmd0aD0xKTowPG4/ci5pc3ViKHRoaXMucCk6dm9pZCAwIT09ci5zdHJpcD9yLnN0cmlwKCk6ci5fc3RyaXAoKSxyfSxoLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe2UuaXVzaHJuKHRoaXMubiwwLHQpfSxoLnByb3RvdHlwZS5pbXVsSz1mdW5jdGlvbihlKXtyZXR1cm4gZS5pbXVsKHRoaXMuayl9LHIodixoKSx2LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1NYXRoLm1pbihlLmxlbmd0aCw5KSxuPTA7bjxyO24rKyl0LndvcmRzW25dPWUud29yZHNbbl07aWYodC5sZW5ndGg9cixlLmxlbmd0aDw9OSlyZXR1cm4gZS53b3Jkc1swXT0wLHZvaWQoZS5sZW5ndGg9MSk7dmFyIGk9ZS53b3Jkc1s5XTtmb3IodC53b3Jkc1t0Lmxlbmd0aCsrXT00MTk0MzAzJmksbj0xMDtuPGUubGVuZ3RoO24rKyl7dmFyIG89MHxlLndvcmRzW25dO2Uud29yZHNbbi0xMF09KDQxOTQzMDMmbyk8PDR8aT4+PjIyLGk9b31pPj4+PTIyLDA9PT0oZS53b3Jkc1tuLTEwXT1pKSYmMTA8ZS5sZW5ndGg/ZS5sZW5ndGgtPTEwOmUubGVuZ3RoLT05fSx2LnByb3RvdHlwZS5pbXVsSz1mdW5jdGlvbihlKXtlLndvcmRzW2UubGVuZ3RoXT0wLGUud29yZHNbZS5sZW5ndGgrMV09MCxlLmxlbmd0aCs9Mjtmb3IodmFyIHQ9MCxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPTB8ZS53b3Jkc1tyXTt0Kz05NzcqbixlLndvcmRzW3JdPTY3MTA4ODYzJnQsdD02NCpuKyh0LzY3MTA4ODY0fDApfXJldHVybiAwPT09ZS53b3Jkc1tlLmxlbmd0aC0xXSYmKGUubGVuZ3RoLS0sMD09PWUud29yZHNbZS5sZW5ndGgtMV0mJmUubGVuZ3RoLS0pLGV9LHIoZyxoKSxyKGIsaCkscih3LGgpLHcucHJvdG90eXBlLmltdWxLPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49MTkqKDB8ZS53b3Jkc1tyXSkrdCxpPTY3MTA4ODYzJm47bj4+Pj0yNixlLndvcmRzW3JdPWksdD1ufXJldHVybiAwIT09dCYmKGUud29yZHNbZS5sZW5ndGgrK109dCksZX0sbS5fcHJpbWU9ZnVuY3Rpb24oZSl7aWYobFtlXSlyZXR1cm4gbFtlXTt2YXIgdDtpZihcImsyNTZcIj09PWUpdD1uZXcgdjtlbHNlIGlmKFwicDIyNFwiPT09ZSl0PW5ldyBnO2Vsc2UgaWYoXCJwMTkyXCI9PT1lKXQ9bmV3IGI7ZWxzZXtpZihcInAyNTUxOVwiIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByaW1lIFwiK2UpO3Q9bmV3IHd9cmV0dXJuIGxbZV09dH0sXy5wcm90b3R5cGUuX3ZlcmlmeTE9ZnVuY3Rpb24oZSl7eSgwPT09ZS5uZWdhdGl2ZSxcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLHkoZS5yZWQsXCJyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpfSxfLnByb3RvdHlwZS5fdmVyaWZ5Mj1mdW5jdGlvbihlLHQpe3koMD09KGUubmVnYXRpdmV8dC5uZWdhdGl2ZSksXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSx5KGUucmVkJiZlLnJlZD09PXQucmVkLFwicmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKX0sXy5wcm90b3R5cGUuaW1vZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wcmltZT90aGlzLnByaW1lLmlyZWR1Y2UoZSkuX2ZvcmNlUmVkKHRoaXMpOmUudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKX0sXy5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKGUpe3JldHVybiBlLmlzWmVybygpP2UuY2xvbmUoKTp0aGlzLm0uc3ViKGUpLl9mb3JjZVJlZCh0aGlzKX0sXy5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdmVyaWZ5MihlLHQpO3ZhciByPWUuYWRkKHQpO3JldHVybiAwPD1yLmNtcCh0aGlzLm0pJiZyLmlzdWIodGhpcy5tKSxyLl9mb3JjZVJlZCh0aGlzKX0sXy5wcm90b3R5cGUuaWFkZD1mdW5jdGlvbihlLHQpe3RoaXMuX3ZlcmlmeTIoZSx0KTt2YXIgcj1lLmlhZGQodCk7cmV0dXJuIDA8PXIuY21wKHRoaXMubSkmJnIuaXN1Yih0aGlzLm0pLHJ9LF8ucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlLHQpe3RoaXMuX3ZlcmlmeTIoZSx0KTt2YXIgcj1lLnN1Yih0KTtyZXR1cm4gci5jbXBuKDApPDAmJnIuaWFkZCh0aGlzLm0pLHIuX2ZvcmNlUmVkKHRoaXMpfSxfLnByb3RvdHlwZS5pc3ViPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdmVyaWZ5MihlLHQpO3ZhciByPWUuaXN1Yih0KTtyZXR1cm4gci5jbXBuKDApPDAmJnIuaWFkZCh0aGlzLm0pLHJ9LF8ucHJvdG90eXBlLnNobD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl92ZXJpZnkxKGUpLHRoaXMuaW1vZChlLnVzaGxuKHQpKX0sXy5wcm90b3R5cGUuaW11bD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl92ZXJpZnkyKGUsdCksdGhpcy5pbW9kKGUuaW11bCh0KSl9LF8ucHJvdG90eXBlLm11bD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl92ZXJpZnkyKGUsdCksdGhpcy5pbW9kKGUubXVsKHQpKX0sXy5wcm90b3R5cGUuaXNxcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pbXVsKGUsZS5jbG9uZSgpKX0sXy5wcm90b3R5cGUuc3FyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm11bChlLGUpfSxfLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKGUpe2lmKGUuaXNaZXJvKCkpcmV0dXJuIGUuY2xvbmUoKTt2YXIgdD10aGlzLm0uYW5kbG4oMyk7aWYoeSh0JTI9PTEpLDM9PT10KXt2YXIgcj10aGlzLm0uYWRkKG5ldyBtKDEpKS5pdXNocm4oMik7cmV0dXJuIHRoaXMucG93KGUscil9Zm9yKHZhciBuPXRoaXMubS5zdWJuKDEpLGk9MDshbi5pc1plcm8oKSYmMD09PW4uYW5kbG4oMSk7KWkrKyxuLml1c2hybigxKTt5KCFuLmlzWmVybygpKTtmb3IodmFyIG89bmV3IG0oMSkudG9SZWQodGhpcykscz1vLnJlZE5lZygpLGE9dGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpLHU9bmV3IG0oMioodT10aGlzLm0uYml0TGVuZ3RoKCkpKnUpLnRvUmVkKHRoaXMpOzAhPT10aGlzLnBvdyh1LGEpLmNtcChzKTspdS5yZWRJQWRkKHMpO2Zvcih2YXIgbD10aGlzLnBvdyh1LG4pLGg9dGhpcy5wb3coZSxuLmFkZG4oMSkuaXVzaHJuKDEpKSxmPXRoaXMucG93KGUsbiksYz1pOzAhPT1mLmNtcChvKTspe2Zvcih2YXIgZD1mLHA9MDswIT09ZC5jbXAobyk7cCsrKWQ9ZC5yZWRTcXIoKTt5KHA8Yyk7dmFyIHY9dGhpcy5wb3cobCxuZXcgbSgxKS5pdXNobG4oYy1wLTEpKSxoPWgucmVkTXVsKHYpLGw9di5yZWRTcXIoKSxmPWYucmVkTXVsKGwpLGM9cH1yZXR1cm4gaH0sXy5wcm90b3R5cGUuaW52bT1mdW5jdGlvbihlKXt2YXIgdD1lLl9pbnZtcCh0aGlzLm0pO3JldHVybiAwIT09dC5uZWdhdGl2ZT8odC5uZWdhdGl2ZT0wLHRoaXMuaW1vZCh0KS5yZWROZWcoKSk6dGhpcy5pbW9kKHQpfSxfLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oZSx0KXtpZih0LmlzWmVybygpKXJldHVybiBuZXcgbSgxKS50b1JlZCh0aGlzKTtpZigwPT09dC5jbXBuKDEpKXJldHVybiBlLmNsb25lKCk7dmFyIHI9bmV3IEFycmF5KDE2KTtyWzBdPW5ldyBtKDEpLnRvUmVkKHRoaXMpLHJbMV09ZTtmb3IodmFyIG49MjtuPHIubGVuZ3RoO24rKylyW25dPXRoaXMubXVsKHJbbi0xXSxlKTt2YXIgaT1yWzBdLG89MCxzPTAsYT10LmJpdExlbmd0aCgpJTI2O2ZvcigwPT09YSYmKGE9MjYpLG49dC5sZW5ndGgtMTswPD1uO24tLSl7Zm9yKHZhciB1PXQud29yZHNbbl0sbD1hLTE7MDw9bDtsLS0pe3ZhciBoPXU+PmwmMTtpIT09clswXSYmKGk9dGhpcy5zcXIoaSkpLDAhPWh8fDAhPT1vPyhvPDw9MSxvfD1oLCg0PT09KytzfHwwPT09biYmMD09PWwpJiYoaT10aGlzLm11bChpLHJbb10pLG89cz0wKSk6cz0wfWE9MjZ9cmV0dXJuIGl9LF8ucHJvdG90eXBlLmNvbnZlcnRUbz1mdW5jdGlvbihlKXt2YXIgdD1lLnVtb2QodGhpcy5tKTtyZXR1cm4gdD09PWU/dC5jbG9uZSgpOnR9LF8ucHJvdG90eXBlLmNvbnZlcnRGcm9tPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2xvbmUoKTtyZXR1cm4gdC5yZWQ9bnVsbCx0fSxtLm1vbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBNKGUpfSxyKE0sXyksTS5wcm90b3R5cGUuY29udmVydFRvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmltb2QoZS51c2hsbih0aGlzLnNoaWZ0KSl9LE0ucHJvdG90eXBlLmNvbnZlcnRGcm9tPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaW1vZChlLm11bCh0aGlzLnJpbnYpKTtyZXR1cm4gdC5yZWQ9bnVsbCx0fSxNLnByb3RvdHlwZS5pbXVsPWZ1bmN0aW9uKGUsdCl7aWYoZS5pc1plcm8oKXx8dC5pc1plcm8oKSlyZXR1cm4gZS53b3Jkc1swXT0wLGUubGVuZ3RoPTEsZTt2YXIgcj1lLmltdWwodCksbj1yLm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKSxpPXIuaXN1YihuKS5pdXNocm4odGhpcy5zaGlmdCksbz1pO3JldHVybiAwPD1pLmNtcCh0aGlzLm0pP289aS5pc3ViKHRoaXMubSk6aS5jbXBuKDApPDAmJihvPWkuaWFkZCh0aGlzLm0pKSxvLl9mb3JjZVJlZCh0aGlzKX0sTS5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKGUsdCl7aWYoZS5pc1plcm8oKXx8dC5pc1plcm8oKSlyZXR1cm4gbmV3IG0oMCkuX2ZvcmNlUmVkKHRoaXMpO3ZhciByPWUubXVsKHQpLG49ci5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSksaT1yLmlzdWIobikuaXVzaHJuKHRoaXMuc2hpZnQpLG89aTtyZXR1cm4gMDw9aS5jbXAodGhpcy5tKT9vPWkuaXN1Yih0aGlzLm0pOmkuY21wbigwKTwwJiYobz1pLmlhZGQodGhpcy5tKSksby5fZm9yY2VSZWQodGhpcyl9LE0ucHJvdG90eXBlLmludm09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaW1vZChlLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSkuX2ZvcmNlUmVkKHRoaXMpfX0odm9pZCAwPT09ZXx8ZSx0aGlzKX0se2J1ZmZlcjoxMX1dLDEwOltmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKHIpe3QuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVWludDhBcnJheShlKTtyZXR1cm4oci5jcnlwdG98fHIubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyh0KSx0fX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se31dLDExOltmdW5jdGlvbihlLHQscil7fSx7fV0sMTI6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yO24udmVyc2lvbj1lKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb24sbi51dGlscz1lKFwiLi9lbGxpcHRpYy91dGlsc1wiKSxuLnJhbmQ9ZShcImJyb3JhbmRcIiksbi5jdXJ2ZT1lKFwiLi9lbGxpcHRpYy9jdXJ2ZVwiKSxuLmN1cnZlcz1lKFwiLi9lbGxpcHRpYy9jdXJ2ZXNcIiksbi5lYz1lKFwiLi9lbGxpcHRpYy9lY1wiKSxuLmVkZHNhPWUoXCIuL2VsbGlwdGljL2VkZHNhXCIpfSx7XCIuLi9wYWNrYWdlLmpzb25cIjoyNSxcIi4vZWxsaXB0aWMvY3VydmVcIjoxNSxcIi4vZWxsaXB0aWMvY3VydmVzXCI6MTgsXCIuL2VsbGlwdGljL2VjXCI6MTksXCIuL2VsbGlwdGljL2VkZHNhXCI6MjIsXCIuL2VsbGlwdGljL3V0aWxzXCI6MjQsYnJvcmFuZDoxMH1dLDEzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZShcImJuLmpzXCIpLGk9ZShcIi4uL3V0aWxzXCIpLFM9aS5nZXROQUYsaz1pLmdldEpTRixmPWkuYXNzZXJ0O2Z1bmN0aW9uIG8oZSx0KXt0aGlzLnR5cGU9ZSx0aGlzLnA9bmV3IG4odC5wLDE2KSx0aGlzLnJlZD10LnByaW1lP24ucmVkKHQucHJpbWUpOm4ubW9udCh0aGlzLnApLHRoaXMuemVybz1uZXcgbigwKS50b1JlZCh0aGlzLnJlZCksdGhpcy5vbmU9bmV3IG4oMSkudG9SZWQodGhpcy5yZWQpLHRoaXMudHdvPW5ldyBuKDIpLnRvUmVkKHRoaXMucmVkKSx0aGlzLm49dC5uJiZuZXcgbih0Lm4sMTYpLHRoaXMuZz10LmcmJnRoaXMucG9pbnRGcm9tSlNPTih0LmcsdC5nUmVkKSx0aGlzLl93bmFmVDE9bmV3IEFycmF5KDQpLHRoaXMuX3duYWZUMj1uZXcgQXJyYXkoNCksdGhpcy5fd25hZlQzPW5ldyBBcnJheSg0KSx0aGlzLl93bmFmVDQ9bmV3IEFycmF5KDQpLHRoaXMuX2JpdExlbmd0aD10aGlzLm4/dGhpcy5uLmJpdExlbmd0aCgpOjA7dmFyIHI9dGhpcy5uJiZ0aGlzLnAuZGl2KHRoaXMubik7IXJ8fDA8ci5jbXBuKDEwMCk/dGhpcy5yZWROPW51bGw6KHRoaXMuX21heHdlbGxUcmljaz0hMCx0aGlzLnJlZE49dGhpcy5uLnRvUmVkKHRoaXMucmVkKSl9ZnVuY3Rpb24gcyhlLHQpe3RoaXMuY3VydmU9ZSx0aGlzLnR5cGU9dCx0aGlzLnByZWNvbXB1dGVkPW51bGx9KHQuZXhwb3J0cz1vKS5wcm90b3R5cGUucG9pbnQ9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIil9LG8ucHJvdG90eXBlLnZhbGlkYXRlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpfSxvLnByb3RvdHlwZS5fZml4ZWROYWZNdWw9ZnVuY3Rpb24oZSx0KXtmKGUucHJlY29tcHV0ZWQpO3ZhciByPWUuX2dldERvdWJsZXMoKSxuPVModCwxLHRoaXMuX2JpdExlbmd0aCksaT0oMTw8ci5zdGVwKzEpLShyLnN0ZXAlMj09MD8yOjEpO2kvPTM7Zm9yKHZhciBvPVtdLHM9MDtzPG4ubGVuZ3RoO3MrPXIuc3RlcCl7Zm9yKHZhciBhPTAsdD1zK3Iuc3RlcC0xO3M8PXQ7dC0tKWE9KGE8PDEpK25bdF07by5wdXNoKGEpfWZvcih2YXIgdT10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCksbD10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCksaD1pOzA8aDtoLS0pe2ZvcihzPTA7czxvLmxlbmd0aDtzKyspeyhhPW9bc10pPT09aD9sPWwubWl4ZWRBZGQoci5wb2ludHNbc10pOmE9PT0taCYmKGw9bC5taXhlZEFkZChyLnBvaW50c1tzXS5uZWcoKSkpfXU9dS5hZGQobCl9cmV0dXJuIHUudG9QKCl9LG8ucHJvdG90eXBlLl93bmFmTXVsPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPWUuX2dldE5BRlBvaW50cyg0KSxuPXIud25kLGk9ci5wb2ludHMsbz1TKHQsbix0aGlzLl9iaXRMZW5ndGgpLHM9dGhpcy5qcG9pbnQobnVsbCxudWxsLG51bGwpLGE9by5sZW5ndGgtMTswPD1hO2EtLSl7Zm9yKHQ9MDswPD1hJiYwPT09b1thXTthLS0pdCsrO2lmKDA8PWEmJnQrKyxzPXMuZGJscCh0KSxhPDApYnJlYWs7dmFyIHU9b1thXTtmKDAhPT11KSxzPVwiYWZmaW5lXCI9PT1lLnR5cGU/MDx1P3MubWl4ZWRBZGQoaVt1LTE+PjFdKTpzLm1peGVkQWRkKGlbLXUtMT4+MV0ubmVnKCkpOjA8dT9zLmFkZChpW3UtMT4+MV0pOnMuYWRkKGlbLXUtMT4+MV0ubmVnKCkpfXJldHVyblwiYWZmaW5lXCI9PT1lLnR5cGU/cy50b1AoKTpzfSxvLnByb3RvdHlwZS5fd25hZk11bEFkZD1mdW5jdGlvbihlLHQscixuLGkpe2Zvcih2YXIgbz10aGlzLl93bmFmVDEscz10aGlzLl93bmFmVDIsYT10aGlzLl93bmFmVDMsdT0wLGw9MDtsPG47bCsrKXt2YXIgaD0oQT10W2xdKS5fZ2V0TkFGUG9pbnRzKGUpO29bbF09aC53bmQsc1tsXT1oLnBvaW50c31mb3IobD1uLTE7MTw9bDtsLT0yKXt2YXIgZj1sLTEsYz1sO2lmKDE9PT1vW2ZdJiYxPT09b1tjXSl7dmFyIGQ9W3RbZl0sbnVsbCxudWxsLHRbY11dOzA9PT10W2ZdLnkuY21wKHRbY10ueSk/KGRbMV09dFtmXS5hZGQodFtjXSksZFsyXT10W2ZdLnRvSigpLm1peGVkQWRkKHRbY10ubmVnKCkpKTowPT09dFtmXS55LmNtcCh0W2NdLnkucmVkTmVnKCkpPyhkWzFdPXRbZl0udG9KKCkubWl4ZWRBZGQodFtjXSksZFsyXT10W2ZdLmFkZCh0W2NdLm5lZygpKSk6KGRbMV09dFtmXS50b0ooKS5taXhlZEFkZCh0W2NdKSxkWzJdPXRbZl0udG9KKCkubWl4ZWRBZGQodFtjXS5uZWcoKSkpO3ZhciBwPVstMywtMSwtNSwtNywwLDcsNSwxLDNdLHY9ayhyW2ZdLHJbY10pLHU9TWF0aC5tYXgodlswXS5sZW5ndGgsdSk7YVtmXT1uZXcgQXJyYXkodSksYVtjXT1uZXcgQXJyYXkodSk7Zm9yKHZhciB5PTA7eTx1O3krKyl7dmFyIG09MHx2WzBdW3ldLGc9MHx2WzFdW3ldO2FbZl1beV09cFszKigxK20pKygxK2cpXSxhW2NdW3ldPTAsc1tmXT1kfX1lbHNlIGFbZl09UyhyW2ZdLG9bZl0sdGhpcy5fYml0TGVuZ3RoKSxhW2NdPVMocltjXSxvW2NdLHRoaXMuX2JpdExlbmd0aCksdT1NYXRoLm1heChhW2ZdLmxlbmd0aCx1KSx1PU1hdGgubWF4KGFbY10ubGVuZ3RoLHUpfWZvcih2YXIgYj10aGlzLmpwb2ludChudWxsLG51bGwsbnVsbCksdz10aGlzLl93bmFmVDQsbD11OzA8PWw7bC0tKXtmb3IodmFyIF89MDswPD1sOyl7Zm9yKHZhciBNPSEwLHk9MDt5PG47eSsrKXdbeV09MHxhW3ldW2xdLDAhPT13W3ldJiYoTT0hMSk7aWYoIU0pYnJlYWs7XysrLGwtLX1pZigwPD1sJiZfKyssYj1iLmRibHAoXyksbDwwKWJyZWFrO2Zvcih5PTA7eTxuO3krKyl7dmFyIEEsRT13W3ldOzAhPT1FJiYoMDxFP0E9c1t5XVtFLTE+PjFdOkU8MCYmKEE9c1t5XVstRS0xPj4xXS5uZWcoKSksYj1cImFmZmluZVwiPT09QS50eXBlP2IubWl4ZWRBZGQoQSk6Yi5hZGQoQSkpfX1mb3IobD0wO2w8bjtsKyspc1tsXT1udWxsO3JldHVybiBpP2I6Yi50b1AoKX0sKG8uQmFzZVBvaW50PXMpLnByb3RvdHlwZS5lcT1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKX0scy5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKX0sby5wcm90b3R5cGUuZGVjb2RlUG9pbnQ9ZnVuY3Rpb24oZSx0KXtlPWkudG9BcnJheShlLHQpO3ZhciByPXRoaXMucC5ieXRlTGVuZ3RoKCk7aWYoKDQ9PT1lWzBdfHw2PT09ZVswXXx8Nz09PWVbMF0pJiZlLmxlbmd0aC0xPT0yKnIpcmV0dXJuIDY9PT1lWzBdP2YoZVtlLmxlbmd0aC0xXSUyPT0wKTo3PT09ZVswXSYmZihlW2UubGVuZ3RoLTFdJTI9PTEpLHRoaXMucG9pbnQoZS5zbGljZSgxLDErciksZS5zbGljZSgxK3IsMSsyKnIpKTtpZigoMj09PWVbMF18fDM9PT1lWzBdKSYmZS5sZW5ndGgtMT09PXIpcmV0dXJuIHRoaXMucG9pbnRGcm9tWChlLnNsaWNlKDEsMStyKSwzPT09ZVswXSk7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb2ludCBmb3JtYXRcIil9LHMucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsITApfSxzLnByb3RvdHlwZS5fZW5jb2RlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkscj10aGlzLmdldFgoKS50b0FycmF5KFwiYmVcIix0KTtyZXR1cm4gZT9bdGhpcy5nZXRZKCkuaXNFdmVuKCk/MjozXS5jb25jYXQocik6WzRdLmNvbmNhdChyLHRoaXMuZ2V0WSgpLnRvQXJyYXkoXCJiZVwiLHQpKX0scy5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGkuZW5jb2RlKHRoaXMuX2VuY29kZSh0KSxlKX0scy5wcm90b3R5cGUucHJlY29tcHV0ZT1mdW5jdGlvbihlKXtpZih0aGlzLnByZWNvbXB1dGVkKXJldHVybiB0aGlzO3ZhciB0PXtkb3VibGVzOm51bGwsbmFmOm51bGwsYmV0YTpudWxsfTtyZXR1cm4gdC5uYWY9dGhpcy5fZ2V0TkFGUG9pbnRzKDgpLHQuZG91Ymxlcz10aGlzLl9nZXREb3VibGVzKDQsZSksdC5iZXRhPXRoaXMuX2dldEJldGEoKSx0aGlzLnByZWNvbXB1dGVkPXQsdGhpc30scy5wcm90b3R5cGUuX2hhc0RvdWJsZXM9ZnVuY3Rpb24oZSl7aWYoIXRoaXMucHJlY29tcHV0ZWQpcmV0dXJuITE7dmFyIHQ9dGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO3JldHVybiEhdCYmdC5wb2ludHMubGVuZ3RoPj1NYXRoLmNlaWwoKGUuYml0TGVuZ3RoKCkrMSkvdC5zdGVwKX0scy5wcm90b3R5cGUuX2dldERvdWJsZXM9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLnByZWNvbXB1dGVkJiZ0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcztmb3IodmFyIHI9W3RoaXNdLG49dGhpcyxpPTA7aTx0O2krPWUpe2Zvcih2YXIgbz0wO288ZTtvKyspbj1uLmRibCgpO3IucHVzaChuKX1yZXR1cm57c3RlcDplLHBvaW50czpyfX0scy5wcm90b3R5cGUuX2dldE5BRlBvaW50cz1mdW5jdGlvbihlKXtpZih0aGlzLnByZWNvbXB1dGVkJiZ0aGlzLnByZWNvbXB1dGVkLm5hZilyZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7Zm9yKHZhciB0PVt0aGlzXSxyPSgxPDxlKS0xLG49MT09cj9udWxsOnRoaXMuZGJsKCksaT0xO2k8cjtpKyspdFtpXT10W2ktMV0uYWRkKG4pO3JldHVybnt3bmQ6ZSxwb2ludHM6dH19LHMucHJvdG90eXBlLl9nZXRCZXRhPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LHMucHJvdG90eXBlLmRibHA9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMscj0wO3I8ZTtyKyspdD10LmRibCgpO3JldHVybiB0fX0se1wiLi4vdXRpbHNcIjoyNCxcImJuLmpzXCI6OX1dLDE0OltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXt9fSx7fV0sMTU6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yO24uYmFzZT1lKFwiLi9iYXNlXCIpLG4uc2hvcnQ9ZShcIi4vc2hvcnRcIiksbi5tb250PWUoXCIuL21vbnRcIiksbi5lZHdhcmRzPWUoXCIuL2Vkd2FyZHNcIil9LHtcIi4vYmFzZVwiOjEzLFwiLi9lZHdhcmRzXCI6MTQsXCIuL21vbnRcIjoxNixcIi4vc2hvcnRcIjoxN31dLDE2OltmdW5jdGlvbihlLHQscil7YXJndW1lbnRzWzRdWzE0XVswXS5hcHBseShyLGFyZ3VtZW50cyl9LHtkdXA6MTR9XSwxNzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuLi91dGlsc1wiKSxfPWUoXCJibi5qc1wiKSxpPWUoXCJpbmhlcml0c1wiKSxvPWUoXCIuL2Jhc2VcIikscz1uLmFzc2VydDtmdW5jdGlvbiBhKGUpe28uY2FsbCh0aGlzLFwic2hvcnRcIixlKSx0aGlzLmE9bmV3IF8oZS5hLDE2KS50b1JlZCh0aGlzLnJlZCksdGhpcy5iPW5ldyBfKGUuYiwxNikudG9SZWQodGhpcy5yZWQpLHRoaXMudGludj10aGlzLnR3by5yZWRJbnZtKCksdGhpcy56ZXJvQT0wPT09dGhpcy5hLmZyb21SZWQoKS5jbXBuKDApLHRoaXMudGhyZWVBPTA9PT10aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpLHRoaXMuZW5kbz10aGlzLl9nZXRFbmRvbW9ycGhpc20oZSksdGhpcy5fZW5kb1duYWZUMT1uZXcgQXJyYXkoNCksdGhpcy5fZW5kb1duYWZUMj1uZXcgQXJyYXkoNCl9ZnVuY3Rpb24gdShlLHQscixuKXtvLkJhc2VQb2ludC5jYWxsKHRoaXMsZSxcImFmZmluZVwiKSxudWxsPT09dCYmbnVsbD09PXI/KHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMuaW5mPSEwKToodGhpcy54PW5ldyBfKHQsMTYpLHRoaXMueT1uZXcgXyhyLDE2KSxuJiYodGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKSx0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpKSx0aGlzLngucmVkfHwodGhpcy54PXRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLHRoaXMueS5yZWR8fCh0aGlzLnk9dGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksdGhpcy5pbmY9ITEpfWZ1bmN0aW9uIGwoZSx0LHIsbil7by5CYXNlUG9pbnQuY2FsbCh0aGlzLGUsXCJqYWNvYmlhblwiKSxudWxsPT09dCYmbnVsbD09PXImJm51bGw9PT1uPyh0aGlzLng9dGhpcy5jdXJ2ZS5vbmUsdGhpcy55PXRoaXMuY3VydmUub25lLHRoaXMuej1uZXcgXygwKSk6KHRoaXMueD1uZXcgXyh0LDE2KSx0aGlzLnk9bmV3IF8ociwxNiksdGhpcy56PW5ldyBfKG4sMTYpKSx0aGlzLngucmVkfHwodGhpcy54PXRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCkpLHRoaXMueS5yZWR8fCh0aGlzLnk9dGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKSksdGhpcy56LnJlZHx8KHRoaXMuej10aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpKSx0aGlzLnpPbmU9dGhpcy56PT09dGhpcy5jdXJ2ZS5vbmV9aShhLG8pLCh0LmV4cG9ydHM9YSkucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc209ZnVuY3Rpb24oZSl7dmFyIHQscixuLGk7aWYodGhpcy56ZXJvQSYmdGhpcy5nJiZ0aGlzLm4mJjE9PT10aGlzLnAubW9kbigzKSlyZXR1cm4gbj1lLmJldGE/bmV3IF8oZS5iZXRhLDE2KS50b1JlZCh0aGlzLnJlZCk6KG49KHI9dGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCkpWzBdLmNtcChyWzFdKTwwP3JbMF06clsxXSkudG9SZWQodGhpcy5yZWQpLGUubGFtYmRhP3Q9bmV3IF8oZS5sYW1iZGEsMTYpOihpPXRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pLDA9PT10aGlzLmcubXVsKGlbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChuKSk/dD1pWzBdOih0PWlbMV0scygwPT09dGhpcy5nLm11bCh0KS54LmNtcCh0aGlzLmcueC5yZWRNdWwobikpKSkpLHtiZXRhOm4sbGFtYmRhOnQsYmFzaXM6ZS5iYXNpcz9lLmJhc2lzLm1hcChmdW5jdGlvbihlKXtyZXR1cm57YTpuZXcgXyhlLmEsMTYpLGI6bmV3IF8oZS5iLDE2KX19KTp0aGlzLl9nZXRFbmRvQmFzaXModCl9fSxhLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzPWZ1bmN0aW9uKGUpe3ZhciB0PWU9PT10aGlzLnA/dGhpcy5yZWQ6Xy5tb250KGUpLHI9bmV3IF8oMikudG9SZWQodCkucmVkSW52bSgpLG49ci5yZWROZWcoKSxpPW5ldyBfKDMpLnRvUmVkKHQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwocik7cmV0dXJuW24ucmVkQWRkKGkpLmZyb21SZWQoKSxuLnJlZFN1YihpKS5mcm9tUmVkKCldfSxhLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG4saSxvLHMsYSx1PXRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKS8yKSksbD1lLGg9dGhpcy5uLmNsb25lKCksZj1uZXcgXygxKSxjPW5ldyBfKDApLGQ9bmV3IF8oMCkscD1uZXcgXygxKSx2PTA7MCE9PWwuY21wbigwKTspe3ZhciB5PWguZGl2KGwpLG09aC5zdWIoeS5tdWwobCkpLGc9ZC5zdWIoeS5tdWwoZikpLGI9cC5zdWIoeS5tdWwoYykpO2lmKCFuJiZtLmNtcCh1KTwwKXQ9YS5uZWcoKSxyPWYsbj1tLm5lZygpLGk9ZztlbHNlIGlmKG4mJjI9PSsrdilicmVhaztoPWwsbD1hPW0sZD1mLGY9ZyxwPWMsYz1ifW89bS5uZWcoKSxzPWc7dmFyIHc9bi5zcXIoKS5hZGQoaS5zcXIoKSk7cmV0dXJuIDA8PW8uc3FyKCkuYWRkKHMuc3FyKCkpLmNtcCh3KSYmKG89dCxzPXIpLG4ubmVnYXRpdmUmJihuPW4ubmVnKCksaT1pLm5lZygpKSxvLm5lZ2F0aXZlJiYobz1vLm5lZygpLHM9cy5uZWcoKSksW3thOm4sYjppfSx7YTpvLGI6c31dfSxhLnByb3RvdHlwZS5fZW5kb1NwbGl0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZW5kby5iYXNpcyxyPXRbMF0sbj10WzFdLGk9bi5iLm11bChlKS5kaXZSb3VuZCh0aGlzLm4pLG89ci5iLm5lZygpLm11bChlKS5kaXZSb3VuZCh0aGlzLm4pLHM9aS5tdWwoci5hKSxhPW8ubXVsKG4uYSksdT1pLm11bChyLmIpLGw9by5tdWwobi5iKTtyZXR1cm57azE6ZS5zdWIocykuc3ViKGEpLGsyOnUuYWRkKGwpLm5lZygpfX0sYS5wcm90b3R5cGUucG9pbnRGcm9tWD1mdW5jdGlvbihlLHQpeyhlPW5ldyBfKGUsMTYpKS5yZWR8fChlPWUudG9SZWQodGhpcy5yZWQpKTt2YXIgcj1lLnJlZFNxcigpLnJlZE11bChlKS5yZWRJQWRkKGUucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKSxuPXIucmVkU3FydCgpO2lmKDAhPT1uLnJlZFNxcigpLnJlZFN1YihyKS5jbXAodGhpcy56ZXJvKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvaW50XCIpO3ZhciBpPW4uZnJvbVJlZCgpLmlzT2RkKCk7cmV0dXJuKHQmJiFpfHwhdCYmaSkmJihuPW4ucmVkTmVnKCkpLHRoaXMucG9pbnQoZSxuKX0sYS5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oZSl7aWYoZS5pbmYpcmV0dXJuITA7dmFyIHQ9ZS54LHI9ZS55LG49dGhpcy5hLnJlZE11bCh0KSxpPXQucmVkU3FyKCkucmVkTXVsKHQpLnJlZElBZGQobikucmVkSUFkZCh0aGlzLmIpO3JldHVybiAwPT09ci5yZWRTcXIoKS5yZWRJU3ViKGkpLmNtcG4oMCl9LGEucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZD1mdW5jdGlvbihlLHQscil7Zm9yKHZhciBuPXRoaXMuX2VuZG9XbmFmVDEsaT10aGlzLl9lbmRvV25hZlQyLG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIHM9dGhpcy5fZW5kb1NwbGl0KHRbb10pLGE9ZVtvXSx1PWEuX2dldEJldGEoKTtzLmsxLm5lZ2F0aXZlJiYocy5rMS5pbmVnKCksYT1hLm5lZyghMCkpLHMuazIubmVnYXRpdmUmJihzLmsyLmluZWcoKSx1PXUubmVnKCEwKSksblsyKm9dPWEsblsyKm8rMV09dSxpWzIqb109cy5rMSxpWzIqbysxXT1zLmsyfWZvcih2YXIgbD10aGlzLl93bmFmTXVsQWRkKDEsbixpLDIqbyxyKSxoPTA7aDwyKm87aCsrKW5baF09bnVsbCxpW2hdPW51bGw7cmV0dXJuIGx9LGkodSxvLkJhc2VQb2ludCksYS5wcm90b3R5cGUucG9pbnQ9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBuZXcgdSh0aGlzLGUsdCxyKX0sYS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTj1mdW5jdGlvbihlLHQpe3JldHVybiB1LmZyb21KU09OKHRoaXMsZSx0KX0sdS5wcm90b3R5cGUuX2dldEJldGE9ZnVuY3Rpb24oKXtpZih0aGlzLmN1cnZlLmVuZG8pe3ZhciBlPXRoaXMucHJlY29tcHV0ZWQ7aWYoZSYmZS5iZXRhKXJldHVybiBlLmJldGE7dmFyIHQscixuPXRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksdGhpcy55KTtyZXR1cm4gZSYmKHQ9dGhpcy5jdXJ2ZSxyPWZ1bmN0aW9uKGUpe3JldHVybiB0LnBvaW50KGUueC5yZWRNdWwodC5lbmRvLmJldGEpLGUueSl9LChlLmJldGE9bikucHJlY29tcHV0ZWQ9e2JldGE6bnVsbCxuYWY6ZS5uYWYmJnt3bmQ6ZS5uYWYud25kLHBvaW50czplLm5hZi5wb2ludHMubWFwKHIpfSxkb3VibGVzOmUuZG91YmxlcyYme3N0ZXA6ZS5kb3VibGVzLnN0ZXAscG9pbnRzOmUuZG91Ymxlcy5wb2ludHMubWFwKHIpfX0pLG59fSx1LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVjb21wdXRlZD9bdGhpcy54LHRoaXMueSx0aGlzLnByZWNvbXB1dGVkJiZ7ZG91Ymxlczp0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMmJntzdGVwOnRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLHBvaW50czp0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpfSxuYWY6dGhpcy5wcmVjb21wdXRlZC5uYWYmJnt3bmQ6dGhpcy5wcmVjb21wdXRlZC5uYWYud25kLHBvaW50czp0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSl9fV06W3RoaXMueCx0aGlzLnldfSx1LmZyb21KU09OPWZ1bmN0aW9uKHQsZSxyKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9SlNPTi5wYXJzZShlKSk7dmFyIG49dC5wb2ludChlWzBdLGVbMV0scik7aWYoIWVbMl0pcmV0dXJuIG47ZnVuY3Rpb24gaShlKXtyZXR1cm4gdC5wb2ludChlWzBdLGVbMV0scil9dmFyIG89ZVsyXTtyZXR1cm4gbi5wcmVjb21wdXRlZD17YmV0YTpudWxsLGRvdWJsZXM6by5kb3VibGVzJiZ7c3RlcDpvLmRvdWJsZXMuc3RlcCxwb2ludHM6W25dLmNvbmNhdChvLmRvdWJsZXMucG9pbnRzLm1hcChpKSl9LG5hZjpvLm5hZiYme3duZDpvLm5hZi53bmQscG9pbnRzOltuXS5jb25jYXQoby5uYWYucG9pbnRzLm1hcChpKSl9fSxufSx1LnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpP1wiPEVDIFBvaW50IEluZmluaXR5PlwiOlwiPEVDIFBvaW50IHg6IFwiK3RoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsMikrXCIgeTogXCIrdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwyKStcIj5cIn0sdS5wcm90b3R5cGUuaXNJbmZpbml0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmluZn0sdS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe2lmKHRoaXMuaW5mKXJldHVybiBlO2lmKGUuaW5mKXJldHVybiB0aGlzO2lmKHRoaXMuZXEoZSkpcmV0dXJuIHRoaXMuZGJsKCk7aWYodGhpcy5uZWcoKS5lcShlKSlyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLG51bGwpO2lmKDA9PT10aGlzLnguY21wKGUueCkpcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCxudWxsKTt2YXIgdD10aGlzLnkucmVkU3ViKGUueSk7MCE9PXQuY21wbigwKSYmKHQ9dC5yZWRNdWwodGhpcy54LnJlZFN1YihlLngpLnJlZEludm0oKSkpO3ZhciByPXQucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIoZS54KSxuPXQucmVkTXVsKHRoaXMueC5yZWRTdWIocikpLnJlZElTdWIodGhpcy55KTtyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChyLG4pfSx1LnByb3RvdHlwZS5kYmw9ZnVuY3Rpb24oKXtpZih0aGlzLmluZilyZXR1cm4gdGhpczt2YXIgZT10aGlzLnkucmVkQWRkKHRoaXMueSk7aWYoMD09PWUuY21wbigwKSlyZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLG51bGwpO3ZhciB0PXRoaXMuY3VydmUuYSxyPXRoaXMueC5yZWRTcXIoKSxuPWUucmVkSW52bSgpLGk9ci5yZWRBZGQocikucmVkSUFkZChyKS5yZWRJQWRkKHQpLnJlZE11bChuKSxvPWkucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpLHM9aS5yZWRNdWwodGhpcy54LnJlZFN1YihvKSkucmVkSVN1Yih0aGlzLnkpO3JldHVybiB0aGlzLmN1cnZlLnBvaW50KG8scyl9LHUucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54LmZyb21SZWQoKX0sdS5wcm90b3R5cGUuZ2V0WT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnkuZnJvbVJlZCgpfSx1LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9bmV3IF8oZSwxNiksdGhpcy5pc0luZmluaXR5KCk/dGhpczp0aGlzLl9oYXNEb3VibGVzKGUpP3RoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsZSk6dGhpcy5jdXJ2ZS5lbmRvP3RoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFt0aGlzXSxbZV0pOnRoaXMuY3VydmUuX3duYWZNdWwodGhpcyxlKX0sdS5wcm90b3R5cGUubXVsQWRkPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1bdGhpcyx0XSxpPVtlLHJdO3JldHVybiB0aGlzLmN1cnZlLmVuZG8/dGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQobixpKTp0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsbixpLDIpfSx1LnByb3RvdHlwZS5qbXVsQWRkPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1bdGhpcyx0XSxpPVtlLHJdO3JldHVybiB0aGlzLmN1cnZlLmVuZG8/dGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQobixpLCEwKTp0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsbixpLDIsITApfSx1LnByb3RvdHlwZS5lcT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcz09PWV8fHRoaXMuaW5mPT09ZS5pbmYmJih0aGlzLmluZnx8MD09PXRoaXMueC5jbXAoZS54KSYmMD09PXRoaXMueS5jbXAoZS55KSl9LHUucHJvdG90eXBlLm5lZz1mdW5jdGlvbihlKXtpZih0aGlzLmluZilyZXR1cm4gdGhpczt2YXIgdCxyLG49dGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsdGhpcy55LnJlZE5lZygpKTtyZXR1cm4gZSYmdGhpcy5wcmVjb21wdXRlZCYmKHQ9dGhpcy5wcmVjb21wdXRlZCxyPWZ1bmN0aW9uKGUpe3JldHVybiBlLm5lZygpfSxuLnByZWNvbXB1dGVkPXtuYWY6dC5uYWYmJnt3bmQ6dC5uYWYud25kLHBvaW50czp0Lm5hZi5wb2ludHMubWFwKHIpfSxkb3VibGVzOnQuZG91YmxlcyYme3N0ZXA6dC5kb3VibGVzLnN0ZXAscG9pbnRzOnQuZG91Ymxlcy5wb2ludHMubWFwKHIpfX0pLG59LHUucHJvdG90eXBlLnRvSj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmluZj90aGlzLmN1cnZlLmpwb2ludChudWxsLG51bGwsbnVsbCk6dGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LHRoaXMueSx0aGlzLmN1cnZlLm9uZSl9LGkobCxvLkJhc2VQb2ludCksYS5wcm90b3R5cGUuanBvaW50PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbmV3IGwodGhpcyxlLHQscil9LGwucHJvdG90eXBlLnRvUD1mdW5jdGlvbigpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsbnVsbCk7dmFyIGU9dGhpcy56LnJlZEludm0oKSx0PWUucmVkU3FyKCkscj10aGlzLngucmVkTXVsKHQpLG49dGhpcy55LnJlZE11bCh0KS5yZWRNdWwoZSk7cmV0dXJuIHRoaXMuY3VydmUucG9pbnQocixuKX0sbC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCx0aGlzLnkucmVkTmVnKCksdGhpcy56KX0sbC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNJbmZpbml0eSgpKXJldHVybiBlO2lmKGUuaXNJbmZpbml0eSgpKXJldHVybiB0aGlzO3ZhciB0PWUuei5yZWRTcXIoKSxyPXRoaXMuei5yZWRTcXIoKSxuPXRoaXMueC5yZWRNdWwodCksaT1lLngucmVkTXVsKHIpLG89dGhpcy55LnJlZE11bCh0LnJlZE11bChlLnopKSxzPWUueS5yZWRNdWwoci5yZWRNdWwodGhpcy56KSksYT1uLnJlZFN1YihpKSx1PW8ucmVkU3ViKHMpO2lmKDA9PT1hLmNtcG4oMCkpcmV0dXJuIDAhPT11LmNtcG4oMCk/dGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCxudWxsLG51bGwpOnRoaXMuZGJsKCk7dmFyIGw9YS5yZWRTcXIoKSxoPWwucmVkTXVsKGEpLGY9bi5yZWRNdWwobCksYz11LnJlZFNxcigpLnJlZElBZGQoaCkucmVkSVN1YihmKS5yZWRJU3ViKGYpLGQ9dS5yZWRNdWwoZi5yZWRJU3ViKGMpKS5yZWRJU3ViKG8ucmVkTXVsKGgpKSxwPXRoaXMuei5yZWRNdWwoZS56KS5yZWRNdWwoYSk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGMsZCxwKX0sbC5wcm90b3R5cGUubWl4ZWRBZGQ9ZnVuY3Rpb24oZSl7aWYodGhpcy5pc0luZmluaXR5KCkpcmV0dXJuIGUudG9KKCk7aWYoZS5pc0luZmluaXR5KCkpcmV0dXJuIHRoaXM7dmFyIHQ9dGhpcy56LnJlZFNxcigpLHI9dGhpcy54LG49ZS54LnJlZE11bCh0KSxpPXRoaXMueSxvPWUueS5yZWRNdWwodCkucmVkTXVsKHRoaXMueikscz1yLnJlZFN1YihuKSxhPWkucmVkU3ViKG8pO2lmKDA9PT1zLmNtcG4oMCkpcmV0dXJuIDAhPT1hLmNtcG4oMCk/dGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCxudWxsLG51bGwpOnRoaXMuZGJsKCk7dmFyIHU9cy5yZWRTcXIoKSxsPXUucmVkTXVsKHMpLGg9ci5yZWRNdWwodSksZj1hLnJlZFNxcigpLnJlZElBZGQobCkucmVkSVN1YihoKS5yZWRJU3ViKGgpLGM9YS5yZWRNdWwoaC5yZWRJU3ViKGYpKS5yZWRJU3ViKGkucmVkTXVsKGwpKSxkPXRoaXMuei5yZWRNdWwocyk7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGYsYyxkKX0sbC5wcm90b3R5cGUuZGJscD1mdW5jdGlvbihlKXtpZigwPT09ZSlyZXR1cm4gdGhpcztpZih0aGlzLmlzSW5maW5pdHkoKSlyZXR1cm4gdGhpcztpZighZSlyZXR1cm4gdGhpcy5kYmwoKTtpZih0aGlzLmN1cnZlLnplcm9BfHx0aGlzLmN1cnZlLnRocmVlQSl7Zm9yKHZhciB0PXRoaXMscj0wO3I8ZTtyKyspdD10LmRibCgpO3JldHVybiB0fWZvcih2YXIgbj10aGlzLmN1cnZlLmEsaT10aGlzLmN1cnZlLnRpbnYsbz10aGlzLngscz10aGlzLnksYT10aGlzLnosdT1hLnJlZFNxcigpLnJlZFNxcigpLGw9cy5yZWRBZGQocykscj0wO3I8ZTtyKyspe3ZhciBoPW8ucmVkU3FyKCksZj1sLnJlZFNxcigpLGM9Zi5yZWRTcXIoKSxkPWgucmVkQWRkKGgpLnJlZElBZGQoaCkucmVkSUFkZChuLnJlZE11bCh1KSkscD1vLnJlZE11bChmKSx2PWQucmVkU3FyKCkucmVkSVN1YihwLnJlZEFkZChwKSkseT1wLnJlZElTdWIodiksbT0obT1kLnJlZE11bCh5KSkucmVkSUFkZChtKS5yZWRJU3ViKGMpLGc9bC5yZWRNdWwoYSk7cisxPGUmJih1PXUucmVkTXVsKGMpKSxvPXYsYT1nLGw9bX1yZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobyxsLnJlZE11bChpKSxhKX0sbC5wcm90b3R5cGUuZGJsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpP3RoaXM6dGhpcy5jdXJ2ZS56ZXJvQT90aGlzLl96ZXJvRGJsKCk6dGhpcy5jdXJ2ZS50aHJlZUE/dGhpcy5fdGhyZWVEYmwoKTp0aGlzLl9kYmwoKX0sbC5wcm90b3R5cGUuX3plcm9EYmw9ZnVuY3Rpb24oKXt2YXIgZSx0LHIsbixpLG8scyxhLHUsbCxoLGYsYyxkLHAsdix5PXRoaXMuek9uZT8ocj10aGlzLngucmVkU3FyKCksaT0obj10aGlzLnkucmVkU3FyKCkpLnJlZFNxcigpLG89KG89dGhpcy54LnJlZEFkZChuKS5yZWRTcXIoKS5yZWRJU3ViKHIpLnJlZElTdWIoaSkpLnJlZElBZGQobyksYT0ocz1yLnJlZEFkZChyKS5yZWRJQWRkKHIpKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIobyksdT0odT0odT1pLnJlZElBZGQoaSkpLnJlZElBZGQodSkpLnJlZElBZGQodSksZT1hLHQ9cy5yZWRNdWwoby5yZWRJU3ViKGEpKS5yZWRJU3ViKHUpLHRoaXMueS5yZWRBZGQodGhpcy55KSk6KGw9dGhpcy54LnJlZFNxcigpLGY9KGg9dGhpcy55LnJlZFNxcigpKS5yZWRTcXIoKSxjPShjPXRoaXMueC5yZWRBZGQoaCkucmVkU3FyKCkucmVkSVN1YihsKS5yZWRJU3ViKGYpKS5yZWRJQWRkKGMpLHA9KGQ9bC5yZWRBZGQobCkucmVkSUFkZChsKSkucmVkU3FyKCksdj0odj0odj1mLnJlZElBZGQoZikpLnJlZElBZGQodikpLnJlZElBZGQodiksZT1wLnJlZElTdWIoYykucmVkSVN1YihjKSx0PWQucmVkTXVsKGMucmVkSVN1YihlKSkucmVkSVN1Yih2KSwoeT10aGlzLnkucmVkTXVsKHRoaXMueikpLnJlZElBZGQoeSkpO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChlLHQseSl9LGwucHJvdG90eXBlLl90aHJlZURibD1mdW5jdGlvbigpe3ZhciBlLHQscixuLGksbyxzLGEsdSxsLGgsZixjLGQscCx2LHk7cmV0dXJuIHRoaXMuek9uZT8ocj10aGlzLngucmVkU3FyKCksaT0obj10aGlzLnkucmVkU3FyKCkpLnJlZFNxcigpLG89KG89dGhpcy54LnJlZEFkZChuKS5yZWRTcXIoKS5yZWRJU3ViKHIpLnJlZElTdWIoaSkpLnJlZElBZGQobyksdT1hPShzPXIucmVkQWRkKHIpLnJlZElBZGQocikucmVkSUFkZCh0aGlzLmN1cnZlLmEpKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIobyksbD0obD0obD1pLnJlZElBZGQoaSkpLnJlZElBZGQobCkpLnJlZElBZGQobCksZT1zLnJlZE11bChvLnJlZElTdWIoYSkpLnJlZElTdWIobCksdD10aGlzLnkucmVkQWRkKHRoaXMueSkpOihoPXRoaXMuei5yZWRTcXIoKSxmPXRoaXMueS5yZWRTcXIoKSxjPXRoaXMueC5yZWRNdWwoZiksZD0oZD10aGlzLngucmVkU3ViKGgpLnJlZE11bCh0aGlzLngucmVkQWRkKGgpKSkucmVkQWRkKGQpLnJlZElBZGQoZCksdj0ocD0ocD1jLnJlZElBZGQoYykpLnJlZElBZGQocCkpLnJlZEFkZChwKSx1PWQucmVkU3FyKCkucmVkSVN1Yih2KSx0PXRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGYpLnJlZElTdWIoaCkseT0oeT0oeT0oeT1mLnJlZFNxcigpKS5yZWRJQWRkKHkpKS5yZWRJQWRkKHkpKS5yZWRJQWRkKHkpLGU9ZC5yZWRNdWwocC5yZWRJU3ViKHUpKS5yZWRJU3ViKHkpKSx0aGlzLmN1cnZlLmpwb2ludCh1LGUsdCl9LGwucHJvdG90eXBlLl9kYmw9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmN1cnZlLmEsdD10aGlzLngscj10aGlzLnksbj10aGlzLnosaT1uLnJlZFNxcigpLnJlZFNxcigpLG89dC5yZWRTcXIoKSxzPXIucmVkU3FyKCksYT1vLnJlZEFkZChvKS5yZWRJQWRkKG8pLnJlZElBZGQoZS5yZWRNdWwoaSkpLHU9dC5yZWRBZGQodCksbD0odT11LnJlZElBZGQodSkpLnJlZE11bChzKSxoPWEucmVkU3FyKCkucmVkSVN1YihsLnJlZEFkZChsKSksZj1sLnJlZElTdWIoaCksYz1zLnJlZFNxcigpO2M9KGM9KGM9Yy5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpO3ZhciBkPWEucmVkTXVsKGYpLnJlZElTdWIoYykscD1yLnJlZEFkZChyKS5yZWRNdWwobik7cmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGgsZCxwKX0sbC5wcm90b3R5cGUudHJwbD1mdW5jdGlvbigpe2lmKCF0aGlzLmN1cnZlLnplcm9BKXJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTt2YXIgZT10aGlzLngucmVkU3FyKCksdD10aGlzLnkucmVkU3FyKCkscj10aGlzLnoucmVkU3FyKCksbj10LnJlZFNxcigpLGk9ZS5yZWRBZGQoZSkucmVkSUFkZChlKSxvPWkucmVkU3FyKCkscz10aGlzLngucmVkQWRkKHQpLnJlZFNxcigpLnJlZElTdWIoZSkucmVkSVN1YihuKSxhPShzPShzPShzPXMucmVkSUFkZChzKSkucmVkQWRkKHMpLnJlZElBZGQocykpLnJlZElTdWIobykpLnJlZFNxcigpLHU9bi5yZWRJQWRkKG4pO3U9KHU9KHU9dS5yZWRJQWRkKHUpKS5yZWRJQWRkKHUpKS5yZWRJQWRkKHUpO3ZhciBsPWkucmVkSUFkZChzKS5yZWRTcXIoKS5yZWRJU3ViKG8pLnJlZElTdWIoYSkucmVkSVN1Yih1KSxoPXQucmVkTXVsKGwpO2g9KGg9aC5yZWRJQWRkKGgpKS5yZWRJQWRkKGgpO3ZhciBmPXRoaXMueC5yZWRNdWwoYSkucmVkSVN1YihoKTtmPShmPWYucmVkSUFkZChmKSkucmVkSUFkZChmKTt2YXIgYz10aGlzLnkucmVkTXVsKGwucmVkTXVsKHUucmVkSVN1YihsKSkucmVkSVN1YihzLnJlZE11bChhKSkpO2M9KGM9KGM9Yy5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpKS5yZWRJQWRkKGMpO3ZhciBkPXRoaXMuei5yZWRBZGQocykucmVkU3FyKCkucmVkSVN1YihyKS5yZWRJU3ViKGEpO3JldHVybiB0aGlzLmN1cnZlLmpwb2ludChmLGMsZCl9LGwucHJvdG90eXBlLm11bD1mdW5jdGlvbihlLHQpe3JldHVybiBlPW5ldyBfKGUsdCksdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLGUpfSxsLnByb3RvdHlwZS5lcT1mdW5jdGlvbihlKXtpZihcImFmZmluZVwiPT09ZS50eXBlKXJldHVybiB0aGlzLmVxKGUudG9KKCkpO2lmKHRoaXM9PT1lKXJldHVybiEwO3ZhciB0PXRoaXMuei5yZWRTcXIoKSxyPWUuei5yZWRTcXIoKTtpZigwIT09dGhpcy54LnJlZE11bChyKS5yZWRJU3ViKGUueC5yZWRNdWwodCkpLmNtcG4oMCkpcmV0dXJuITE7dmFyIG49dC5yZWRNdWwodGhpcy56KSxpPXIucmVkTXVsKGUueik7cmV0dXJuIDA9PT10aGlzLnkucmVkTXVsKGkpLnJlZElTdWIoZS55LnJlZE11bChuKSkuY21wbigwKX0sbC5wcm90b3R5cGUuZXFYVG9QPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuei5yZWRTcXIoKSxyPWUudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh0KTtpZigwPT09dGhpcy54LmNtcChyKSlyZXR1cm4hMDtmb3IodmFyIG49ZS5jbG9uZSgpLGk9dGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0KTs7KXtpZihuLmlhZGQodGhpcy5jdXJ2ZS5uKSwwPD1uLmNtcCh0aGlzLmN1cnZlLnApKXJldHVybiExO2lmKHIucmVkSUFkZChpKSwwPT09dGhpcy54LmNtcChyKSlyZXR1cm4hMH19LGwucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0luZmluaXR5KCk/XCI8RUMgSlBvaW50IEluZmluaXR5PlwiOlwiPEVDIEpQb2ludCB4OiBcIit0aGlzLngudG9TdHJpbmcoMTYsMikrXCIgeTogXCIrdGhpcy55LnRvU3RyaW5nKDE2LDIpK1wiIHo6IFwiK3RoaXMuei50b1N0cmluZygxNiwyKStcIj5cIn0sbC5wcm90b3R5cGUuaXNJbmZpbml0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy56LmNtcG4oMCl9fSx7XCIuLi91dGlsc1wiOjI0LFwiLi9iYXNlXCI6MTMsXCJibi5qc1wiOjksaW5oZXJpdHM6Mzl9XSwxODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9cixvPWUoXCJoYXNoLmpzXCIpLHM9ZShcIi4vY3VydmVcIiksYT1lKFwiLi91dGlsc1wiKS5hc3NlcnQ7ZnVuY3Rpb24gdShlKXtcInNob3J0XCI9PT1lLnR5cGU/dGhpcy5jdXJ2ZT1uZXcgcy5zaG9ydChlKTpcImVkd2FyZHNcIj09PWUudHlwZT90aGlzLmN1cnZlPW5ldyBzLmVkd2FyZHMoZSk6dGhpcy5jdXJ2ZT1uZXcgcy5tb250KGUpLHRoaXMuZz10aGlzLmN1cnZlLmcsdGhpcy5uPXRoaXMuY3VydmUubix0aGlzLmhhc2g9ZS5oYXNoLGEodGhpcy5nLnZhbGlkYXRlKCksXCJJbnZhbGlkIGN1cnZlXCIpLGEodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSxcIkludmFsaWQgY3VydmUsIEcqTiAhPSBPXCIpfWZ1bmN0aW9uIGwodCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoaSx0LHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXt2YXIgZT1uZXcgdShyKTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGksdCx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6ZX0pLGV9fSl9aS5QcmVzZXRDdXJ2ZT11LGwoXCJwMTkyXCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwicDE5MlwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCI2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMVwiLG46XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMVwiLGhhc2g6by5zaGEyNTYsZ1JlZDohMSxnOltcIjE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyXCIsXCIwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMVwiXX0pLGwoXCJwMjI0XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwicDIyNFwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiLGE6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZVwiLGI6XCJiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNFwiLG46XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZFwiLGhhc2g6by5zaGEyNTYsZ1JlZDohMSxnOltcImI3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxXCIsXCJiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNFwiXX0pLGwoXCJwMjU2XCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOm51bGwscDpcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmXCIsYTpcImZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjXCIsYjpcIjVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiXCIsbjpcImZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxXCIsaGFzaDpvLnNoYTI1NixnUmVkOiExLGc6W1wiNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTZcIixcIjRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1XCJdfSksbChcInAzODRcIix7dHlwZTpcInNob3J0XCIscHJpbWU6bnVsbCxwOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmZcIixhOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmNcIixiOlwiYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWZcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzNcIixoYXNoOm8uc2hhMzg0LGdSZWQ6ITEsZzpbXCJhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCA1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiN1wiLFwiMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWZcIl19KSxsKFwicDUyMVwiLHt0eXBlOlwic2hvcnRcIixwcmltZTpudWxsLHA6XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZlwiLGE6XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmY1wiLGI6XCIwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiA5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAzYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMFwiLG46XCIwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCBmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOVwiLGhhc2g6by5zaGE1MTIsZ1JlZDohMSxnOltcIjAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5IDA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3IGEyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2XCIsXCIwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSA1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAzZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MFwiXX0pLGwoXCJjdXJ2ZTI1NTE5XCIse3R5cGU6XCJtb250XCIscHJpbWU6XCJwMjU1MTlcIixwOlwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiLGE6XCI3NmQwNlwiLGI6XCIxXCIsbjpcIjEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWRcIixoYXNoOm8uc2hhMjU2LGdSZWQ6ITEsZzpbXCI5XCJdfSksbChcImVkMjU1MTlcIix7dHlwZTpcImVkd2FyZHNcIixwcmltZTpcInAyNTUxOVwiLHA6XCI3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkXCIsYTpcIi0xXCIsYzpcIjFcIixkOlwiNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhM1wiLG46XCIxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkXCIsaGFzaDpvLnNoYTI1NixnUmVkOiExLGc6W1wiMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYVwiLFwiNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OFwiXX0pO3RyeXtuPWUoXCIuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMVwiKX1jYXRjaChlKXtuPXZvaWQgMH1sKFwic2VjcDI1NmsxXCIse3R5cGU6XCJzaG9ydFwiLHByaW1lOlwiazI1NlwiLHA6XCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZlwiLGE6XCIwXCIsYjpcIjdcIixuOlwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDFcIixoOlwiMVwiLGhhc2g6by5zaGEyNTYsYmV0YTpcIjdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWVcIixsYW1iZGE6XCI1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyXCIsYmFzaXM6W3thOlwiMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIixiOlwiLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCJ9LHthOlwiMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIsYjpcIjMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCJ9XSxnUmVkOiExLGc6W1wiNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OFwiLFwiNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiLG5dfSl9LHtcIi4vY3VydmVcIjoxNSxcIi4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxXCI6MjMsXCIuL3V0aWxzXCI6MjQsXCJoYXNoLmpzXCI6MjZ9XSwxOTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciB5PWUoXCJibi5qc1wiKSxtPWUoXCJobWFjLWRyYmdcIiksbj1lKFwiLi4vdXRpbHNcIiksaT1lKFwiLi4vY3VydmVzXCIpLG89ZShcImJyb3JhbmRcIiksZD1uLmFzc2VydCxzPWUoXCIuL2tleVwiKSxnPWUoXCIuL3NpZ25hdHVyZVwiKTtmdW5jdGlvbiBhKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGEpKXJldHVybiBuZXcgYShlKTtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGQoaS5oYXNPd25Qcm9wZXJ0eShlKSxcIlVua25vd24gY3VydmUgXCIrZSksZT1pW2VdKSxlIGluc3RhbmNlb2YgaS5QcmVzZXRDdXJ2ZSYmKGU9e2N1cnZlOmV9KSx0aGlzLmN1cnZlPWUuY3VydmUuY3VydmUsdGhpcy5uPXRoaXMuY3VydmUubix0aGlzLm5oPXRoaXMubi51c2hybigxKSx0aGlzLmc9dGhpcy5jdXJ2ZS5nLHRoaXMuZz1lLmN1cnZlLmcsdGhpcy5nLnByZWNvbXB1dGUoZS5jdXJ2ZS5uLmJpdExlbmd0aCgpKzEpLHRoaXMuaGFzaD1lLmhhc2h8fGUuY3VydmUuaGFzaH0odC5leHBvcnRzPWEpLnByb3RvdHlwZS5rZXlQYWlyPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcyh0aGlzLGUpfSxhLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZT1mdW5jdGlvbihlLHQpe3JldHVybiBzLmZyb21Qcml2YXRlKHRoaXMsZSx0KX0sYS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYz1mdW5jdGlvbihlLHQpe3JldHVybiBzLmZyb21QdWJsaWModGhpcyxlLHQpfSxhLnByb3RvdHlwZS5nZW5LZXlQYWlyPWZ1bmN0aW9uKGUpe2U9ZXx8e307Zm9yKHZhciB0PW5ldyBtKHtoYXNoOnRoaXMuaGFzaCxwZXJzOmUucGVycyxwZXJzRW5jOmUucGVyc0VuY3x8XCJ1dGY4XCIsZW50cm9weTplLmVudHJvcHl8fG8odGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksZW50cm9weUVuYzplLmVudHJvcHkmJmUuZW50cm9weUVuY3x8XCJ1dGY4XCIsbm9uY2U6dGhpcy5uLnRvQXJyYXkoKX0pLHI9dGhpcy5uLmJ5dGVMZW5ndGgoKSxuPXRoaXMubi5zdWIobmV3IHkoMikpOzspe3ZhciBpPW5ldyB5KHQuZ2VuZXJhdGUocikpO2lmKCEoMDxpLmNtcChuKSkpcmV0dXJuIGkuaWFkZG4oMSksdGhpcy5rZXlGcm9tUHJpdmF0ZShpKX19LGEucHJvdG90eXBlLl90cnVuY2F0ZVRvTj1mdW5jdGlvbihlLHQpe3ZhciByPTgqZS5ieXRlTGVuZ3RoKCktdGhpcy5uLmJpdExlbmd0aCgpO3JldHVybiAwPHImJihlPWUudXNocm4ocikpLCF0JiYwPD1lLmNtcCh0aGlzLm4pP2Uuc3ViKHRoaXMubik6ZX0sYS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlLHQscixuKXtcIm9iamVjdFwiPT10eXBlb2YgciYmKG49cixyPW51bGwpLG49bnx8e30sdD10aGlzLmtleUZyb21Qcml2YXRlKHQsciksZT10aGlzLl90cnVuY2F0ZVRvTihuZXcgeShlLDE2KSk7Zm9yKHZhciBpPXRoaXMubi5ieXRlTGVuZ3RoKCksbz10LmdldFByaXZhdGUoKS50b0FycmF5KFwiYmVcIixpKSxzPWUudG9BcnJheShcImJlXCIsaSksYT1uZXcgbSh7aGFzaDp0aGlzLmhhc2gsZW50cm9weTpvLG5vbmNlOnMscGVyczpuLnBlcnMscGVyc0VuYzpuLnBlcnNFbmN8fFwidXRmOFwifSksdT10aGlzLm4uc3ViKG5ldyB5KDEpKSxsPTA7O2wrKyl7dmFyIGg9bi5rP24uayhsKTpuZXcgeShhLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtpZighKChoPXRoaXMuX3RydW5jYXRlVG9OKGgsITApKS5jbXBuKDEpPD0wfHwwPD1oLmNtcCh1KSkpe3ZhciBmPXRoaXMuZy5tdWwoaCk7aWYoIWYuaXNJbmZpbml0eSgpKXt2YXIgYz1mLmdldFgoKSxkPWMudW1vZCh0aGlzLm4pO2lmKDAhPT1kLmNtcG4oMCkpe3ZhciBwPWguaW52bSh0aGlzLm4pLm11bChkLm11bCh0LmdldFByaXZhdGUoKSkuaWFkZChlKSk7aWYoMCE9PShwPXAudW1vZCh0aGlzLm4pKS5jbXBuKDApKXt2YXIgdj0oZi5nZXRZKCkuaXNPZGQoKT8xOjApfCgwIT09Yy5jbXAoZCk/MjowKTtyZXR1cm4gbi5jYW5vbmljYWwmJjA8cC5jbXAodGhpcy5uaCkmJihwPXRoaXMubi5zdWIocCksdl49MSksbmV3IGcoe3I6ZCxzOnAscmVjb3ZlcnlQYXJhbTp2fSl9fX19fX0sYS5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uKGUsdCxyLG4pe2U9dGhpcy5fdHJ1bmNhdGVUb04obmV3IHkoZSwxNikpLHI9dGhpcy5rZXlGcm9tUHVibGljKHIsbik7dmFyIGk9KHQ9bmV3IGcodCxcImhleFwiKSkucixvPXQucztpZihpLmNtcG4oMSk8MHx8MDw9aS5jbXAodGhpcy5uKSlyZXR1cm4hMTtpZihvLmNtcG4oMSk8MHx8MDw9by5jbXAodGhpcy5uKSlyZXR1cm4hMTt2YXIgcyxhPW8uaW52bSh0aGlzLm4pLHU9YS5tdWwoZSkudW1vZCh0aGlzLm4pLGw9YS5tdWwoaSkudW1vZCh0aGlzLm4pO3JldHVybiB0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2s/IShzPXRoaXMuZy5qbXVsQWRkKHUsci5nZXRQdWJsaWMoKSxsKSkuaXNJbmZpbml0eSgpJiZzLmVxWFRvUChpKTohKHM9dGhpcy5nLm11bEFkZCh1LHIuZ2V0UHVibGljKCksbCkpLmlzSW5maW5pdHkoKSYmMD09PXMuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAoaSl9LGEucHJvdG90eXBlLnJlY292ZXJQdWJLZXk9ZnVuY3Rpb24oZSx0LHIsbil7ZCgoMyZyKT09PXIsXCJUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzXCIpLHQ9bmV3IGcodCxuKTt2YXIgaT10aGlzLm4sbz1uZXcgeShlKSxzPXQucixhPXQucyx1PTEmcixsPXI+PjE7aWYoMDw9cy5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkmJmwpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlXCIpO3M9bD90aGlzLmN1cnZlLnBvaW50RnJvbVgocy5hZGQodGhpcy5jdXJ2ZS5uKSx1KTp0aGlzLmN1cnZlLnBvaW50RnJvbVgocyx1KTt2YXIgaD10LnIuaW52bShpKSxmPWkuc3ViKG8pLm11bChoKS51bW9kKGkpLGM9YS5tdWwoaCkudW1vZChpKTtyZXR1cm4gdGhpcy5nLm11bEFkZChmLHMsYyl9LGEucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW09ZnVuY3Rpb24oZSx0LHIsbil7aWYobnVsbCE9PSh0PW5ldyBnKHQsbikpLnJlY292ZXJ5UGFyYW0pcmV0dXJuIHQucmVjb3ZlcnlQYXJhbTtmb3IodmFyIGksbz0wO288NDtvKyspe3RyeXtpPXRoaXMucmVjb3ZlclB1YktleShlLHQsbyl9Y2F0Y2goZSl7Y29udGludWV9aWYoaS5lcShyKSlyZXR1cm4gb310aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3JcIil9fSx7XCIuLi9jdXJ2ZXNcIjoxOCxcIi4uL3V0aWxzXCI6MjQsXCIuL2tleVwiOjIwLFwiLi9zaWduYXR1cmVcIjoyMSxcImJuLmpzXCI6OSxicm9yYW5kOjEwLFwiaG1hYy1kcmJnXCI6Mzh9XSwyMDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCJibi5qc1wiKSxpPWUoXCIuLi91dGlsc1wiKS5hc3NlcnQ7ZnVuY3Rpb24gbyhlLHQpe3RoaXMuZWM9ZSx0aGlzLnByaXY9bnVsbCx0aGlzLnB1Yj1udWxsLHQucHJpdiYmdGhpcy5faW1wb3J0UHJpdmF0ZSh0LnByaXYsdC5wcml2RW5jKSx0LnB1YiYmdGhpcy5faW1wb3J0UHVibGljKHQucHViLHQucHViRW5jKX0odC5leHBvcnRzPW8pLmZyb21QdWJsaWM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0IGluc3RhbmNlb2Ygbz90Om5ldyBvKGUse3B1Yjp0LHB1YkVuYzpyfSl9LG8uZnJvbVByaXZhdGU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0IGluc3RhbmNlb2Ygbz90Om5ldyBvKGUse3ByaXY6dCxwcml2RW5jOnJ9KX0sby5wcm90b3R5cGUudmFsaWRhdGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldFB1YmxpYygpO3JldHVybiBlLmlzSW5maW5pdHkoKT97cmVzdWx0OiExLHJlYXNvbjpcIkludmFsaWQgcHVibGljIGtleVwifTplLnZhbGlkYXRlKCk/ZS5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCk/e3Jlc3VsdDohMCxyZWFzb246bnVsbH06e3Jlc3VsdDohMSxyZWFzb246XCJQdWJsaWMga2V5ICogTiAhPSBPXCJ9OntyZXN1bHQ6ITEscmVhc29uOlwiUHVibGljIGtleSBpcyBub3QgYSBwb2ludFwifX0sby5wcm90b3R5cGUuZ2V0UHVibGljPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUmJih0PWUsZT1udWxsKSx0aGlzLnB1Ynx8KHRoaXMucHViPXRoaXMuZWMuZy5tdWwodGhpcy5wcml2KSksdD90aGlzLnB1Yi5lbmNvZGUodCxlKTp0aGlzLnB1Yn0sby5wcm90b3R5cGUuZ2V0UHJpdmF0ZT1mdW5jdGlvbihlKXtyZXR1cm5cImhleFwiPT09ZT90aGlzLnByaXYudG9TdHJpbmcoMTYsMik6dGhpcy5wcml2fSxvLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZT1mdW5jdGlvbihlLHQpe3RoaXMucHJpdj1uZXcgbihlLHR8fDE2KSx0aGlzLnByaXY9dGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKX0sby5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYz1mdW5jdGlvbihlLHQpe2lmKGUueHx8ZS55KXJldHVyblwibW9udFwiPT09dGhpcy5lYy5jdXJ2ZS50eXBlP2koZS54LFwiTmVlZCB4IGNvb3JkaW5hdGVcIik6XCJzaG9ydFwiIT09dGhpcy5lYy5jdXJ2ZS50eXBlJiZcImVkd2FyZHNcIiE9PXRoaXMuZWMuY3VydmUudHlwZXx8aShlLngmJmUueSxcIk5lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGVcIiksdm9pZCh0aGlzLnB1Yj10aGlzLmVjLmN1cnZlLnBvaW50KGUueCxlLnkpKTt0aGlzLnB1Yj10aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGUsdCl9LG8ucHJvdG90eXBlLmRlcml2ZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5tdWwodGhpcy5wcml2KS5nZXRYKCl9LG8ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLmVjLnNpZ24oZSx0aGlzLHQscil9LG8ucHJvdG90eXBlLnZlcmlmeT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVjLnZlcmlmeShlLHQsdGhpcyl9LG8ucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm5cIjxLZXkgcHJpdjogXCIrKHRoaXMucHJpdiYmdGhpcy5wcml2LnRvU3RyaW5nKDE2LDIpKStcIiBwdWI6IFwiKyh0aGlzLnB1YiYmdGhpcy5wdWIuaW5zcGVjdCgpKStcIiA+XCJ9fSx7XCIuLi91dGlsc1wiOjI0LFwiYm4uanNcIjo5fV0sMjE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgdT1lKFwiYm4uanNcIiksbD1lKFwiLi4vdXRpbHNcIiksbj1sLmFzc2VydDtmdW5jdGlvbiBpKGUsdCl7aWYoZSBpbnN0YW5jZW9mIGkpcmV0dXJuIGU7dGhpcy5faW1wb3J0REVSKGUsdCl8fChuKGUuciYmZS5zLFwiU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzXCIpLHRoaXMucj1uZXcgdShlLnIsMTYpLHRoaXMucz1uZXcgdShlLnMsMTYpLHZvaWQgMD09PWUucmVjb3ZlcnlQYXJhbT90aGlzLnJlY292ZXJ5UGFyYW09bnVsbDp0aGlzLnJlY292ZXJ5UGFyYW09ZS5yZWNvdmVyeVBhcmFtKX1mdW5jdGlvbiBoKCl7dGhpcy5wbGFjZT0wfWZ1bmN0aW9uIGYoZSx0KXt2YXIgcj1lW3QucGxhY2UrK107aWYoISgxMjgmcikpcmV0dXJuIHI7dmFyIG49MTUmcjtpZigwPT1ufHw0PG4pcmV0dXJuITE7Zm9yKHZhciBpPTAsbz0wLHM9dC5wbGFjZTtvPG47bysrLHMrKylpPDw9OCxpfD1lW3NdLGk+Pj49MDtyZXR1cm4hKGk8PTEyNykmJih0LnBsYWNlPXMsaSl9ZnVuY3Rpb24gcyhlKXtmb3IodmFyIHQ9MCxyPWUubGVuZ3RoLTE7IWVbdF0mJiEoMTI4JmVbdCsxXSkmJnQ8cjspdCsrO3JldHVybiAwPT09dD9lOmUuc2xpY2UodCl9ZnVuY3Rpb24gYShlLHQpe2lmKHQ8MTI4KWUucHVzaCh0KTtlbHNle3ZhciByPTErKE1hdGgubG9nKHQpL01hdGguTE4yPj4+Myk7Zm9yKGUucHVzaCgxMjh8cik7LS1yOyllLnB1c2godD4+PihyPDwzKSYyNTUpO2UucHVzaCh0KX19KHQuZXhwb3J0cz1pKS5wcm90b3R5cGUuX2ltcG9ydERFUj1mdW5jdGlvbihlLHQpe2U9bC50b0FycmF5KGUsdCk7dmFyIHI9bmV3IGg7aWYoNDghPT1lW3IucGxhY2UrK10pcmV0dXJuITE7dmFyIG49ZihlLHIpO2lmKCExPT09bilyZXR1cm4hMTtpZihuK3IucGxhY2UhPT1lLmxlbmd0aClyZXR1cm4hMTtpZigyIT09ZVtyLnBsYWNlKytdKXJldHVybiExO3ZhciBpPWYoZSxyKTtpZighMT09PWkpcmV0dXJuITE7dmFyIG89ZS5zbGljZShyLnBsYWNlLGkrci5wbGFjZSk7aWYoci5wbGFjZSs9aSwyIT09ZVtyLnBsYWNlKytdKXJldHVybiExO3ZhciBzPWYoZSxyKTtpZighMT09PXMpcmV0dXJuITE7aWYoZS5sZW5ndGghPT1zK3IucGxhY2UpcmV0dXJuITE7dmFyIGE9ZS5zbGljZShyLnBsYWNlLHMrci5wbGFjZSk7aWYoMD09PW9bMF0pe2lmKCEoMTI4Jm9bMV0pKXJldHVybiExO289by5zbGljZSgxKX1pZigwPT09YVswXSl7aWYoISgxMjgmYVsxXSkpcmV0dXJuITE7YT1hLnNsaWNlKDEpfXJldHVybiB0aGlzLnI9bmV3IHUobyksdGhpcy5zPW5ldyB1KGEpLCEodGhpcy5yZWNvdmVyeVBhcmFtPW51bGwpfSxpLnByb3RvdHlwZS50b0RFUj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnIudG9BcnJheSgpLHI9dGhpcy5zLnRvQXJyYXkoKTtmb3IoMTI4JnRbMF0mJih0PVswXS5jb25jYXQodCkpLDEyOCZyWzBdJiYocj1bMF0uY29uY2F0KHIpKSx0PXModCkscj1zKHIpOyEoclswXXx8MTI4JnJbMV0pOylyPXIuc2xpY2UoMSk7dmFyIG49WzJdO2Eobix0Lmxlbmd0aCksKG49bi5jb25jYXQodCkpLnB1c2goMiksYShuLHIubGVuZ3RoKTt2YXIgaT1uLmNvbmNhdChyKSxvPVs0OF07cmV0dXJuIGEobyxpLmxlbmd0aCksbz1vLmNvbmNhdChpKSxsLmVuY29kZShvLGUpfX0se1wiLi4vdXRpbHNcIjoyNCxcImJuLmpzXCI6OX1dLDIyOltmdW5jdGlvbihlLHQscil7YXJndW1lbnRzWzRdWzE0XVswXS5hcHBseShyLGFyZ3VtZW50cyl9LHtkdXA6MTR9XSwyMzpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz12b2lkIDB9LHt9XSwyNDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIsaT1lKFwiYm4uanNcIiksbz1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKSxzPWUoXCJtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzXCIpO24uYXNzZXJ0PW8sbi50b0FycmF5PXMudG9BcnJheSxuLnplcm8yPXMuemVybzIsbi50b0hleD1zLnRvSGV4LG4uZW5jb2RlPXMuZW5jb2RlLG4uZ2V0TkFGPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1uZXcgQXJyYXkoTWF0aC5tYXgoZS5iaXRMZW5ndGgoKSxyKSsxKTtuLmZpbGwoMCk7Zm9yKHZhciBpPTE8PHQrMSxvPWUuY2xvbmUoKSxzPTA7czxuLmxlbmd0aDtzKyspe3ZhciBhLHU9by5hbmRsbihpLTEpO28uaXNPZGQoKT8oYT0oaT4+MSktMTx1PyhpPj4xKS11OnUsby5pc3VibihhKSk6YT0wLG5bc109YSxvLml1c2hybigxKX1yZXR1cm4gbn0sbi5nZXRKU0Y9ZnVuY3Rpb24oZSx0KXt2YXIgcj1bW10sW11dO2U9ZS5jbG9uZSgpLHQ9dC5jbG9uZSgpO2Zvcih2YXIgbj0wLGk9MDswPGUuY21wbigtbil8fDA8dC5jbXBuKC1pKTspe3ZhciBvLHMsYSx1PWUuYW5kbG4oMykrbiYzLGw9dC5hbmRsbigzKStpJjM7Mz09PXUmJih1PS0xKSwzPT09bCYmKGw9LTEpLG89MD09KDEmdSk/MDozIT09KHM9ZS5hbmRsbig3KStuJjcpJiY1IT09c3x8MiE9PWw/dTotdSxyWzBdLnB1c2gobyksYT0wPT0oMSZsKT8wOjMhPT0ocz10LmFuZGxuKDcpK2kmNykmJjUhPT1zfHwyIT09dT9sOi1sLHJbMV0ucHVzaChhKSwyKm49PT1vKzEmJihuPTEtbiksMippPT09YSsxJiYoaT0xLWkpLGUuaXVzaHJuKDEpLHQuaXVzaHJuKDEpfXJldHVybiByfSxuLmNhY2hlZFByb3BlcnR5PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1cIl9cIit0O2UucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXNbbl0/dGhpc1tuXTp0aGlzW25dPXIuY2FsbCh0aGlzKX19LG4ucGFyc2VCeXRlcz1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9uLnRvQXJyYXkoZSxcImhleFwiKTplfSxuLmludEZyb21MRT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGkoZSxcImhleFwiLFwibGVcIil9fSx7XCJibi5qc1wiOjksXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6NDEsXCJtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzXCI6NDJ9XSwyNTpbZnVuY3Rpb24oZSx0LHIpe3QuZXhwb3J0cz17dmVyc2lvbjpcIjYuNS4zXCJ9fSx7fV0sMjY6W2Z1bmN0aW9uKGUsdCxyKXt2YXIgbj1yO24udXRpbHM9ZShcIi4vaGFzaC91dGlsc1wiKSxuLmNvbW1vbj1lKFwiLi9oYXNoL2NvbW1vblwiKSxuLnNoYT1lKFwiLi9oYXNoL3NoYVwiKSxuLnJpcGVtZD1lKFwiLi9oYXNoL3JpcGVtZFwiKSxuLmhtYWM9ZShcIi4vaGFzaC9obWFjXCIpLG4uc2hhMT1uLnNoYS5zaGExLG4uc2hhMjU2PW4uc2hhLnNoYTI1NixuLnNoYTIyND1uLnNoYS5zaGEyMjQsbi5zaGEzODQ9bi5zaGEuc2hhMzg0LG4uc2hhNTEyPW4uc2hhLnNoYTUxMixuLnJpcGVtZDE2MD1uLnJpcGVtZC5yaXBlbWQxNjB9LHtcIi4vaGFzaC9jb21tb25cIjoyNyxcIi4vaGFzaC9obWFjXCI6MjgsXCIuL2hhc2gvcmlwZW1kXCI6MjksXCIuL2hhc2gvc2hhXCI6MzAsXCIuL2hhc2gvdXRpbHNcIjozN31dLDI3OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4vdXRpbHNcIiksbj1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKTtmdW5jdGlvbiBvKCl7dGhpcy5wZW5kaW5nPW51bGwsdGhpcy5wZW5kaW5nVG90YWw9MCx0aGlzLmJsb2NrU2l6ZT10aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZSx0aGlzLm91dFNpemU9dGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplLHRoaXMuaG1hY1N0cmVuZ3RoPXRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoLHRoaXMucGFkTGVuZ3RoPXRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoLzgsdGhpcy5lbmRpYW49XCJiaWdcIix0aGlzLl9kZWx0YTg9dGhpcy5ibG9ja1NpemUvOCx0aGlzLl9kZWx0YTMyPXRoaXMuYmxvY2tTaXplLzMyfShyLkJsb2NrSGFzaD1vKS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGUsdCl7aWYoZT1pLnRvQXJyYXkoZSx0KSx0aGlzLnBlbmRpbmc/dGhpcy5wZW5kaW5nPXRoaXMucGVuZGluZy5jb25jYXQoZSk6dGhpcy5wZW5kaW5nPWUsdGhpcy5wZW5kaW5nVG90YWwrPWUubGVuZ3RoLHRoaXMucGVuZGluZy5sZW5ndGg+PXRoaXMuX2RlbHRhOCl7dmFyIHI9KGU9dGhpcy5wZW5kaW5nKS5sZW5ndGgldGhpcy5fZGVsdGE4O3RoaXMucGVuZGluZz1lLnNsaWNlKGUubGVuZ3RoLXIsZS5sZW5ndGgpLDA9PT10aGlzLnBlbmRpbmcubGVuZ3RoJiYodGhpcy5wZW5kaW5nPW51bGwpLGU9aS5qb2luMzIoZSwwLGUubGVuZ3RoLXIsdGhpcy5lbmRpYW4pO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bis9dGhpcy5fZGVsdGEzMil0aGlzLl91cGRhdGUoZSxuLG4rdGhpcy5fZGVsdGEzMil9cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLmRpZ2VzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy51cGRhdGUodGhpcy5fcGFkKCkpLG4obnVsbD09PXRoaXMucGVuZGluZyksdGhpcy5fZGlnZXN0KGUpfSxvLnByb3RvdHlwZS5fcGFkPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wZW5kaW5nVG90YWwsdD10aGlzLl9kZWx0YTgscj10LShlK3RoaXMucGFkTGVuZ3RoKSV0LG49bmV3IEFycmF5KHIrdGhpcy5wYWRMZW5ndGgpO25bMF09MTI4O2Zvcih2YXIgaT0xO2k8cjtpKyspbltpXT0wO2lmKGU8PD0zLFwiYmlnXCI9PT10aGlzLmVuZGlhbil7Zm9yKHZhciBvPTg7bzx0aGlzLnBhZExlbmd0aDtvKyspbltpKytdPTA7bltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbltpKytdPWU+Pj4yNCYyNTUsbltpKytdPWU+Pj4xNiYyNTUsbltpKytdPWU+Pj44JjI1NSxuW2krK109MjU1JmV9ZWxzZSBmb3IobltpKytdPTI1NSZlLG5baSsrXT1lPj4+OCYyNTUsbltpKytdPWU+Pj4xNiYyNTUsbltpKytdPWU+Pj4yNCYyNTUsbltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbltpKytdPTAsbz04O288dGhpcy5wYWRMZW5ndGg7bysrKW5baSsrXT0wO3JldHVybiBufX0se1wiLi91dGlsc1wiOjM3LFwibWluaW1hbGlzdGljLWFzc2VydFwiOjQxfV0sMjg6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi91dGlsc1wiKSxpPWUoXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCIpO2Z1bmN0aW9uIG8oZSx0LHIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBuZXcgbyhlLHQscik7dGhpcy5IYXNoPWUsdGhpcy5ibG9ja1NpemU9ZS5ibG9ja1NpemUvOCx0aGlzLm91dFNpemU9ZS5vdXRTaXplLzgsdGhpcy5pbm5lcj1udWxsLHRoaXMub3V0ZXI9bnVsbCx0aGlzLl9pbml0KG4udG9BcnJheSh0LHIpKX0odC5leHBvcnRzPW8pLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbihlKXtlLmxlbmd0aD50aGlzLmJsb2NrU2l6ZSYmKGU9KG5ldyB0aGlzLkhhc2gpLnVwZGF0ZShlKS5kaWdlc3QoKSksaShlLmxlbmd0aDw9dGhpcy5ibG9ja1NpemUpO2Zvcih2YXIgdD1lLmxlbmd0aDt0PHRoaXMuYmxvY2tTaXplO3QrKyllLnB1c2goMCk7Zm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdXj01NDtmb3IodGhpcy5pbm5lcj0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGUpLHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdXj0xMDY7dGhpcy5vdXRlcj0obmV3IHRoaXMuSGFzaCkudXBkYXRlKGUpfSxvLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5pbm5lci51cGRhdGUoZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpLHRoaXMub3V0ZXIuZGlnZXN0KGUpfX0se1wiLi91dGlsc1wiOjM3LFwibWluaW1hbGlzdGljLWFzc2VydFwiOjQxfV0sMjk6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1lKFwiLi91dGlsc1wiKSxpPWUoXCIuL2NvbW1vblwiKSx5PW4ucm90bDMyLG09bi5zdW0zMixnPW4uc3VtMzJfMyxiPW4uc3VtMzJfNCxvPWkuQmxvY2tIYXNoO2Z1bmN0aW9uIHMoKXtpZighKHRoaXMgaW5zdGFuY2VvZiBzKSlyZXR1cm4gbmV3IHM7by5jYWxsKHRoaXMpLHRoaXMuaD1bMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdLHRoaXMuZW5kaWFuPVwibGl0dGxlXCJ9ZnVuY3Rpb24gdyhlLHQscixuKXtyZXR1cm4gZTw9MTU/dF5yXm46ZTw9MzE/dCZyfH50Jm46ZTw9NDc/KHR8fnIpXm46ZTw9NjM/dCZufHImfm46dF4ocnx+bil9bi5pbmhlcml0cyhzLG8pLChyLnJpcGVtZDE2MD1zKS5ibG9ja1NpemU9NTEyLHMub3V0U2l6ZT0xNjAscy5obWFjU3RyZW5ndGg9MTkyLHMucGFkTGVuZ3RoPTY0LHMucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIsbixpPWY9dGhpcy5oWzBdLG89dj10aGlzLmhbMV0scz1wPXRoaXMuaFsyXSxhPWQ9dGhpcy5oWzNdLHU9Yz10aGlzLmhbNF0sbD0wO2w8ODA7bCsrKXZhciBoPW0oeShiKGYsdyhsLHYscCxkKSxlW19bbF0rdF0sKG49bCk8PTE1PzA6bjw9MzE/MTUxODUwMDI0OTpuPD00Nz8xODU5Nzc1MzkzOm48PTYzPzI0MDA5NTk3MDg6Mjg0MDg1MzgzOCksQVtsXSksYyksZj1jLGM9ZCxkPXkocCwxMCkscD12LHY9aCxoPW0oeShiKGksdyg3OS1sLG8scyxhKSxlW01bbF0rdF0sKHI9bCk8PTE1PzEzNTI4Mjk5MjY6cjw9MzE/MTU0ODYwMzY4NDpyPD00Nz8xODM2MDcyNjkxOnI8PTYzPzIwNTM5OTQyMTc6MCksRVtsXSksdSksaT11LHU9YSxhPXkocywxMCkscz1vLG89aDtoPWcodGhpcy5oWzFdLHAsYSksdGhpcy5oWzFdPWcodGhpcy5oWzJdLGQsdSksdGhpcy5oWzJdPWcodGhpcy5oWzNdLGMsaSksdGhpcy5oWzNdPWcodGhpcy5oWzRdLGYsbyksdGhpcy5oWzRdPWcodGhpcy5oWzBdLHYscyksdGhpcy5oWzBdPWh9LHMucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuXCJoZXhcIj09PWU/bi50b0hleDMyKHRoaXMuaCxcImxpdHRsZVwiKTpuLnNwbGl0MzIodGhpcy5oLFwibGl0dGxlXCIpfTt2YXIgXz1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSw3LDQsMTMsMSwxMCw2LDE1LDMsMTIsMCw5LDUsMiwxNCwxMSw4LDMsMTAsMTQsNCw5LDE1LDgsMSwyLDcsMCw2LDEzLDExLDUsMTIsMSw5LDExLDEwLDAsOCwxMiw0LDEzLDMsNywxNSwxNCw1LDYsMiw0LDAsNSw5LDcsMTIsMiwxMCwxNCwxLDMsOCwxMSw2LDE1LDEzXSxNPVs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdLEE9WzExLDE0LDE1LDEyLDUsOCw3LDksMTEsMTMsMTQsMTUsNiw3LDksOCw3LDYsOCwxMywxMSw5LDcsMTUsNywxMiwxNSw5LDExLDcsMTMsMTIsMTEsMTMsNiw3LDE0LDksMTMsMTUsMTQsOCwxMyw2LDUsMTIsNyw1LDExLDEyLDE0LDE1LDE0LDE1LDksOCw5LDE0LDUsNiw4LDYsNSwxMiw5LDE1LDUsMTEsNiw4LDEzLDEyLDUsMTIsMTMsMTQsMTEsOCw1LDZdLEU9WzgsOSw5LDExLDEzLDE1LDE1LDUsNyw3LDgsMTEsMTQsMTQsMTIsNiw5LDEzLDE1LDcsMTIsOCw5LDExLDcsNywxMiw3LDYsMTUsMTMsMTEsOSw3LDE1LDExLDgsNiw2LDE0LDEyLDEzLDUsMTQsMTMsMTMsNyw1LDE1LDUsOCwxMSwxNCwxNCw2LDE0LDYsOSwxMiw5LDEyLDUsMTUsOCw4LDUsMTIsOSwxMiw1LDE0LDYsOCwxMyw2LDUsMTUsMTMsMTEsMTFdfSx7XCIuL2NvbW1vblwiOjI3LFwiLi91dGlsc1wiOjM3fV0sMzA6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLnNoYTE9ZShcIi4vc2hhLzFcIiksci5zaGEyMjQ9ZShcIi4vc2hhLzIyNFwiKSxyLnNoYTI1Nj1lKFwiLi9zaGEvMjU2XCIpLHIuc2hhMzg0PWUoXCIuL3NoYS8zODRcIiksci5zaGE1MTI9ZShcIi4vc2hhLzUxMlwiKX0se1wiLi9zaGEvMVwiOjMxLFwiLi9zaGEvMjI0XCI6MzIsXCIuL3NoYS8yNTZcIjozMyxcIi4vc2hhLzM4NFwiOjM0LFwiLi9zaGEvNTEyXCI6MzV9XSwzMTpbZnVuY3Rpb24oZSx0LHIpe2FyZ3VtZW50c1s0XVsxNF1bMF0uYXBwbHkocixhcmd1bWVudHMpfSx7ZHVwOjE0fV0sMzI6W2Z1bmN0aW9uKGUsdCxyKXthcmd1bWVudHNbNF1bMTRdWzBdLmFwcGx5KHIsYXJndW1lbnRzKX0se2R1cDoxNH1dLDMzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZShcIi4uL3V0aWxzXCIpLGk9ZShcIi4uL2NvbW1vblwiKSxvPWUoXCIuL2NvbW1vblwiKSxwPWUoXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCIpLHY9bi5zdW0zMix5PW4uc3VtMzJfNCxtPW4uc3VtMzJfNSxnPW8uY2gzMixiPW8ubWFqMzIsdz1vLnMwXzI1NixfPW8uczFfMjU2LE09by5nMF8yNTYsQT1vLmcxXzI1NixzPWkuQmxvY2tIYXNoLGE9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF07ZnVuY3Rpb24gdSgpe2lmKCEodGhpcyBpbnN0YW5jZW9mIHUpKXJldHVybiBuZXcgdTtzLmNhbGwodGhpcyksdGhpcy5oPVsxNzc5MDMzNzAzLDMxNDQxMzQyNzcsMTAxMzkwNDI0MiwyNzczNDgwNzYyLDEzNTk4OTMxMTksMjYwMDgyMjkyNCw1Mjg3MzQ2MzUsMTU0MTQ1OTIyNV0sdGhpcy5rPWEsdGhpcy5XPW5ldyBBcnJheSg2NCl9bi5pbmhlcml0cyh1LHMpLCh0LmV4cG9ydHM9dSkuYmxvY2tTaXplPTUxMix1Lm91dFNpemU9MjU2LHUuaG1hY1N0cmVuZ3RoPTE5Mix1LnBhZExlbmd0aD02NCx1LnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPXRoaXMuVyxuPTA7bjwxNjtuKyspcltuXT1lW3Qrbl07Zm9yKDtuPHIubGVuZ3RoO24rKylyW25dPXkoQShyW24tMl0pLHJbbi03XSxNKHJbbi0xNV0pLHJbbi0xNl0pO3ZhciBpPXRoaXMuaFswXSxvPXRoaXMuaFsxXSxzPXRoaXMuaFsyXSxhPXRoaXMuaFszXSx1PXRoaXMuaFs0XSxsPXRoaXMuaFs1XSxoPXRoaXMuaFs2XSxmPXRoaXMuaFs3XTtmb3IocCh0aGlzLmsubGVuZ3RoPT09ci5sZW5ndGgpLG49MDtuPHIubGVuZ3RoO24rKyl2YXIgYz1tKGYsXyh1KSxnKHUsbCxoKSx0aGlzLmtbbl0scltuXSksZD12KHcoaSksYihpLG8scykpLGY9aCxoPWwsbD11LHU9dihhLGMpLGE9cyxzPW8sbz1pLGk9dihjLGQpO3RoaXMuaFswXT12KHRoaXMuaFswXSxpKSx0aGlzLmhbMV09dih0aGlzLmhbMV0sbyksdGhpcy5oWzJdPXYodGhpcy5oWzJdLHMpLHRoaXMuaFszXT12KHRoaXMuaFszXSxhKSx0aGlzLmhbNF09dih0aGlzLmhbNF0sdSksdGhpcy5oWzVdPXYodGhpcy5oWzVdLGwpLHRoaXMuaFs2XT12KHRoaXMuaFs2XSxoKSx0aGlzLmhbN109dih0aGlzLmhbN10sZil9LHUucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuXCJoZXhcIj09PWU/bi50b0hleDMyKHRoaXMuaCxcImJpZ1wiKTpuLnNwbGl0MzIodGhpcy5oLFwiYmlnXCIpfX0se1wiLi4vY29tbW9uXCI6MjcsXCIuLi91dGlsc1wiOjM3LFwiLi9jb21tb25cIjozNixcIm1pbmltYWxpc3RpYy1hc3NlcnRcIjo0MX1dLDM0OltmdW5jdGlvbihlLHQscil7YXJndW1lbnRzWzRdWzE0XVswXS5hcHBseShyLGFyZ3VtZW50cyl9LHtkdXA6MTR9XSwzNTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuLi91dGlsc1wiKSxpPWUoXCIuLi9jb21tb25cIiksQz1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKSxMPW4ucm90cjY0X2hpLEI9bi5yb3RyNjRfbG8sYz1uLnNocjY0X2hpLGQ9bi5zaHI2NF9sbyxEPW4uc3VtNjQsVT1uLnN1bTY0X2hpLEY9bi5zdW02NF9sbyxwPW4uc3VtNjRfNF9oaSx2PW4uc3VtNjRfNF9sbyxqPW4uc3VtNjRfNV9oaSxHPW4uc3VtNjRfNV9sbyxvPWkuQmxvY2tIYXNoLHM9WzExMTYzNTI0MDgsMzYwOTc2NzQ1OCwxODk5NDQ3NDQxLDYwMjg5MTcyNSwzMDQ5MzIzNDcxLDM5NjQ0ODQzOTksMzkyMTAwOTU3MywyMTczMjk1NTQ4LDk2MTk4NzE2Myw0MDgxNjI4NDcyLDE1MDg5NzA5OTMsMzA1MzgzNDI2NSwyNDUzNjM1NzQ4LDI5Mzc2NzE1NzksMjg3MDc2MzIyMSwzNjY0NjA5NTYwLDM2MjQzODEwODAsMjczNDg4MzM5NCwzMTA1OTg0MDEsMTE2NDk5NjU0Miw2MDcyMjUyNzgsMTMyMzYxMDc2NCwxNDI2ODgxOTg3LDM1OTAzMDQ5OTQsMTkyNTA3ODM4OCw0MDY4MTgyMzgzLDIxNjIwNzgyMDYsOTkxMzM2MTEzLDI2MTQ4ODgxMDMsNjMzODAzMzE3LDMyNDgyMjI1ODAsMzQ3OTc3NDg2OCwzODM1MzkwNDAxLDI2NjY2MTM0NTgsNDAyMjIyNDc3NCw5NDQ3MTExMzksMjY0MzQ3MDc4LDIzNDEyNjI3NzMsNjA0ODA3NjI4LDIwMDc4MDA5MzMsNzcwMjU1OTgzLDE0OTU5OTA5MDEsMTI0OTE1MDEyMiwxODU2NDMxMjM1LDE1NTUwODE2OTIsMzE3NTIxODEzMiwxOTk2MDY0OTg2LDIxOTg5NTA4MzcsMjU1NDIyMDg4MiwzOTk5NzE5MzM5LDI4MjE4MzQzNDksNzY2Nzg0MDE2LDI5NTI5OTY4MDgsMjU2NjU5NDg3OSwzMjEwMzEzNjcxLDMyMDMzMzc5NTYsMzMzNjU3MTg5MSwxMDM0NDU3MDI2LDM1ODQ1Mjg3MTEsMjQ2Njk0ODkwMSwxMTM5MjY5OTMsMzc1ODMyNjM4MywzMzgyNDE4OTUsMTY4NzE3OTM2LDY2NjMwNzIwNSwxMTg4MTc5OTY0LDc3MzUyOTkxMiwxNTQ2MDQ1NzM0LDEyOTQ3NTczNzIsMTUyMjgwNTQ4NSwxMzk2MTgyMjkxLDI2NDM4MzM4MjMsMTY5NTE4MzcwMCwyMzQzNTI3MzkwLDE5ODY2NjEwNTEsMTAxNDQ3NzQ4MCwyMTc3MDI2MzUwLDEyMDY3NTkxNDIsMjQ1Njk1NjAzNywzNDQwNzc2MjcsMjczMDQ4NTkyMSwxMjkwODYzNDYwLDI4MjAzMDI0MTEsMzE1ODQ1NDI3MywzMjU5NzMwODAwLDM1MDU5NTI2NTcsMzM0NTc2NDc3MSwxMDYyMTcwMDgsMzUxNjA2NTgxNywzNjA2MDA4MzQ0LDM2MDAzNTI4MDQsMTQzMjcyNTc3Niw0MDk0NTcxOTA5LDE0NjcwMzE1OTQsMjc1NDIzMzQ0LDg1MTE2OTcyMCw0MzAyMjc3MzQsMzEwMDgyMzc1Miw1MDY5NDg2MTYsMTM2MzI1ODE5NSw2NTkwNjA1NTYsMzc1MDY4NTU5Myw4ODM5OTc4NzcsMzc4NTA1MDI4MCw5NTgxMzk1NzEsMzMxODMwNzQyNywxMzIyODIyMjE4LDM4MTI3MjM0MDMsMTUzNzAwMjA2MywyMDAzMDM0OTk1LDE3NDc4NzM3NzksMzYwMjAzNjg5OSwxOTU1NTYyMjIyLDE1NzU5OTAwMTIsMjAyNDEwNDgxNSwxMTI1NTkyOTI4LDIyMjc3MzA0NTIsMjcxNjkwNDMwNiwyMzYxODUyNDI0LDQ0Mjc3NjA0NCwyNDI4NDM2NDc0LDU5MzY5ODM0NCwyNzU2NzM0MTg3LDM3MzMxMTAyNDksMzIwNDAzMTQ3OSwyOTk5MzUxNTczLDMzMjkzMjUyOTgsMzgxNTkyMDQyNywzMzkxNTY5NjE0LDM5MjgzODM5MDAsMzUxNTI2NzI3MSw1NjYyODA3MTEsMzk0MDE4NzYwNiwzNDU0MDY5NTM0LDQxMTg2MzAyNzEsNDAwMDIzOTk5MiwxMTY0MTg0NzQsMTkxNDEzODU1NCwxNzQyOTI0MjEsMjczMTA1NTI3MCwyODkzODAzNTYsMzIwMzk5MzAwNiw0NjAzOTMyNjksMzIwNjIwMzE1LDY4NTQ3MTczMyw1ODc0OTY4MzYsODUyMTQyOTcxLDEwODY3OTI4NTEsMTAxNzAzNjI5OCwzNjU1NDMxMDAsMTEyNjAwMDU4MCwyNjE4Mjk3Njc2LDEyODgwMzM0NzAsMzQwOTg1NTE1OCwxNTAxNTA1OTQ4LDQyMzQ1MDk4NjYsMTYwNzE2NzkxNSw5ODcxNjc0NjgsMTgxNjQwMjMxNiwxMjQ2MTg5NTkxXTtmdW5jdGlvbiBhKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgYSkpcmV0dXJuIG5ldyBhO28uY2FsbCh0aGlzKSx0aGlzLmg9WzE3NzkwMzM3MDMsNDA4OTIzNTcyMCwzMTQ0MTM0Mjc3LDIyMjc4NzM1OTUsMTAxMzkwNDI0Miw0MjcxMTc1NzIzLDI3NzM0ODA3NjIsMTU5NTc1MDEyOSwxMzU5ODkzMTE5LDI5MTc1NjUxMzcsMjYwMDgyMjkyNCw3MjU1MTExOTksNTI4NzM0NjM1LDQyMTUzODk1NDcsMTU0MTQ1OTIyNSwzMjcwMzMyMDldLHRoaXMuaz1zLHRoaXMuVz1uZXcgQXJyYXkoMTYwKX1uLmluaGVyaXRzKGEsbyksKHQuZXhwb3J0cz1hKS5ibG9ja1NpemU9MTAyNCxhLm91dFNpemU9NTEyLGEuaG1hY1N0cmVuZ3RoPTE5MixhLnBhZExlbmd0aD0xMjgsYS5wcm90b3R5cGUuX3ByZXBhcmVCbG9jaz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLlcsbj0wO248MzI7bisrKXJbbl09ZVt0K25dO2Zvcig7bjxyLmxlbmd0aDtuKz0yKXt2YXIgaT1mdW5jdGlvbihlLHQpe3ZhciByPUwoZSx0LDE5KSxuPUwodCxlLDI5KSxpPWMoZSx0LDYpLG89cl5uXmk7bzwwJiYobys9NDI5NDk2NzI5Nik7cmV0dXJuIG99KHJbbi00XSxyW24tM10pLG89ZnVuY3Rpb24oZSx0KXt2YXIgcj1CKGUsdCwxOSksbj1CKHQsZSwyOSksaT1kKGUsdCw2KSxvPXJebl5pO288MCYmKG8rPTQyOTQ5NjcyOTYpO3JldHVybiBvfShyW24tNF0scltuLTNdKSxzPXJbbi0xNF0sYT1yW24tMTNdLHU9ZnVuY3Rpb24oZSx0KXt2YXIgcj1MKGUsdCwxKSxuPUwoZSx0LDgpLGk9YyhlLHQsNyksbz1yXm5eaTtvPDAmJihvKz00Mjk0OTY3Mjk2KTtyZXR1cm4gb30ocltuLTMwXSxyW24tMjldKSxsPWZ1bmN0aW9uKGUsdCl7dmFyIHI9QihlLHQsMSksbj1CKGUsdCw4KSxpPWQoZSx0LDcpLG89cl5uXmk7bzwwJiYobys9NDI5NDk2NzI5Nik7cmV0dXJuIG99KHJbbi0zMF0scltuLTI5XSksaD1yW24tMzJdLGY9cltuLTMxXTtyW25dPXAoaSxvLHMsYSx1LGwsaCxmKSxyW24rMV09dihpLG8scyxhLHUsbCxoLGYpfX0sYS5wcm90b3R5cGUuX3VwZGF0ZT1mdW5jdGlvbihlLHQpe3RoaXMuX3ByZXBhcmVCbG9jayhlLHQpO3ZhciByPXRoaXMuVyxuPXRoaXMuaFswXSxpPXRoaXMuaFsxXSxvPXRoaXMuaFsyXSxzPXRoaXMuaFszXSxhPXRoaXMuaFs0XSx1PXRoaXMuaFs1XSxsPXRoaXMuaFs2XSxoPXRoaXMuaFs3XSxmPXRoaXMuaFs4XSxjPXRoaXMuaFs5XSxkPXRoaXMuaFsxMF0scD10aGlzLmhbMTFdLHY9dGhpcy5oWzEyXSx5PXRoaXMuaFsxM10sbT10aGlzLmhbMTRdLGc9dGhpcy5oWzE1XTtDKHRoaXMuay5sZW5ndGg9PT1yLmxlbmd0aCk7Zm9yKHZhciBiPTA7YjxyLmxlbmd0aDtiKz0yKXZhciB3PW0sXz1nLE09ZnVuY3Rpb24oZSx0KXt2YXIgcj1MKGUsdCwxNCksbj1MKGUsdCwxOCksaT1MKHQsZSw5KSxvPXJebl5pO288MCYmKG8rPTQyOTQ5NjcyOTYpO3JldHVybiBvfShmLGMpLEE9ZnVuY3Rpb24oZSx0KXt2YXIgcj1CKGUsdCwxNCksbj1CKGUsdCwxOCksaT1CKHQsZSw5KSxvPXJebl5pO288MCYmKG8rPTQyOTQ5NjcyOTYpO3JldHVybiBvfShmLGMpLEU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUmdF5+ZSZyO248MCYmKG4rPTQyOTQ5NjcyOTYpO3JldHVybiBufShmLGQsdiksUz1mdW5jdGlvbihlLHQscil7dmFyIG49ZSZ0Xn5lJnI7bjwwJiYobis9NDI5NDk2NzI5Nik7cmV0dXJuIG59KGMscCx5KSxrPXRoaXMua1tiXSxOPXRoaXMua1tiKzFdLHg9cltiXSxQPXJbYisxXSxJPWoodyxfLE0sQSxFLFMsayxOLHgsUCksVD1HKHcsXyxNLEEsRSxTLGssTix4LFApLHc9ZnVuY3Rpb24oZSx0KXt2YXIgcj1MKGUsdCwyOCksbj1MKHQsZSwyKSxpPUwodCxlLDcpLG89cl5uXmk7bzwwJiYobys9NDI5NDk2NzI5Nik7cmV0dXJuIG99KG4saSksXz1mdW5jdGlvbihlLHQpe3ZhciByPUIoZSx0LDI4KSxuPUIodCxlLDIpLGk9Qih0LGUsNyksbz1yXm5eaTtvPDAmJihvKz00Mjk0OTY3Mjk2KTtyZXR1cm4gb30obixpKSxNPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1lJnReZSZyXnQmcjtuPDAmJihuKz00Mjk0OTY3Mjk2KTtyZXR1cm4gbn0obixvLGEpLEE9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUmdF5lJnJedCZyO248MCYmKG4rPTQyOTQ5NjcyOTYpO3JldHVybiBufShpLHMsdSksUj1VKHcsXyxNLEEpLE89Rih3LF8sTSxBKSxtPXYsZz15LHY9ZCx5PXAsZD1mLHA9YyxmPVUobCxoLEksVCksYz1GKGgsaCxJLFQpLGw9YSxoPXUsYT1vLHU9cyxvPW4scz1pLG49VShJLFQsUixPKSxpPUYoSSxULFIsTyk7RCh0aGlzLmgsMCxuLGkpLEQodGhpcy5oLDIsbyxzKSxEKHRoaXMuaCw0LGEsdSksRCh0aGlzLmgsNixsLGgpLEQodGhpcy5oLDgsZixjKSxEKHRoaXMuaCwxMCxkLHApLEQodGhpcy5oLDEyLHYseSksRCh0aGlzLmgsMTQsbSxnKX0sYS5wcm90b3R5cGUuX2RpZ2VzdD1mdW5jdGlvbihlKXtyZXR1cm5cImhleFwiPT09ZT9uLnRvSGV4MzIodGhpcy5oLFwiYmlnXCIpOm4uc3BsaXQzMih0aGlzLmgsXCJiaWdcIil9fSx7XCIuLi9jb21tb25cIjoyNyxcIi4uL3V0aWxzXCI6MzcsXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6NDF9XSwzNjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCIuLi91dGlsc1wiKS5yb3RyMzI7ZnVuY3Rpb24gaShlLHQscil7cmV0dXJuIGUmdF5+ZSZyfWZ1bmN0aW9uIG8oZSx0LHIpe3JldHVybiBlJnReZSZyXnQmcn1mdW5jdGlvbiBzKGUsdCxyKXtyZXR1cm4gZV50XnJ9ci5mdF8xPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiAwPT09ZT9pKHQscixuKToxPT09ZXx8Mz09PWU/dF5yXm46Mj09PWU/byh0LHIsbik6dm9pZCAwfSxyLmNoMzI9aSxyLm1hajMyPW8sci5wMzI9cyxyLnMwXzI1Nj1mdW5jdGlvbihlKXtyZXR1cm4gbihlLDIpXm4oZSwxMylebihlLDIyKX0sci5zMV8yNTY9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSw2KV5uKGUsMTEpXm4oZSwyNSl9LHIuZzBfMjU2PWZ1bmN0aW9uKGUpe3JldHVybiBuKGUsNylebihlLDE4KV5lPj4+M30sci5nMV8yNTY9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZSwxNylebihlLDE5KV5lPj4+MTB9fSx7XCIuLi91dGlsc1wiOjM3fV0sMzc6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbD1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKSxuPWUoXCJpbmhlcml0c1wiKTtmdW5jdGlvbiBvKGUpe3JldHVybihlPj4+MjR8ZT4+PjgmNjUyODB8ZTw8OCYxNjcxMTY4MHwoMjU1JmUpPDwyNCk+Pj4wfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIDE9PT1lLmxlbmd0aD9cIjBcIitlOmV9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gNz09PWUubGVuZ3RoP1wiMFwiK2U6Nj09PWUubGVuZ3RoP1wiMDBcIitlOjU9PT1lLmxlbmd0aD9cIjAwMFwiK2U6ND09PWUubGVuZ3RoP1wiMDAwMFwiK2U6Mz09PWUubGVuZ3RoP1wiMDAwMDBcIitlOjI9PT1lLmxlbmd0aD9cIjAwMDAwMFwiK2U6MT09PWUubGVuZ3RoP1wiMDAwMDAwMFwiK2U6ZX1yLmluaGVyaXRzPW4sci50b0FycmF5PWZ1bmN0aW9uKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5zbGljZSgpO2lmKCFlKXJldHVybltdO3ZhciByPVtdO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKWlmKHQpe2lmKFwiaGV4XCI9PT10KWZvcigoZT1lLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksXCJcIikpLmxlbmd0aCUyIT0wJiYoZT1cIjBcIitlKSxuPTA7bjxlLmxlbmd0aDtuKz0yKXIucHVzaChwYXJzZUludChlW25dK2VbbisxXSwxNikpfWVsc2UgZm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWUuY2hhckNvZGVBdChuKSxvPWk+Pjgscz0yNTUmaTtvP3IucHVzaChvLHMpOnIucHVzaChzKX1lbHNlIGZvcihuPTA7bjxlLmxlbmd0aDtuKyspcltuXT0wfGVbbl07cmV0dXJuIHJ9LHIudG9IZXg9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXQrPWkoZVtyXS50b1N0cmluZygxNikpO3JldHVybiB0fSxyLmh0b25sPW8sci50b0hleDMyPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVwiXCIsbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1lW25dO1wibGl0dGxlXCI9PT10JiYoaT1vKGkpKSxyKz1zKGkudG9TdHJpbmcoMTYpKX1yZXR1cm4gcn0sci56ZXJvMj1pLHIuemVybzg9cyxyLmpvaW4zMj1mdW5jdGlvbihlLHQscixuKXt2YXIgaT1yLXQ7bChpJTQ9PTApO2Zvcih2YXIgbz1uZXcgQXJyYXkoaS80KSxzPTAsYT10O3M8by5sZW5ndGg7cysrLGErPTQpe3ZhciB1PVwiYmlnXCI9PT1uP2VbYV08PDI0fGVbYSsxXTw8MTZ8ZVthKzJdPDw4fGVbYSszXTplW2ErM108PDI0fGVbYSsyXTw8MTZ8ZVthKzFdPDw4fGVbYV07b1tzXT11Pj4+MH1yZXR1cm4gb30sci5zcGxpdDMyPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPW5ldyBBcnJheSg0KmUubGVuZ3RoKSxuPTAsaT0wO248ZS5sZW5ndGg7bisrLGkrPTQpe3ZhciBvPWVbbl07XCJiaWdcIj09PXQ/KHJbaV09bz4+PjI0LHJbaSsxXT1vPj4+MTYmMjU1LHJbaSsyXT1vPj4+OCYyNTUscltpKzNdPTI1NSZvKToocltpKzNdPW8+Pj4yNCxyW2krMl09bz4+PjE2JjI1NSxyW2krMV09bz4+PjgmMjU1LHJbaV09MjU1Jm8pfXJldHVybiByfSxyLnJvdHIzMj1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+dHxlPDwzMi10fSxyLnJvdGwzMj1mdW5jdGlvbihlLHQpe3JldHVybiBlPDx0fGU+Pj4zMi10fSxyLnN1bTMyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdD4+PjB9LHIuc3VtMzJfMz1mdW5jdGlvbihlLHQscil7cmV0dXJuIGUrdCtyPj4+MH0sci5zdW0zMl80PWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBlK3QrcituPj4+MH0sci5zdW0zMl81PWZ1bmN0aW9uKGUsdCxyLG4saSl7cmV0dXJuIGUrdCtyK24raT4+PjB9LHIuc3VtNjQ9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9ZVt0XSxvPW4rZVt0KzFdPj4+MCxzPShvPG4/MTowKStyK2k7ZVt0XT1zPj4+MCxlW3QrMV09b30sci5zdW02NF9oaT1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4odCtuPj4+MDx0PzE6MCkrZStyPj4+MH0sci5zdW02NF9sbz1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gdCtuPj4+MH0sci5zdW02NF80X2hpPWZ1bmN0aW9uKGUsdCxyLG4saSxvLHMsYSl7dmFyIHU9MCxsPXQ7cmV0dXJuIHUrPShsPWwrbj4+PjApPHQ/MTowLHUrPShsPWwrbz4+PjApPG8/MTowLGUrcitpK3MrKHUrPShsPWwrYT4+PjApPGE/MTowKT4+PjB9LHIuc3VtNjRfNF9sbz1mdW5jdGlvbihlLHQscixuLGksbyxzLGEpe3JldHVybiB0K24rbythPj4+MH0sci5zdW02NF81X2hpPWZ1bmN0aW9uKGUsdCxyLG4saSxvLHMsYSx1LGwpe3ZhciBoPTAsZj10O3JldHVybiBoKz0oZj1mK24+Pj4wKTx0PzE6MCxoKz0oZj1mK28+Pj4wKTxvPzE6MCxoKz0oZj1mK2E+Pj4wKTxhPzE6MCxlK3IraStzK3UrKGgrPShmPWYrbD4+PjApPGw/MTowKT4+PjB9LHIuc3VtNjRfNV9sbz1mdW5jdGlvbihlLHQscixuLGksbyxzLGEsdSxsKXtyZXR1cm4gdCtuK28rYStsPj4+MH0sci5yb3RyNjRfaGk9ZnVuY3Rpb24oZSx0LHIpe3JldHVybih0PDwzMi1yfGU+Pj5yKT4+PjB9LHIucm90cjY0X2xvPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4oZTw8MzItcnx0Pj4+cik+Pj4wfSxyLnNocjY0X2hpPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT4+PnJ9LHIuc2hyNjRfbG89ZnVuY3Rpb24oZSx0LHIpe3JldHVybihlPDwzMi1yfHQ+Pj5yKT4+PjB9fSx7aW5oZXJpdHM6MzksXCJtaW5pbWFsaXN0aWMtYXNzZXJ0XCI6NDF9XSwzODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPWUoXCJoYXNoLmpzXCIpLHM9ZShcIm1pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHNcIiksaT1lKFwibWluaW1hbGlzdGljLWFzc2VydFwiKTtmdW5jdGlvbiBvKGUpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBuZXcgbyhlKTt0aGlzLmhhc2g9ZS5oYXNoLHRoaXMucHJlZFJlc2lzdD0hIWUucHJlZFJlc2lzdCx0aGlzLm91dExlbj10aGlzLmhhc2gub3V0U2l6ZSx0aGlzLm1pbkVudHJvcHk9ZS5taW5FbnRyb3B5fHx0aGlzLmhhc2guaG1hY1N0cmVuZ3RoLHRoaXMuX3Jlc2VlZD1udWxsLHRoaXMucmVzZWVkSW50ZXJ2YWw9bnVsbCx0aGlzLks9bnVsbCx0aGlzLlY9bnVsbDt2YXIgdD1zLnRvQXJyYXkoZS5lbnRyb3B5LGUuZW50cm9weUVuY3x8XCJoZXhcIikscj1zLnRvQXJyYXkoZS5ub25jZSxlLm5vbmNlRW5jfHxcImhleFwiKSxuPXMudG9BcnJheShlLnBlcnMsZS5wZXJzRW5jfHxcImhleFwiKTtpKHQubGVuZ3RoPj10aGlzLm1pbkVudHJvcHkvOCxcIk5vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogXCIrdGhpcy5taW5FbnRyb3B5K1wiIGJpdHNcIiksdGhpcy5faW5pdCh0LHIsbil9KHQuZXhwb3J0cz1vKS5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuY29uY2F0KHQpLmNvbmNhdChyKTt0aGlzLks9bmV3IEFycmF5KHRoaXMub3V0TGVuLzgpLHRoaXMuVj1uZXcgQXJyYXkodGhpcy5vdXRMZW4vOCk7Zm9yKHZhciBpPTA7aTx0aGlzLlYubGVuZ3RoO2krKyl0aGlzLktbaV09MCx0aGlzLlZbaV09MTt0aGlzLl91cGRhdGUobiksdGhpcy5fcmVzZWVkPTEsdGhpcy5yZXNlZWRJbnRlcnZhbD0yODE0NzQ5NzY3MTA2NTZ9LG8ucHJvdG90eXBlLl9obWFjPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuLmhtYWModGhpcy5oYXNoLHRoaXMuSyl9LG8ucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMF0pO2UmJih0PXQudXBkYXRlKGUpKSx0aGlzLks9dC5kaWdlc3QoKSx0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpLGUmJih0aGlzLks9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLnVwZGF0ZShbMV0pLnVwZGF0ZShlKS5kaWdlc3QoKSx0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpKX0sby5wcm90b3R5cGUucmVzZWVkPWZ1bmN0aW9uKGUsdCxyLG4pe1wic3RyaW5nXCIhPXR5cGVvZiB0JiYobj1yLHI9dCx0PW51bGwpLGU9cy50b0FycmF5KGUsdCkscj1zLnRvQXJyYXkocixuKSxpKGUubGVuZ3RoPj10aGlzLm1pbkVudHJvcHkvOCxcIk5vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogXCIrdGhpcy5taW5FbnRyb3B5K1wiIGJpdHNcIiksdGhpcy5fdXBkYXRlKGUuY29uY2F0KHJ8fFtdKSksdGhpcy5fcmVzZWVkPTF9LG8ucHJvdG90eXBlLmdlbmVyYXRlPWZ1bmN0aW9uKGUsdCxyLG4pe2lmKHRoaXMuX3Jlc2VlZD50aGlzLnJlc2VlZEludGVydmFsKXRocm93IG5ldyBFcnJvcihcIlJlc2VlZCBpcyByZXF1aXJlZFwiKTtcInN0cmluZ1wiIT10eXBlb2YgdCYmKG49cixyPXQsdD1udWxsKSxyJiYocj1zLnRvQXJyYXkocixufHxcImhleFwiKSx0aGlzLl91cGRhdGUocikpO2Zvcih2YXIgaT1bXTtpLmxlbmd0aDxlOyl0aGlzLlY9dGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpLGk9aS5jb25jYXQodGhpcy5WKTt2YXIgbz1pLnNsaWNlKDAsZSk7cmV0dXJuIHRoaXMuX3VwZGF0ZShyKSx0aGlzLl9yZXNlZWQrKyxzLmVuY29kZShvLHQpfX0se1wiaGFzaC5qc1wiOjI2LFwibWluaW1hbGlzdGljLWFzc2VydFwiOjQxLFwibWluaW1hbGlzdGljLWNyeXB0by11dGlsc1wiOjQyfV0sMzk6W2Z1bmN0aW9uKGUsdCxyKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuY3JlYXRlP3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3QmJihlLnN1cGVyXz10LGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pKX06dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHI7dCYmKGUuc3VwZXJfPXQsKHI9ZnVuY3Rpb24oKXt9KS5wcm90b3R5cGU9dC5wcm90b3R5cGUsZS5wcm90b3R5cGU9bmV3IHIsZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSl9fSx7fV0sNDA6W2Z1bmN0aW9uKGUsXyx0KXsoZnVuY3Rpb24oYix3KXshZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fTshZS5KU19TSEEzX05PX05PREVfSlMmJlwib2JqZWN0XCI9PXR5cGVvZiBiJiZiLnZlcnNpb25zJiZiLnZlcnNpb25zLm5vZGUmJihlPXcpO2Zvcih2YXIgdD0hZS5KU19TSEEzX05PX0NPTU1PTl9KUyYmXCJvYmplY3RcIj09dHlwZW9mIF8mJl8uZXhwb3J0cyx1PVwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpLGg9WzAsOCwxNiwyNF0saGU9WzEsMCwzMjg5OCwwLDMyOTA2LDIxNDc0ODM2NDgsMjE0NzUxNjQxNiwyMTQ3NDgzNjQ4LDMyOTA3LDAsMjE0NzQ4MzY0OSwwLDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjc3NywyMTQ3NDgzNjQ4LDEzOCwwLDEzNiwwLDIxNDc1MTY0MjUsMCwyMTQ3NDgzNjU4LDAsMjE0NzUxNjU1NSwwLDEzOSwyMTQ3NDgzNjQ4LDMyOTA1LDIxNDc0ODM2NDgsMzI3NzEsMjE0NzQ4MzY0OCwzMjc3MCwyMTQ3NDgzNjQ4LDEyOCwyMTQ3NDgzNjQ4LDMyNzc4LDAsMjE0NzQ4MzY1OCwyMTQ3NDgzNjQ4LDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjg5NiwyMTQ3NDgzNjQ4LDIxNDc0ODM2NDksMCwyMTQ3NTE2NDI0LDIxNDc0ODM2NDhdLHI9WzIyNCwyNTYsMzg0LDUxMl0sbz1bXCJoZXhcIixcImJ1ZmZlclwiLFwiYXJyYXlCdWZmZXJcIixcImFycmF5XCJdLHM9ZnVuY3Rpb24odCxyLG4pe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbmV3IG0odCxyLHQpLnVwZGF0ZShlKVtuXSgpfX0sYT1mdW5jdGlvbihyLG4saSl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBtKHIsbix0KS51cGRhdGUoZSlbaV0oKX19LG49ZnVuY3Rpb24oZSx0KXt2YXIgcj1zKGUsdCxcImhleFwiKTtyLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgbShlLHQsZSl9LHIudXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiByLmNyZWF0ZSgpLnVwZGF0ZShlKX07Zm9yKHZhciBuPTA7bjxvLmxlbmd0aDsrK24pe3ZhciBpPW9bbl07cltpXT1zKGUsdCxpKX1yZXR1cm4gcn0saT1be25hbWU6XCJrZWNjYWtcIixwYWRkaW5nOlsxLDI1Niw2NTUzNiwxNjc3NzIxNl0sYml0czpyLGNyZWF0ZU1ldGhvZDpufSx7bmFtZTpcInNoYTNcIixwYWRkaW5nOls2LDE1MzYsMzkzMjE2LDEwMDY2MzI5Nl0sYml0czpyLGNyZWF0ZU1ldGhvZDpufSx7bmFtZTpcInNoYWtlXCIscGFkZGluZzpbMzEsNzkzNiwyMDMxNjE2LDUyMDA5MzY5Nl0sYml0czpbMTI4LDI1Nl0sY3JlYXRlTWV0aG9kOmZ1bmN0aW9uKHQscil7dmFyIG49YSh0LHIsXCJoZXhcIik7bi5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtKHQscixlKX0sbi51cGRhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5jcmVhdGUodCkudXBkYXRlKGUpfTtmb3IodmFyIGU9MDtlPG8ubGVuZ3RoOysrZSl7dmFyIGk9b1tlXTtuW2ldPWEodCxyLGkpfXJldHVybiBufX1dLGw9e30sZj1bXSxjPTA7YzxpLmxlbmd0aDsrK2MpZm9yKHZhciBkPWlbY10scD1kLmJpdHMsdj0wO3Y8cC5sZW5ndGg7Kyt2KXt2YXIgeT1kLm5hbWUrXCJfXCIrcFt2XTtmLnB1c2goeSksbFt5XT1kLmNyZWF0ZU1ldGhvZChwW3ZdLGQucGFkZGluZyl9ZnVuY3Rpb24gbShlLHQscil7dGhpcy5ibG9ja3M9W10sdGhpcy5zPVtdLHRoaXMucGFkZGluZz10LHRoaXMub3V0cHV0Qml0cz1yLHRoaXMucmVzZXQ9ITAsdGhpcy5ibG9jaz0wLHRoaXMuc3RhcnQ9MCx0aGlzLmJsb2NrQ291bnQ9MTYwMC0oZTw8MSk+PjUsdGhpcy5ieXRlQ291bnQ9dGhpcy5ibG9ja0NvdW50PDwyLHRoaXMub3V0cHV0QmxvY2tzPXI+PjUsdGhpcy5leHRyYUJ5dGVzPSgzMSZyKT4+Mztmb3IodmFyIG49MDtuPDUwOysrbil0aGlzLnNbbl09MH1tLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJzdHJpbmdcIiE9dHlwZW9mIGU7dCYmZS5jb25zdHJ1Y3Rvcj09PUFycmF5QnVmZmVyJiYoZT1uZXcgVWludDhBcnJheShlKSk7Zm9yKHZhciByLG4saT1lLmxlbmd0aCxvPXRoaXMuYmxvY2tzLHM9dGhpcy5ieXRlQ291bnQsYT10aGlzLmJsb2NrQ291bnQsdT0wLGw9dGhpcy5zO3U8aTspe2lmKHRoaXMucmVzZXQpZm9yKHRoaXMucmVzZXQ9ITEsb1swXT10aGlzLmJsb2NrLHI9MTtyPGErMTsrK3Ipb1tyXT0wO2lmKHQpZm9yKHI9dGhpcy5zdGFydDt1PGkmJnI8czsrK3Upb1tyPj4yXXw9ZVt1XTw8aFszJnIrK107ZWxzZSBmb3Iocj10aGlzLnN0YXJ0O3U8aSYmcjxzOysrdSkobj1lLmNoYXJDb2RlQXQodSkpPDEyOD9vW3I+PjJdfD1uPDxoWzMmcisrXToobjwyMDQ4P29bcj4+Ml18PSgxOTJ8bj4+Nik8PGhbMyZyKytdOihuPDU1Mjk2fHw1NzM0NDw9bj9vW3I+PjJdfD0oMjI0fG4+PjEyKTw8aFszJnIrK106KG49NjU1MzYrKCgxMDIzJm4pPDwxMHwxMDIzJmUuY2hhckNvZGVBdCgrK3UpKSxvW3I+PjJdfD0oMjQwfG4+PjE4KTw8aFszJnIrK10sb1tyPj4yXXw9KDEyOHxuPj4xMiY2Myk8PGhbMyZyKytdKSxvW3I+PjJdfD0oMTI4fG4+PjYmNjMpPDxoWzMmcisrXSksb1tyPj4yXXw9KDEyOHw2MyZuKTw8aFszJnIrK10pO2lmKHM8PSh0aGlzLmxhc3RCeXRlSW5kZXg9cikpe2Zvcih0aGlzLnN0YXJ0PXItcyx0aGlzLmJsb2NrPW9bYV0scj0wO3I8YTsrK3IpbFtyXV49b1tyXTtnKGwpLHRoaXMucmVzZXQ9ITB9ZWxzZSB0aGlzLnN0YXJ0PXJ9cmV0dXJuIHRoaXN9LG0ucHJvdG90eXBlLmZpbmFsaXplPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ibG9ja3MsdD10aGlzLmxhc3RCeXRlSW5kZXgscj10aGlzLmJsb2NrQ291bnQsbj10aGlzLnM7aWYoZVt0Pj4yXXw9dGhpcy5wYWRkaW5nWzMmdF0sdGhpcy5sYXN0Qnl0ZUluZGV4PT09dGhpcy5ieXRlQ291bnQpZm9yKGVbMF09ZVtyXSx0PTE7dDxyKzE7Kyt0KWVbdF09MDtmb3IoZVtyLTFdfD0yMTQ3NDgzNjQ4LHQ9MDt0PHI7Kyt0KW5bdF1ePWVbdF07ZyhuKX0sbS5wcm90b3R5cGUudG9TdHJpbmc9bS5wcm90b3R5cGUuaGV4PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0PXRoaXMuYmxvY2tDb3VudCxyPXRoaXMucyxuPXRoaXMub3V0cHV0QmxvY2tzLGk9dGhpcy5leHRyYUJ5dGVzLG89MCxzPTAsYT1cIlwiO3M8bjspe2ZvcihvPTA7bzx0JiZzPG47KytvLCsrcyllPXJbb10sYSs9dVtlPj40JjE1XSt1WzE1JmVdK3VbZT4+MTImMTVdK3VbZT4+OCYxNV0rdVtlPj4yMCYxNV0rdVtlPj4xNiYxNV0rdVtlPj4yOCYxNV0rdVtlPj4yNCYxNV07cyV0PT0wJiYoZyhyKSxvPTApfXJldHVybiBpJiYoZT1yW29dLDA8aSYmKGErPXVbZT4+NCYxNV0rdVsxNSZlXSksMTxpJiYoYSs9dVtlPj4xMiYxNV0rdVtlPj44JjE1XSksMjxpJiYoYSs9dVtlPj4yMCYxNV0rdVtlPj4xNiYxNV0pKSxhfSxtLnByb3RvdHlwZS5idWZmZXI9bS5wcm90b3R5cGUuYXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXt0aGlzLmZpbmFsaXplKCk7Zm9yKHZhciBlPXRoaXMuYmxvY2tDb3VudCx0PXRoaXMucyxyPXRoaXMub3V0cHV0QmxvY2tzLG49dGhpcy5leHRyYUJ5dGVzLGk9MCxvPTAscz10aGlzLm91dHB1dEJpdHM+PjMsYT1uP25ldyBBcnJheUJ1ZmZlcihyKzE8PDIpOm5ldyBBcnJheUJ1ZmZlcihzKSx1PW5ldyBVaW50MzJBcnJheShhKTtvPHI7KXtmb3IoaT0wO2k8ZSYmbzxyOysraSwrK28pdVtvXT10W2ldO28lZT09MCYmZyh0KX1yZXR1cm4gbiYmKHVbaV09dFtpXSxhPWEuc2xpY2UoMCxzKSksYX0sbS5wcm90b3R5cGUuZGlnZXN0PW0ucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0LHI9dGhpcy5ibG9ja0NvdW50LG49dGhpcy5zLGk9dGhpcy5vdXRwdXRCbG9ja3Msbz10aGlzLmV4dHJhQnl0ZXMscz0wLGE9MCx1PVtdO2E8aTspe2ZvcihzPTA7czxyJiZhPGk7KytzLCsrYSllPWE8PDIsdD1uW3NdLHVbZV09MjU1JnQsdVtlKzFdPXQ+PjgmMjU1LHVbZSsyXT10Pj4xNiYyNTUsdVtlKzNdPXQ+PjI0JjI1NTthJXI9PTAmJmcobil9cmV0dXJuIG8mJihlPWE8PDIsdD1uW3NdLDA8byYmKHVbZV09MjU1JnQpLDE8byYmKHVbZSsxXT10Pj44JjI1NSksMjxvJiYodVtlKzJdPXQ+PjE2JjI1NSkpLHV9O3ZhciBnPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG4saSxvLHMsYSx1LGwsaCxmLGMsZCxwLHYseSxtLGcsYix3LF8sTSxBLEUsUyxrLE4seCxQLEksVCxSLE8sQyxMLEIsRCxVLEYsaixHLEgseixWLEsscSxXLFosSixYLCQsUSxZLGVlLHRlLHJlLG5lLGllLG9lLHNlLGFlLHVlLGxlPTA7bGU8NDg7bGUrPTIpbj1lWzBdXmVbMTBdXmVbMjBdXmVbMzBdXmVbNDBdLGk9ZVsxXV5lWzExXV5lWzIxXV5lWzMxXV5lWzQxXSxvPWVbMl1eZVsxMl1eZVsyMl1eZVszMl1eZVs0Ml0scz1lWzNdXmVbMTNdXmVbMjNdXmVbMzNdXmVbNDNdLGE9ZVs0XV5lWzE0XV5lWzI0XV5lWzM0XV5lWzQ0XSx1PWVbNV1eZVsxNV1eZVsyNV1eZVszNV1eZVs0NV0sbD1lWzZdXmVbMTZdXmVbMjZdXmVbMzZdXmVbNDZdLGg9ZVs3XV5lWzE3XV5lWzI3XV5lWzM3XV5lWzQ3XSx0PShmPWVbOF1eZVsxOF1eZVsyOF1eZVszOF1eZVs0OF0pXihvPDwxfHM+Pj4zMSkscj0oYz1lWzldXmVbMTldXmVbMjldXmVbMzldXmVbNDldKV4oczw8MXxvPj4+MzEpLGVbMF1ePXQsZVsxXV49cixlWzEwXV49dCxlWzExXV49cixlWzIwXV49dCxlWzIxXV49cixlWzMwXV49dCxlWzMxXV49cixlWzQwXV49dCxlWzQxXV49cix0PW5eKGE8PDF8dT4+PjMxKSxyPWleKHU8PDF8YT4+PjMxKSxlWzJdXj10LGVbM11ePXIsZVsxMl1ePXQsZVsxM11ePXIsZVsyMl1ePXQsZVsyM11ePXIsZVszMl1ePXQsZVszM11ePXIsZVs0Ml1ePXQsZVs0M11ePXIsdD1vXihsPDwxfGg+Pj4zMSkscj1zXihoPDwxfGw+Pj4zMSksZVs0XV49dCxlWzVdXj1yLGVbMTRdXj10LGVbMTVdXj1yLGVbMjRdXj10LGVbMjVdXj1yLGVbMzRdXj10LGVbMzVdXj1yLGVbNDRdXj10LGVbNDVdXj1yLHQ9YV4oZjw8MXxjPj4+MzEpLHI9dV4oYzw8MXxmPj4+MzEpLGVbNl1ePXQsZVs3XV49cixlWzE2XV49dCxlWzE3XV49cixlWzI2XV49dCxlWzI3XV49cixlWzM2XV49dCxlWzM3XV49cixlWzQ2XV49dCxlWzQ3XV49cix0PWxeKG48PDF8aT4+PjMxKSxyPWheKGk8PDF8bj4+PjMxKSxlWzhdXj10LGVbOV1ePXIsZVsxOF1ePXQsZVsxOV1ePXIsZVsyOF1ePXQsZVsyOV1ePXIsZVszOF1ePXQsZVszOV1ePXIsZVs0OF1ePXQsZVs0OV1ePXIsZD1lWzBdLHA9ZVsxXSxLPWVbMTFdPDw0fGVbMTBdPj4+MjgscT1lWzEwXTw8NHxlWzExXT4+PjI4LE49ZVsyMF08PDN8ZVsyMV0+Pj4yOSx4PWVbMjFdPDwzfGVbMjBdPj4+Mjksb2U9ZVszMV08PDl8ZVszMF0+Pj4yMyxzZT1lWzMwXTw8OXxlWzMxXT4+PjIzLEc9ZVs0MF08PDE4fGVbNDFdPj4+MTQsSD1lWzQxXTw8MTh8ZVs0MF0+Pj4xNCxPPWVbMl08PDF8ZVszXT4+PjMxLEM9ZVszXTw8MXxlWzJdPj4+MzEsdj1lWzEzXTw8MTJ8ZVsxMl0+Pj4yMCx5PWVbMTJdPDwxMnxlWzEzXT4+PjIwLFc9ZVsyMl08PDEwfGVbMjNdPj4+MjIsWj1lWzIzXTw8MTB8ZVsyMl0+Pj4yMixQPWVbMzNdPDwxM3xlWzMyXT4+PjE5LEk9ZVszMl08PDEzfGVbMzNdPj4+MTksYWU9ZVs0Ml08PDJ8ZVs0M10+Pj4zMCx1ZT1lWzQzXTw8MnxlWzQyXT4+PjMwLFk9ZVs1XTw8MzB8ZVs0XT4+PjIsZWU9ZVs0XTw8MzB8ZVs1XT4+PjIsTD1lWzE0XTw8NnxlWzE1XT4+PjI2LEI9ZVsxNV08PDZ8ZVsxNF0+Pj4yNixtPWVbMjVdPDwxMXxlWzI0XT4+PjIxLGc9ZVsyNF08PDExfGVbMjVdPj4+MjEsSj1lWzM0XTw8MTV8ZVszNV0+Pj4xNyxYPWVbMzVdPDwxNXxlWzM0XT4+PjE3LFQ9ZVs0NV08PDI5fGVbNDRdPj4+MyxSPWVbNDRdPDwyOXxlWzQ1XT4+PjMsQT1lWzZdPDwyOHxlWzddPj4+NCxFPWVbN108PDI4fGVbNl0+Pj40LHRlPWVbMTddPDwyM3xlWzE2XT4+PjkscmU9ZVsxNl08PDIzfGVbMTddPj4+OSxEPWVbMjZdPDwyNXxlWzI3XT4+PjcsVT1lWzI3XTw8MjV8ZVsyNl0+Pj43LGI9ZVszNl08PDIxfGVbMzddPj4+MTEsdz1lWzM3XTw8MjF8ZVszNl0+Pj4xMSwkPWVbNDddPDwyNHxlWzQ2XT4+PjgsUT1lWzQ2XTw8MjR8ZVs0N10+Pj44LHo9ZVs4XTw8Mjd8ZVs5XT4+PjUsVj1lWzldPDwyN3xlWzhdPj4+NSxTPWVbMThdPDwyMHxlWzE5XT4+PjEyLGs9ZVsxOV08PDIwfGVbMThdPj4+MTIsbmU9ZVsyOV08PDd8ZVsyOF0+Pj4yNSxpZT1lWzI4XTw8N3xlWzI5XT4+PjI1LEY9ZVszOF08PDh8ZVszOV0+Pj4yNCxqPWVbMzldPDw4fGVbMzhdPj4+MjQsXz1lWzQ4XTw8MTR8ZVs0OV0+Pj4xOCxNPWVbNDldPDwxNHxlWzQ4XT4+PjE4LGVbMF09ZF5+diZtLGVbMV09cF5+eSZnLGVbMTBdPUFeflMmTixlWzExXT1FXn5rJngsZVsyMF09T15+TCZELGVbMjFdPUNefkImVSxlWzMwXT16Xn5LJlcsZVszMV09Vl5+cSZaLGVbNDBdPVlefnRlJm5lLGVbNDFdPWVlXn5yZSZpZSxlWzJdPXZefm0mYixlWzNdPXlefmcmdyxlWzEyXT1TXn5OJlAsZVsxM109a15+eCZJLGVbMjJdPUxefkQmRixlWzIzXT1CXn5VJmosZVszMl09S15+VyZKLGVbMzNdPXFeflomWCxlWzQyXT10ZV5+bmUmb2UsZVs0M109cmVefmllJnNlLGVbNF09bV5+YiZfLGVbNV09Z15+dyZNLGVbMTRdPU5eflAmVCxlWzE1XT14Xn5JJlIsZVsyNF09RF5+RiZHLGVbMjVdPVVefmomSCxlWzM0XT1XXn5KJiQsZVszNV09Wl5+WCZRLGVbNDRdPW5lXn5vZSZhZSxlWzQ1XT1pZV5+c2UmdWUsZVs2XT1iXn5fJmQsZVs3XT13Xn5NJnAsZVsxNl09UF5+VCZBLGVbMTddPUleflImRSxlWzI2XT1GXn5HJk8sZVsyN109al5+SCZDLGVbMzZdPUpefiQmeixlWzM3XT1YXn5RJlYsZVs0Nl09b2VefmFlJlksZVs0N109c2VefnVlJmVlLGVbOF09X15+ZCZ2LGVbOV09TV5+cCZ5LGVbMThdPVRefkEmUyxlWzE5XT1SXn5FJmssZVsyOF09R15+TyZMLGVbMjldPUhefkMmQixlWzM4XT0kXn56JkssZVszOV09UV5+ViZxLGVbNDhdPWFlXn5ZJnRlLGVbNDldPXVlXn5lZSZyZSxlWzBdXj1oZVtsZV0sZVsxXV49aGVbbGUrMV19O2lmKHQpXy5leHBvcnRzPWw7ZWxzZSBmb3IoYz0wO2M8Zi5sZW5ndGg7KytjKWVbZltjXV09bFtmW2NdXX0oKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHtfcHJvY2Vzczo0M31dLDQxOltmdW5jdGlvbihlLHQscil7ZnVuY3Rpb24gbihlLHQpe2lmKCFlKXRocm93IG5ldyBFcnJvcih0fHxcIkFzc2VydGlvbiBmYWlsZWRcIil9KHQuZXhwb3J0cz1uKS5lcXVhbD1mdW5jdGlvbihlLHQscil7aWYoZSE9dCl0aHJvdyBuZXcgRXJyb3Iocnx8XCJBc3NlcnRpb24gZmFpbGVkOiBcIitlK1wiICE9IFwiK3QpfX0se31dLDQyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cjtmdW5jdGlvbiBpKGUpe3JldHVybiAxPT09ZS5sZW5ndGg/XCIwXCIrZTplfWZ1bmN0aW9uIG8oZSl7Zm9yKHZhciB0PVwiXCIscj0wO3I8ZS5sZW5ndGg7cisrKXQrPWkoZVtyXS50b1N0cmluZygxNikpO3JldHVybiB0fW4udG9BcnJheT1mdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGUuc2xpY2UoKTtpZighZSlyZXR1cm5bXTt2YXIgcj1bXTtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspcltuXT0wfGVbbl07cmV0dXJuIHJ9aWYoXCJoZXhcIj09PXQpeyhlPWUucmVwbGFjZSgvW15hLXowLTldKy9naSxcIlwiKSkubGVuZ3RoJTIhPTAmJihlPVwiMFwiK2UpO2ZvcihuPTA7bjxlLmxlbmd0aDtuKz0yKXIucHVzaChwYXJzZUludChlW25dK2VbbisxXSwxNikpfWVsc2UgZm9yKG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZS5jaGFyQ29kZUF0KG4pLG89aT4+OCxzPTI1NSZpO28/ci5wdXNoKG8scyk6ci5wdXNoKHMpfXJldHVybiByfSxuLnplcm8yPWksbi50b0hleD1vLG4uZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJoZXhcIj09PXQ/byhlKTplfX0se31dLDQzOltmdW5jdGlvbihlLHQscil7dC5leHBvcnRzPXticm93c2VyOiEwfX0se31dLDQ0OltmdW5jdGlvbihlLHIsbyl7KGZ1bmN0aW9uKG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGwoZSl7dmFyIHk9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF0sbT0xNzc5MDMzNzAzLGc9MzE0NDEzNDI3NyxiPTEwMTM5MDQyNDIsdz0yNzczNDgwNzYyLF89MTM1OTg5MzExOSxNPTI2MDA4MjI5MjQsQT01Mjg3MzQ2MzUsRT0xNTQxNDU5MjI1LFM9bmV3IEFycmF5KDY0KTtmdW5jdGlvbiB0KGUpe2Zvcih2YXIgdD0wLHI9ZS5sZW5ndGg7NjQ8PXI7KXtmb3IodmFyIG4saSxvLHMsYT1tLHU9ZyxsPWIsaD13LGY9XyxjPU0sZD1BLHA9RSx2PTA7djwxNjt2KyspaT10KzQqdixTW3ZdPSgyNTUmZVtpXSk8PDI0fCgyNTUmZVtpKzFdKTw8MTZ8KDI1NSZlW2krMl0pPDw4fDI1NSZlW2krM107Zm9yKHY9MTY7djw2NDt2Kyspbz0oKG49U1t2LTJdKT4+PjE3fG48PDE1KV4obj4+PjE5fG48PDEzKV5uPj4+MTAscz0oKG49U1t2LTE1XSk+Pj43fG48PDI1KV4obj4+PjE4fG48PDE0KV5uPj4+MyxTW3ZdPShvK1Nbdi03XXwwKSsocytTW3YtMTZdfDApfDA7Zm9yKHY9MDt2PDY0O3YrKylvPSgoKGY+Pj42fGY8PDI2KV4oZj4+PjExfGY8PDIxKV4oZj4+PjI1fGY8PDcpKSsoZiZjXn5mJmQpfDApKyhwKyh5W3ZdK1Nbdl18MCl8MCl8MCxzPSgoYT4+PjJ8YTw8MzApXihhPj4+MTN8YTw8MTkpXihhPj4+MjJ8YTw8MTApKSsoYSZ1XmEmbF51JmwpfDAscD1kLGQ9YyxjPWYsZj1oK298MCxoPWwsbD11LHU9YSxhPW8rc3wwO209bSthfDAsZz1nK3V8MCxiPWIrbHwwLHc9dytofDAsXz1fK2Z8MCxNPU0rY3wwLEE9QStkfDAsRT1FK3B8MCx0Kz02NCxyLT02NH19dChlKTt2YXIgcixuPWUubGVuZ3RoJTY0LGk9ZS5sZW5ndGgvNTM2ODcwOTEyfDAsbz1lLmxlbmd0aDw8MyxzPW48NTY/NTY6MTIwLGE9ZS5zbGljZShlLmxlbmd0aC1uLGUubGVuZ3RoKTtmb3IoYS5wdXNoKDEyOCkscj0xK247cjxzO3IrKylhLnB1c2goMCk7cmV0dXJuIGEucHVzaChpPj4+MjQmMjU1KSxhLnB1c2goaT4+PjE2JjI1NSksYS5wdXNoKGk+Pj44JjI1NSksYS5wdXNoKGk+Pj4wJjI1NSksYS5wdXNoKG8+Pj4yNCYyNTUpLGEucHVzaChvPj4+MTYmMjU1KSxhLnB1c2gobz4+PjgmMjU1KSxhLnB1c2gobz4+PjAmMjU1KSx0KGEpLFttPj4+MjQmMjU1LG0+Pj4xNiYyNTUsbT4+PjgmMjU1LG0+Pj4wJjI1NSxnPj4+MjQmMjU1LGc+Pj4xNiYyNTUsZz4+PjgmMjU1LGc+Pj4wJjI1NSxiPj4+MjQmMjU1LGI+Pj4xNiYyNTUsYj4+PjgmMjU1LGI+Pj4wJjI1NSx3Pj4+MjQmMjU1LHc+Pj4xNiYyNTUsdz4+PjgmMjU1LHc+Pj4wJjI1NSxfPj4+MjQmMjU1LF8+Pj4xNiYyNTUsXz4+PjgmMjU1LF8+Pj4wJjI1NSxNPj4+MjQmMjU1LE0+Pj4xNiYyNTUsTT4+PjgmMjU1LE0+Pj4wJjI1NSxBPj4+MjQmMjU1LEE+Pj4xNiYyNTUsQT4+PjgmMjU1LEE+Pj4wJjI1NSxFPj4+MjQmMjU1LEU+Pj4xNiYyNTUsRT4+PjgmMjU1LEU+Pj4wJjI1NV19ZnVuY3Rpb24gUChlLHQscil7ZT1lLmxlbmd0aDw9NjQ/ZTpsKGUpO2Zvcih2YXIgbj02NCt0Lmxlbmd0aCs0LGk9bmV3IEFycmF5KG4pLG89bmV3IEFycmF5KDY0KSxzPVtdLGE9MDthPDY0O2ErKylpW2FdPTU0O2ZvcihhPTA7YTxlLmxlbmd0aDthKyspaVthXV49ZVthXTtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKWlbNjQrYV09dFthXTtmb3IoYT1uLTQ7YTxuO2ErKylpW2FdPTA7Zm9yKGE9MDthPDY0O2ErKylvW2FdPTkyO2ZvcihhPTA7YTxlLmxlbmd0aDthKyspb1thXV49ZVthXTtmdW5jdGlvbiB1KCl7Zm9yKHZhciBlPW4tMTtuLTQ8PWU7ZS0tKXtpZihpW2VdKyssaVtlXTw9MjU1KXJldHVybjtpW2VdPTB9fWZvcig7MzI8PXI7KXUoKSxzPXMuY29uY2F0KGwoby5jb25jYXQobChpKSkpKSxyLT0zMjtyZXR1cm4gMDxyJiYodSgpLHM9cy5jb25jYXQobChvLmNvbmNhdChsKGkpKSkuc2xpY2UoMCxyKSkpLHN9ZnVuY3Rpb24gSShlLHQscixuLGkpe3ZhciBvO2ZvcihSKGUsMTYqKDIqci0xKSxpLDAsMTYpLG89MDtvPDIqcjtvKyspVChlLDE2Km8saSwxNiksZnVuY3Rpb24oZSx0KXtSKGUsMCx0LDAsMTYpO2Zvcih2YXIgcj04OzA8cjtyLT0yKXRbNF1ePXModFswXSt0WzEyXSw3KSx0WzhdXj1zKHRbNF0rdFswXSw5KSx0WzEyXV49cyh0WzhdK3RbNF0sMTMpLHRbMF1ePXModFsxMl0rdFs4XSwxOCksdFs5XV49cyh0WzVdK3RbMV0sNyksdFsxM11ePXModFs5XSt0WzVdLDkpLHRbMV1ePXModFsxM10rdFs5XSwxMyksdFs1XV49cyh0WzFdK3RbMTNdLDE4KSx0WzE0XV49cyh0WzEwXSt0WzZdLDcpLHRbMl1ePXModFsxNF0rdFsxMF0sOSksdFs2XV49cyh0WzJdK3RbMTRdLDEzKSx0WzEwXV49cyh0WzZdK3RbMl0sMTgpLHRbM11ePXModFsxNV0rdFsxMV0sNyksdFs3XV49cyh0WzNdK3RbMTVdLDkpLHRbMTFdXj1zKHRbN10rdFszXSwxMyksdFsxNV1ePXModFsxMV0rdFs3XSwxOCksdFsxXV49cyh0WzBdK3RbM10sNyksdFsyXV49cyh0WzFdK3RbMF0sOSksdFszXV49cyh0WzJdK3RbMV0sMTMpLHRbMF1ePXModFszXSt0WzJdLDE4KSx0WzZdXj1zKHRbNV0rdFs0XSw3KSx0WzddXj1zKHRbNl0rdFs1XSw5KSx0WzRdXj1zKHRbN10rdFs2XSwxMyksdFs1XV49cyh0WzRdK3RbN10sMTgpLHRbMTFdXj1zKHRbMTBdK3RbOV0sNyksdFs4XV49cyh0WzExXSt0WzEwXSw5KSx0WzldXj1zKHRbOF0rdFsxMV0sMTMpLHRbMTBdXj1zKHRbOV0rdFs4XSwxOCksdFsxMl1ePXModFsxNV0rdFsxNF0sNyksdFsxM11ePXModFsxMl0rdFsxNV0sOSksdFsxNF1ePXModFsxM10rdFsxMl0sMTMpLHRbMTVdXj1zKHRbMTRdK3RbMTNdLDE4KTtmb3Iocj0wO3I8MTY7KytyKWVbcl0rPXRbcl19KGksbiksUihpLDAsZSx0KzE2Km8sMTYpO2ZvcihvPTA7bzxyO28rKylSKGUsdCsyKm8qMTYsZSwxNipvLDE2KTtmb3Iobz0wO288cjtvKyspUihlLHQrMTYqKDIqbysxKSxlLDE2KihvK3IpLDE2KX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGU8PHR8ZT4+PjMyLXR9ZnVuY3Rpb24gVChlLHQscixuKXtmb3IodmFyIGk9MDtpPG47aSsrKXJbaV1ePWVbdCtpXX1mdW5jdGlvbiBSKGUsdCxyLG4saSl7Zm9yKDtpLS07KXJbbisrXT1lW3QrK119ZnVuY3Rpb24gaShlKXtpZihlJiZcIm51bWJlclwiPT10eXBlb2YgZS5sZW5ndGgpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtpZihcIm51bWJlclwiIT10eXBlb2YgZVt0XSlyZXR1cm47dmFyIHI9cGFyc2VJbnQoZVt0XSk7aWYociE9ZVt0XXx8cjwwfHwyNTY8PXIpcmV0dXJufXJldHVybiAxfX1mdW5jdGlvbiBPKGUsdCl7dmFyIHI9cGFyc2VJbnQoZSk7aWYoZSE9cil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFwiK3QpO3JldHVybiByfWZ1bmN0aW9uIGUobyxlLHMsYSx1LGwsaCl7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjYWxsYmFja1wiKTtpZihzPU8ocyxcIk5cIiksYT1PKGEsXCJyXCIpLHU9Tyh1LFwicFwiKSxsPU8obCxcImRrTGVuXCIpLDA9PT1zfHwwIT0ocyZzLTEpKXRocm93IG5ldyBFcnJvcihcIk4gbXVzdCBiZSBwb3dlciBvZiAyXCIpO2lmKEMvMTI4L2E8cyl0aHJvdyBuZXcgRXJyb3IoXCJOIHRvbyBsYXJnZVwiKTtpZihDLzEyOC91PGEpdGhyb3cgbmV3IEVycm9yKFwiciB0b28gbGFyZ2VcIik7aWYoIWkobykpdGhyb3cgbmV3IEVycm9yKFwicGFzc3dvcmQgbXVzdCBiZSBhbiBhcnJheSBvciBidWZmZXJcIik7aWYobz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvKSwhaShlKSl0aHJvdyBuZXcgRXJyb3IoXCJzYWx0IG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyXCIpO2U9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSk7Zm9yKHZhciBmPVAobyxlLDEyOCp1KmEpLGM9bmV3IFVpbnQzMkFycmF5KDMyKnUqYSksdD0wO3Q8Yy5sZW5ndGg7dCsrKXt2YXIgcj00KnQ7Y1t0XT0oMjU1JmZbMytyXSk8PDI0fCgyNTUmZlsyK3JdKTw8MTZ8KDI1NSZmWzErcl0pPDw4fCgyNTUmZlswK3JdKTw8MH12YXIgZCxwLHY9bmV3IFVpbnQzMkFycmF5KDY0KmEpLHk9bmV3IFVpbnQzMkFycmF5KDMyKmEqcyksbT0zMiphLGc9bmV3IFVpbnQzMkFycmF5KDE2KSxiPW5ldyBVaW50MzJBcnJheSgxNiksdz11KnMqMixfPTAsTT1udWxsLEE9ITEsRT0wLFM9MCxrPXBhcnNlSW50KDFlMy9hKSxOPXZvaWQgMCE9PW4/bjpzZXRUaW1lb3V0LHg9ZnVuY3Rpb24oKXtpZihBKXJldHVybiBoKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSxfL3cpO3N3aXRjaChFKXtjYXNlIDA6UihjLHA9MzIqUyphLHYsMCxtKSxFPTEsZD0wO2Nhc2UgMTprPCh0PXMtZCkmJih0PWspO2Zvcih2YXIgZT0wO2U8dDtlKyspUih2LDAseSwoZCtlKSptLG0pLEkodixtLGEsZyxiKTtpZihkKz10LF8rPXQsKHI9cGFyc2VJbnQoMWUzKl8vdykpIT09TSl7aWYoQT1oKG51bGwsXy93KSlicmVhaztNPXJ9aWYoZDxzKWJyZWFrO2Q9MCxFPTI7Y2FzZSAyOnZhciB0O2s8KHQ9cy1kKSYmKHQ9ayk7Zm9yKHZhciByLGU9MDtlPHQ7ZSsrKXt2YXIgbj12WzE2KigyKmEtMSldJnMtMTtUKHksbiptLHYsbSksSSh2LG0sYSxnLGIpfWlmKGQrPXQsXys9dCwocj1wYXJzZUludCgxZTMqXy93KSkhPT1NKXtpZihBPWgobnVsbCxfL3cpKWJyZWFrO009cn1pZihkPHMpYnJlYWs7aWYoUih2LDAsYyxwLG0pLCsrUzx1KXtFPTA7YnJlYWt9Zj1bXTtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKWYucHVzaChjW2VdPj4wJjI1NSksZi5wdXNoKGNbZV0+PjgmMjU1KSxmLnB1c2goY1tlXT4+MTYmMjU1KSxmLnB1c2goY1tlXT4+MjQmMjU1KTt2YXIgaT1QKG8sZixsKTtyZXR1cm4gaChudWxsLDEsaSl9Tih4KX07eCgpfXZhciB0LEM7dD10aGlzLEM9MjE0NzQ4MzY0Nyx2b2lkIDAhPT1vP3IuZXhwb3J0cz1lOnQmJih0LnNjcnlwdCYmKHQuX3NjcnlwdD10LnNjcnlwdCksdC5zY3J5cHQ9ZSl9KS5jYWxsKHRoaXMsZShcInRpbWVyc1wiKS5zZXRJbW1lZGlhdGUpfSx7dGltZXJzOjQ2fV0sNDU6W2Z1bmN0aW9uKGUsdCxyKXsoZnVuY3Rpb24oeSxlLHQpeyFmdW5jdGlvbihyLG4pe1widXNlIHN0cmljdFwiO3ZhciB0LGksbyxzLGUsYSx1LGwsaDtmdW5jdGlvbiBmKGUpe3JldHVybiBpW3RdPWMuYXBwbHkobixlKSx0Kyt9ZnVuY3Rpb24gYyhlKXt2YXIgdD1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UuYXBwbHkobix0KTpuZXcgRnVuY3Rpb24oXCJcIitlKSgpfX1mdW5jdGlvbiBkKGUpe2lmKG8pc2V0VGltZW91dChjKGQsZSksMCk7ZWxzZXt2YXIgdD1pW2VdO2lmKHQpe289ITA7dHJ5e3QoKX1maW5hbGx5e3AoZSksbz0hMX19fX1mdW5jdGlvbiBwKGUpe2RlbGV0ZSBpW2VdfWZ1bmN0aW9uIHYoZSl7ZS5zb3VyY2U9PT1yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYwPT09ZS5kYXRhLmluZGV4T2YobCkmJmQoK2UuZGF0YS5zbGljZShsLmxlbmd0aCkpfXIuc2V0SW1tZWRpYXRlfHwodD0xLG89IShpPXt9KSxzPXIuZG9jdW1lbnQsaD0oaD1PYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihyKSkmJmguc2V0VGltZW91dD9oOnIsZT1cIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwoci5wcm9jZXNzKT9mdW5jdGlvbigpe3ZhciBlPWYoYXJndW1lbnRzKTtyZXR1cm4geS5uZXh0VGljayhjKGQsZSkpLGV9OmZ1bmN0aW9uKCl7aWYoci5wb3N0TWVzc2FnZSYmIXIuaW1wb3J0U2NyaXB0cyl7dmFyIGU9ITAsdD1yLm9ubWVzc2FnZTtyZXR1cm4gci5vbm1lc3NhZ2U9ZnVuY3Rpb24oKXtlPSExfSxyLnBvc3RNZXNzYWdlKFwiXCIsXCIqXCIpLHIub25tZXNzYWdlPXQsZX19KCk/KGw9XCJzZXRJbW1lZGlhdGUkXCIrTWF0aC5yYW5kb20oKStcIiRcIixyLmFkZEV2ZW50TGlzdGVuZXI/ci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHYsITEpOnIuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIix2KSxmdW5jdGlvbigpe3ZhciBlPWYoYXJndW1lbnRzKTtyZXR1cm4gci5wb3N0TWVzc2FnZShsK2UsXCIqXCIpLGV9KTpyLk1lc3NhZ2VDaGFubmVsPygodT1uZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbihlKXtkKGUuZGF0YSl9LGZ1bmN0aW9uKCl7dmFyIGU9Zihhcmd1bWVudHMpO3JldHVybiB1LnBvcnQyLnBvc3RNZXNzYWdlKGUpLGV9KTpzJiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gcy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpPyhhPXMuZG9jdW1lbnRFbGVtZW50LGZ1bmN0aW9uKCl7dmFyIGU9Zihhcmd1bWVudHMpLHQ9cy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO3JldHVybiB0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2QoZSksdC5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxhLnJlbW92ZUNoaWxkKHQpLHQ9bnVsbH0sYS5hcHBlbmRDaGlsZCh0KSxlfSk6ZnVuY3Rpb24oKXt2YXIgZT1mKGFyZ3VtZW50cyk7cmV0dXJuIHNldFRpbWVvdXQoYyhkLGUpLDApLGV9LGguc2V0SW1tZWRpYXRlPWUsaC5jbGVhckltbWVkaWF0ZT1wKX0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/dm9pZCAwPT09ZT90aGlzOmU6c2VsZil9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30sZShcInRpbWVyc1wiKS5jbGVhckltbWVkaWF0ZSl9LHtfcHJvY2Vzczo0Myx0aW1lcnM6NDZ9XSw0NjpbZnVuY3Rpb24oZSx0LHIpeyhmdW5jdGlvbihlKXt0LmV4cG9ydHM9e3NldEltbWVkaWF0ZTplLnNldEltbWVkaWF0ZX19KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHt9XSw0NzpbZnVuY3Rpb24oZSxpLHQpeyhmdW5jdGlvbihlKXt2YXIgdCxyLG47ZS5jcnlwdG8mJmNyeXB0by5nZXRSYW5kb21WYWx1ZXMmJih0PW5ldyBVaW50OEFycmF5KDE2KSxyPWZ1bmN0aW9uKCl7cmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdH0pLHJ8fChuPW5ldyBBcnJheSgxNikscj1mdW5jdGlvbigpe2Zvcih2YXIgZSx0PTA7dDwxNjt0KyspMD09KDMmdCkmJihlPTQyOTQ5NjcyOTYqTWF0aC5yYW5kb20oKSksblt0XT1lPj4+KCgzJnQpPDwzKSYyNTU7cmV0dXJuIG59KSxpLmV4cG9ydHM9cn0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Ont9KX0se31dLDQ4OltmdW5jdGlvbihlLHQscil7Zm9yKHZhciBzPWUoXCIuL3JuZ1wiKSxuPVtdLG89e30saT0wO2k8MjU2O2krKyluW2ldPShpKzI1NikudG9TdHJpbmcoMTYpLnN1YnN0cigxKSxvW25baV1dPWk7ZnVuY3Rpb24gZChlLHQpe3ZhciByPXR8fDA7cmV0dXJuIG5bZVtyKytdXStuW2VbcisrXV0rbltlW3IrK11dK25bZVtyKytdXStcIi1cIituW2VbcisrXV0rbltlW3IrK11dK1wiLVwiK25bZVtyKytdXStuW2VbcisrXV0rXCItXCIrbltlW3IrK11dK25bZVtyKytdXStcIi1cIituW2VbcisrXV0rbltlW3IrK11dK25bZVtyKytdXStuW2VbcisrXV0rbltlW3IrK11dK25bZVtyKytdXX12YXIgYT1zKCkscD1bMXxhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XV0sdj0xNjM4MyYoYVs2XTw8OHxhWzddKSx5PTAsbT0wO2Z1bmN0aW9uIHUoZSx0LHIpe3ZhciBuPXQmJnJ8fDA7XCJzdHJpbmdcIj09dHlwZW9mIGUmJih0PVwiYmluYXJ5XCI9PWU/bmV3IEFycmF5KDE2KTpudWxsLGU9bnVsbCk7dmFyIGk9KGU9ZXx8e30pLnJhbmRvbXx8KGUucm5nfHxzKSgpO2lmKGlbNl09MTUmaVs2XXw2NCxpWzhdPTYzJmlbOF18MTI4LHQpZm9yKHZhciBvPTA7bzwxNjtvKyspdFtuK29dPWlbb107cmV0dXJuIHR8fGQoaSl9dmFyIGw9dTtsLnYxPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10JiZyfHwwLGk9dHx8W10sbz12b2lkIDAhPT0oZT1lfHx7fSkuY2xvY2tzZXE/ZS5jbG9ja3NlcTp2LHM9dm9pZCAwIT09ZS5tc2Vjcz9lLm1zZWNzOihuZXcgRGF0ZSkuZ2V0VGltZSgpLGE9dm9pZCAwIT09ZS5uc2Vjcz9lLm5zZWNzOm0rMSx1PXMteSsoYS1tKS8xZTQ7aWYodTwwJiZ2b2lkIDA9PT1lLmNsb2Nrc2VxJiYobz1vKzEmMTYzODMpLCh1PDB8fHk8cykmJnZvaWQgMD09PWUubnNlY3MmJihhPTApLDFlNDw9YSl0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTt5PXMsdj1vO3ZhciBsPSgxZTQqKDI2ODQzNTQ1NSYocys9MTIyMTkyOTI4ZTUpKSsobT1hKSklNDI5NDk2NzI5NjtpW24rK109bD4+PjI0JjI1NSxpW24rK109bD4+PjE2JjI1NSxpW24rK109bD4+PjgmMjU1LGlbbisrXT0yNTUmbDt2YXIgaD1zLzQyOTQ5NjcyOTYqMWU0JjI2ODQzNTQ1NTtpW24rK109aD4+PjgmMjU1LGlbbisrXT0yNTUmaCxpW24rK109aD4+PjI0JjE1fDE2LGlbbisrXT1oPj4+MTYmMjU1LGlbbisrXT1vPj4+OHwxMjgsaVtuKytdPTI1NSZvO2Zvcih2YXIgZj1lLm5vZGV8fHAsYz0wO2M8NjtjKyspaVtuK2NdPWZbY107cmV0dXJuIHR8fGQoaSl9LGwudjQ9dSxsLnBhcnNlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10JiZyfHwwLGk9MDtmb3IodD10fHxbXSxlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZyxmdW5jdGlvbihlKXtpPDE2JiYodFtuK2krK109b1tlXSl9KTtpPDE2Oyl0W24raSsrXT0wO3JldHVybiB0fSxsLnVucGFyc2U9ZCx0LmV4cG9ydHM9bH0se1wiLi9ybmdcIjo0N31dLDQ5OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dHJ5e3QuZXhwb3J0cy5YTUxIdHRwUmVxdWVzdD1YTUxIdHRwUmVxdWVzdH1jYXRjaChlKXtjb25zb2xlLmxvZyhcIldhcm5pbmc6IFhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBkZWZpbmVkXCIpLHQuZXhwb3J0cy5YTUxIdHRwUmVxdWVzdD1udWxsfX0se31dLDUwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksaT0oby5pc1Byb3ZpZGVyPWZ1bmN0aW9uKGUpe3JldHVybiBuLmlzVHlwZShlLFwiUHJvdmlkZXJcIil9LG8pO2Z1bmN0aW9uIG8oKXtuLnNldFR5cGUodGhpcyxcIlByb3ZpZGVyXCIpfXIuUHJvdmlkZXI9aX0se1wiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0fV0sNTE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihyLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgcil9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZShcIi4uL3V0aWxzL2FkZHJlc3NcIiksYT1lKFwiLi4vdXRpbHMvYmlnbnVtYmVyXCIpLHU9ZShcIi4uL3V0aWxzL2J5dGVzXCIpLGw9ZShcIi4uL2NvbnN0YW50c1wiKSxoPWUoXCIuLi91dGlscy9oYXNoXCIpLGY9ZShcIi4uL3V0aWxzL25ldHdvcmtzXCIpLGM9ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksZD1lKFwiLi4vdXRpbHMvcmxwXCIpLHA9ZShcIi4uL3V0aWxzL3RyYW5zYWN0aW9uXCIpLHY9ZShcIi4uL3V0aWxzL3V0ZjhcIikseT1lKFwiLi4vdXRpbHMvd2ViXCIpLG09byhlKFwiLi4vZXJyb3JzXCIpKSxnPWUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyXCIpO2Z1bmN0aW9uIGIoZSx0KXt2YXIgcj17fTtmb3IodmFyIG4gaW4gZSl0cnl7dmFyIGk9ZVtuXSh0W25dKTt2b2lkIDAhPT1pJiYocltuXT1pKX1jYXRjaChlKXt0aHJvdyBlLmNoZWNrS2V5PW4sZS5jaGVja1ZhbHVlPXRbbl0sZX1yZXR1cm4gcn1mdW5jdGlvbiB3KHQscil7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP3I6dChlKX19ZnVuY3Rpb24gXyhyKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO3ZhciB0PVtdO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7dC5wdXNoKHIoZSkpfSksdH19ZnVuY3Rpb24gTShlLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYodHx8XCIweFwiPT09ZS5zdWJzdHJpbmcoMCwyKXx8KGU9XCIweFwiK2UpLDMyPT09dS5oZXhEYXRhTGVuZ3RoKGUpKT9lLnRvTG93ZXJDYXNlKCk6KG0udGhyb3dFcnJvcihcImludmFsaWQgaGFzaFwiLG0uSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiaGFzaFwiLHZhbHVlOmV9KSxudWxsKX1mdW5jdGlvbiBBKGUpe3JldHVybiBhLmJpZ051bWJlcmlmeShlKS50b051bWJlcigpfWZ1bmN0aW9uIEUoZSl7aWYoIXUuaXNIZXhTdHJpbmcoZSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO2Zvcig7ZS5sZW5ndGg8NjY7KWU9XCIweDBcIitlLnN1YnN0cmluZygyKTtyZXR1cm4gZX1mdW5jdGlvbiBTKGUpe2lmKG51bGw9PWUpcmV0dXJuXCJsYXRlc3RcIjtpZihcImVhcmxpZXN0XCI9PT1lKXJldHVyblwiMHgwXCI7aWYoXCJsYXRlc3RcIj09PWV8fFwicGVuZGluZ1wiPT09ZSlyZXR1cm4gZTtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gdS5oZXhTdHJpcFplcm9zKHUuaGV4bGlmeShlKSk7aWYodS5pc0hleFN0cmluZyhlKSlyZXR1cm4gdS5oZXhTdHJpcFplcm9zKGUpO3Rocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIil9dmFyIGs9e2hhc2g6TSxibG9ja0hhc2g6dyhNLG51bGwpLGJsb2NrTnVtYmVyOncoQSxudWxsKSx0cmFuc2FjdGlvbkluZGV4OncoQSxudWxsKSxjb25maXJtYXRpb25zOncoQSxudWxsKSxmcm9tOnMuZ2V0QWRkcmVzcyxnYXNQcmljZTphLmJpZ051bWJlcmlmeSxnYXNMaW1pdDphLmJpZ051bWJlcmlmeSx0bzp3KHMuZ2V0QWRkcmVzcyxudWxsKSx2YWx1ZTphLmJpZ051bWJlcmlmeSxub25jZTpBLGRhdGE6dS5oZXhsaWZ5LHI6dyhFKSxzOncoRSksdjp3KEEpLGNyZWF0ZXM6dyhzLmdldEFkZHJlc3MsbnVsbCkscmF3OncodS5oZXhsaWZ5KX07ZnVuY3Rpb24gTihlKXt2YXIgdDtudWxsIT1lLmdhcyYmbnVsbD09ZS5nYXNMaW1pdCYmKGUuZ2FzTGltaXQ9ZS5nYXMpLGUudG8mJmEuYmlnTnVtYmVyaWZ5KGUudG8pLmlzWmVybygpJiYoZS50bz1cIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSxudWxsIT1lLmlucHV0JiZudWxsPT1lLmRhdGEmJihlLmRhdGE9ZS5pbnB1dCksbnVsbD09ZS50byYmbnVsbD09ZS5jcmVhdGVzJiYoZS5jcmVhdGVzPXMuZ2V0Q29udHJhY3RBZGRyZXNzKGUpKSxlLnJhd3x8ZS52JiZlLnImJmUucyYmKHQ9W3Uuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5ub25jZSkpLHUuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5nYXNQcmljZSkpLHUuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5nYXNMaW1pdCkpLGUudG98fFwiMHhcIix1LnN0cmlwWmVyb3ModS5oZXhsaWZ5KGUudmFsdWV8fFwiMHhcIikpLHUuaGV4bGlmeShlLmRhdGF8fFwiMHhcIiksdS5zdHJpcFplcm9zKHUuaGV4bGlmeShlLnZ8fFwiMHhcIikpLHUuc3RyaXBaZXJvcyh1LmhleGxpZnkoZS5yKSksdS5zdHJpcFplcm9zKHUuaGV4bGlmeShlLnMpKV0sZS5yYXc9ZC5lbmNvZGUodCkpO3ZhciByPWIoayxlKSxuPWUubmV0d29ya0lkO3JldHVybiBudWxsIT1lLmNoYWluSWQmJm51bGw9PW4mJm51bGw9PXIudiYmKG49ZS5jaGFpbklkKSx1LmlzSGV4U3RyaW5nKG4pJiYobj1hLmJpZ051bWJlcmlmeShuKS50b051bWJlcigpKSxcIm51bWJlclwiIT10eXBlb2YgbiYmbnVsbCE9ci52JiYoKG49KHIudi0zNSkvMik8MCYmKG49MCksbj1wYXJzZUludChuKSksXCJudW1iZXJcIiE9dHlwZW9mIG4mJihuPTApLHIubmV0d29ya0lkPW4sbnVsbD09ci5jaGFpbklkJiZudWxsIT1uJiYoci5jaGFpbklkPW4pLHIuYmxvY2tIYXNoJiZcInhcIj09PXIuYmxvY2tIYXNoLnJlcGxhY2UoLzAvZyxcIlwiKSYmKHIuYmxvY2tIYXNoPW51bGwpLHJ9dmFyIHg9e2hhc2g6TSxwYXJlbnRIYXNoOk0sbnVtYmVyOkEsdGltZXN0YW1wOkEsbm9uY2U6dyh1LmhleGxpZnkpLGRpZmZpY3VsdHk6ZnVuY3Rpb24oZSl7dmFyIHQ9YS5iaWdOdW1iZXJpZnkoZSk7dHJ5e3JldHVybiB0LnRvTnVtYmVyKCl9Y2F0Y2goZSl7fXJldHVybiBudWxsfSxnYXNMaW1pdDphLmJpZ051bWJlcmlmeSxnYXNVc2VkOmEuYmlnTnVtYmVyaWZ5LG1pbmVyOnMuZ2V0QWRkcmVzcyxleHRyYURhdGE6dS5oZXhsaWZ5LHRyYW5zYWN0aW9uczp3KF8oTSkpfSxQPWMuc2hhbGxvd0NvcHkoeCk7ZnVuY3Rpb24gSShlLHQpe3JldHVybiBudWxsIT1lLmF1dGhvciYmbnVsbD09ZS5taW5lciYmKGUubWluZXI9ZS5hdXRob3IpLGIodD9QOngsZSl9UC50cmFuc2FjdGlvbnM9dyhfKE4pKTt2YXIgVD17ZnJvbTp3KHMuZ2V0QWRkcmVzcyksbm9uY2U6dyhBKSxnYXNMaW1pdDp3KGEuYmlnTnVtYmVyaWZ5KSxnYXNQcmljZTp3KGEuYmlnTnVtYmVyaWZ5KSx0bzp3KHMuZ2V0QWRkcmVzcyksdmFsdWU6dyhhLmJpZ051bWJlcmlmeSksZGF0YTp3KHUuaGV4bGlmeSl9O2Z1bmN0aW9uIFIoZSl7cmV0dXJuIGIoVCxlKX12YXIgTz17dHJhbnNhY3Rpb25Mb2dJbmRleDp3KEEpLHRyYW5zYWN0aW9uSW5kZXg6QSxibG9ja051bWJlcjpBLHRyYW5zYWN0aW9uSGFzaDpNLGFkZHJlc3M6cy5nZXRBZGRyZXNzLHRvcGljczpfKE0pLGRhdGE6dS5oZXhsaWZ5LGxvZ0luZGV4OkEsYmxvY2tIYXNoOk19O3ZhciBDPXt0bzp3KHMuZ2V0QWRkcmVzcyxudWxsKSxmcm9tOncocy5nZXRBZGRyZXNzLG51bGwpLGNvbnRyYWN0QWRkcmVzczp3KHMuZ2V0QWRkcmVzcyxudWxsKSx0cmFuc2FjdGlvbkluZGV4OkEscm9vdDp3KE0pLGdhc1VzZWQ6YS5iaWdOdW1iZXJpZnksbG9nc0Jsb29tOncodS5oZXhsaWZ5KSxibG9ja0hhc2g6TSx0cmFuc2FjdGlvbkhhc2g6TSxsb2dzOl8oZnVuY3Rpb24oZSl7cmV0dXJuIGIoTyxlKX0pLGJsb2NrTnVtYmVyOkEsY29uZmlybWF0aW9uczp3KEEsbnVsbCksY3VtdWxhdGl2ZUdhc1VzZWQ6YS5iaWdOdW1iZXJpZnksc3RhdHVzOncoQSl9O2Z1bmN0aW9uIEwoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe0woZSl9KTpudWxsIT1lJiZNKGUpLGV9dmFyIEI9e2Zyb21CbG9jazp3KFMsdm9pZCAwKSx0b0Jsb2NrOncoUyx2b2lkIDApLGFkZHJlc3M6dyhzLmdldEFkZHJlc3Msdm9pZCAwKSx0b3BpY3M6dyhMLHZvaWQgMCl9LEQ9e2Jsb2NrSGFzaDp3KE0sdm9pZCAwKSxhZGRyZXNzOncocy5nZXRBZGRyZXNzLHZvaWQgMCksdG9waWNzOncoTCx2b2lkIDApfTt2YXIgVSxGLGo9e2Jsb2NrTnVtYmVyOncoQSksYmxvY2tIYXNoOncoTSksdHJhbnNhY3Rpb25JbmRleDpBLHJlbW92ZWQ6dyhmdW5jdGlvbihlKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGUpcmV0dXJuIGU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKFwidHJ1ZVwiPT09ZSlyZXR1cm4hMDtpZihcImZhbHNlXCI9PT1lKXJldHVybiExfXRocm93IG5ldyBFcnJvcihcImludmFpZCBib29sZWFuIC0gXCIrZSl9KSxhZGRyZXNzOnMuZ2V0QWRkcmVzcyxkYXRhOihVPXUuaGV4bGlmeSxGPVwiMHhcIixmdW5jdGlvbihlKXtyZXR1cm4gZT9VKGUpOkZ9KSx0b3BpY3M6XyhNKSx0cmFuc2FjdGlvbkhhc2g6TSxsb2dJbmRleDpBfTtmdW5jdGlvbiBHKGUpe3JldHVybiBiKGosZSl9ZnVuY3Rpb24gSChlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpBcnJheS5pc0FycmF5KGUpPyhlLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9PWUmJjMyIT09dS5oZXhEYXRhTGVuZ3RoKGUpJiZtLnRocm93RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsbS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInRvcGljXCIsdmFsdWU6ZX0pfSksZS5qb2luKFwiLFwiKSk6bnVsbD09PWU/XCJcIjptLnRocm93RXJyb3IoXCJpbnZhbGlkIHRvcGljIHZhbHVlXCIsbS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInRvcGljXCIsdmFsdWU6ZX0pfSkuam9pbihcIiZcIil9ZnVuY3Rpb24geihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoMjA9PT11LmhleERhdGFMZW5ndGgoZSkpcmV0dXJuXCJhZGRyZXNzOlwiK3MuZ2V0QWRkcmVzcyhlKTtpZihlPWUudG9Mb3dlckNhc2UoKSwzMj09PXUuaGV4RGF0YUxlbmd0aChlKSlyZXR1cm5cInR4OlwiK2U7aWYoLTE9PT1lLmluZGV4T2YoXCI6XCIpKXJldHVybiBlfWVsc2V7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm5cImZpbHRlcjo6XCIrSChlKTtpZihlJiZcIm9iamVjdFwiPT10eXBlb2YgZSlyZXR1cm5cImZpbHRlcjpcIisoZS5hZGRyZXNzfHxcIlwiKStcIjpcIitIKGUudG9waWNzfHxbXSl9dGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiK2UpfWZ1bmN0aW9uIFYoKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX12YXIgSyxxPShLPWcuUHJvdmlkZXIsaShXLEspLFcucHJvdG90eXBlLl9kb1BvbGw9ZnVuY3Rpb24oKXt2YXIgdT10aGlzO3RoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKGZ1bmN0aW9uKHMpe2lmKHUucG9sbGluZyYmKHUuX3NldEZhc3RCbG9ja051bWJlcihzKSxzIT09dS5fbGFzdEJsb2NrTnVtYmVyKSl7LTI9PT11Ll9lbWl0dGVkLmJsb2NrJiYodS5fZW1pdHRlZC5ibG9jaz1zLTEpO2Zvcih2YXIgZT11Ll9lbWl0dGVkLmJsb2NrKzE7ZTw9cztlKyspdS5lbWl0KFwiYmxvY2tcIixlKTt1Ll9lbWl0dGVkLmJsb2NrIT09cyYmKHUuX2VtaXR0ZWQuYmxvY2s9cyxPYmplY3Qua2V5cyh1Ll9lbWl0dGVkKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0O1wiYmxvY2tcIj09PWV8fFwicGVuZGluZ1wiIT09KHQ9dS5fZW1pdHRlZFtlXSkmJjEyPHMtdCYmZGVsZXRlIHUuX2VtaXR0ZWRbZV19KSksLTI9PT11Ll9sYXN0QmxvY2tOdW1iZXImJih1Ll9sYXN0QmxvY2tOdW1iZXI9cy0xKTt2YXIgYT17fSx0PXt9O3JldHVybiB1Ll9ldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKXt0W2UudGFnXT0hMH0pLE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIjpcIik7c3dpdGNoKHRbMF0pe2Nhc2VcInR4XCI6dmFyIHI9dFsxXTt1LmdldFRyYW5zYWN0aW9uUmVjZWlwdChyKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlJiZudWxsIT1lLmJsb2NrTnVtYmVyJiYodS5fZW1pdHRlZFtcInQ6XCIrcl09ZS5ibG9ja051bWJlcix1LmVtaXQocixlKSksbnVsbH0pLmNhdGNoKGZ1bmN0aW9uKGUpe3UuZW1pdChcImVycm9yXCIsZSl9KTticmVhaztjYXNlXCJhZGRyZXNzXCI6dmFyIG49dFsxXTt1Ll9iYWxhbmNlc1tuXSYmKGFbbl09dS5fYmFsYW5jZXNbbl0pLHUuZ2V0QmFsYW5jZShuLFwibGF0ZXN0XCIpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9dS5fYmFsYW5jZXNbbl07aWYoIXR8fCFlLmVxKHQpKXJldHVybiB1Ll9iYWxhbmNlc1tuXT1lLHUuZW1pdChuLGUpLG51bGx9KS5jYXRjaChmdW5jdGlvbihlKXt1LmVtaXQoXCJlcnJvclwiLGUpfSk7YnJlYWs7Y2FzZVwiZmlsdGVyXCI6dmFyIGk9dFsyXS5zcGxpdCgvJi9nKS5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIixcIik7cmV0dXJuIDE9PT10Lmxlbmd0aD9cIlwiPT09dFswXT9udWxsOmU6dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJcIj09PWU/bnVsbDplfSl9KSxvPXthZGRyZXNzOnRbMV0sZnJvbUJsb2NrOnUuX2xhc3RCbG9ja051bWJlcisxLHRvQmxvY2s6cyx0b3BpY3M6aX07by5hZGRyZXNzfHxkZWxldGUgby5hZGRyZXNzLHUuZ2V0TG9ncyhvKS50aGVuKGZ1bmN0aW9uKGUpe2lmKDAhPT1lLmxlbmd0aClyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3UuX2VtaXR0ZWRbXCJiOlwiK2UuYmxvY2tIYXNoXT1lLmJsb2NrTnVtYmVyLHUuX2VtaXR0ZWRbXCJ0OlwiK2UudHJhbnNhY3Rpb25IYXNoXT1lLmJsb2NrTnVtYmVyLHUuZW1pdChvLGUpfSksbnVsbH0pLmNhdGNoKGZ1bmN0aW9uKGUpe3UuZW1pdChcImVycm9yXCIsZSl9KX19KSx1Ll9sYXN0QmxvY2tOdW1iZXI9cyx1Ll9iYWxhbmNlcz1hLG51bGx9fSkuY2F0Y2goZnVuY3Rpb24oZSl7fSksdGhpcy5kb1BvbGwoKX0sVy5wcm90b3R5cGUucmVzZXRFdmVudHNCbG9jaz1mdW5jdGlvbihlKXt0aGlzLl9sYXN0QmxvY2tOdW1iZXI9ZS0xLHRoaXMucG9sbGluZyYmdGhpcy5fZG9Qb2xsKCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXLnByb3RvdHlwZSxcIm5ldHdvcmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25ldHdvcmt9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksVy5wcm90b3R5cGUuZ2V0TmV0d29yaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWR5fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVy5wcm90b3R5cGUsXCJibG9ja051bWJlclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXLnByb3RvdHlwZSxcInBvbGxpbmdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuX3BvbGxlcn0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe2UmJiF0Ll9wb2xsZXI/KHQuX3BvbGxlcj1zZXRJbnRlcnZhbCh0Ll9kb1BvbGwuYmluZCh0KSx0LnBvbGxpbmdJbnRlcnZhbCksdC5fZG9Qb2xsKCkpOiFlJiZ0Ll9wb2xsZXImJihjbGVhckludGVydmFsKHQuX3BvbGxlciksdC5fcG9sbGVyPW51bGwpfSwwKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVy5wcm90b3R5cGUsXCJwb2xsaW5nSW50ZXJ2YWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvbGxpbmdJbnRlcnZhbH0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fGU8PTB8fHBhcnNlSW50KFN0cmluZyhlKSkhPWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2xsaW5nIGludGVydmFsXCIpO3RoaXMuX3BvbGxpbmdJbnRlcnZhbD1lLHRoaXMuX3BvbGxlciYmKGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKSx0aGlzLl9wb2xsZXI9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXt0Ll9kb1BvbGwoKX0sdGhpcy5fcG9sbGluZ0ludGVydmFsKSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksVy5wcm90b3R5cGUuX2dldEZhc3RCbG9ja051bWJlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1WKCk7cmV0dXJuIGUtdGhpcy5fZmFzdFF1ZXJ5RGF0ZT4yKnRoaXMuX3BvbGxpbmdJbnRlcnZhbCYmKHRoaXMuX2Zhc3RRdWVyeURhdGU9ZSx0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlPXRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybihudWxsPT10Ll9mYXN0QmxvY2tOdW1iZXJ8fGU+dC5fZmFzdEJsb2NrTnVtYmVyKSYmKHQuX2Zhc3RCbG9ja051bWJlcj1lKSx0Ll9mYXN0QmxvY2tOdW1iZXJ9KSksdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZX0sVy5wcm90b3R5cGUuX3NldEZhc3RCbG9ja051bWJlcj1mdW5jdGlvbihlKXtudWxsIT10aGlzLl9mYXN0QmxvY2tOdW1iZXImJmU8dGhpcy5fZmFzdEJsb2NrTnVtYmVyfHwodGhpcy5fZmFzdFF1ZXJ5RGF0ZT1WKCksKG51bGw9PXRoaXMuX2Zhc3RCbG9ja051bWJlcnx8ZT50aGlzLl9mYXN0QmxvY2tOdW1iZXIpJiYodGhpcy5fZmFzdEJsb2NrTnVtYmVyPWUsdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZT1Qcm9taXNlLnJlc29sdmUoZSkpKX0sVy5wcm90b3R5cGUud2FpdEZvclRyYW5zYWN0aW9uPWZ1bmN0aW9uKG4saSl7dmFyIG89dGhpcztyZXR1cm4gbnVsbD09aSYmKGk9MSksdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQobikudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gMD09PWl8fGUmJmUuY29uZmlybWF0aW9ucz49aT9lOm5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3ZhciByPWZ1bmN0aW9uKGUpe2UuY29uZmlybWF0aW9uczxpfHwoby5yZW1vdmVMaXN0ZW5lcihuLHIpLHQoZSkpfTtvLm9uKG4scil9KX0pfSxXLnByb3RvdHlwZS5nZXRCbG9ja051bWJlcj1mdW5jdGlvbigpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiByLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLHt9KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXBhcnNlSW50KGUpO2lmKHQhPWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIGdldEJsb2NrTnVtYmVyXCIpO3JldHVybiByLl9zZXRGYXN0QmxvY2tOdW1iZXIodCksdH0pfSl9LFcucHJvdG90eXBlLmdldEdhc1ByaWNlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGUucGVyZm9ybShcImdldEdhc1ByaWNlXCIse30pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGEuYmlnTnVtYmVyaWZ5KGUpfSl9KX0sVy5wcm90b3R5cGUuZ2V0QmFsYW5jZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzT3JOYW1lOmUsYmxvY2tUYWc6dH0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hZGRyZXNzT3JOYW1lLHI9ZS5ibG9ja1RhZztyZXR1cm4gbi5fZ2V0QWRkcmVzcyh0KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXthZGRyZXNzOmUsYmxvY2tUYWc6UyhyKX07cmV0dXJuIG4ucGVyZm9ybShcImdldEJhbGFuY2VcIix0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBhLmJpZ051bWJlcmlmeShlKX0pfSl9KX0pfSxXLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkNvdW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXMoe2FkZHJlc3NPck5hbWU6ZSxibG9ja1RhZzp0fSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLmFkZHJlc3NPck5hbWUscj1lLmJsb2NrVGFnO3JldHVybiBuLl9nZXRBZGRyZXNzKHQpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9e2FkZHJlc3M6ZSxibG9ja1RhZzpTKHIpfTtyZXR1cm4gbi5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGEuYmlnTnVtYmVyaWZ5KGUpLnRvTnVtYmVyKCl9KX0pfSl9KX0sVy5wcm90b3R5cGUuZ2V0Q29kZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHthZGRyZXNzT3JOYW1lOmUsYmxvY2tUYWc6dH0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hZGRyZXNzT3JOYW1lLHI9ZS5ibG9ja1RhZztyZXR1cm4gbi5fZ2V0QWRkcmVzcyh0KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXthZGRyZXNzOmUsYmxvY2tUYWc6UyhyKX07cmV0dXJuIG4ucGVyZm9ybShcImdldENvZGVcIix0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB1LmhleGxpZnkoZSl9KX0pfSl9KX0sVy5wcm90b3R5cGUuZ2V0U3RvcmFnZUF0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgaT10aGlzO3JldHVybiB0aGlzLnJlYWR5LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYy5yZXNvbHZlUHJvcGVydGllcyh7YWRkcmVzc09yTmFtZTplLHBvc2l0aW9uOnQsYmxvY2tUYWc6cn0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5hZGRyZXNzT3JOYW1lLHI9ZS5wb3NpdGlvbixuPWUuYmxvY2tUYWc7cmV0dXJuIGkuX2dldEFkZHJlc3ModCkudGhlbihmdW5jdGlvbihlKXt2YXIgdD17YWRkcmVzczplLGJsb2NrVGFnOlMobikscG9zaXRpb246dS5oZXhTdHJpcFplcm9zKHUuaGV4bGlmeShyKSl9O3JldHVybiBpLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIix0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB1LmhleGxpZnkoZSl9KX0pfSl9KX0sVy5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHtzaWduZWRUcmFuc2FjdGlvbjplfSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLnNpZ25lZFRyYW5zYWN0aW9uLHI9e3NpZ25lZFRyYW5zYWN0aW9uOnUuaGV4bGlmeSh0KX07cmV0dXJuIG4ucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG4uX3dyYXBUcmFuc2FjdGlvbihwLnBhcnNlKHQpLGUpfSxmdW5jdGlvbihlKXt0aHJvdyBlLnRyYW5zYWN0aW9uPXAucGFyc2UodCksZS50cmFuc2FjdGlvbi5oYXNoJiYoZS50cmFuc2FjdGlvbkhhc2g9ZS50cmFuc2FjdGlvbi5oYXNoKSxlfSl9KX0pfSxXLnByb3RvdHlwZS5fd3JhcFRyYW5zYWN0aW9uPWZ1bmN0aW9uKHIsZSl7dmFyIG49dGhpcztpZihudWxsIT1lJiYzMiE9PXUuaGV4RGF0YUxlbmd0aChlKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO3ZhciB0PXI7cmV0dXJuIG51bGwhPWUmJnIuaGFzaCE9PWUmJm0udGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsbS5VTktOT1dOX0VSUk9SLHtleHBlY3RlZEhhc2g6ci5oYXNoLHJldHVybmVkSGFzaDplfSksdC53YWl0PWZ1bmN0aW9uKHQpe3JldHVybiAwIT09dCYmKG4uX2VtaXR0ZWRbXCJ0OlwiK3IuaGFzaF09XCJwZW5kaW5nXCIpLG4ud2FpdEZvclRyYW5zYWN0aW9uKHIuaGFzaCx0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lJiYwPT09dD9udWxsOihuLl9lbWl0dGVkW1widDpcIityLmhhc2hdPWUuYmxvY2tOdW1iZXIsMD09PWUuc3RhdHVzJiZtLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIixtLkNBTExfRVhDRVBUSU9OLHt0cmFuc2FjdGlvbkhhc2g6ci5oYXNoLHRyYW5zYWN0aW9uOnJ9KSxlKX0pfSx0fSxXLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxyPWMuc2hhbGxvd0NvcHkoZSk7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKHtibG9ja1RhZzp0LHR4OnJ9KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciByPWUuYmxvY2tUYWcsdD1lLnR4O3JldHVybiBuLl9yZXNvbHZlTmFtZXModCxbXCJ0b1wiLFwiZnJvbVwiXSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD17YmxvY2tUYWc6UyhyKSx0cmFuc2FjdGlvbjpSKGUpfTtyZXR1cm4gbi5wZXJmb3JtKFwiY2FsbFwiLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHUuaGV4bGlmeShlKX0pfSl9KX0pfSxXLnByb3RvdHlwZS5lc3RpbWF0ZUdhcz1mdW5jdGlvbihlKXt2YXIgcj10aGlzLHQ9e3RvOmUudG8sZnJvbTplLmZyb20sZGF0YTplLmRhdGEsZ2FzUHJpY2U6ZS5nYXNQcmljZSx2YWx1ZTplLnZhbHVlfTtyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXModCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5fcmVzb2x2ZU5hbWVzKGUsW1widG9cIixcImZyb21cIl0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9e3RyYW5zYWN0aW9uOlIoZSl9O3JldHVybiByLnBlcmZvcm0oXCJlc3RpbWF0ZUdhc1wiLHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGEuYmlnTnVtYmVyaWZ5KGUpfSl9KX0pfSl9LFcucHJvdG90eXBlLmdldEJsb2NrPWZ1bmN0aW9uKGUsbyl7dmFyIHM9dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXMoe2Jsb2NrSGFzaE9yQmxvY2tUYWc6ZX0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ibG9ja0hhc2hPckJsb2NrVGFnO3RyeXt2YXIgcj11LmhleGxpZnkodCk7aWYoMzI9PT11LmhleERhdGFMZW5ndGgocikpcmV0dXJuIHkucG9sbChmdW5jdGlvbigpe3JldHVybiBzLnBlcmZvcm0oXCJnZXRCbG9ja1wiLHtibG9ja0hhc2g6cixpbmNsdWRlVHJhbnNhY3Rpb25zOiEhb30pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/bnVsbD09cy5fZW1pdHRlZFtcImI6XCIrcl0/bnVsbDp2b2lkIDA6SShlLG8pfSl9LHtvbmNlQmxvY2s6c30pfWNhdGNoKGUpe310cnl7dmFyIG49LTEyOCxpPVModCk7cmV0dXJuIHUuaXNIZXhTdHJpbmcoaSkmJihuPXBhcnNlSW50KGkuc3Vic3RyaW5nKDIpLDE2KSkseS5wb2xsKGZ1bmN0aW9uKCl7cmV0dXJuIHMucGVyZm9ybShcImdldEJsb2NrXCIse2Jsb2NrVGFnOmksaW5jbHVkZVRyYW5zYWN0aW9uczohIW99KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP0koZSxvKTpuPD1zLl9lbWl0dGVkLmJsb2NrP3ZvaWQgMDpudWxsfSl9LHtvbmNlQmxvY2s6c30pfWNhdGNoKGUpe310aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrIGhhc2ggb3IgYmxvY2sgdGFnXCIpfSl9KX0sVy5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5yZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGMucmVzb2x2ZVByb3BlcnRpZXMoe3RyYW5zYWN0aW9uSGFzaDplfSkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLnRyYW5zYWN0aW9uSGFzaCxyPXt0cmFuc2FjdGlvbkhhc2g6TSh0LCEwKX07cmV0dXJuIHkucG9sbChmdW5jdGlvbigpe3JldHVybiBuLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLHIpLnRoZW4oZnVuY3Rpb24oZSl7aWYobnVsbD09ZSlyZXR1cm4gbnVsbD09bi5fZW1pdHRlZFtcInQ6XCIrdF0/bnVsbDp2b2lkIDA7dmFyIHI9Vy5jaGVja1RyYW5zYWN0aW9uUmVzcG9uc2UoZSk7aWYobnVsbD09ci5ibG9ja051bWJlcilyLmNvbmZpcm1hdGlvbnM9MDtlbHNlIGlmKG51bGw9PXIuY29uZmlybWF0aW9ucylyZXR1cm4gbi5fZ2V0RmFzdEJsb2NrTnVtYmVyKCkudGhlbihmdW5jdGlvbihlKXt2YXIgdD1lLXIuYmxvY2tOdW1iZXIrMTtyZXR1cm4gdDw9MCYmKHQ9MSksci5jb25maXJtYXRpb25zPXQsbi5fd3JhcFRyYW5zYWN0aW9uKHIpfSk7cmV0dXJuIG4uX3dyYXBUcmFuc2FjdGlvbihyKX0pfSx7b25jZUJsb2NrOm59KX0pfSl9LFcucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uUmVjZWlwdD1mdW5jdGlvbihlKXt2YXIgbz10aGlzO3JldHVybiB0aGlzLnJlYWR5LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYy5yZXNvbHZlUHJvcGVydGllcyh7dHJhbnNhY3Rpb25IYXNoOmV9KS50aGVuKGZ1bmN0aW9uKGUpe3ZhciBpPWUudHJhbnNhY3Rpb25IYXNoLHQ9e3RyYW5zYWN0aW9uSGFzaDpNKGksITApfTtyZXR1cm4geS5wb2xsKGZ1bmN0aW9uKCl7cmV0dXJuIG8ucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLHQpLnRoZW4oZnVuY3Rpb24oZSl7aWYobnVsbD09ZSlyZXR1cm4gbnVsbD09by5fZW1pdHRlZFtcInQ6XCIraV0/bnVsbDp2b2lkIDA7aWYobnVsbCE9ZS5ibG9ja0hhc2gpe3ZhciB0LHIsbj0oKHI9YihDLHQ9ZSkpLmxvZ3MuZm9yRWFjaChmdW5jdGlvbihlLHQpe251bGw9PWUudHJhbnNhY3Rpb25Mb2dJbmRleCYmKGUudHJhbnNhY3Rpb25Mb2dJbmRleD10KX0pLG51bGwhPXQuc3RhdHVzJiYoci5ieXphbnRpdW09ITApLHIpO2lmKG51bGw9PW4uYmxvY2tOdW1iZXIpbi5jb25maXJtYXRpb25zPTA7ZWxzZSBpZihudWxsPT1uLmNvbmZpcm1hdGlvbnMpcmV0dXJuIG8uX2dldEZhc3RCbG9ja051bWJlcigpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQ9ZS1uLmJsb2NrTnVtYmVyKzE7cmV0dXJuIHQ8PTAmJih0PTEpLG4uY29uZmlybWF0aW9ucz10LG59KTtyZXR1cm4gbn19KX0se29uY2VCbG9jazpvfSl9KX0pfSxXLnByb3RvdHlwZS5nZXRMb2dzPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBjLnJlc29sdmVQcm9wZXJ0aWVzKGUpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG4uX3Jlc29sdmVOYW1lcyhlLFtcImFkZHJlc3NcIl0pLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHQscj17ZmlsdGVyOih0PWUpJiZ0LmJsb2NrSGFzaD9iKEQsdCk6YihCLHQpfTtyZXR1cm4gbi5wZXJmb3JtKFwiZ2V0TG9nc1wiLHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIF8oRykoZSl9KX0pfSl9KX0sVy5wcm90b3R5cGUuZ2V0RXRoZXJQcmljZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHRoaXMucmVhZHkudGhlbihmdW5jdGlvbigpe3JldHVybiBlLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIse30pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGV9KX0pfSxXLnByb3RvdHlwZS5fZ2V0QWRkcmVzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZXNvbHZlTmFtZSh0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lJiZtLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLG0uVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJyZXNvbHZlTmFtZShcIitKU09OLnN0cmluZ2lmeSh0KStcIilcIn0pLGV9KX0sVy5wcm90b3R5cGUuX3Jlc29sdmVOYW1lcz1mdW5jdGlvbihlLHQpe3ZhciByPVtdLG49Yy5zaGFsbG93Q29weShlKTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe251bGwhPW5bdF0mJnIucHVzaCh0aGlzLl9nZXRBZGRyZXNzKG5bdF0pLnRoZW4oZnVuY3Rpb24oZSl7blt0XT1lfSkpfSx0aGlzKSxQcm9taXNlLmFsbChyKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG59KX0sVy5wcm90b3R5cGUuX2dldFJlc29sdmVyPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXM7cmV0dXJuIHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24oZSl7ZS5lbnNBZGRyZXNzfHxtLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsbS5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcIkVOU1wiLG5ldHdvcms6ZS5uYW1lfSk7dmFyIHQ9XCIweDAxNzhiOGJmXCIraC5uYW1laGFzaChuKS5zdWJzdHJpbmcoMikscj17dG86ZS5lbnNBZGRyZXNzLGRhdGE6dH07cmV0dXJuIGkuY2FsbChyKS50aGVuKGZ1bmN0aW9uKGUpe2lmKDMyIT09dS5oZXhEYXRhTGVuZ3RoKGUpKXJldHVybiBudWxsO3ZhciB0PXMuZ2V0QWRkcmVzcyh1LmhleERhdGFTbGljZShlLDEyKSk7cmV0dXJuIHQ9PT1sLkFkZHJlc3NaZXJvP251bGw6dH0pfSl9LFcucHJvdG90eXBlLnJlc29sdmVOYW1lPWZ1bmN0aW9uKHQpe3ZhciByPXRoaXM7aWYodCBpbnN0YW5jZW9mIFByb21pc2UpcmV0dXJuIHQudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5yZXNvbHZlTmFtZShlKX0pO3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHMuZ2V0QWRkcmVzcyh0KSl9Y2F0Y2goZSl7aWYodS5pc0hleFN0cmluZyh0KSl0aHJvdyBlfXZhciBuPXRoaXMsaT1oLm5hbWVoYXNoKHQpO3JldHVybiB0aGlzLl9nZXRSZXNvbHZlcih0KS50aGVuKGZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7dmFyIHQ9e3RvOmUsZGF0YTpcIjB4M2IzYjU3ZGVcIitpLnN1YnN0cmluZygyKX07cmV0dXJuIG4uY2FsbCh0KX0pLnRoZW4oZnVuY3Rpb24oZSl7aWYoMzIhPT11LmhleERhdGFMZW5ndGgoZSkpcmV0dXJuIG51bGw7dmFyIHQ9cy5nZXRBZGRyZXNzKHUuaGV4RGF0YVNsaWNlKGUsMTIpKTtyZXR1cm4gdD09PWwuQWRkcmVzc1plcm8/bnVsbDp0fSl9LFcucHJvdG90eXBlLmxvb2t1cEFkZHJlc3M9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcztpZihuIGluc3RhbmNlb2YgUHJvbWlzZSlyZXR1cm4gbi50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB0Lmxvb2t1cEFkZHJlc3MoZSl9KTt2YXIgZT0obj1zLmdldEFkZHJlc3MobikpLnN1YnN0cmluZygyKStcIi5hZGRyLnJldmVyc2VcIixyPWgubmFtZWhhc2goZSksaT10aGlzO3JldHVybiB0aGlzLl9nZXRSZXNvbHZlcihlKS50aGVuKGZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiBudWxsO3ZhciB0PXt0bzplLGRhdGE6XCIweDY5MWYzNDMxXCIrci5zdWJzdHJpbmcoMil9O3JldHVybiBpLmNhbGwodCl9KS50aGVuKGZ1bmN0aW9uKGUpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7aWYoKGU9ZS5zdWJzdHJpbmcoMikpLmxlbmd0aDw2NClyZXR1cm4gbnVsbDtpZigoZT1lLnN1YnN0cmluZyg2NCkpLmxlbmd0aDw2NClyZXR1cm4gbnVsbDt2YXIgdD1hLmJpZ051bWJlcmlmeShcIjB4XCIrZS5zdWJzdHJpbmcoMCw2NCkpLnRvTnVtYmVyKCk7aWYoMip0PihlPWUuc3Vic3RyaW5nKDY0KSkubGVuZ3RoKXJldHVybiBudWxsO3ZhciByPXYudG9VdGY4U3RyaW5nKFwiMHhcIitlLnN1YnN0cmluZygwLDIqdCkpO3JldHVybiBpLnJlc29sdmVOYW1lKHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUhPW4/bnVsbDpyfSl9KX0sVy5jaGVja1RyYW5zYWN0aW9uUmVzcG9uc2U9TixXLnByb3RvdHlwZS5kb1BvbGw9ZnVuY3Rpb24oKXt9LFcucHJvdG90eXBlLnBlcmZvcm09ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbS50aHJvd0Vycm9yKGUrXCIgbm90IGltcGxlbWVudGVkXCIsbS5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjplfSksbnVsbH0sVy5wcm90b3R5cGUuX3N0YXJ0UGVuZGluZz1mdW5jdGlvbigpe20ud2FybihcIldBUk5JTkc6IHRoaXMgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGV2ZW50c1wiKX0sVy5wcm90b3R5cGUuX3N0b3BQZW5kaW5nPWZ1bmN0aW9uKCl7fSxXLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihlLHQscil7dGhpcy5fZXZlbnRzLnB1c2goe3RhZzp6KGUpLGxpc3RlbmVyOnQsb25jZTpyfSksXCJwZW5kaW5nXCI9PT1lJiZ0aGlzLl9zdGFydFBlbmRpbmcoKSx0aGlzLnBvbGxpbmc9ITB9LFcucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZSx0LCExKSx0aGlzfSxXLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZSx0LCEwKSx0aGlzfSxXLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub24oZSx0KX0sVy5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcyxyPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXJbbi0xXT1hcmd1bWVudHNbbl07dmFyIGk9ITEsbz16KGUpO3JldHVybiB0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YWchPT1vfHwoc2V0VGltZW91dChmdW5jdGlvbigpe2UubGlzdGVuZXIuYXBwbHkodCxyKX0sMCksaT0hMCwhZS5vbmNlKX0pLDA9PT10aGlzLmxpc3RlbmVyQ291bnQoKSYmKHRoaXMucG9sbGluZz0hMSksaX0sVy5wcm90b3R5cGUubGlzdGVuZXJDb3VudD1mdW5jdGlvbihlKXtpZighZSlyZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDt2YXIgdD16KGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZz09PXR9KS5sZW5ndGh9LFcucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgdD16KGUpO3JldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZz09PXR9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubGlzdGVuZXJ9KX0sVy5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBudWxsPT1lPyh0aGlzLl9ldmVudHM9W10sdGhpcy5fc3RvcFBlbmRpbmcoKSk6KHQ9eihlKSx0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50YWchPT10fSksXCJwZW5kaW5nXCI9PT1lJiZ0aGlzLl9zdG9wUGVuZGluZygpKSwwPT09dGhpcy5fZXZlbnRzLmxlbmd0aCYmKHRoaXMucG9sbGluZz0hMSksdGhpc30sVy5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj0hMSxuPXooZSk7cmV0dXJuIHRoaXMuX2V2ZW50cz10aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhZyE9PW58fGUubGlzdGVuZXIhPXR8fCghIXJ8fCEocj0hMCkpfSksXCJwZW5kaW5nXCI9PT1lJiYwPT09dGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSYmdGhpcy5fc3RvcFBlbmRpbmcoKSwwPT09dGhpcy5saXN0ZW5lckNvdW50KCkmJih0aGlzLnBvbGxpbmc9ITEpLHRoaXN9LFcpO2Z1bmN0aW9uIFcoZSl7dmFyIHQscj1LLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG0uY2hlY2tOZXcocixnLlByb3ZpZGVyKSxlIGluc3RhbmNlb2YgUHJvbWlzZT8oYy5kZWZpbmVSZWFkT25seShyLFwicmVhZHlcIixlLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGMuZGVmaW5lUmVhZE9ubHkocixcIl9uZXR3b3JrXCIsZSksZX0pKSxyLnJlYWR5LmNhdGNoKGZ1bmN0aW9uKGUpe30pKToodD1mLmdldE5ldHdvcmsobnVsbD09ZT9cImhvbWVzdGVhZFwiOmUpKT8oYy5kZWZpbmVSZWFkT25seShyLFwiX25ldHdvcmtcIix0KSxjLmRlZmluZVJlYWRPbmx5KHIsXCJyZWFkeVwiLFByb21pc2UucmVzb2x2ZShyLl9uZXR3b3JrKSkpOm0udGhyb3dFcnJvcihcImludmFsaWQgbmV0d29ya1wiLG0uSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwibmV0d29ya1wiLHZhbHVlOmV9KSxyLl9sYXN0QmxvY2tOdW1iZXI9LTIsci5fYmFsYW5jZXM9e30sci5fZXZlbnRzPVtdLHIuX3BvbGxpbmdJbnRlcnZhbD00ZTMsci5fZW1pdHRlZD17YmxvY2s6LTJ9LHIuX2Zhc3RRdWVyeURhdGU9MCxyfXIuQmFzZVByb3ZpZGVyPXEsYy5kZWZpbmVSZWFkT25seShnLlByb3ZpZGVyLFwiaW5oZXJpdHNcIixjLmluaGVyaXRhYmxlKGcuUHJvdmlkZXIpKX0se1wiLi4vY29uc3RhbnRzXCI6MyxcIi4uL2Vycm9yc1wiOjUsXCIuLi91dGlscy9hZGRyZXNzXCI6NjAsXCIuLi91dGlscy9iaWdudW1iZXJcIjo2MyxcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCIuLi91dGlscy9oYXNoXCI6NjUsXCIuLi91dGlscy9uZXR3b3Jrc1wiOjcyLFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi4vdXRpbHMvcmxwXCI6NzYsXCIuLi91dGlscy90cmFuc2FjdGlvblwiOjgzLFwiLi4vdXRpbHMvdXRmOFwiOjg1LFwiLi4vdXRpbHMvd2ViXCI6ODYsXCIuL2Fic3RyYWN0LXByb3ZpZGVyXCI6NTB9XSw1MjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1lKFwiLi9iYXNlLXByb3ZpZGVyXCIpLGE9ZShcIi4uL3V0aWxzL2J5dGVzXCIpLHU9ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksbD1lKFwiLi4vdXRpbHMvd2ViXCIpLGg9byhlKFwiLi4vZXJyb3JzXCIpKTtmdW5jdGlvbiBmKGUpe3ZhciB0LHI9W107Zm9yKHZhciBuIGluIGUpe251bGwhPWVbbl0mJih0PWEuaGV4bGlmeShlW25dKSx7Z2FzTGltaXQ6ITAsZ2FzUHJpY2U6ITAsbm9uY2U6ITAsdmFsdWU6ITB9W25dJiYodD1hLmhleFN0cmlwWmVyb3ModCkpLHIucHVzaChuK1wiPVwiK3QpKX1yZXR1cm4gci5qb2luKFwiJlwiKX1mdW5jdGlvbiBjKGUpe2lmKDA9PWUuc3RhdHVzJiYoXCJObyByZWNvcmRzIGZvdW5kXCI9PT1lLm1lc3NhZ2V8fFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCI9PT1lLm1lc3NhZ2UpKXJldHVybiBlLnJlc3VsdDtpZigxPT1lLnN0YXR1cyYmXCJPS1wiPT1lLm1lc3NhZ2UpcmV0dXJuIGUucmVzdWx0O3ZhciB0PW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7dGhyb3cgdC5yZXN1bHQ9SlNPTi5zdHJpbmdpZnkoZSksdH1mdW5jdGlvbiBkKGUpe2lmKFwiMi4wXCIhPWUuanNvbnJwYyl0aHJvdyh0PW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIikpLnJlc3VsdD1KU09OLnN0cmluZ2lmeShlKSx0O2lmKGUuZXJyb3Ipe3ZhciB0PW5ldyBFcnJvcihlLmVycm9yLm1lc3NhZ2V8fFwidW5rbm93biBlcnJvclwiKTt0aHJvdyBlLmVycm9yLmNvZGUmJih0LmNvZGU9ZS5lcnJvci5jb2RlKSxlLmVycm9yLmRhdGEmJih0LmRhdGE9ZS5lcnJvci5kYXRhKSx0fXJldHVybiBlLnJlc3VsdH1mdW5jdGlvbiBwKGUpe2lmKFwicGVuZGluZ1wiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJwZW5kaW5nIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuXCJsYXRlc3RcIj09PWU/ZTpwYXJzZUludChlLnN1YnN0cmluZygyKSwxNil9dmFyIHYseT1cIjhGRzNKTVo5VVNTNE5UQTZZS0VLSElOVTU2U0VQUFZCSlJcIixtPSh2PXMuQmFzZVByb3ZpZGVyLGkoZyx2KSxnLnByb3RvdHlwZS5wZXJmb3JtPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcyxuPXRoaXMuYmFzZVVybCxpPVwiXCI7dGhpcy5hcGlLZXkmJihpKz1cIiZhcGlrZXk9XCIrdGhpcy5hcGlLZXkpO2Z1bmN0aW9uIG8odCxlKXtyZXR1cm4gbC5mZXRjaEpzb24odCxudWxsLGV8fGQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHIuZW1pdChcImRlYnVnXCIse2FjdGlvbjpcInBlcmZvcm1cIixyZXF1ZXN0OnQscmVzcG9uc2U6ZSxwcm92aWRlcjpyfSksZX0pfXZhciBzO3N3aXRjaChlKXtjYXNlXCJnZXRCbG9ja051bWJlclwiOnJldHVybiBvKG4rPVwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9ibG9ja051bWJlclwiK2kpO2Nhc2VcImdldEdhc1ByaWNlXCI6cmV0dXJuIG8obis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dhc1ByaWNlXCIraSk7Y2FzZVwiZ2V0QmFsYW5jZVwiOnJldHVybiBuKz1cIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPWJhbGFuY2UmYWRkcmVzcz1cIit0LmFkZHJlc3MsbyhuKz1cIiZ0YWc9XCIrdC5ibG9ja1RhZytpLGMpO2Nhc2VcImdldFRyYW5zYWN0aW9uQ291bnRcIjpyZXR1cm4gbis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFRyYW5zYWN0aW9uQ291bnQmYWRkcmVzcz1cIit0LmFkZHJlc3MsbyhuKz1cIiZ0YWc9XCIrdC5ibG9ja1RhZytpKTtjYXNlXCJnZXRDb2RlXCI6cmV0dXJuIG4rPVwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRDb2RlJmFkZHJlc3M9XCIrdC5hZGRyZXNzLG8obis9XCImdGFnPVwiK3QuYmxvY2tUYWcraSxkKTtjYXNlXCJnZXRTdG9yYWdlQXRcIjpyZXR1cm4gbis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFN0b3JhZ2VBdCZhZGRyZXNzPVwiK3QuYWRkcmVzcyxuKz1cIiZwb3NpdGlvbj1cIit0LnBvc2l0aW9uLG8obis9XCImdGFnPVwiK3QuYmxvY2tUYWcraSxkKTtjYXNlXCJzZW5kVHJhbnNhY3Rpb25cIjpyZXR1cm4gbis9XCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX3NlbmRSYXdUcmFuc2FjdGlvbiZoZXg9XCIrdC5zaWduZWRUcmFuc2FjdGlvbixvKG4rPWkpLmNhdGNoKGZ1bmN0aW9uKGUpe3Rocm93IGUucmVzcG9uc2VUZXh0JiYoMDw9ZS5yZXNwb25zZVRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpJiZoLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIixoLklOU1VGRklDSUVOVF9GVU5EUyx7fSksMDw9ZS5yZXNwb25zZVRleHQuaW5kZXhPZihcInNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZFwiKSYmaC50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsaC5OT05DRV9FWFBJUkVELHt9KSwwPD1lLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2VcIikmJmgudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsaC5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCx7fSkpLGV9KTtjYXNlXCJnZXRCbG9ja1wiOnJldHVybiB0LmJsb2NrVGFnPyhuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0QmxvY2tCeU51bWJlciZ0YWc9XCIrdC5ibG9ja1RhZyx0LmluY2x1ZGVUcmFuc2FjdGlvbnM/bis9XCImYm9vbGVhbj10cnVlXCI6bis9XCImYm9vbGVhbj1mYWxzZVwiLG8obis9aSkpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3QgaW1wbGVtZW5ldGVkXCIpKTtjYXNlXCJnZXRUcmFuc2FjdGlvblwiOnJldHVybiBuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gmdHhoYXNoPVwiK3QudHJhbnNhY3Rpb25IYXNoLG8obis9aSk7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6cmV0dXJuIG4rPVwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQmdHhoYXNoPVwiK3QudHJhbnNhY3Rpb25IYXNoLG8obis9aSk7Y2FzZVwiY2FsbFwiOnJldHVybihuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfY2FsbFwiKyhzPShzPWYodC50cmFuc2FjdGlvbikpJiZcIiZcIitzKSxcImxhdGVzdFwiIT09dC5ibG9ja1RhZyk/UHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiRXRoZXJzY2FuUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBibG9ja1RhZyBmb3IgY2FsbFwiKSk6byhuKz1pKTtjYXNlXCJlc3RpbWF0ZUdhc1wiOnJldHVybiBuKz1cIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZXN0aW1hdGVHYXMmXCIrKHM9KHM9Zih0LnRyYW5zYWN0aW9uKSkmJlwiJlwiK3MpLG8obis9aSk7Y2FzZVwiZ2V0TG9nc1wiOm4rPVwiL2FwaT9tb2R1bGU9bG9ncyZhY3Rpb249Z2V0TG9nc1wiO3RyeXtpZih0LmZpbHRlci5mcm9tQmxvY2smJihuKz1cIiZmcm9tQmxvY2s9XCIrcCh0LmZpbHRlci5mcm9tQmxvY2spKSx0LmZpbHRlci50b0Jsb2NrJiYobis9XCImdG9CbG9jaz1cIitwKHQuZmlsdGVyLnRvQmxvY2spKSx0LmZpbHRlci5ibG9ja0hhc2gpdHJ5e2gudGhyb3dFcnJvcihcIkV0aGVyc2NhbiBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrSGFzaCBmaWx0ZXJzXCIsaC5VTlNVUFBPUlRFRF9PUEVSQVRJT04se29wZXJhdGlvbjpcImdldExvZ3MoYmxvY2tIYXNoKVwifSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfWlmKHQuZmlsdGVyLmFkZHJlc3MmJihuKz1cIiZhZGRyZXNzPVwiK3QuZmlsdGVyLmFkZHJlc3MpLHQuZmlsdGVyLnRvcGljcyYmMDx0LmZpbHRlci50b3BpY3MubGVuZ3RoKXtpZigxPHQuZmlsdGVyLnRvcGljcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgZm9ybWF0XCIpO3ZhciBhPXQuZmlsdGVyLnRvcGljc1swXTtpZihcInN0cmluZ1wiIT10eXBlb2YgYXx8NjYhPT1hLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYzAgZm9ybWF0XCIpO24rPVwiJnRvcGljMD1cIithfX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9dmFyIHU9dGhpcztyZXR1cm4gbyhuKz1pLGMpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIHI9e30sbj1Qcm9taXNlLnJlc29sdmUoKTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe249bi50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXQuYmxvY2tIYXNoP251bGw6KHQuYmxvY2tIYXNoPXJbdC50cmFuc2FjdGlvbkhhc2hdLG51bGw9PXQuYmxvY2tIYXNoP3UuZ2V0VHJhbnNhY3Rpb24odC50cmFuc2FjdGlvbkhhc2gpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHJbdC50cmFuc2FjdGlvbkhhc2hdPWUuYmxvY2tIYXNoLHQuYmxvY2tIYXNoPWUuYmxvY2tIYXNoLG51bGx9KTpudWxsKX0pfSksbi50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX0pO2Nhc2VcImdldEV0aGVyUHJpY2VcIjpyZXR1cm5cImhvbWVzdGVhZFwiIT09dGhpcy5uZXR3b3JrLm5hbWU/UHJvbWlzZS5yZXNvbHZlKDApOihuKz1cIi9hcGk/bW9kdWxlPXN0YXRzJmFjdGlvbj1ldGhwcmljZVwiLG8obis9aSxjKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUZsb2F0KGUuZXRodXNkKX0pKX1yZXR1cm4gdi5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsZSx0KX0sZy5wcm90b3R5cGUuZ2V0SGlzdG9yeT1mdW5jdGlvbihlLHQscil7dmFyIG49dGhpcyxpPXRoaXMuYmFzZVVybCxvPVwiXCI7cmV0dXJuIHRoaXMuYXBpS2V5JiYobys9XCImYXBpa2V5PVwiK3RoaXMuYXBpS2V5KSxudWxsPT10JiYodD0wKSxudWxsPT1yJiYocj05OTk5OTk5OSksdGhpcy5yZXNvbHZlTmFtZShlKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBpKz1cIi9hcGk/bW9kdWxlPWFjY291bnQmYWN0aW9uPXR4bGlzdCZhZGRyZXNzPVwiK2UsaSs9XCImc3RhcnRibG9jaz1cIit0LGkrPVwiJmVuZGJsb2NrPVwiK3IsaSs9XCImc29ydD1hc2NcIitvLGwuZmV0Y2hKc29uKGksbnVsbCxjKS50aGVuKGZ1bmN0aW9uKGUpe24uZW1pdChcImRlYnVnXCIse2FjdGlvbjpcImdldEhpc3RvcnlcIixyZXF1ZXN0OmkscmVzcG9uc2U6ZSxwcm92aWRlcjpufSk7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbih0KXtbXCJjb250cmFjdEFkZHJlc3NcIixcInRvXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7XCJcIj09dFtlXSYmZGVsZXRlIHRbZV19KSxudWxsPT10LmNyZWF0ZXMmJm51bGwhPXQuY29udHJhY3RBZGRyZXNzJiYodC5jcmVhdGVzPXQuY29udHJhY3RBZGRyZXNzKTt2YXIgZT1zLkJhc2VQcm92aWRlci5jaGVja1RyYW5zYWN0aW9uUmVzcG9uc2UodCk7dC50aW1lU3RhbXAmJihlLnRpbWVzdGFtcD1wYXJzZUludCh0LnRpbWVTdGFtcCkpLHIucHVzaChlKX0pLHJ9KX0pfSxnKTtmdW5jdGlvbiBnKGUsdCl7dmFyIHI9di5jYWxsKHRoaXMsZSl8fHRoaXM7aC5jaGVja05ldyhyLGcpO3ZhciBuPVwiaW52YWxpZFwiO3IubmV0d29yayYmKG49ci5uZXR3b3JrLm5hbWUpO3ZhciBpPW51bGw7c3dpdGNoKG4pe2Nhc2VcImhvbWVzdGVhZFwiOmk9XCJodHRwczovL2FwaS5ldGhlcnNjYW4uaW9cIjticmVhaztjYXNlXCJyb3BzdGVuXCI6aT1cImh0dHBzOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvXCI7YnJlYWs7Y2FzZVwicmlua2VieVwiOmk9XCJodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6aT1cImh0dHBzOi8vYXBpLWtvdmFuLmV0aGVyc2Nhbi5pb1wiO2JyZWFrO2Nhc2VcImdvZXJsaVwiOmk9XCJodHRwczovL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIpfXJldHVybiB1LmRlZmluZVJlYWRPbmx5KHIsXCJiYXNlVXJsXCIsaSksdS5kZWZpbmVSZWFkT25seShyLFwiYXBpS2V5XCIsdHx8eSkscn1yLkV0aGVyc2NhblByb3ZpZGVyPW19LHtcIi4uL2Vycm9yc1wiOjUsXCIuLi91dGlscy9ieXRlc1wiOjY0LFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi4vdXRpbHMvd2ViXCI6ODYsXCIuL2Jhc2UtcHJvdmlkZXJcIjo1MX1dLDUzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKGVbcl09dFtyXSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX1uKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooci5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IHIpfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPWUoXCIuL2Jhc2UtcHJvdmlkZXJcIiksYT1vKGUoXCIuLi9lcnJvcnNcIikpO2Z1bmN0aW9uIHUodCl7dmFyIHI9ITAsbj1udWxsO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9ZT9udWxsIT1uP24ubmFtZT09PWUubmFtZSYmbi5jaGFpbklkPT09ZS5jaGFpbklkJiYobi5lbnNBZGRyZXNzPT09ZS5lbnNBZGRyZXNzfHxudWxsPT1uLmVuc0FkZHJlc3MmJm51bGw9PWUuZW5zQWRkcmVzcyl8fGEudGhyb3dFcnJvcihcInByb3ZpZGVyIG1pc21hdGNoXCIsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJuZXR3b3Jrc1wiLHZhbHVlOnR9KTpuPWU6cj0hMX0pLHJ9dmFyIGwsaD0obD1zLkJhc2VQcm92aWRlcixpKGYsbCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGYucHJvdG90eXBlLFwicHJvdmlkZXJzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm92aWRlcnMuc2xpY2UoMCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZi5wcm90b3R5cGUucGVyZm9ybT1mdW5jdGlvbihpLG8pe3ZhciBzPXRoaXMucHJvdmlkZXJzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyLGUpe3ZhciBuPW51bGw7IWZ1bmN0aW9uIHQoKXtzLmxlbmd0aD9zLnNoaWZ0KCkucGVyZm9ybShpLG8pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl9KS5jYXRjaChmdW5jdGlvbihlKXtuPW58fGUsc2V0VGltZW91dCh0LDApfSk6ZShuKX0oKX0pfSxmKTtmdW5jdGlvbiBmKGUpe3ZhciB0LHI9dGhpcztpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibm8gcHJvdmlkZXJzXCIpO3JldHVybiByPXUoZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmV0d29ya30pKT9sLmNhbGwodGhpcyxlWzBdLm5ldHdvcmspfHx0aGlzOih0PVByb21pc2UuYWxsKGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldE5ldHdvcmsoKX0pKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB1KGUpfHxhLnRocm93RXJyb3IoXCJnZXROZXR3b3JrIHJldHVybmVkIG51bGxcIixhLlVOS05PV05fRVJST1Ise30pLGVbMF19KSxsLmNhbGwodGhpcyx0KXx8dGhpcyksYS5jaGVja05ldyhyLGYpLHIuX3Byb3ZpZGVycz1lLnNsaWNlKDApLHJ9ci5GYWxsYmFja1Byb3ZpZGVyPWh9LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2Jhc2UtcHJvdmlkZXJcIjo1MX1dLDU0OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vYWJzdHJhY3QtcHJvdmlkZXJcIik7ci5Qcm92aWRlcj1uLlByb3ZpZGVyO3ZhciBpPWUoXCIuL2Jhc2UtcHJvdmlkZXJcIik7ci5CYXNlUHJvdmlkZXI9aS5CYXNlUHJvdmlkZXI7dmFyIG89ZShcIi4vZXRoZXJzY2FuLXByb3ZpZGVyXCIpO3IuRXRoZXJzY2FuUHJvdmlkZXI9by5FdGhlcnNjYW5Qcm92aWRlcjt2YXIgcz1lKFwiLi9mYWxsYmFjay1wcm92aWRlclwiKTtyLkZhbGxiYWNrUHJvdmlkZXI9cy5GYWxsYmFja1Byb3ZpZGVyO3ZhciBhPWUoXCIuL2lwYy1wcm92aWRlclwiKTtyLklwY1Byb3ZpZGVyPWEuSXBjUHJvdmlkZXI7dmFyIHU9ZShcIi4vaW5mdXJhLXByb3ZpZGVyXCIpO3IuSW5mdXJhUHJvdmlkZXI9dS5JbmZ1cmFQcm92aWRlcjt2YXIgbD1lKFwiLi9qc29uLXJwYy1wcm92aWRlclwiKTtyLkpzb25ScGNQcm92aWRlcj1sLkpzb25ScGNQcm92aWRlcixyLkpzb25ScGNTaWduZXI9bC5Kc29uUnBjU2lnbmVyO3ZhciBoPWUoXCIuL3dlYjMtcHJvdmlkZXJcIik7ci5XZWIzUHJvdmlkZXI9aC5XZWIzUHJvdmlkZXJ9LHtcIi4vYWJzdHJhY3QtcHJvdmlkZXJcIjo1MCxcIi4vYmFzZS1wcm92aWRlclwiOjUxLFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIjo1MixcIi4vZmFsbGJhY2stcHJvdmlkZXJcIjo1MyxcIi4vaW5mdXJhLXByb3ZpZGVyXCI6NTUsXCIuL2lwYy1wcm92aWRlclwiOjU2LFwiLi9qc29uLXJwYy1wcm92aWRlclwiOjU3LFwiLi93ZWIzLXByb3ZpZGVyXCI6NTh9XSw1NTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxhPWUoXCIuL2pzb24tcnBjLXByb3ZpZGVyXCIpLHU9ZShcIi4uL3V0aWxzL2J5dGVzXCIpLGw9ZShcIi4uL3V0aWxzL25ldHdvcmtzXCIpLGg9ZShcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIiksZj1vKGUoXCIuLi9lcnJvcnNcIikpLGM9XCI3ZDBkODFkMDkxOWY0ZjA1YjlhYjY2MzRiZTAxZWU3M1wiLGQ9KHM9YS5Kc29uUnBjUHJvdmlkZXIsaShwLHMpLHAucHJvdG90eXBlLl9zdGFydFBlbmRpbmc9ZnVuY3Rpb24oKXtmLndhcm4oXCJXQVJOSU5HOiBJTkZVUkEgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnNcIil9LHAucHJvdG90eXBlLmdldFNpZ25lcj1mdW5jdGlvbihlKXtyZXR1cm4gZi50aHJvd0Vycm9yKFwiSU5GVVJBIGRvZXMgbm90IHN1cHBvcnQgc2lnbmluZ1wiLGYuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRTaWduZXJcIn0pfSxwLnByb3RvdHlwZS5saXN0QWNjb3VudHM9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKX0scCk7ZnVuY3Rpb24gcChlLHQpe3ZhciByPXRoaXMsbj1sLmdldE5ldHdvcmsobnVsbD09ZT9cImhvbWVzdGVhZFwiOmUpO251bGw9PXQmJih0PWMpO3ZhciBpPW51bGw7c3dpdGNoKG4ubmFtZSl7Y2FzZVwiaG9tZXN0ZWFkXCI6aT1cIm1haW5uZXQuaW5mdXJhLmlvXCI7YnJlYWs7Y2FzZVwicm9wc3RlblwiOmk9XCJyb3BzdGVuLmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcInJpbmtlYnlcIjppPVwicmlua2VieS5pbmZ1cmEuaW9cIjticmVhaztjYXNlXCJnb2VybGlcIjppPVwiZ29lcmxpLmluZnVyYS5pb1wiO2JyZWFrO2Nhc2VcImtvdmFuXCI6aT1cImtvdmFuLmluZnVyYS5pb1wiO2JyZWFrO2RlZmF1bHQ6Zi50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLGYuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJuZXR3b3JrXCIsdmFsdWU6ZX0pfXJldHVybiB1LmlzSGV4U3RyaW5nKFwiMHhcIit0LDE2KT8ocj1zLmNhbGwodGhpcyxcImh0dHBzOi8vXCIraStcIi92My9cIit0LG4pfHx0aGlzLGguZGVmaW5lUmVhZE9ubHkocixcImFwaUFjY2Vzc1Rva2VuXCIsbnVsbCksaC5kZWZpbmVSZWFkT25seShyLFwicHJvamVjdElkXCIsdCkpOihmLndhcm4oXCJUaGUgbGVnYWN5IElORlVSQSBhcGlBY2Nlc1Rva2VuIEFQSSBpcyBkZXByZWNhdGVkOyBwbGVhc2UgdXBncmFkZSB0byBhIFByb2plY3QgSUQgaW5zdGVhZCAoc2VlIElORlVSQSBkc2hib2FyZDsgaHR0cHM6Ly9pbmZ1cmEuaW8pXCIpLHI9cy5jYWxsKHRoaXMsXCJodHRwczovL1wiK2krXCIvXCIrdCxuKXx8dGhpcyxoLmRlZmluZVJlYWRPbmx5KHIsXCJhcGlBY2Nlc3NUb2tlblwiLHQpLGguZGVmaW5lUmVhZE9ubHkocixcInByb2plY3RJZFwiLG51bGwpKSxmLmNoZWNrTmV3KHIscCkscn1yLkluZnVyYVByb3ZpZGVyPWR9LHtcIi4uL2Vycm9yc1wiOjUsXCIuLi91dGlscy9ieXRlc1wiOjY0LFwiLi4vdXRpbHMvbmV0d29ya3NcIjo3MixcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIjo3NCxcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjo1N31dLDU2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHt9XSw1NzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1lKFwiLi9iYXNlLXByb3ZpZGVyXCIpLGE9ZShcIi4uL2Fic3RyYWN0LXNpZ25lclwiKSx1PW8oZShcIi4uL2Vycm9yc1wiKSksbD1lKFwiLi4vdXRpbHMvYWRkcmVzc1wiKSxoPWUoXCIuLi91dGlscy9ieXRlc1wiKSxmPWUoXCIuLi91dGlscy9uZXR3b3Jrc1wiKSxjPWUoXCIuLi91dGlscy9wcm9wZXJ0aWVzXCIpLGQ9ZShcIi4uL3V0aWxzL3V0ZjhcIikscD1lKFwiLi4vdXRpbHMvd2ViXCIpO2Z1bmN0aW9uIHYoZSl7aWYoZS5lcnJvcil7dmFyIHQ9bmV3IEVycm9yKGUuZXJyb3IubWVzc2FnZSk7dGhyb3cgdC5jb2RlPWUuZXJyb3IuY29kZSx0LmRhdGE9ZS5lcnJvci5kYXRhLHR9cmV0dXJuIGUucmVzdWx0fWZ1bmN0aW9uIHkoZSl7cmV0dXJuIGU/ZS50b0xvd2VyQ2FzZSgpOmV9dmFyIG0sZz17fSxiPTQyLHc9KG09YS5TaWduZXIsaShfLG0pLF8ucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiB0aGlzLl9hZGRyZXNzP1Byb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTp0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIixbXSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5sZW5ndGg8PXQuX2luZGV4JiZ1LnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiK3QuX2luZGV4LHUuVU5TVVBQT1JURURfT1BFUkFUSU9OLHtvcGVyYXRpb246XCJnZXRBZGRyZXNzXCJ9KSx0Ll9hZGRyZXNzPWwuZ2V0QWRkcmVzcyhlW3QuX2luZGV4XSksdC5fYWRkcmVzc30pfSxfLnByb3RvdHlwZS5nZXRCYWxhbmNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksZSl9LF8ucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmdldEFkZHJlc3MoKSxlKX0sXy5wcm90b3R5cGUuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7ZT1jLnNoYWxsb3dDb3B5KGUpO3ZhciB0LHI9dGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZT1lJiZlLnRvTG93ZXJDYXNlKCl9KTtyZXR1cm4gbnVsbD09ZS5nYXNMaW1pdCYmKCh0PWMuc2hhbGxvd0NvcHkoZSkpLmZyb209cixlLmdhc0xpbWl0PXRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXModCkpLFByb21pc2UuYWxsKFtjLnJlc29sdmVQcm9wZXJ0aWVzKGUpLHJdKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0scj1FLmhleGxpZnlUcmFuc2FjdGlvbih0KTtyZXR1cm4gci5mcm9tPWVbMV0sbi5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLFtyXSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZX0sZnVuY3Rpb24oZSl7dGhyb3cgZS5yZXNwb25zZVRleHQmJigwPD1lLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpJiZ1LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIix1LklOU1VGRklDSUVOVF9GVU5EUyx7dHJhbnNhY3Rpb246dH0pLDA8PWUucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJub25jZSB0b28gbG93XCIpJiZ1LnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIix1Lk5PTkNFX0VYUElSRUQse3RyYW5zYWN0aW9uOnR9KSwwPD1lLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIikmJnUudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsdS5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCx7dHJhbnNhY3Rpb246dH0pKSxlfSl9KX0sXy5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKGUpe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKGUpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHAucG9sbChmdW5jdGlvbigpe3JldHVybiByLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHQpLnRoZW4oZnVuY3Rpb24oZSl7aWYobnVsbCE9PWUpcmV0dXJuIHIucHJvdmlkZXIuX3dyYXBUcmFuc2FjdGlvbihlLHQpfSl9LHtmYXN0UmV0cnk6MjUwLG9uY2VCbG9jazpyLnByb3ZpZGVyfSkuY2F0Y2goZnVuY3Rpb24oZSl7dGhyb3cgZS50cmFuc2FjdGlvbkhhc2g9dCxlfSl9KX0sXy5wcm90b3R5cGUuc2lnbk1lc3NhZ2U9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPVwic3RyaW5nXCI9PXR5cGVvZiBlP2QudG9VdGY4Qnl0ZXMoZSk6ZTtyZXR1cm4gdGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdC5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIixbZS50b0xvd2VyQ2FzZSgpLGguaGV4bGlmeShyKV0pfSl9LF8ucHJvdG90eXBlLnVubG9jaz1mdW5jdGlvbih0KXt2YXIgcj10aGlzLnByb3ZpZGVyO3JldHVybiB0aGlzLmdldEFkZHJlc3MoKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsW2UudG9Mb3dlckNhc2UoKSx0LG51bGxdKX0pfSxfKTtmdW5jdGlvbiBfKGUsdCxyKXt2YXIgbj1tLmNhbGwodGhpcyl8fHRoaXM7aWYodS5jaGVja05ldyhuLF8pLGUhPT1nKXRocm93IG5ldyBFcnJvcihcImRvIG5vdCBjYWxsIHRoZSBKc29uUnBjU2lnbmVyIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgcHJvdmlkZXIuZ2V0U2lnbmVyXCIpO3JldHVybiBjLmRlZmluZVJlYWRPbmx5KG4sXCJwcm92aWRlclwiLHQpLHI/XCJzdHJpbmdcIj09dHlwZW9mIHI/Yy5kZWZpbmVSZWFkT25seShuLFwiX2FkZHJlc3NcIixsLmdldEFkZHJlc3MocikpOlwibnVtYmVyXCI9PXR5cGVvZiByP2MuZGVmaW5lUmVhZE9ubHkobixcIl9pbmRleFwiLHIpOnUudGhyb3dFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJhZGRyZXNzT3JJbmRleFwiLHZhbHVlOnJ9KTpjLmRlZmluZVJlYWRPbmx5KG4sXCJfaW5kZXhcIiwwKSxufXIuSnNvblJwY1NpZ25lcj13O3ZhciBNLEE9e2NoYWluSWQ6ITAsZGF0YTohMCxnYXNMaW1pdDohMCxnYXNQcmljZTohMCxub25jZTohMCx0bzohMCx2YWx1ZTohMH0sRT0oTT1zLkJhc2VQcm92aWRlcixpKFMsTSksUy5wcm90b3R5cGUuZ2V0U2lnbmVyPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdyhnLHRoaXMsZSl9LFMucHJvdG90eXBlLmxpc3RBY2NvdW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIixbXSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGwuZ2V0QWRkcmVzcyhlKX0pfSl9LFMucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLG49e21ldGhvZDplLHBhcmFtczp0LGlkOmIrKyxqc29ucnBjOlwiMi4wXCJ9O3JldHVybiBwLmZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sSlNPTi5zdHJpbmdpZnkobiksdikudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gci5lbWl0KFwiZGVidWdcIix7YWN0aW9uOlwic2VuZFwiLHJlcXVlc3Q6bixyZXNwb25zZTplLHByb3ZpZGVyOnJ9KSxlfSl9LFMucHJvdG90eXBlLnBlcmZvcm09ZnVuY3Rpb24oZSx0KXtzd2l0Y2goZSl7Y2FzZVwiZ2V0QmxvY2tOdW1iZXJcIjpyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2Jsb2NrTnVtYmVyXCIsW10pO2Nhc2VcImdldEdhc1ByaWNlXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9nYXNQcmljZVwiLFtdKTtjYXNlXCJnZXRCYWxhbmNlXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9nZXRCYWxhbmNlXCIsW3kodC5hZGRyZXNzKSx0LmJsb2NrVGFnXSk7Y2FzZVwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOnJldHVybiB0aGlzLnNlbmQoXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFt5KHQuYWRkcmVzcyksdC5ibG9ja1RhZ10pO2Nhc2VcImdldENvZGVcIjpyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2dldENvZGVcIixbeSh0LmFkZHJlc3MpLHQuYmxvY2tUYWddKTtjYXNlXCJnZXRTdG9yYWdlQXRcIjpyZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2dldFN0b3JhZ2VBdFwiLFt5KHQuYWRkcmVzcyksdC5wb3NpdGlvbix0LmJsb2NrVGFnXSk7Y2FzZVwic2VuZFRyYW5zYWN0aW9uXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIixbdC5zaWduZWRUcmFuc2FjdGlvbl0pLmNhdGNoKGZ1bmN0aW9uKGUpe3Rocm93IGUucmVzcG9uc2VUZXh0JiYoMDxlLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIpJiZ1LnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHNcIix1LklOU1VGRklDSUVOVF9GVU5EUyx7fSksMDxlLnJlc3BvbnNlVGV4dC5pbmRleE9mKFwibm9uY2UgdG9vIGxvd1wiKSYmdS50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsdS5OT05DRV9FWFBJUkVELHt9KSwwPGUucmVzcG9uc2VUZXh0LmluZGV4T2YoXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiKSYmdS50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIix1LlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELHt9KSksZX0pO2Nhc2VcImdldEJsb2NrXCI6cmV0dXJuIHQuYmxvY2tUYWc/dGhpcy5zZW5kKFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixbdC5ibG9ja1RhZywhIXQuaW5jbHVkZVRyYW5zYWN0aW9uc10pOnQuYmxvY2tIYXNoP3RoaXMuc2VuZChcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFt0LmJsb2NrSGFzaCwhIXQuaW5jbHVkZVRyYW5zYWN0aW9uc10pOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgYmxvY2sgdGFnIG9yIGJsb2NrIGhhc2hcIikpO2Nhc2VcImdldFRyYW5zYWN0aW9uXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFt0LnRyYW5zYWN0aW9uSGFzaF0pO2Nhc2VcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOnJldHVybiB0aGlzLnNlbmQoXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsW3QudHJhbnNhY3Rpb25IYXNoXSk7Y2FzZVwiY2FsbFwiOnJldHVybiB0aGlzLnNlbmQoXCJldGhfY2FsbFwiLFtTLmhleGxpZnlUcmFuc2FjdGlvbih0LnRyYW5zYWN0aW9uLHtmcm9tOiEwfSksdC5ibG9ja1RhZ10pO2Nhc2VcImVzdGltYXRlR2FzXCI6cmV0dXJuIHRoaXMuc2VuZChcImV0aF9lc3RpbWF0ZUdhc1wiLFtTLmhleGxpZnlUcmFuc2FjdGlvbih0LnRyYW5zYWN0aW9uLHtmcm9tOiEwfSldKTtjYXNlXCJnZXRMb2dzXCI6cmV0dXJuIHQuZmlsdGVyJiZudWxsIT10LmZpbHRlci5hZGRyZXNzJiYodC5maWx0ZXIuYWRkcmVzcz15KHQuZmlsdGVyLmFkZHJlc3MpKSx0aGlzLnNlbmQoXCJldGhfZ2V0TG9nc1wiLFt0LmZpbHRlcl0pfXJldHVybiB1LnRocm93RXJyb3IoZStcIiBub3QgaW1wbGVtZW50ZWRcIix1Lk5PVF9JTVBMRU1FTlRFRCx7b3BlcmF0aW9uOmV9KSxudWxsfSxTLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nPWZ1bmN0aW9uKCl7dmFyIHIsbjtudWxsPT10aGlzLl9wZW5kaW5nRmlsdGVyJiYobj0ocj10aGlzKS5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLFtdKSwodGhpcy5fcGVuZGluZ0ZpbHRlcj1uKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbiBlKCl7ci5zZW5kKFwiZXRoX2dldEZpbHRlckNoYW5nZXNcIixbdF0pLnRoZW4oZnVuY3Rpb24oZSl7aWYoci5fcGVuZGluZ0ZpbHRlciE9bilyZXR1cm4gbnVsbDt2YXIgdD1Qcm9taXNlLnJlc29sdmUoKTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IuX2VtaXR0ZWRbXCJ0OlwiK2UudG9Mb3dlckNhc2UoKV09XCJwZW5kaW5nXCIsdD10LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gci5nZXRUcmFuc2FjdGlvbihlKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByLmVtaXQoXCJwZW5kaW5nXCIsZSksbnVsbH0pfSl9KSx0LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdD0xZTMsbmV3IFByb21pc2UoZnVuY3Rpb24oZSl7c2V0VGltZW91dChmdW5jdGlvbigpe2UoKX0sdCl9KTt2YXIgdH0pfSkudGhlbihmdW5jdGlvbigpe3JldHVybiByLl9wZW5kaW5nRmlsdGVyPT1uPyhzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZSgpfSwwKSxudWxsKTp2b2lkIHIuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIixbdF0pfSkuY2F0Y2goZnVuY3Rpb24oZSl7fSl9KCksdH0pLmNhdGNoKGZ1bmN0aW9uKGUpe30pKX0sUy5wcm90b3R5cGUuX3N0b3BQZW5kaW5nPWZ1bmN0aW9uKCl7dGhpcy5fcGVuZGluZ0ZpbHRlcj1udWxsfSxTLmhleGxpZnlUcmFuc2FjdGlvbj1mdW5jdGlvbihyLGUpe3ZhciB0PWMuc2hhbGxvd0NvcHkoQSk7aWYoZSlmb3IodmFyIG4gaW4gZSllW25dJiYodFtuXT0hMCk7Yy5jaGVja1Byb3BlcnRpZXMocix0KTt2YXIgaT17fTtyZXR1cm5bXCJnYXNMaW1pdFwiLFwiZ2FzUHJpY2VcIixcIm5vbmNlXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0O251bGwhPXJbZV0mJih0PWguaGV4U3RyaXBaZXJvcyhoLmhleGxpZnkocltlXSkpLFwiZ2FzTGltaXRcIj09PWUmJihlPVwiZ2FzXCIpLGlbZV09dCl9KSxbXCJmcm9tXCIsXCJ0b1wiLFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGwhPXJbZV0mJihpW2VdPWguaGV4bGlmeShyW2VdKSl9KSxpfSxTKTtmdW5jdGlvbiBTKGUsdCl7dmFyIHIsbj10aGlzO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiZudWxsPT09dCYmZi5nZXROZXR3b3JrKGUpJiYodD1lLGU9bnVsbCksbj10P00uY2FsbCh0aGlzLHQpfHx0aGlzOihyPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHQscil7c2V0VGltZW91dChmdW5jdGlvbigpe24uc2VuZChcIm5ldF92ZXJzaW9uXCIsW10pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHQoZi5nZXROZXR3b3JrKHBhcnNlSW50KGUpKSl9KS5jYXRjaChmdW5jdGlvbihlKXtyKGUpfSl9KX0pLE0uY2FsbCh0aGlzLHIpfHx0aGlzKSx1LmNoZWNrTmV3KG4sUyksZT1lfHxcImh0dHA6Ly9sb2NhbGhvc3Q6ODU0NVwiLG4uY29ubmVjdGlvbj1cInN0cmluZ1wiPT10eXBlb2YgZT97dXJsOmV9OmUsbn1yLkpzb25ScGNQcm92aWRlcj1FfSx7XCIuLi9hYnN0cmFjdC1zaWduZXJcIjoyLFwiLi4vZXJyb3JzXCI6NSxcIi4uL3V0aWxzL2FkZHJlc3NcIjo2MCxcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCIuLi91dGlscy9uZXR3b3Jrc1wiOjcyLFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi4vdXRpbHMvdXRmOFwiOjg1LFwiLi4vdXRpbHMvd2ViXCI6ODYsXCIuL2Jhc2UtcHJvdmlkZXJcIjo1MX1dLDU4OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKGVbcl09dFtyXSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX1uKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooci5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IHIpfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzLGE9ZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIiksdT1lKFwiLi4vdXRpbHMvcHJvcGVydGllc1wiKSxsPW8oZShcIi4uL2Vycm9yc1wiKSksaD00MixmPShzPWEuSnNvblJwY1Byb3ZpZGVyLGkoYyxzKSxjLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQscil7dmFyIG89dGhpcztyZXR1cm5cImV0aF9zaWduXCI9PXQmJnRoaXMuX3dlYjNQcm92aWRlci5pc01ldGFNYXNrJiYodD1cInBlcnNvbmFsX3NpZ25cIixyPVtyWzFdLHJbMF1dKSxuZXcgUHJvbWlzZShmdW5jdGlvbihuLGkpe3ZhciBlPXttZXRob2Q6dCxwYXJhbXM6cixpZDpoKyssanNvbnJwYzpcIjIuMFwifTtvLl9zZW5kQXN5bmMoZSxmdW5jdGlvbihlLHQpe2lmKGUpaShlKTtlbHNle2lmKHQuZXJyb3Ipe3ZhciByPW5ldyBFcnJvcih0LmVycm9yLm1lc3NhZ2UpO3JldHVybiByLmNvZGU9dC5lcnJvci5jb2RlLHIuZGF0YT10LmVycm9yLmRhdGEsdm9pZCBpKHIpfW4odC5yZXN1bHQpfX0pfSl9LGMpO2Z1bmN0aW9uIGMoZSx0KXt2YXIgcj1zLmNhbGwodGhpcyxlLmhvc3R8fGUucGF0aHx8XCJcIix0KXx8dGhpcztyZXR1cm4gbC5jaGVja05ldyhyLGMpLGUmJihlLnNlbmRBc3luYz9yLl9zZW5kQXN5bmM9ZS5zZW5kQXN5bmMuYmluZChlKTplLnNlbmQmJihyLl9zZW5kQXN5bmM9ZS5zZW5kLmJpbmQoZSkpKSxlJiZyLl9zZW5kQXN5bmN8fGwudGhyb3dFcnJvcihcImludmFsaWQgd2ViM1Byb3ZpZGVyXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ3ZWIzUHJvdmlkZXJcIix2YWx1ZTplfSksdS5kZWZpbmVSZWFkT25seShyLFwiX3dlYjNQcm92aWRlclwiLGUpLHUuZGVmaW5lUmVhZE9ubHkocixcInByb3ZpZGVyXCIsZSkscn1yLldlYjNQcm92aWRlcj1mfSx7XCIuLi9lcnJvcnNcIjo1LFwiLi4vdXRpbHMvcHJvcGVydGllc1wiOjc0LFwiLi9qc29uLXJwYy1wcm92aWRlclwiOjU3fV0sNTk6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihyLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgcil9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHM9ZShcIi4uL2NvbnN0YW50c1wiKSxsPW8oZShcIi4uL2Vycm9yc1wiKSksYT1lKFwiLi9hZGRyZXNzXCIpLHU9ZShcIi4vYmlnbnVtYmVyXCIpLGg9ZShcIi4vYnl0ZXNcIiksZj1lKFwiLi91dGY4XCIpLGM9ZShcIi4vcHJvcGVydGllc1wiKSxkPW5ldyBSZWdFeHAoL15ieXRlcyhbMC05XSopJC8pLHA9bmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKSx2PW5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7ci5kZWZhdWx0Q29lcmNlRnVuYz1mdW5jdGlvbihlLHQpe3ZhciByPWUubWF0Y2gocCk7cmV0dXJuIHImJnBhcnNlSW50KHJbMl0pPD00OD90LnRvTnVtYmVyKCk6dH07dmFyIHk9bmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpLG09bmV3IFJlZ0V4cChcIl5bQS1aYS16X11bQS1aYS16MC05X10qJFwiKTtmdW5jdGlvbiBnKGUpe3JldHVybiBlLm1hdGNoKC9edWludCgkfFteMS05XSkvKT9lPVwidWludDI1NlwiK2Uuc3Vic3RyaW5nKDQpOmUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykmJihlPVwiaW50MjU2XCIrZS5zdWJzdHJpbmcoMykpLGV9ZnVuY3Rpb24gYihlLHQpe3ZhciByPWU7ZnVuY3Rpb24gbihlKXt0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJytyW2VdKydcIiBhdCBwb3NpdGlvbiAnK2UrJyBpbiBcIicrcisnXCInKX1lPWUucmVwbGFjZSgvXFxzL2csXCIgXCIpO2Zvcih2YXIgaT17dHlwZTpcIlwiLG5hbWU6XCJcIixzdGF0ZTp7YWxsb3dUeXBlOiEwfX0sbz1pLHM9MDtzPGUubGVuZ3RoO3MrKyl7dmFyIGE9ZVtzXTtzd2l0Y2goYSl7Y2FzZVwiKFwiOm8uc3RhdGUuYWxsb3dQYXJhbXN8fG4ocyksby5zdGF0ZS5hbGxvd1R5cGU9ITEsby50eXBlPWcoby50eXBlKSxvLmNvbXBvbmVudHM9W3t0eXBlOlwiXCIsbmFtZTpcIlwiLHBhcmVudDpvLHN0YXRlOnthbGxvd1R5cGU6ITB9fV0sbz1vLmNvbXBvbmVudHNbMF07YnJlYWs7Y2FzZVwiKVwiOmRlbGV0ZSBvLnN0YXRlLHQmJlwiaW5kZXhlZFwiPT09by5uYW1lJiYoby5pbmRleGVkPSEwLG8ubmFtZT1cIlwiKSxvLnR5cGU9ZyhvLnR5cGUpO3ZhciB1PW87KG89by5wYXJlbnQpfHxuKHMpLGRlbGV0ZSB1LnBhcmVudCxvLnN0YXRlLmFsbG93UGFyYW1zPSExLG8uc3RhdGUuYWxsb3dOYW1lPSEwLG8uc3RhdGUuYWxsb3dBcnJheT0hMDticmVhaztjYXNlXCIsXCI6ZGVsZXRlIG8uc3RhdGUsdCYmXCJpbmRleGVkXCI9PT1vLm5hbWUmJihvLmluZGV4ZWQ9ITAsby5uYW1lPVwiXCIpLG8udHlwZT1nKG8udHlwZSk7dmFyIGw9e3R5cGU6XCJcIixuYW1lOlwiXCIscGFyZW50Om8ucGFyZW50LHN0YXRlOnthbGxvd1R5cGU6ITB9fTtvLnBhcmVudC5jb21wb25lbnRzLnB1c2gobCksZGVsZXRlIG8ucGFyZW50LG89bDticmVhaztjYXNlXCIgXCI6by5zdGF0ZS5hbGxvd1R5cGUmJlwiXCIhPT1vLnR5cGUmJihvLnR5cGU9ZyhvLnR5cGUpLGRlbGV0ZSBvLnN0YXRlLmFsbG93VHlwZSxvLnN0YXRlLmFsbG93TmFtZT0hMCxvLnN0YXRlLmFsbG93UGFyYW1zPSEwKSxvLnN0YXRlLmFsbG93TmFtZSYmXCJcIiE9PW8ubmFtZSYmKHQmJlwiaW5kZXhlZFwiPT09by5uYW1lPyhvLmluZGV4ZWQ9ITAsby5uYW1lPVwiXCIpOm8uc3RhdGUuYWxsb3dOYW1lPSExKTticmVhaztjYXNlXCJbXCI6by5zdGF0ZS5hbGxvd0FycmF5fHxuKHMpLG8udHlwZSs9YSxvLnN0YXRlLmFsbG93QXJyYXk9ITEsby5zdGF0ZS5hbGxvd05hbWU9ITEsby5zdGF0ZS5yZWFkQXJyYXk9ITA7YnJlYWs7Y2FzZVwiXVwiOm8uc3RhdGUucmVhZEFycmF5fHxuKHMpLG8udHlwZSs9YSxvLnN0YXRlLnJlYWRBcnJheT0hMSxvLnN0YXRlLmFsbG93QXJyYXk9ITAsby5zdGF0ZS5hbGxvd05hbWU9ITA7YnJlYWs7ZGVmYXVsdDpvLnN0YXRlLmFsbG93VHlwZT8oby50eXBlKz1hLG8uc3RhdGUuYWxsb3dQYXJhbXM9ITAsby5zdGF0ZS5hbGxvd0FycmF5PSEwKTpvLnN0YXRlLmFsbG93TmFtZT8oby5uYW1lKz1hLGRlbGV0ZSBvLnN0YXRlLmFsbG93QXJyYXkpOm8uc3RhdGUucmVhZEFycmF5P28udHlwZSs9YTpuKHMpfX1pZihvLnBhcmVudCl0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGVvZlwiKTtyZXR1cm4gZGVsZXRlIGkuc3RhdGUsdCYmXCJpbmRleGVkXCI9PT1vLm5hbWUmJihvLmluZGV4ZWQ9ITAsby5uYW1lPVwiXCIpLGkudHlwZT1nKGkudHlwZSksaX1mdW5jdGlvbiB3KGUpe3JldHVybiBzZShyLmRlZmF1bHRDb2VyY2VGdW5jLGUpLnR5cGV9ci5wYXJzZVBhcmFtVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gYihlLCEwKX0sci5mb3JtYXRQYXJhbVR5cGU9dyxyLmZvcm1hdFNpZ25hdHVyZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lK1wiKFwiK2UuaW5wdXRzLm1hcCh3KS5qb2luKFwiLFwiKStcIilcIn0sci5wYXJzZVNpZ25hdHVyZT1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm5cImV2ZW50IFwiPT09KGU9KGU9KGU9ZS5yZXBsYWNlKC9cXHMvZyxcIiBcIikpLnJlcGxhY2UoL1xcKC9nLFwiIChcIikucmVwbGFjZSgvXFwpL2csXCIpIFwiKS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpKS50cmltKCkpLnN1YnN0cmluZygwLDYpP2Z1bmN0aW9uKGUpe3ZhciB0PXthbm9ueW1vdXM6ITEsaW5wdXRzOltdLG5hbWU6XCJcIix0eXBlOlwiZXZlbnRcIn0scj1lLm1hdGNoKHkpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQ6IFwiK2UpO2lmKHQubmFtZT1yWzFdLnRyaW0oKSxpZShyWzJdKS5mb3JFYWNoKGZ1bmN0aW9uKGUpeyhlPWIoZSwhMCkpLmluZGV4ZWQ9ISFlLmluZGV4ZWQsdC5pbnB1dHMucHVzaChlKX0pLHJbM10uc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcImFub255bW91c1wiOnQuYW5vbnltb3VzPSEwO2JyZWFrO2Nhc2VcIlwiOmJyZWFrO2RlZmF1bHQ6bC5pbmZvKFwidW5rbm93biBtb2RpZmllcjogXCIrZSl9fSksdC5uYW1lJiYhdC5uYW1lLm1hdGNoKG0pKXRocm93IG5ldyBFcnJvcignaW52YWxpZCBpZGVudGlmaWVyOiBcIicrdC5uYW1lKydcIicpO3JldHVybiB0fShlLnN1YnN0cmluZyg2KS50cmltKCkpOihcImZ1bmN0aW9uIFwiPT09ZS5zdWJzdHJpbmcoMCw5KSYmKGU9ZS5zdWJzdHJpbmcoOSkpLGZ1bmN0aW9uKGUpe3ZhciB0PXtjb25zdGFudDohMSxnYXM6bnVsbCxpbnB1dHM6W10sbmFtZTpcIlwiLG91dHB1dHM6W10scGF5YWJsZTohMSxzdGF0ZU11dGFiaWxpdHk6bnVsbCx0eXBlOlwiZnVuY3Rpb25cIn0scj1lLnNwbGl0KFwiQFwiKTtpZigxIT09ci5sZW5ndGgpe2lmKDI8ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmVcIik7aWYoIXJbMV0ubWF0Y2goL15bMC05XSskLykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgZ2FzXCIpO3QuZ2FzPXUuYmlnTnVtYmVyaWZ5KHJbMV0pLGU9clswXX12YXIgbj0ocj1lLnNwbGl0KFwiIHJldHVybnMgXCIpKVswXS5tYXRjaCh5KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpZ25hdHVyZVwiKTtpZih0Lm5hbWU9blsxXS50cmltKCksIXQubmFtZS5tYXRjaChtKSl0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaWRlbnRpZmllcjogXCInK25bMV0rJ1wiJyk7aWYoaWUoblsyXSkuZm9yRWFjaChmdW5jdGlvbihlKXt0LmlucHV0cy5wdXNoKGIoZSkpfSksblszXS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZVwiY29uc3RhbnRcIjp0LmNvbnN0YW50PSEwO2JyZWFrO2Nhc2VcInBheWFibGVcIjp0LnBheWFibGU9ITAsdC5zdGF0ZU11dGFiaWxpdHk9XCJwYXlhYmxlXCI7YnJlYWs7Y2FzZVwicHVyZVwiOnQuY29uc3RhbnQ9ITAsdC5zdGF0ZU11dGFiaWxpdHk9XCJwdXJlXCI7YnJlYWs7Y2FzZVwidmlld1wiOnQuY29uc3RhbnQ9ITAsdC5zdGF0ZU11dGFiaWxpdHk9XCJ2aWV3XCI7YnJlYWs7Y2FzZVwiZXh0ZXJuYWxcIjpjYXNlXCJwdWJsaWNcIjpjYXNlXCJcIjpicmVhaztkZWZhdWx0OmwuaW5mbyhcInVua25vd24gbW9kaWZpZXI6IFwiK2UpfX0pLDE8ci5sZW5ndGgpe3ZhciBpPXJbMV0ubWF0Y2goeSk7aWYoXCJcIiE9aVsxXS50cmltKCl8fFwiXCIhPWlbM10udHJpbSgpKXRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5zXCIpO2llKGlbMl0pLmZvckVhY2goZnVuY3Rpb24oZSl7dC5vdXRwdXRzLnB1c2goYihlKSl9KX1pZihcImNvbnN0cnVjdG9yXCI9PT10Lm5hbWUpe2lmKHQudHlwZT1cImNvbnN0cnVjdG9yXCIsdC5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RvciBtYXkgbm90IGhhdmUgb3V0cHV0c1wiKTtkZWxldGUgdC5uYW1lLGRlbGV0ZSB0Lm91dHB1dHN9cmV0dXJuIHR9KGUudHJpbSgpKSk7dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBzaWduYXR1cmVcIil9O2Z1bmN0aW9uIF8oZSx0LHIsbixpKXt0aGlzLmNvZXJjZUZ1bmM9ZSx0aGlzLm5hbWU9dCx0aGlzLnR5cGU9cix0aGlzLmxvY2FsTmFtZT1uLHRoaXMuZHluYW1pYz1pfXZhciBNLEE9KGkoRSxNPV8pLEUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb2Rlci5lbmNvZGUoZSl9LEUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmNvZGVyLmRlY29kZShlLHQpfSxFKTtmdW5jdGlvbiBFKGUpe3ZhciB0PU0uY2FsbCh0aGlzLGUuY29lcmNlRnVuYyxlLm5hbWUsZS50eXBlLHZvaWQgMCxlLmR5bmFtaWMpfHx0aGlzO3JldHVybiBjLmRlZmluZVJlYWRPbmx5KHQsXCJjb2RlclwiLGUpLHR9dmFyIFMsaz0oaShOLFM9XyksTi5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBoLmFycmF5aWZ5KFtdKX0sTi5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7aWYodD5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG51bGxcIik7cmV0dXJue2NvbnN1bWVkOjAsdmFsdWU6dGhpcy5jb2VyY2VGdW5jKFwibnVsbFwiLHZvaWQgMCl9fSxOKTtmdW5jdGlvbiBOKGUsdCl7cmV0dXJuIFMuY2FsbCh0aGlzLGUsXCJudWxsXCIsXCJcIix0LCExKXx8dGhpc312YXIgeCxQPShpKEkseD1fKSxJLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCl7dHJ5e3ZhciBlPXUuYmlnTnVtYmVyaWZ5KHQpO2lmKHRoaXMuc2lnbmVkKXt2YXIgcj1zLk1heFVpbnQyNTYubWFza24oOCp0aGlzLnNpemUtMSk7aWYoZS5ndChyKSl0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO2lmKHI9ci5hZGQocy5PbmUpLm11bChzLk5lZ2F0aXZlT25lKSxlLmx0KHIpKXRocm93IG5ldyBFcnJvcihcIm91dC1vZi1ib3VuZHNcIil9ZWxzZSBpZihlLmx0KHMuWmVybyl8fGUuZ3Qocy5NYXhVaW50MjU2Lm1hc2tuKDgqdGhpcy5zaXplKSkpdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtyZXR1cm4gZT1lLnRvVHdvcyg4KnRoaXMuc2l6ZSkubWFza24oOCp0aGlzLnNpemUpLHRoaXMuc2lnbmVkJiYoZT1lLmZyb21Ud29zKDgqdGhpcy5zaXplKS50b1R3b3MoMjU2KSksaC5wYWRaZXJvcyhoLmFycmF5aWZ5KGUpLDMyKX1jYXRjaChlKXtsLnRocm93RXJyb3IoXCJpbnZhbGlkIG51bWJlciB2YWx1ZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTp0aGlzLm5hbWUsdmFsdWU6dH0pfXJldHVybiBudWxsfSxJLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlLmxlbmd0aDx0KzMyJiZsLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZGF0YSBmb3IgXCIrdGhpcy5uYW1lK1wiIHR5cGVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6dGhpcy5uYW1lLHZhbHVlOmguaGV4bGlmeShlLnNsaWNlKHQsdCszMikpfSk7dmFyIHI9MzItdGhpcy5zaXplLG49dS5iaWdOdW1iZXJpZnkoZS5zbGljZSh0K3IsdCszMikpLG49dGhpcy5zaWduZWQ/bi5mcm9tVHdvcyg4KnRoaXMuc2l6ZSk6bi5tYXNrbig4KnRoaXMuc2l6ZSk7cmV0dXJue2NvbnN1bWVkOjMyLHZhbHVlOnRoaXMuY29lcmNlRnVuYyh0aGlzLm5hbWUsbil9fSxJKTtmdW5jdGlvbiBJKGUsdCxyLG4pe3ZhciBpPXRoaXMsbz0ocj9cImludFwiOlwidWludFwiKSs4KnQ7cmV0dXJuKGk9eC5jYWxsKHRoaXMsZSxvLG8sbiwhMSl8fHRoaXMpLnNpemU9dCxpLnNpZ25lZD1yLGl9dmFyIFQsUj1uZXcgUChmdW5jdGlvbihlLHQpe3JldHVybiB0fSwzMiwhMSxcIm5vbmVcIiksTz0oaShDLFQ9XyksQy5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBSLmVuY29kZShlPzE6MCl9LEMucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3RyeXt2YXIgcj1SLmRlY29kZShlLHQpfWNhdGNoKGUpe3Rocm93XCJpbnN1ZmZpY2llbnQgZGF0YSBmb3IgdWludDI1NiB0eXBlXCI9PT1lLnJlYXNvbiYmbC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGJvb2xlYW4gdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImJvb2xlYW5cIix2YWx1ZTplLnZhbHVlfSksZX1yZXR1cm57Y29uc3VtZWQ6ci5jb25zdW1lZCx2YWx1ZTp0aGlzLmNvZXJjZUZ1bmMoXCJib29sXCIsIXIudmFsdWUuaXNaZXJvKCkpfX0sQyk7ZnVuY3Rpb24gQyhlLHQpe3JldHVybiBULmNhbGwodGhpcyxlLFwiYm9vbFwiLFwiYm9vbFwiLHQsITEpfHx0aGlzfXZhciBMLEI9KGkoRCxMPV8pLEQucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgVWludDhBcnJheSgzMik7dHJ5e3ZhciByPWguYXJyYXlpZnkodCk7aWYoci5sZW5ndGghPT10aGlzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIik7ZS5zZXQocil9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiaW52YWxpZCBcIit0aGlzLm5hbWUrXCIgdmFsdWVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6dGhpcy5uYW1lLHZhbHVlOmUudmFsdWV8fHR9KX1yZXR1cm4gZX0sRC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubGVuZ3RoPHQrMzImJmwudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGZvciBcIit0aGlzLm5hbWUrXCIgdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTp0aGlzLm5hbWUsdmFsdWU6aC5oZXhsaWZ5KGUuc2xpY2UodCx0KzMyKSl9KSx7Y29uc3VtZWQ6MzIsdmFsdWU6dGhpcy5jb2VyY2VGdW5jKHRoaXMubmFtZSxoLmhleGxpZnkoZS5zbGljZSh0LHQrdGhpcy5sZW5ndGgpKSl9fSxEKTtmdW5jdGlvbiBEKGUsdCxyKXt2YXIgbj10aGlzLGk9XCJieXRlc1wiK3Q7cmV0dXJuKG49TC5jYWxsKHRoaXMsZSxpLGksciwhMSl8fHRoaXMpLmxlbmd0aD10LG59dmFyIFUsRj0oaShqLFU9Xyksai5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBVaW50OEFycmF5KDMyKTt0cnl7ZS5zZXQoaC5hcnJheWlmeShhLmdldEFkZHJlc3ModCkpLDEyKX1jYXRjaChlKXtsLnRocm93RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6XCJhZGRyZXNzXCIsdmFsdWU6dH0pfXJldHVybiBlfSxqLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5sZW5ndGg8dCszMiYmbC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGFkZHJlc3MgdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImFkZHJlc3NcIix2YWx1ZTpoLmhleGxpZnkoZS5zbGljZSh0LHQrMzIpKX0pLHtjb25zdW1lZDozMix2YWx1ZTp0aGlzLmNvZXJjZUZ1bmMoXCJhZGRyZXNzXCIsYS5nZXRBZGRyZXNzKGguaGV4bGlmeShlLnNsaWNlKHQrMTIsdCszMikpKSl9fSxqKTtmdW5jdGlvbiBqKGUsdCl7cmV0dXJuIFUuY2FsbCh0aGlzLGUsXCJhZGRyZXNzXCIsXCJhZGRyZXNzXCIsdCwhMSl8fHRoaXN9ZnVuY3Rpb24gRyhlKXt2YXIgdD0zMipNYXRoLmNlaWwoZS5sZW5ndGgvMzIpLHI9bmV3IFVpbnQ4QXJyYXkodC1lLmxlbmd0aCk7cmV0dXJuIGguY29uY2F0KFtSLmVuY29kZShlLmxlbmd0aCksZSxyXSl9ZnVuY3Rpb24gSChlLHQscil7ZS5sZW5ndGg8dCszMiYmbC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGR5bmFtaWNCeXRlcyBsZW5ndGhcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpyLGNvZGVyVHlwZTpcImR5bmFtaWNCeXRlc1wiLHZhbHVlOmguaGV4bGlmeShlLnNsaWNlKHQsdCszMikpfSk7dmFyIG49Ui5kZWNvZGUoZSx0KS52YWx1ZTt0cnl7bj1uLnRvTnVtYmVyKCl9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiZHluYW1pYyBieXRlcyBjb3VudCB0b28gbGFyZ2VcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzpyLGNvZGVyVHlwZTpcImR5bmFtaWNCeXRlc1wiLHZhbHVlOm4udG9TdHJpbmcoKX0pfXJldHVybiBlLmxlbmd0aDx0KzMyK24mJmwudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGZvciBkeW5hbWljQnl0ZXMgdHlwZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnIsY29kZXJUeXBlOlwiZHluYW1pY0J5dGVzXCIsdmFsdWU6aC5oZXhsaWZ5KGUuc2xpY2UodCx0KzMyK24pKX0pLHtjb25zdW1lZDozMiszMipNYXRoLmNlaWwobi8zMiksdmFsdWU6ZS5zbGljZSh0KzMyLHQrMzIrbil9fXZhciB6LFY9KGkoSyx6PV8pLEsucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIEcoaC5hcnJheWlmeShlKSl9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiaW52YWxpZCBieXRlcyB2YWx1ZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImJ5dGVzXCIsdmFsdWU6ZS52YWx1ZX0pfXJldHVybiBudWxsfSxLLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXt2YXIgcj1IKGUsdCx0aGlzLmxvY2FsTmFtZSk7cmV0dXJuIHIudmFsdWU9dGhpcy5jb2VyY2VGdW5jKFwiYnl0ZXNcIixoLmhleGxpZnkoci52YWx1ZSkpLHJ9LEspO2Z1bmN0aW9uIEsoZSx0KXtyZXR1cm4gei5jYWxsKHRoaXMsZSxcImJ5dGVzXCIsXCJieXRlc1wiLHQsITApfHx0aGlzfXZhciBxLFc9KGkoWixxPV8pLFoucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZSYmbC50aHJvd0Vycm9yKFwiaW52YWxpZCBzdHJpbmcgdmFsdWVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6XCJzdHJpbmdcIix2YWx1ZTplfSksRyhmLnRvVXRmOEJ5dGVzKGUpKX0sWi5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9SChlLHQsdGhpcy5sb2NhbE5hbWUpO3JldHVybiByLnZhbHVlPXRoaXMuY29lcmNlRnVuYyhcInN0cmluZ1wiLGYudG9VdGY4U3RyaW5nKHIudmFsdWUpKSxyfSxaKTtmdW5jdGlvbiBaKGUsdCl7cmV0dXJuIHEuY2FsbCh0aGlzLGUsXCJzdHJpbmdcIixcInN0cmluZ1wiLHQsITApfHx0aGlzfWZ1bmN0aW9uIEooZSl7cmV0dXJuIDMyKk1hdGguY2VpbChlLzMyKX1mdW5jdGlvbiBYKGUscil7dmFyIHQ7QXJyYXkuaXNBcnJheShyKXx8KHImJlwib2JqZWN0XCI9PXR5cGVvZiByPyh0PVtdLGUuZm9yRWFjaChmdW5jdGlvbihlKXt0LnB1c2gocltlLmxvY2FsTmFtZV0pfSkscj10KTpsLnRocm93RXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsbC5JTlZBTElEX0FSR1VNRU5ULHtjb2RlclR5cGU6XCJ0dXBsZVwiLHZhbHVlOnJ9KSksZS5sZW5ndGghPT1yLmxlbmd0aCYmbC50aHJvd0Vycm9yKFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsbC5JTlZBTElEX0FSR1VNRU5ULHtjb2RlclR5cGU6XCJ0dXBsZVwiLHZhbHVlOnJ9KTt2YXIgbj1bXTtlLmZvckVhY2goZnVuY3Rpb24oZSx0KXtuLnB1c2goe2R5bmFtaWM6ZS5keW5hbWljLHZhbHVlOmUuZW5jb2RlKHJbdF0pfSl9KTt2YXIgaT0wLG89MDtuLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5keW5hbWljPyhpKz0zMixvKz1KKGUudmFsdWUubGVuZ3RoKSk6aSs9SihlLnZhbHVlLmxlbmd0aCl9KTt2YXIgcz0wLGE9aSx1PW5ldyBVaW50OEFycmF5KGkrbyk7cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihlKXtlLmR5bmFtaWM/KHUuc2V0KFIuZW5jb2RlKGEpLHMpLHMrPTMyLHUuc2V0KGUudmFsdWUsYSksYSs9SihlLnZhbHVlLmxlbmd0aCkpOih1LnNldChlLnZhbHVlLHMpLHMrPUooZS52YWx1ZS5sZW5ndGgpKX0pLHV9ZnVuY3Rpb24gJChlLG4saSl7dmFyIG89aSxzPTAsYT1bXTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0LHI7ZS5keW5hbWljPyh0PVIuZGVjb2RlKG4saSksKHI9ZS5kZWNvZGUobixvK3QudmFsdWUudG9OdW1iZXIoKSkpLmNvbnN1bWVkPXQuY29uc3VtZWQpOnI9ZS5kZWNvZGUobixpKSxudWxsIT1yLnZhbHVlJiZhLnB1c2goci52YWx1ZSksaSs9ci5jb25zdW1lZCxzKz1yLmNvbnN1bWVkfSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5sb2NhbE5hbWU7ciYmKFwibGVuZ3RoXCI9PT1yJiYocj1cIl9sZW5ndGhcIiksbnVsbD09YVtyXSYmKGFbcl09YVt0XSkpfSkse3ZhbHVlOmEsY29uc3VtZWQ6c319dmFyIFEsWT0oaShlZSxRPV8pLGVlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oZSl7QXJyYXkuaXNBcnJheShlKXx8bC50aHJvd0Vycm9yKFwiZXhwZWN0ZWQgYXJyYXkgdmFsdWVcIixsLklOVkFMSURfQVJHVU1FTlQse2FyZzp0aGlzLmxvY2FsTmFtZSxjb2RlclR5cGU6XCJhcnJheVwiLHZhbHVlOmV9KTt2YXIgdD10aGlzLmxlbmd0aCxyPW5ldyBVaW50OEFycmF5KDApOy0xPT09dCYmKHQ9ZS5sZW5ndGgscj1SLmVuY29kZSh0KSksbC5jaGVja0FyZ3VtZW50Q291bnQodCxlLmxlbmd0aCxcIiBpbiBjb2RlciBhcnJheVwiKyh0aGlzLmxvY2FsTmFtZT9cIiBcIit0aGlzLmxvY2FsTmFtZTpcIlwiKSk7Zm9yKHZhciBuPVtdLGk9MDtpPGUubGVuZ3RoO2krKyluLnB1c2godGhpcy5jb2Rlcik7cmV0dXJuIGguY29uY2F0KFtyLFgobixlKV0pfSxlZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9MCxuPXRoaXMubGVuZ3RoO2lmKC0xPT09bil7dHJ5e3ZhciBpPVIuZGVjb2RlKGUsdCl9Y2F0Y2goZSl7bC50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGRhdGEgZm9yIGR5bmFtaWMgYXJyYXkgbGVuZ3RoXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6dGhpcy5sb2NhbE5hbWUsY29kZXJUeXBlOlwiYXJyYXlcIix2YWx1ZTplLnZhbHVlfSl9dHJ5e249aS52YWx1ZS50b051bWJlcigpfWNhdGNoKGUpe2wudGhyb3dFcnJvcihcImFycmF5IGNvdW50IHRvbyBsYXJnZVwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOnRoaXMubG9jYWxOYW1lLGNvZGVyVHlwZTpcImFycmF5XCIsdmFsdWU6aS52YWx1ZS50b1N0cmluZygpfSl9cis9aS5jb25zdW1lZCx0Kz1pLmNvbnN1bWVkfWZvcih2YXIgbz1bXSxzPTA7czxuO3MrKylvLnB1c2gobmV3IEEodGhpcy5jb2RlcikpO3ZhciBhPSQobyxlLHQpO3JldHVybiBhLmNvbnN1bWVkKz1yLGEudmFsdWU9dGhpcy5jb2VyY2VGdW5jKHRoaXMudHlwZSxhLnZhbHVlKSxhfSxlZSk7ZnVuY3Rpb24gZWUoZSx0LHIsbil7dmFyIGk9dGhpcyxvPXQudHlwZStcIltcIisoMDw9cj9yOlwiXCIpK1wiXVwiLHM9LTE9PT1yfHx0LmR5bmFtaWM7cmV0dXJuKGk9US5jYWxsKHRoaXMsZSxcImFycmF5XCIsbyxuLHMpfHx0aGlzKS5jb2Rlcj10LGkubGVuZ3RoPXIsaX12YXIgdGUscmU9KGkobmUsdGU9XyksbmUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gWCh0aGlzLmNvZGVycyxlKX0sbmUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHQpe3ZhciByPSQodGhpcy5jb2RlcnMsZSx0KTtyZXR1cm4gci52YWx1ZT10aGlzLmNvZXJjZUZ1bmModGhpcy50eXBlLHIudmFsdWUpLHJ9LG5lKTtmdW5jdGlvbiBuZShlLHQscil7dmFyIG49dGhpcyxpPSExLG89W107dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZHluYW1pYyYmKGk9ITApLG8ucHVzaChlLnR5cGUpfSk7dmFyIHM9XCJ0dXBsZShcIitvLmpvaW4oXCIsXCIpK1wiKVwiO3JldHVybihuPXRlLmNhbGwodGhpcyxlLFwidHVwbGVcIixzLHIsaSl8fHRoaXMpLmNvZGVycz10LG59ZnVuY3Rpb24gaWUoZSl7ZT1lLnRyaW0oKTtmb3IodmFyIHQ9W10scj1cIlwiLG49MCxpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBvPWVbaV07aWYoXCIsXCI9PT1vJiYwPT09bil0LnB1c2gocikscj1cIlwiO2Vsc2UgaWYocis9byxcIihcIj09PW8pbisrO2Vsc2UgaWYoXCIpXCI9PT1vJiYtMT09PS0tbil0aHJvdyBuZXcgRXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhzaXNcIil9cmV0dXJuIHImJnQucHVzaChyKSx0fXZhciBvZT17YWRkcmVzczpGLGJvb2w6TyxzdHJpbmc6VyxieXRlczpWfTtmdW5jdGlvbiBzZShlLHQpe3ZhciByPW9lW3QudHlwZV07aWYocilyZXR1cm4gbmV3IHIoZSx0Lm5hbWUpO3ZhciBuLGksbyxzLGE9dC50eXBlLm1hdGNoKHApO2lmKGEpcmV0dXJuKDA9PT0odT1wYXJzZUludChhWzJdfHxcIjI1NlwiKSl8fDI1Njx1fHx1JTghPTApJiZsLnRocm93RXJyb3IoXCJpbnZhbGlkIFwiK2FbMV0rXCIgYml0IGxlbmd0aFwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwicGFyYW1cIix2YWx1ZTp0fSksbmV3IFAoZSx1LzgsXCJpbnRcIj09PWFbMV0sdC5uYW1lKTtpZihhPXQudHlwZS5tYXRjaChkKSlyZXR1cm4oMD09PSh1PXBhcnNlSW50KGFbMV0pKXx8MzI8dSkmJmwudGhyb3dFcnJvcihcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJwYXJhbVwiLHZhbHVlOnR9KSxuZXcgQihlLHUsdC5uYW1lKTtpZihhPXQudHlwZS5tYXRjaCh2KSl7dmFyIHU9cGFyc2VJbnQoYVsyXXx8XCItMVwiKTtyZXR1cm4odD1jLnNoYWxsb3dDb3B5KHQpKS50eXBlPWFbMV0sdD1jLmRlZXBDb3B5KHQpLG5ldyBZKGUsc2UoZSx0KSx1LHQubmFtZSl9cmV0dXJuXCJ0dXBsZVwiPT09dC50eXBlLnN1YnN0cmluZygwLDUpPyhuPWUsaT10LmNvbXBvbmVudHMsbz10Lm5hbWUscz1bXSwoaT1pfHxbXSkuZm9yRWFjaChmdW5jdGlvbihlKXtzLnB1c2goc2UobixlKSl9KSxuZXcgcmUobixzLG8pKTpcIlwiPT09dC50eXBlP25ldyBrKGUsdC5uYW1lKToobC50aHJvd0Vycm9yKFwiaW52YWxpZCB0eXBlXCIsbC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ0eXBlXCIsdmFsdWU6dC50eXBlfSksbnVsbCl9dmFyIGFlPSh1ZS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7ZS5sZW5ndGghPT10Lmxlbmd0aCYmbC50aHJvd0Vycm9yKFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiLGwuSU5WQUxJRF9BUkdVTUVOVCx7Y291bnQ6e3R5cGVzOmUubGVuZ3RoLHZhbHVlczp0Lmxlbmd0aH0sdmFsdWU6e3R5cGVzOmUsdmFsdWVzOnR9fSk7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1udWxsLHQ9XCJzdHJpbmdcIj09dHlwZW9mIGU/YihlKTplO3IucHVzaChzZSh0aGlzLmNvZXJjZUZ1bmMsdCkpfSx0aGlzKSxoLmhleGxpZnkobmV3IHJlKHRoaXMuY29lcmNlRnVuYyxyLFwiX1wiKS5lbmNvZGUodCkpfSx1ZS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1udWxsLHQ9XCJzdHJpbmdcIj09dHlwZW9mIGU/YihlKTpjLmRlZXBDb3B5KGUpO3IucHVzaChzZSh0aGlzLmNvZXJjZUZ1bmMsdCkpfSx0aGlzKSxuZXcgcmUodGhpcy5jb2VyY2VGdW5jLHIsXCJfXCIpLmRlY29kZShoLmFycmF5aWZ5KHQpLDApLnZhbHVlfSx1ZSk7ZnVuY3Rpb24gdWUoZSl7bC5jaGVja05ldyh0aGlzLHVlKSxlPWV8fHIuZGVmYXVsdENvZXJjZUZ1bmMsYy5kZWZpbmVSZWFkT25seSh0aGlzLFwiY29lcmNlRnVuY1wiLGUpfXIuQWJpQ29kZXI9YWUsci5kZWZhdWx0QWJpQ29kZXI9bmV3IGFlfSx7XCIuLi9jb25zdGFudHNcIjozLFwiLi4vZXJyb3JzXCI6NSxcIi4vYWRkcmVzc1wiOjYwLFwiLi9iaWdudW1iZXJcIjo2MyxcIi4vYnl0ZXNcIjo2NCxcIi4vcHJvcGVydGllc1wiOjc0LFwiLi91dGY4XCI6ODV9XSw2MDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oZShcImJuLmpzXCIpKSxvPWUoXCIuL2J5dGVzXCIpLHM9ZShcIi4va2VjY2FrMjU2XCIpLGE9ZShcIi4vcmxwXCIpLHU9ZShcIi4uL2Vycm9yc1wiKTtmdW5jdGlvbiBsKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiZlLm1hdGNoKC9eMHhbMC05QS1GYS1mXXs0MH0kLyl8fHUudGhyb3dFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiYWRkcmVzc1wiLHZhbHVlOmV9KTtmb3IodmFyIHQ9KGU9ZS50b0xvd2VyQ2FzZSgpKS5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIikscj1uZXcgVWludDhBcnJheSg0MCksbj0wO248NDA7bisrKXJbbl09dFtuXS5jaGFyQ29kZUF0KDApO3I9by5hcnJheWlmeShzLmtlY2NhazI1NihyKSk7Zm9yKHZhciBpPTA7aTw0MDtpKz0yKTg8PXJbaT4+MV0+PjQmJih0W2ldPXRbaV0udG9VcHBlckNhc2UoKSksODw9KDE1JnJbaT4+MV0pJiYodFtpKzFdPXRbaSsxXS50b1VwcGVyQ2FzZSgpKTtyZXR1cm5cIjB4XCIrdC5qb2luKFwiXCIpfWZvcih2YXIgaD17fSxmPTA7ZjwxMDtmKyspaFtTdHJpbmcoZildPVN0cmluZyhmKTtmb3IoZj0wO2Y8MjY7ZisrKWhbU3RyaW5nLmZyb21DaGFyQ29kZSg2NStmKV09U3RyaW5nKDEwK2YpO3ZhciBjLGQ9TWF0aC5mbG9vcigoYz05MDA3MTk5MjU0NzQwOTkxLE1hdGgubG9nMTA/TWF0aC5sb2cxMChjKTpNYXRoLmxvZyhjKS9NYXRoLkxOMTApKTtmdW5jdGlvbiBwKGUpe2U9KGU9ZS50b1VwcGVyQ2FzZSgpKS5zdWJzdHJpbmcoNCkrZS5zdWJzdHJpbmcoMCwyKStcIjAwXCI7dmFyIHQ9XCJcIjtmb3IoZS5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QrPWhbZV19KTt0Lmxlbmd0aD49ZDspdmFyIHI9dC5zdWJzdHJpbmcoMCxkKSx0PXBhcnNlSW50KHIsMTApJTk3K3Quc3Vic3RyaW5nKHIubGVuZ3RoKTtmb3IodmFyIG49U3RyaW5nKDk4LXBhcnNlSW50KHQsMTApJTk3KTtuLmxlbmd0aDwyOyluPVwiMFwiK247cmV0dXJuIG59ZnVuY3Rpb24gdihlKXt2YXIgdD1udWxsO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlJiZ1LnRocm93RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIix1LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImFkZHJlc3NcIix2YWx1ZTplfSksZS5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKVwiMHhcIiE9PWUuc3Vic3RyaW5nKDAsMikmJihlPVwiMHhcIitlKSx0PWwoZSksZS5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSYmdCE9PWUmJnUudGhyb3dFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJhZGRyZXNzXCIsdmFsdWU6ZX0pO2Vsc2UgaWYoZS5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpe2ZvcihlLnN1YnN0cmluZygyLDQpIT09cChlKSYmdS50aHJvd0Vycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIix1LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImFkZHJlc3NcIix2YWx1ZTplfSksdD1uZXcgaS5kZWZhdWx0LkJOKGUuc3Vic3RyaW5nKDQpLDM2KS50b1N0cmluZygxNik7dC5sZW5ndGg8NDA7KXQ9XCIwXCIrdDt0PWwoXCIweFwiK3QpfWVsc2UgdS50aHJvd0Vycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJhZGRyZXNzXCIsdmFsdWU6ZX0pO3JldHVybiB0fXIuZ2V0QWRkcmVzcz12LHIuZ2V0SWNhcEFkZHJlc3M9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PW5ldyBpLmRlZmF1bHQuQk4odihlKS5zdWJzdHJpbmcoMiksMTYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO3QubGVuZ3RoPDMwOyl0PVwiMFwiK3Q7cmV0dXJuXCJYRVwiK3AoXCJYRTAwXCIrdCkrdH0sci5nZXRDb250cmFjdEFkZHJlc3M9ZnVuY3Rpb24oZSl7aWYoIWUuZnJvbSl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiKTt2YXIgdD1lLm5vbmNlO3JldHVybiB2KFwiMHhcIitzLmtlY2NhazI1NihhLmVuY29kZShbdihlLmZyb20pLG8uc3RyaXBaZXJvcyhvLmhleGxpZnkodCkpXSkpLnN1YnN0cmluZygyNikpfSxyLmdldENyZWF0ZTJBZGRyZXNzPWZ1bmN0aW9uKGUpe3ZhciB0PWUuaW5pdENvZGVIYXNoO2UuaW5pdENvZGUmJih0P3Mua2VjY2FrMjU2KGUuaW5pdENvZGUpIT09dCYmdS50aHJvd0Vycm9yKFwiaW5pdENvZGUvaW5pdENvZGVIYXNoIG1pc21hdGNoXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJvcHRpb25zXCIsdmFsdWU6ZX0pOnQ9cy5rZWNjYWsyNTYoZS5pbml0Q29kZSkpLHR8fHUudGhyb3dFcnJvcihcIm1pc3NpbmcgaW5pdENvZGUgb3IgaW5pdENvZGVIYXNoXCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJvcHRpb25zXCIsdmFsdWU6ZX0pO3ZhciByPXYoZS5mcm9tKSxuPW8uYXJyYXlpZnkoZS5zYWx0KTtyZXR1cm4gMzIhPT1uLmxlbmd0aCYmdS50aHJvd0Vycm9yKFwiaW52YWxpZCBzYWx0XCIsdS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJvcHRpb25zXCIsdmFsdWU6ZX0pLHYoXCIweFwiK3Mua2VjY2FrMjU2KG8uY29uY2F0KFtcIjB4ZmZcIixyLG4sdF0pKS5zdWJzdHJpbmcoMjYpKX19LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2J5dGVzXCI6NjQsXCIuL2tlY2NhazI1NlwiOjcxLFwiLi9ybHBcIjo3NixcImJuLmpzXCI6OX1dLDYxOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4uL3V0aWxzL2J5dGVzXCIpO3QuZXhwb3J0cz17ZGVjb2RlOmZ1bmN0aW9uKGUpe2U9YXRvYihlKTtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7cisrKXQucHVzaChlLmNoYXJDb2RlQXQocikpO3JldHVybiBuLmFycmF5aWZ5KHQpfSxlbmNvZGU6ZnVuY3Rpb24oZSl7ZT1uLmFycmF5aWZ5KGUpO2Zvcih2YXIgdD1cIlwiLHI9MDtyPGUubGVuZ3RoO3IrKyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbcl0pO3JldHVybiBidG9hKHQpfX19LHtcIi4uL3V0aWxzL2J5dGVzXCI6NjR9XSw2MjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPWUoXCIuL2J5dGVzXCIpLG49ZShcIi4vcHJvcGVydGllc1wiKSxpPShvLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oZSl7dmFyIHQ9bC5hcnJheWlmeShlKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuXCJcIjtmb3IodmFyIHI9WzBdLG49MDtuPHQubGVuZ3RoOysrbil7Zm9yKHZhciBpPXRbbl0sbz0wO288ci5sZW5ndGg7KytvKWkrPXJbb108PDgscltvXT1pJXRoaXMuYmFzZSxpPWkvdGhpcy5iYXNlfDA7Zm9yKDswPGk7KXIucHVzaChpJXRoaXMuYmFzZSksaT1pL3RoaXMuYmFzZXwwfWZvcih2YXIgcz1cIlwiLGE9MDswPT09dFthXSYmYTx0Lmxlbmd0aC0xOysrYSlzKz10aGlzLl9sZWFkZXI7Zm9yKHZhciB1PXIubGVuZ3RoLTE7MDw9dTstLXUpcys9dGhpcy5hbHBoYWJldFtyW3VdXTtyZXR1cm4gc30sby5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7dmFyIHQ9W107aWYoMD09PWUubGVuZ3RoKXJldHVybiBuZXcgVWludDhBcnJheSh0KTt0LnB1c2goMCk7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPXRoaXMuX2FscGhhYmV0TWFwW2Vbcl1dO2lmKHZvaWQgMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIit0aGlzLmJhc2UrXCIgY2hhcmFjdGVyXCIpO2Zvcih2YXIgaT1uLG89MDtvPHQubGVuZ3RoOysrbylpKz10W29dKnRoaXMuYmFzZSx0W29dPTI1NSZpLGk+Pj04O2Zvcig7MDxpOyl0LnB1c2goMjU1JmkpLGk+Pj04fWZvcih2YXIgcz0wO2Vbc109PT10aGlzLl9sZWFkZXImJnM8ZS5sZW5ndGgtMTsrK3MpdC5wdXNoKDApO3JldHVybiBsLmFycmF5aWZ5KG5ldyBVaW50OEFycmF5KHQucmV2ZXJzZSgpKSl9LG8pO2Z1bmN0aW9uIG8oZSl7bi5kZWZpbmVSZWFkT25seSh0aGlzLFwiYWxwaGFiZXRcIixlKSxuLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJiYXNlXCIsZS5sZW5ndGgpLG4uZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9hbHBoYWJldE1hcFwiLHt9KSxuLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJfbGVhZGVyXCIsZS5jaGFyQXQoMCkpO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXRoaXMuX2FscGhhYmV0TWFwW2UuY2hhckF0KHQpXT10fXZhciBzPW5ldyhyLkJhc2VYPWkpKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7ci5CYXNlMzI9czt2YXIgYT1uZXcgaShcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7ci5CYXNlNTg9YX0se1wiLi9ieXRlc1wiOjY0LFwiLi9wcm9wZXJ0aWVzXCI6NzR9XSw2MzpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19LGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKGUoXCJibi5qc1wiKSkscz1lKFwiLi9ieXRlc1wiKSxhPWUoXCIuL3Byb3BlcnRpZXNcIiksdT1pKGUoXCIuLi9lcnJvcnNcIikpLGw9bmV3IG8uZGVmYXVsdC5CTigtMSk7ZnVuY3Rpb24gaChlKXt2YXIgdD1lLnRvU3RyaW5nKDE2KTtyZXR1cm5cIi1cIj09PXRbMF0/dC5sZW5ndGglMj09MD9cIi0weDBcIit0LnN1YnN0cmluZygxKTpcIi0weFwiK3Quc3Vic3RyaW5nKDEpOnQubGVuZ3RoJTI9PTE/XCIweDBcIit0OlwiMHhcIit0fWZ1bmN0aW9uIGYoZSl7cmV0dXJuIGQoeShlKSl9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gbmV3IHAoaChlKSl9ZnVuY3Rpb24gZChlKXt2YXIgdD1lLl9oZXg7cmV0dXJuXCItXCI9PT10WzBdP25ldyBvLmRlZmF1bHQuQk4odC5zdWJzdHJpbmcoMyksMTYpLm11bChsKTpuZXcgby5kZWZhdWx0LkJOKHQuc3Vic3RyaW5nKDIpLDE2KX12YXIgcD0odi5wcm90b3R5cGUuZnJvbVR3b3M9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZCh0aGlzKS5mcm9tVHdvcyhlKSl9LHYucHJvdG90eXBlLnRvVHdvcz1mdW5jdGlvbihlKXtyZXR1cm4gYyhkKHRoaXMpLnRvVHdvcyhlKSl9LHYucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVyblwiLVwiPT09dGhpcy5faGV4WzBdP2MoZCh0aGlzKS5tdWwobCkpOnRoaXN9LHYucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXtyZXR1cm4gYyhkKHRoaXMpLmFkZChmKGUpKSl9LHYucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlKXtyZXR1cm4gYyhkKHRoaXMpLnN1YihmKGUpKSl9LHYucHJvdG90eXBlLmRpdj1mdW5jdGlvbihlKXtyZXR1cm4geShlKS5pc1plcm8oKSYmdS50aHJvd0Vycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiLHUuTlVNRVJJQ19GQVVMVCx7b3BlcmF0aW9uOlwiZGl2aWRlXCIsZmF1bHQ6XCJkaXZpc2lvbiBieSB6ZXJvXCJ9KSxjKGQodGhpcykuZGl2KGYoZSkpKX0sdi5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKGUpe3JldHVybiBjKGQodGhpcykubXVsKGYoZSkpKX0sdi5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKGUpe3JldHVybiBjKGQodGhpcykubW9kKGYoZSkpKX0sdi5wcm90b3R5cGUucG93PWZ1bmN0aW9uKGUpe3JldHVybiBjKGQodGhpcykucG93KGYoZSkpKX0sdi5wcm90b3R5cGUubWFza249ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZCh0aGlzKS5tYXNrbihlKSl9LHYucHJvdG90eXBlLmVxPWZ1bmN0aW9uKGUpe3JldHVybiBkKHRoaXMpLmVxKGYoZSkpfSx2LnByb3RvdHlwZS5sdD1mdW5jdGlvbihlKXtyZXR1cm4gZCh0aGlzKS5sdChmKGUpKX0sdi5wcm90b3R5cGUubHRlPWZ1bmN0aW9uKGUpe3JldHVybiBkKHRoaXMpLmx0ZShmKGUpKX0sdi5wcm90b3R5cGUuZ3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGQodGhpcykuZ3QoZihlKSl9LHYucHJvdG90eXBlLmd0ZT1mdW5jdGlvbihlKXtyZXR1cm4gZCh0aGlzKS5ndGUoZihlKSl9LHYucHJvdG90eXBlLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMpLmlzWmVybygpfSx2LnByb3RvdHlwZS50b051bWJlcj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gZCh0aGlzKS50b051bWJlcigpfWNhdGNoKGUpe3UudGhyb3dFcnJvcihcIm92ZXJmbG93XCIsdS5OVU1FUklDX0ZBVUxULHtvcGVyYXRpb246XCJzZXRWYWx1ZVwiLGZhdWx0Olwib3ZlcmZsb3dcIixkZXRhaWxzOmUubWVzc2FnZX0pfXJldHVybiBudWxsfSx2LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMpLnRvU3RyaW5nKDEwKX0sdi5wcm90b3R5cGUudG9IZXhTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGV4fSx2LmlzQmlnTnVtYmVyPWZ1bmN0aW9uKGUpe3JldHVybiBhLmlzVHlwZShlLFwiQmlnTnVtYmVyXCIpfSx2KTtmdW5jdGlvbiB2KGUpe2lmKHUuY2hlY2tOZXcodGhpcyx2KSxhLnNldFR5cGUodGhpcyxcIkJpZ051bWJlclwiKSxcInN0cmluZ1wiPT10eXBlb2YgZSlzLmlzSGV4U3RyaW5nKGUpPyhcIjB4XCI9PWUmJihlPVwiMHgwXCIpLGEuZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9oZXhcIixlKSk6XCItXCI9PT1lWzBdJiZzLmlzSGV4U3RyaW5nKGUuc3Vic3RyaW5nKDEpKT9hLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJfaGV4XCIsZSk6ZS5tYXRjaCgvXi0/WzAtOV0qJC8pPyhcIlwiPT1lJiYoZT1cIjBcIiksYS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGgobmV3IG8uZGVmYXVsdC5CTihlKSkpKTp1LnRocm93RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmcgdmFsdWVcIix1LklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe3BhcnNlSW50KFN0cmluZyhlKSkhPT1lJiZ1LnRocm93RXJyb3IoXCJ1bmRlcmZsb3dcIix1Lk5VTUVSSUNfRkFVTFQse29wZXJhdGlvbjpcInNldFZhbHVlXCIsZmF1bHQ6XCJ1bmRlcmZsb3dcIix2YWx1ZTplLG91dHB1dFZhbHVlOnBhcnNlSW50KFN0cmluZyhlKSl9KTt0cnl7YS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGgobmV3IG8uZGVmYXVsdC5CTihlKSkpfWNhdGNoKGUpe3UudGhyb3dFcnJvcihcIm92ZXJmbG93XCIsdS5OVU1FUklDX0ZBVUxULHtvcGVyYXRpb246XCJzZXRWYWx1ZVwiLGZhdWx0Olwib3ZlcmZsb3dcIixkZXRhaWxzOmUubWVzc2FnZX0pfX1lbHNlIGUgaW5zdGFuY2VvZiB2P2EuZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9oZXhcIixlLl9oZXgpOmUudG9IZXhTdHJpbmc/YS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGgoZihlLnRvSGV4U3RyaW5nKCkpKSk6ZS5faGV4JiZzLmlzSGV4U3RyaW5nKGUuX2hleCk/YS5kZWZpbmVSZWFkT25seSh0aGlzLFwiX2hleFwiLGUuX2hleCk6cy5pc0FycmF5aXNoKGUpP2EuZGVmaW5lUmVhZE9ubHkodGhpcyxcIl9oZXhcIixoKG5ldyBvLmRlZmF1bHQuQk4ocy5oZXhsaWZ5KGUpLnN1YnN0cmluZygyKSwxNikpKTp1LnRocm93RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSl9ZnVuY3Rpb24geShlKXtyZXR1cm4gcC5pc0JpZ051bWJlcihlKT9lOm5ldyBwKGUpfXIuQmlnTnVtYmVyPXAsci5iaWdOdW1iZXJpZnk9eX0se1wiLi4vZXJyb3JzXCI6NSxcIi4vYnl0ZXNcIjo2NCxcIi4vcHJvcGVydGllc1wiOjc0LFwiYm4uanNcIjo5fV0sNjQ6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPW4oZShcIi4uL2Vycm9yc1wiKSk7ZnVuY3Rpb24gcyhlKXtyZXR1cm4hIWUudG9IZXhTdHJpbmd9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gdC5zbGljZXx8KHQuc2xpY2U9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiB1KG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0LGUpKSl9KSx0fWZ1bmN0aW9uIGwoZSl7aWYoIWV8fHBhcnNlSW50KFN0cmluZyhlLmxlbmd0aCkpIT1lLmxlbmd0aHx8XCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuITE7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDt0Kyspe3ZhciByPWVbdF07aWYocjwwfHwyNTY8PXJ8fHBhcnNlSW50KFN0cmluZyhyKSkhPXIpcmV0dXJuITF9cmV0dXJuITB9ZnVuY3Rpb24gaChlKXtpZihudWxsPT1lJiZhLnRocm93RXJyb3IoXCJjYW5ub3QgY29udmVydCBudWxsIHZhbHVlIHRvIGFycmF5XCIsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KSxzKGUpJiYoZT1lLnRvSGV4U3RyaW5nKCkpLFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiBsKGUpP3UobmV3IFVpbnQ4QXJyYXkoZSkpOihhLnRocm93RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsbnVsbCx7YXJnOlwidmFsdWVcIix2YWx1ZTplLHR5cGU6dHlwZW9mIGV9KSxudWxsKTt2YXIgdD1lLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXSokLyk7dHx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXhpZGVjaW1hbCBzdHJpbmdcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLFwiMHhcIiE9PXRbMV0mJmEudGhyb3dFcnJvcihcImhleCBzdHJpbmcgbXVzdCBoYXZlIDB4IHByZWZpeFwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksKGU9ZS5zdWJzdHJpbmcoMikpLmxlbmd0aCUyJiYoZT1cIjBcIitlKTtmb3IodmFyIHI9W10sbj0wO248ZS5sZW5ndGg7bis9MilyLnB1c2gocGFyc2VJbnQoZS5zdWJzdHIobiwyKSwxNikpO3JldHVybiB1KG5ldyBVaW50OEFycmF5KHIpKX1mdW5jdGlvbiBpKGUpe2Zvcih2YXIgdD1bXSxyPTAsbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1oKGVbbl0pO3QucHVzaChpKSxyKz1pLmxlbmd0aH1mb3IodmFyIG89bmV3IFVpbnQ4QXJyYXkocikscz0wLG49MDtuPHQubGVuZ3RoO24rKylvLnNldCh0W25dLHMpLHMrPXRbbl0ubGVuZ3RoO3JldHVybiB1KG8pfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4hKFwic3RyaW5nXCIhPXR5cGVvZiBlfHwhZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSYmKCF0fHxlLmxlbmd0aD09PTIrMip0KX1yLmlzSGV4YWJsZT1zLHIuaXNBcnJheWlzaD1sLHIuYXJyYXlpZnk9aCxyLmNvbmNhdD1pLHIuc3RyaXBaZXJvcz1mdW5jdGlvbihlKXt2YXIgdD1oKGUpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gdDtmb3IodmFyIHI9MDswPT09dFtyXTspcisrO3JldHVybiByJiYodD10LnNsaWNlKHIpKSx0fSxyLnBhZFplcm9zPWZ1bmN0aW9uKGUsdCl7aWYodDwoZT1oKGUpKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHBhZFwiKTt2YXIgcj1uZXcgVWludDhBcnJheSh0KTtyZXR1cm4gci5zZXQoZSx0LWUubGVuZ3RoKSx1KHIpfSxyLmlzSGV4U3RyaW5nPW87dmFyIGY9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7ZnVuY3Rpb24gYyhlKXtpZihzKGUpKXJldHVybiBlLnRvSGV4U3RyaW5nKCk7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe2U8MCYmYS50aHJvd0Vycm9yKFwiY2Fubm90IGhleGxpZnkgbmVnYXRpdmUgdmFsdWVcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLDkwMDcxOTkyNTQ3NDA5OTE8PWUmJmEudGhyb3dFcnJvcihcIm91dC1vZi1yYW5nZVwiLGEuTlVNRVJJQ19GQVVMVCx7b3BlcmFydGlvbjpcImhleGxpZnlcIixmYXVsdDpcIm91dC1vZi1zYWZlLXJhbmdlXCJ9KTtmb3IodmFyIHQ9XCJcIjtlOyl0PWZbMTUmZV0rdCxlPU1hdGguZmxvb3IoZS8xNik7cmV0dXJuIHQubGVuZ3RoPyh0Lmxlbmd0aCUyJiYodD1cIjBcIit0KSxcIjB4XCIrdCk6XCIweDAwXCJ9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciByPWUubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdKiQvKTtyZXR1cm4gcnx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXhpZGVjaW1hbCBzdHJpbmdcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLFwiMHhcIiE9PXJbMV0mJmEudGhyb3dFcnJvcihcImhleCBzdHJpbmcgbXVzdCBoYXZlIDB4IHByZWZpeFwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksZS5sZW5ndGglMiYmKGU9XCIweDBcIitlLnN1YnN0cmluZygyKSksZX1pZihsKGUpKXtmb3IodmFyIG49W10saT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbz1lW2ldO24ucHVzaChmWygyNDAmbyk+PjRdK2ZbMTUmb10pfXJldHVyblwiMHhcIituLmpvaW4oXCJcIil9cmV0dXJuIGEudGhyb3dFcnJvcihcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiLG51bGwse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pLFwibmV2ZXJcIn1mdW5jdGlvbiBkKGUsdCl7Zm9yKG8oZSl8fGEudGhyb3dFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSk7ZS5sZW5ndGg8Mip0KzI7KWU9XCIweDBcIitlLnN1YnN0cmluZygyKTtyZXR1cm4gZX1mdW5jdGlvbiBwKGUpe3ZhciB0LHI9MCxuPVwiMHhcIixpPVwiMHhcIjtpZigodD1lKSYmbnVsbCE9dC5yJiZudWxsIT10LnMpe251bGw9PWUudiYmbnVsbD09ZS5yZWNvdmVyeVBhcmFtJiZhLnRocm93RXJyb3IoXCJhdCBsZWFzdCBvbiBvZiByZWNvdmVyeVBhcmFtIG9yIHYgbXVzdCBiZSBzcGVjaWZpZWRcIixhLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50Olwic2lnbmF0dXJlXCIsdmFsdWU6ZX0pLG49ZChlLnIsMzIpLGk9ZChlLnMsMzIpLFwic3RyaW5nXCI9PXR5cGVvZihyPWUudikmJihyPXBhcnNlSW50KHIsMTYpKTt2YXIgbz1lLnJlY292ZXJ5UGFyYW07bnVsbD09byYmbnVsbCE9ZS52JiYobz0xLXIlMikscj0yNytvfWVsc2V7dmFyIHM9aChlKTtpZig2NSE9PXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2lnbmF0dXJlXCIpO249YyhzLnNsaWNlKDAsMzIpKSxpPWMocy5zbGljZSgzMiw2NCkpLDI3IT09KHI9c1s2NF0pJiYyOCE9PXImJihyPTI3K3IlMil9cmV0dXJue3I6bixzOmkscmVjb3ZlcnlQYXJhbTpyLTI3LHY6cn19ci5oZXhsaWZ5PWMsci5oZXhEYXRhTGVuZ3RoPWZ1bmN0aW9uKGUpe3JldHVybiBvKGUpJiZlLmxlbmd0aCUyPT0wPyhlLmxlbmd0aC0yKS8yOm51bGx9LHIuaGV4RGF0YVNsaWNlPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbyhlKXx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXggZGF0YVwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksZS5sZW5ndGglMiE9MCYmYS50aHJvd0Vycm9yKFwiaGV4IGRhdGEgbGVuZ3RoIG11c3QgYmUgZXZlblwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidmFsdWVcIix2YWx1ZTplfSksdD0yKzIqdCxudWxsIT1yP1wiMHhcIitlLnN1YnN0cmluZyh0LDIrMipyKTpcIjB4XCIrZS5zdWJzdHJpbmcodCl9LHIuaGV4U3RyaXBaZXJvcz1mdW5jdGlvbihlKXtmb3IobyhlKXx8YS50aHJvd0Vycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KTszPGUubGVuZ3RoJiZcIjB4MFwiPT09ZS5zdWJzdHJpbmcoMCwzKTspZT1cIjB4XCIrZS5zdWJzdHJpbmcoMyk7cmV0dXJuIGV9LHIuaGV4WmVyb1BhZD1kLHIuc3BsaXRTaWduYXR1cmU9cCxyLmpvaW5TaWduYXR1cmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoaShbKGU9cChlKSkucixlLnMsZS5yZWNvdmVyeVBhcmFtP1wiMHgxY1wiOlwiMHgxYlwiXSkpfX0se1wiLi4vZXJyb3JzXCI6NX1dLDY1OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1uKGUoXCIuLi9lcnJvcnNcIikpLG89ZShcIi4vYnl0ZXNcIikscz1lKFwiLi91dGY4XCIpLGE9ZShcIi4va2VjY2FrMjU2XCIpLHU9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF0pLGw9bmV3IFJlZ0V4cChcIl4oKC4qKVxcXFwuKT8oW14uXSspJFwiKSxoPW5ldyBSZWdFeHAoXCJeW2EtejAtOS4tXSokXCIpO3IubmFtZWhhc2g9ZnVuY3Rpb24oZSl7XCJzdHJpbmdcIiE9dHlwZW9mIGUmJmkudGhyb3dFcnJvcihcImludmFsaWQgYWRkcmVzcyAtIFwiK1N0cmluZyhlKSxpLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmFtZVwiLHZhbHVlOmV9KSwoZT1lLnRvTG93ZXJDYXNlKCkpLm1hdGNoKGgpfHxpLnRocm93RXJyb3IoXCJjb250YWlucyBpbnZhbGlkIFVzZVNURDNBU0NJSVJ1bGVzIGNoYXJhY3RlcnNcIixpLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmFtZVwiLHZhbHVlOmV9KTtmb3IodmFyIHQ9dTtlLmxlbmd0aDspe3ZhciByPWUubWF0Y2gobCksbj1zLnRvVXRmOEJ5dGVzKHJbM10pLHQ9YS5rZWNjYWsyNTYoby5jb25jYXQoW3QsYS5rZWNjYWsyNTYobildKSk7ZT1yWzJdfHxcIlwifXJldHVybiBvLmhleGxpZnkodCl9LHIuaWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGEua2VjY2FrMjU2KHMudG9VdGY4Qnl0ZXMoZSkpfSxyLmhhc2hNZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiBhLmtlY2NhazI1NihvLmNvbmNhdChbcy50b1V0ZjhCeXRlcyhcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCIpLHMudG9VdGY4Qnl0ZXMoU3RyaW5nKGUubGVuZ3RoKSksXCJzdHJpbmdcIj09dHlwZW9mIGU/cy50b1V0ZjhCeXRlcyhlKTplXSkpfX0se1wiLi4vZXJyb3JzXCI6NSxcIi4vYnl0ZXNcIjo2NCxcIi4va2VjY2FrMjU2XCI6NzEsXCIuL3V0ZjhcIjo4NX1dLDY2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZj1uKGUoXCIuLi9lcnJvcnNcIikpLGM9ZShcIi4uL3dvcmRsaXN0cy9sYW5nLWVuXCIpLGE9ZShcIi4vYmFzZXhcIiksZD1lKFwiLi9ieXRlc1wiKSxsPWUoXCIuL2JpZ251bWJlclwiKSxpPWUoXCIuL3V0ZjhcIiksbz1lKFwiLi9wYmtkZjJcIiksaD1lKFwiLi9obWFjXCIpLHA9ZShcIi4vcHJvcGVydGllc1wiKSx2PWUoXCIuL3NlY3AyNTZrMVwiKSx5PWUoXCIuL3NoYTJcIiksbT1sLmJpZ051bWJlcmlmeShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKSxzPWkudG9VdGY4Qnl0ZXMoXCJCaXRjb2luIHNlZWRcIiksZz0yMTQ3NDgzNjQ4O2Z1bmN0aW9uIGIoZSl7cmV0dXJuKDE8PGUpLTE8PDgtZX1mdW5jdGlvbiB3KGUpe3JldHVybiBkLmhleFplcm9QYWQoZC5oZXhsaWZ5KGUpLDMyKX1mdW5jdGlvbiB1KGUpe3ZhciB0PWQuaGV4RGF0YVNsaWNlKHkuc2hhMjU2KHkuc2hhMjU2KGUpKSwwLDQpO3JldHVybiBhLkJhc2U1OC5lbmNvZGUoZC5jb25jYXQoW2UsdF0pKX12YXIgXz17fTtyLmRlZmF1bHRQYXRoPVwibS80NCcvNjAnLzAnLzAvMFwiO3ZhciBNPShPYmplY3QuZGVmaW5lUHJvcGVydHkoQS5wcm90b3R5cGUsXCJleHRlbmRlZEtleVwiLHtnZXQ6ZnVuY3Rpb24oKXtpZigyNTY8PXRoaXMuZGVwdGgpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGggdG9vIGxhcmdlIVwiKTtyZXR1cm4gdShkLmNvbmNhdChbbnVsbCE9dGhpcy5wcml2YXRlS2V5P1wiMHgwNDg4QURFNFwiOlwiMHgwNDg4QjIxRVwiLGQuaGV4bGlmeSh0aGlzLmRlcHRoKSx0aGlzLnBhcmVudEZpbmdlcnByaW50LGQuaGV4WmVyb1BhZChkLmhleGxpZnkodGhpcy5pbmRleCksNCksdGhpcy5jaGFpbkNvZGUsbnVsbCE9dGhpcy5wcml2YXRlS2V5P2QuY29uY2F0KFtcIjB4MDBcIix0aGlzLnByaXZhdGVLZXldKTp0aGlzLnB1YmxpY0tleV0pKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxBLnByb3RvdHlwZS5uZXV0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEEoXyxudWxsLHRoaXMucHVibGljS2V5LHRoaXMucGFyZW50RmluZ2VycHJpbnQsdGhpcy5jaGFpbkNvZGUsdGhpcy5pbmRleCx0aGlzLmRlcHRoLG51bGwsdGhpcy5wYXRoKX0sQS5wcm90b3R5cGUuX2Rlcml2ZT1mdW5jdGlvbihlKXtpZig0Mjk0OTY3Mjk1PGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmRleCAtIFwiK1N0cmluZyhlKSk7dmFyIHQ9dGhpcy5wYXRoO3QmJih0Kz1cIi9cIisoZSZ+ZykpO3ZhciByPW5ldyBVaW50OEFycmF5KDM3KTtpZihlJmcpe2lmKCF0aGlzLnByaXZhdGVLZXkpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIpO3Iuc2V0KGQuYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSwxKSx0JiYodCs9XCInXCIpfWVsc2Ugci5zZXQoZC5hcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO2Zvcih2YXIgbj0yNDswPD1uO24tPTgpclszMysobj4+MyldPWU+PjI0LW4mMjU1O3ZhciBpPWguY29tcHV0ZUhtYWMoaC5TdXBwb3J0ZWRBbGdvcml0aG1zLnNoYTUxMix0aGlzLmNoYWluQ29kZSxyKSxvPWkuc2xpY2UoMCwzMikscz1pLnNsaWNlKDMyKSxhPW51bGwsdT1udWxsO3JldHVybiB0aGlzLnByaXZhdGVLZXk/YT13KGwuYmlnTnVtYmVyaWZ5KG8pLmFkZCh0aGlzLnByaXZhdGVLZXkpLm1vZChtKSk6dT1uZXcgdi5LZXlQYWlyKGQuaGV4bGlmeShvKSkuX2FkZFBvaW50KHRoaXMucHVibGljS2V5KSxuZXcgQShfLGEsdSx0aGlzLmZpbmdlcnByaW50LHcocyksZSx0aGlzLmRlcHRoKzEsdGhpcy5tbmVtb25pYyx0KX0sQS5wcm90b3R5cGUuZGVyaXZlUGF0aD1mdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KFwiL1wiKTtpZigwPT09dC5sZW5ndGh8fFwibVwiPT09dFswXSYmMCE9PXRoaXMuZGVwdGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXRoIC0gXCIrZSk7XCJtXCI9PT10WzBdJiZ0LnNoaWZ0KCk7Zm9yKHZhciByPXRoaXMsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2lmKGkubWF0Y2goL15bMC05XSsnJC8pKXt2YXIgbz1wYXJzZUludChpLnN1YnN0cmluZygwLGkubGVuZ3RoLTEpKTtpZihnPD1vKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBpbmRleCAtIFwiK2kpO3I9ci5fZGVyaXZlKGcrbyl9ZWxzZXtpZighaS5tYXRjaCgvXlswLTldKyQvKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggY29tcG9uZW50IC0gXCIraSk7bz1wYXJzZUludChpKTtpZihnPD1vKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBpbmRleCAtIFwiK2kpO3I9ci5fZGVyaXZlKG8pfX1yZXR1cm4gcn0sQS5pc0hETm9kZT1mdW5jdGlvbihlKXtyZXR1cm4gcC5pc1R5cGUoZSxcIkhETm9kZVwiKX0sQSk7ZnVuY3Rpb24gQShlLHQscixuLGksbyxzLGEsdSl7aWYoZi5jaGVja05ldyh0aGlzLEEpLGUhPT1fKXRocm93IG5ldyBFcnJvcihcIkhETm9kZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpO3ZhciBsO3Q/KGw9bmV3IHYuS2V5UGFpcih0KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcml2YXRlS2V5XCIsbC5wcml2YXRlS2V5KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixsLmNvbXByZXNzZWRQdWJsaWNLZXkpKToocC5kZWZpbmVSZWFkT25seSh0aGlzLFwicHJpdmF0ZUtleVwiLG51bGwpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInB1YmxpY0tleVwiLGQuaGV4bGlmeShyKSkpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcInBhcmVudEZpbmdlcnByaW50XCIsbikscC5kZWZpbmVSZWFkT25seSh0aGlzLFwiZmluZ2VycHJpbnRcIixkLmhleERhdGFTbGljZSh5LnJpcGVtZDE2MCh5LnNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLDAsNCkpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImFkZHJlc3NcIix2LmNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwiY2hhaW5Db2RlXCIsaSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwiaW5kZXhcIixvKSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJkZXB0aFwiLHMpLHAuZGVmaW5lUmVhZE9ubHkodGhpcyxcIm1uZW1vbmljXCIsYSkscC5kZWZpbmVSZWFkT25seSh0aGlzLFwicGF0aFwiLHUpLHAuc2V0VHlwZSh0aGlzLFwiSEROb2RlXCIpfWZ1bmN0aW9uIEUoZSx0KXt2YXIgcj1kLmFycmF5aWZ5KGUpO2lmKHIubGVuZ3RoPDE2fHw2NDxyLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlZWRcIik7dmFyIG49ZC5hcnJheWlmeShoLmNvbXB1dGVIbWFjKGguU3VwcG9ydGVkQWxnb3JpdGhtcy5zaGE1MTIscyxyKSk7cmV0dXJuIG5ldyBNKF8sdyhuLnNsaWNlKDAsMzIpKSxudWxsLFwiMHgwMDAwMDAwMFwiLHcobi5zbGljZSgzMikpLDAsMCx0LFwibVwiKX1mdW5jdGlvbiBTKGUsdCl7dD10fHxcIlwiO3ZhciByPWkudG9VdGY4Qnl0ZXMoXCJtbmVtb25pY1wiK3QsaS5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLRCk7cmV0dXJuIGQuaGV4bGlmeShvLnBia2RmMihpLnRvVXRmOEJ5dGVzKGUsaS5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLRCksciwyMDQ4LDY0LFwic2hhNTEyXCIpKX1mdW5jdGlvbiBrKGUsdCl7dD10fHxjLmxhbmdFbixmLmNoZWNrTm9ybWFsaXplKCk7dmFyIHI9dC5zcGxpdChlKTtpZihyLmxlbmd0aCUzIT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIik7Zm9yKHZhciBuPWQuYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExKnIubGVuZ3RoLzgpKSksaT0wLG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIHM9dC5nZXRXb3JkSW5kZXgocltvXS5ub3JtYWxpemUoXCJORktEXCIpKTtpZigtMT09PXMpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKTtmb3IodmFyIGE9MDthPDExO2ErKylzJjE8PDEwLWEmJihuW2k+PjNdfD0xPDw3LWklOCksaSsrfXZhciB1PTMyKnIubGVuZ3RoLzMsbD1iKHIubGVuZ3RoLzMpLGg9ZC5hcnJheWlmeSh5LnNoYTI1NihuLnNsaWNlKDAsdS84KSkpWzBdO2lmKChoJj1sKSE9KG5bbi5sZW5ndGgtMV0mbCkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaGVja3N1bVwiKTtyZXR1cm4gZC5oZXhsaWZ5KG4uc2xpY2UoMCx1LzgpKX1mdW5jdGlvbiBOKGUsdCl7aWYoKGU9ZC5hcnJheWlmeShlKSkubGVuZ3RoJTQhPTB8fGUubGVuZ3RoPDE2fHwzMjxlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVudHJvcHlcIik7Zm9yKHZhciByPVswXSxuPTExLGk9MDtpPGUubGVuZ3RoO2krKyk4PG4/KHJbci5sZW5ndGgtMV08PD04LHJbci5sZW5ndGgtMV18PWVbaV0sbi09OCk6KHJbci5sZW5ndGgtMV08PD1uLHJbci5sZW5ndGgtMV18PWVbaV0+PjgtbixyLnB1c2goZVtpXSYoMTw8OC1uKS0xKSxuKz0zKTt2YXIgbz1kLmFycmF5aWZ5KHkuc2hhMjU2KGUpKVswXSxzPWUubGVuZ3RoLzQ7cmV0dXJuIG8mPWIocykscltyLmxlbmd0aC0xXTw8PXMscltyLmxlbmd0aC0xXXw9bz4+OC1zLCh0PXR8fGMubGFuZ0VuKS5qb2luKHIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0LmdldFdvcmQoZSl9KSl9ci5IRE5vZGU9TSxyLmZyb21FeHRlbmRlZEtleT1mdW5jdGlvbihlKXt2YXIgdD1hLkJhc2U1OC5kZWNvZGUoZSk7ODI9PT10Lmxlbmd0aCYmdSh0LnNsaWNlKDAsNzgpKT09PWV8fGYudGhyb3dFcnJvcihcImludmFsaWQgZXh0ZW5kZWQga2V5XCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcImV4dGVuZGVkS2V5XCIsdmFsdWU6XCJbUkVEQUNURURdXCJ9KTt2YXIgcj10WzRdLG49ZC5oZXhsaWZ5KHQuc2xpY2UoNSw5KSksaT1wYXJzZUludChkLmhleGxpZnkodC5zbGljZSg5LDEzKSkuc3Vic3RyaW5nKDIpLDE2KSxvPWQuaGV4bGlmeSh0LnNsaWNlKDEzLDQ1KSkscz10LnNsaWNlKDQ1LDc4KTtzd2l0Y2goZC5oZXhsaWZ5KHQuc2xpY2UoMCw0KSkpe2Nhc2VcIjB4MDQ4OGIyMWVcIjpjYXNlXCIweDA0MzU4N2NmXCI6cmV0dXJuIG5ldyBNKF8sbnVsbCxkLmhleGxpZnkocyksbixvLGkscixudWxsLG51bGwpO2Nhc2VcIjB4MDQ4OGFkZTRcIjpjYXNlXCIweDA0MzU4Mzk0XCI6aWYoMCE9PXNbMF0pYnJlYWs7cmV0dXJuIG5ldyBNKF8sZC5oZXhsaWZ5KHMuc2xpY2UoMSkpLG51bGwsbixvLGkscixudWxsLG51bGwpfXJldHVybiBmLnRocm93RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLGYuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJleHRlbmRlZEtleVwiLHZhbHVlOlwiW1JFREFDVEVEXVwifSl9LHIuZnJvbU1uZW1vbmljPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gRShTKGU9TihrKGUsdCksdCksciksZSl9LHIuZnJvbVNlZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIEUoZSxudWxsKX0sci5tbmVtb25pY1RvU2VlZD1TLHIubW5lbW9uaWNUb0VudHJvcHk9ayxyLmVudHJvcHlUb01uZW1vbmljPU4sci5pc1ZhbGlkTW5lbW9uaWM9ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIGsoZSx0KSwhMH1jYXRjaChlKXt9cmV0dXJuITF9fSx7XCIuLi9lcnJvcnNcIjo1LFwiLi4vd29yZGxpc3RzL2xhbmctZW5cIjo5MCxcIi4vYmFzZXhcIjo2MixcIi4vYmlnbnVtYmVyXCI6NjMsXCIuL2J5dGVzXCI6NjQsXCIuL2htYWNcIjo2NyxcIi4vcGJrZGYyXCI6NzMsXCIuL3Byb3BlcnRpZXNcIjo3NCxcIi4vc2VjcDI1NmsxXCI6NzcsXCIuL3NoYTJcIjo3OSxcIi4vdXRmOFwiOjg1fV0sNjc6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpLG8scz1uKGUoXCJoYXNoLmpzXCIpKSxhPWUoXCIuLi91dGlscy9ieXRlc1wiKSx1PW4oZShcIi4uL2Vycm9yc1wiKSk7KG89aT1yLlN1cHBvcnRlZEFsZ29yaXRobXN8fChyLlN1cHBvcnRlZEFsZ29yaXRobXM9e30pKS5zaGEyNTY9XCJzaGEyNTZcIixvLnNoYTUxMj1cInNoYTUxMlwiLHIuY29tcHV0ZUhtYWM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBpW2VdfHx1LnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG0gXCIrZSx1LlVOU1VQUE9SVEVEX09QRVJBVElPTix7b3BlcmF0aW9uOlwiaG1hY1wiLGFsZ29yaXRobTplfSksYS5hcnJheWlmeShzLmhtYWMoc1tlXSxhLmFycmF5aWZ5KHQpKS51cGRhdGUoYS5hcnJheWlmeShyKSkuZGlnZXN0KCkpfX0se1wiLi4vZXJyb3JzXCI6NSxcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCJoYXNoLmpzXCI6MjZ9XSw2ODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9ZShcIi4vYWJpLWNvZGVyXCIpO3IuQWJpQ29kZXI9aS5BYmlDb2RlcixyLmRlZmF1bHRBYmlDb2Rlcj1pLmRlZmF1bHRBYmlDb2RlcixyLmZvcm1hdFNpZ25hdHVyZT1pLmZvcm1hdFNpZ25hdHVyZSxyLmZvcm1hdFBhcmFtVHlwZT1pLmZvcm1hdFBhcmFtVHlwZSxyLnBhcnNlU2lnbmF0dXJlPWkucGFyc2VTaWduYXR1cmUsci5wYXJzZVBhcmFtVHlwZT1pLnBhcnNlUGFyYW1UeXBlO3ZhciBvPWUoXCIuL2FkZHJlc3NcIik7ci5nZXRBZGRyZXNzPW8uZ2V0QWRkcmVzcyxyLmdldENvbnRyYWN0QWRkcmVzcz1vLmdldENvbnRyYWN0QWRkcmVzcyxyLmdldENyZWF0ZTJBZGRyZXNzPW8uZ2V0Q3JlYXRlMkFkZHJlc3Msci5nZXRJY2FwQWRkcmVzcz1vLmdldEljYXBBZGRyZXNzO3ZhciBzPW4oZShcIi4vYmFzZTY0XCIpKTtyLmJhc2U2ND1zO3ZhciBhPWUoXCIuL2JpZ251bWJlclwiKTtyLkJpZ051bWJlcj1hLkJpZ051bWJlcixyLmJpZ051bWJlcmlmeT1hLmJpZ051bWJlcmlmeTt2YXIgdT1lKFwiLi9ieXRlc1wiKTtyLmFycmF5aWZ5PXUuYXJyYXlpZnksci5jb25jYXQ9dS5jb25jYXQsci5oZXhEYXRhU2xpY2U9dS5oZXhEYXRhU2xpY2Usci5oZXhEYXRhTGVuZ3RoPXUuaGV4RGF0YUxlbmd0aCxyLmhleGxpZnk9dS5oZXhsaWZ5LHIuaGV4U3RyaXBaZXJvcz11LmhleFN0cmlwWmVyb3Msci5oZXhaZXJvUGFkPXUuaGV4WmVyb1BhZCxyLmlzSGV4U3RyaW5nPXUuaXNIZXhTdHJpbmcsci5qb2luU2lnbmF0dXJlPXUuam9pblNpZ25hdHVyZSxyLnBhZFplcm9zPXUucGFkWmVyb3Msci5zcGxpdFNpZ25hdHVyZT11LnNwbGl0U2lnbmF0dXJlLHIuc3RyaXBaZXJvcz11LnN0cmlwWmVyb3M7dmFyIGw9ZShcIi4vaGFzaFwiKTtyLmhhc2hNZXNzYWdlPWwuaGFzaE1lc3NhZ2Usci5pZD1sLmlkLHIubmFtZWhhc2g9bC5uYW1laGFzaDt2YXIgaD1uKGUoXCIuL2hkbm9kZVwiKSk7ci5IRE5vZGU9aDt2YXIgZj1lKFwiLi9pbnRlcmZhY2VcIik7ci5JbnRlcmZhY2U9Zi5JbnRlcmZhY2U7dmFyIGM9ZShcIi4vanNvbi13YWxsZXRcIik7ci5nZXRKc29uV2FsbGV0QWRkcmVzcz1jLmdldEpzb25XYWxsZXRBZGRyZXNzO3ZhciBkPWUoXCIuL2tlY2NhazI1NlwiKTtyLmtlY2NhazI1Nj1kLmtlY2NhazI1Njt2YXIgcD1lKFwiLi9zaGEyXCIpO3Iuc2hhMjU2PXAuc2hhMjU2O3ZhciB2PWUoXCIuL3NvbGlkaXR5XCIpO3Iuc29saWRpdHlLZWNjYWsyNTY9di5rZWNjYWsyNTYsci5zb2xpZGl0eVBhY2s9di5wYWNrLHIuc29saWRpdHlTaGEyNTY9di5zaGEyNTY7dmFyIHk9ZShcIi4vcmFuZG9tLWJ5dGVzXCIpO3IucmFuZG9tQnl0ZXM9eS5yYW5kb21CeXRlczt2YXIgbT1lKFwiLi9uZXR3b3Jrc1wiKTtyLmdldE5ldHdvcms9bS5nZXROZXR3b3JrO3ZhciBnPWUoXCIuL3Byb3BlcnRpZXNcIik7ci5jaGVja1Byb3BlcnRpZXM9Zy5jaGVja1Byb3BlcnRpZXMsci5kZWVwQ29weT1nLmRlZXBDb3B5LHIuZGVmaW5lUmVhZE9ubHk9Zy5kZWZpbmVSZWFkT25seSxyLnJlc29sdmVQcm9wZXJ0aWVzPWcucmVzb2x2ZVByb3BlcnRpZXMsci5zaGFsbG93Q29weT1nLnNoYWxsb3dDb3B5O3ZhciBiPW4oZShcIi4vcmxwXCIpKTtyLlJMUD1iO3ZhciB3PWUoXCIuL3NlY3AyNTZrMVwiKTtyLmNvbXB1dGVBZGRyZXNzPXcuY29tcHV0ZUFkZHJlc3Msci5jb21wdXRlUHVibGljS2V5PXcuY29tcHV0ZVB1YmxpY0tleSxyLnJlY292ZXJBZGRyZXNzPXcucmVjb3ZlckFkZHJlc3Msci5yZWNvdmVyUHVibGljS2V5PXcucmVjb3ZlclB1YmxpY0tleSxyLnZlcmlmeU1lc3NhZ2U9dy52ZXJpZnlNZXNzYWdlO3ZhciBfPWUoXCIuL3NpZ25pbmcta2V5XCIpO3IuU2lnbmluZ0tleT1fLlNpZ25pbmdLZXk7dmFyIE09ZShcIi4vdHJhbnNhY3Rpb25cIik7ci5wb3B1bGF0ZVRyYW5zYWN0aW9uPU0ucG9wdWxhdGVUcmFuc2FjdGlvbjt2YXIgQT1lKFwiLi90cmFuc2FjdGlvblwiKTtyLnBhcnNlVHJhbnNhY3Rpb249QS5wYXJzZSxyLnNlcmlhbGl6ZVRyYW5zYWN0aW9uPUEuc2VyaWFsaXplO3ZhciBFPWUoXCIuL3V0ZjhcIik7ci5mb3JtYXRCeXRlczMyU3RyaW5nPUUuZm9ybWF0Qnl0ZXMzMlN0cmluZyxyLnBhcnNlQnl0ZXMzMlN0cmluZz1FLnBhcnNlQnl0ZXMzMlN0cmluZyxyLnRvVXRmOEJ5dGVzPUUudG9VdGY4Qnl0ZXMsci50b1V0ZjhTdHJpbmc9RS50b1V0ZjhTdHJpbmc7dmFyIFM9ZShcIi4vdW5pdHNcIik7ci5jb21taWZ5PVMuY29tbWlmeSxyLmZvcm1hdEV0aGVyPVMuZm9ybWF0RXRoZXIsci5wYXJzZUV0aGVyPVMucGFyc2VFdGhlcixyLmZvcm1hdFVuaXRzPVMuZm9ybWF0VW5pdHMsci5wYXJzZVVuaXRzPVMucGFyc2VVbml0czt2YXIgaz1lKFwiLi93ZWJcIik7ci5mZXRjaEpzb249ay5mZXRjaEpzb24sci5wb2xsPWsucG9sbDt2YXIgTj1lKFwiLi9obWFjXCIpO3IuU3VwcG9ydGVkQWxnb3JpdGhtcz1OLlN1cHBvcnRlZEFsZ29yaXRobXM7dmFyIHg9ZShcIi4vdXRmOFwiKTtyLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybT14LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTt2YXIgUD1lKFwiLi93b3JkbGlzdFwiKTtyLldvcmRsaXN0PVAuV29yZGxpc3R9LHtcIi4vYWJpLWNvZGVyXCI6NTksXCIuL2FkZHJlc3NcIjo2MCxcIi4vYmFzZTY0XCI6NjEsXCIuL2JpZ251bWJlclwiOjYzLFwiLi9ieXRlc1wiOjY0LFwiLi9oYXNoXCI6NjUsXCIuL2hkbm9kZVwiOjY2LFwiLi9obWFjXCI6NjcsXCIuL2ludGVyZmFjZVwiOjY5LFwiLi9qc29uLXdhbGxldFwiOjcwLFwiLi9rZWNjYWsyNTZcIjo3MSxcIi4vbmV0d29ya3NcIjo3MixcIi4vcHJvcGVydGllc1wiOjc0LFwiLi9yYW5kb20tYnl0ZXNcIjo3NSxcIi4vcmxwXCI6NzYsXCIuL3NlY3AyNTZrMVwiOjc3LFwiLi9zaGEyXCI6NzksXCIuL3NpZ25pbmcta2V5XCI6ODEsXCIuL3NvbGlkaXR5XCI6ODIsXCIuL3RyYW5zYWN0aW9uXCI6ODMsXCIuL3VuaXRzXCI6ODQsXCIuL3V0ZjhcIjo4NSxcIi4vd2ViXCI6ODYsXCIuL3dvcmRsaXN0XCI6ODd9XSw2OTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtmdW5jdGlvbiBzKGUpe2Zvcih2YXIgdCBpbiBwLnNldFR5cGUodGhpcyxcIkRlc2NyaXB0aW9uXCIpLGUpcC5kZWZpbmVSZWFkT25seSh0aGlzLHQscC5kZWVwQ29weShlW3RdLCEwKSk7T2JqZWN0LmZyZWV6ZSh0aGlzKX12YXIgYSx1PWUoXCIuL2FkZHJlc3NcIiksZj1lKFwiLi9hYmktY29kZXJcIiksbD1lKFwiLi9iaWdudW1iZXJcIiksYz1lKFwiLi9ieXRlc1wiKSxoPWUoXCIuL2hhc2hcIiksZD1lKFwiLi9rZWNjYWsyNTZcIikscD1lKFwiLi9wcm9wZXJ0aWVzXCIpLHY9byhlKFwiLi4vZXJyb3JzXCIpKSx5PWZ1bmN0aW9uKGUpe3Auc2V0VHlwZSh0aGlzLFwiSW5kZXhlZFwiKSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJoYXNoXCIsZSl9LG09KGkoZyxhPXMpLGcucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlLHQpe2MuaXNIZXhTdHJpbmcoZSl8fHYudGhyb3dFcnJvcihcImludmFsaWQgY29udHJhY3QgYnl0ZWNvZGVcIix2LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImJ5dGVjb2RlXCIsdmFsdWU6ZX0pLHYuY2hlY2tBcmd1bWVudENvdW50KHQubGVuZ3RoLHRoaXMuaW5wdXRzLmxlbmd0aCxcIiBpbiBJbnRlcmZhY2UgY29uc3RydWN0b3JcIik7dHJ5e3JldHVybiBlK2YuZGVmYXVsdEFiaUNvZGVyLmVuY29kZSh0aGlzLmlucHV0cyx0KS5zdWJzdHJpbmcoMil9Y2F0Y2goZSl7di50aHJvd0Vycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBhcmd1bWVudFwiLHYuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOmUuYXJnLHJlYXNvbjplLnJlYXNvbix2YWx1ZTplLnZhbHVlfSl9cmV0dXJuIG51bGx9LGcpO2Z1bmN0aW9uIGcoKXtyZXR1cm4gbnVsbCE9PWEmJmEuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciBiLHc9KGkoXyxiPXMpLF8ucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXt2LmNoZWNrQXJndW1lbnRDb3VudChlLmxlbmd0aCx0aGlzLmlucHV0cy5sZW5ndGgsXCIgaW4gaW50ZXJmYWNlIGZ1bmN0aW9uIFwiK3RoaXMubmFtZSk7dHJ5e3JldHVybiB0aGlzLnNpZ2hhc2grZi5kZWZhdWx0QWJpQ29kZXIuZW5jb2RlKHRoaXMuaW5wdXRzLGUpLnN1YnN0cmluZygyKX1jYXRjaChlKXt2LnRocm93RXJyb3IoXCJpbnZhbGlkIGlucHV0IGFyZ3VtZW50XCIsdi5JTlZBTElEX0FSR1VNRU5ULHthcmc6ZS5hcmcscmVhc29uOmUucmVhc29uLHZhbHVlOmUudmFsdWV9KX1yZXR1cm4gbnVsbH0sXy5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gZi5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKHRoaXMub3V0cHV0cyxjLmFycmF5aWZ5KHQpKX1jYXRjaChlKXt2LnRocm93RXJyb3IoXCJpbnZhbGlkIGRhdGEgZm9yIGZ1bmN0aW9uIG91dHB1dFwiLHYuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwiZGF0YVwiLGVycm9yQXJnOmUuYXJnLGVycm9yVmFsdWU6ZS52YWx1ZSx2YWx1ZTp0LHJlYXNvbjplLnJlYXNvbn0pfX0sXyk7ZnVuY3Rpb24gXygpe3JldHVybiBudWxsIT09YiYmYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9dmFyIE0sQT0oaShFLE09cyksRSk7ZnVuY3Rpb24gRSgpe3JldHVybiBudWxsIT09TSYmTS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9dmFyIFMsaz0oaShOLFM9cyksTi5wcm90b3R5cGUuZW5jb2RlVG9waWNzPWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7ZS5sZW5ndGg+dGhpcy5pbnB1dHMubGVuZ3RoJiZ2LnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHMgZm9yIFwiK3RoaXMubmFtZSx2LlVORVhQRUNURURfQVJHVU1FTlQse21heENvdW50OmUubGVuZ3RoLGV4cGVjdGVkQ291bnQ6dGhpcy5pbnB1dHMubGVuZ3RofSk7dmFyIGk9W107Zm9yKHRoaXMuYW5vbnltb3VzfHxpLnB1c2godGhpcy50b3BpYyksZS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIHI9bi5pbnB1dHNbdF07ci5pbmRleGVkP251bGw9PWU/aS5wdXNoKG51bGwpOlwic3RyaW5nXCI9PT1yLnR5cGU/aS5wdXNoKGguaWQoZSkpOlwiYnl0ZXNcIj09PXIudHlwZT9pLnB1c2goZC5rZWNjYWsyNTYoZSkpOi0xIT09ci50eXBlLmluZGV4T2YoXCJbXCIpfHxcInR1cGxlXCI9PT1yLnR5cGUuc3Vic3RyaW5nKDAsNSk/di50aHJvd0Vycm9yKFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3QgaW1wbGVtZW50ZWQgeWV0OyBidWcgdXMgb24gR2l0SHViXCIsdi5OT1RfSU1QTEVNRU5URUQse29wZXJhdGlvbjpcImZpbHRlcihhcnJheXx0dXBsZSlcIn0pOihcImFkZHJlc3NcIj09PXIudHlwZSYmdS5nZXRBZGRyZXNzKGUpLGkucHVzaChjLmhleFplcm9QYWQoYy5oZXhsaWZ5KGUpLDMyKS50b0xvd2VyQ2FzZSgpKSk6bnVsbCE9ZSYmdi50aHJvd0Vycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIix2LklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OnIubmFtZXx8dCx2YWx1ZTplfSl9KTtpLmxlbmd0aCYmbnVsbD09PWlbaS5sZW5ndGgtMV07KWkucG9wKCk7cmV0dXJuIGl9LE4ucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbihlLHIpe251bGw9PXJ8fHRoaXMuYW5vbnltb3VzfHwocj1yLnNsaWNlKDEpKTt2YXIgbixpPVtdLG89W10scz1bXTt0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7ZS5pbmRleGVkP1wic3RyaW5nXCI9PT1lLnR5cGV8fFwiYnl0ZXNcIj09PWUudHlwZXx8MDw9ZS50eXBlLmluZGV4T2YoXCJbXCIpfHxcInR1cGxlXCI9PT1lLnR5cGUuc3Vic3RyaW5nKDAsNSk/KGkucHVzaCh7dHlwZTpcImJ5dGVzMzJcIixuYW1lOmUubmFtZXx8XCJcIn0pLHMucHVzaCghMCkpOihpLnB1c2goZSkscy5wdXNoKCExKSk6KG8ucHVzaChlKSxzLnB1c2goITEpKX0pLG51bGwhPXImJihuPWYuZGVmYXVsdEFiaUNvZGVyLmRlY29kZShpLGMuY29uY2F0KHIpKSk7dmFyIGE9Zi5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKG8sYy5hcnJheWlmeShlKSksdT17fSxsPTAsaD0wO3JldHVybiB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7ZS5pbmRleGVkP251bGw9PXI/dVt0XT1uZXcgeShudWxsKTpzW3RdP3VbdF09bmV3IHkobltoKytdKTp1W3RdPW5baCsrXTp1W3RdPWFbbCsrXSxlLm5hbWUmJih1W2UubmFtZV09dVt0XSl9KSx1Lmxlbmd0aD10aGlzLmlucHV0cy5sZW5ndGgsbmV3IEEodSl9LE4pO2Z1bmN0aW9uIE4oKXtyZXR1cm4gbnVsbCE9PVMmJlMuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciB4LFA9KGkoSSx4PXMpLEkpO2Z1bmN0aW9uIEkoKXtyZXR1cm4gbnVsbCE9PXgmJnguYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXZhciBULFI9KGkoTyxUPXMpLE8pO2Z1bmN0aW9uIE8oKXtyZXR1cm4gbnVsbCE9PVQmJlQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfWZ1bmN0aW9uIEMoZSl7c3dpdGNoKGUudHlwZSl7Y2FzZVwiY29uc3RydWN0b3JcIjp2YXIgdD1uZXcgbSh7aW5wdXRzOmUuaW5wdXRzLHBheWFibGU6bnVsbD09ZS5wYXlhYmxlfHwhIWUucGF5YWJsZX0pO3RoaXMuZGVwbG95RnVuY3Rpb258fCh0aGlzLmRlcGxveUZ1bmN0aW9uPXQpO2JyZWFrO2Nhc2VcImZ1bmN0aW9uXCI6dmFyIHI9Zi5mb3JtYXRTaWduYXR1cmUoZSkucmVwbGFjZSgvdHVwbGUvZyxcIlwiKSxuPWguaWQocikuc3Vic3RyaW5nKDAsMTApLGk9ITE7bnVsbCE9ZS5jb25zdGFudD9pPWUuY29uc3RhbnQ6bnVsbCE9ZS5zdGF0ZU11dGFiaWxpdHkmJihpPVwidmlld1wiPT1lLnN0YXRlTXV0YWJpbGl0eXx8XCJwdXJlXCI9PWUuc3RhdGVNdXRhYmlsaXR5KTt0PW5ldyB3KHtpbnB1dHM6ZS5pbnB1dHMsb3V0cHV0czplLm91dHB1dHMsZ2FzOmUuZ2FzLHBheWFibGU6bnVsbD09ZS5wYXlhYmxlfHwhIWUucGF5YWJsZSx0eXBlOmk/XCJjYWxsXCI6XCJ0cmFuc2FjdGlvblwiLG5hbWU6ZS5uYW1lLHNpZ25hdHVyZTpyLHNpZ2hhc2g6bn0pO2UubmFtZSYmKG51bGw9PXRoaXMuZnVuY3Rpb25zW2UubmFtZV0/cC5kZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucyxlLm5hbWUsdCk6di53YXJuKFwiV0FSTklORzogTXVsdGlwbGUgZGVmaW5pdGlvbnMgZm9yIFwiK2UubmFtZSkpLG51bGw9PXRoaXMuZnVuY3Rpb25zW3Quc2lnbmF0dXJlXSYmcC5kZWZpbmVSZWFkT25seSh0aGlzLmZ1bmN0aW9ucyx0LnNpZ25hdHVyZSx0KTticmVhaztjYXNlXCJldmVudFwiOnI9Zi5mb3JtYXRTaWduYXR1cmUoZSkucmVwbGFjZSgvdHVwbGUvZyxcIlwiKSx0PW5ldyBrKHtuYW1lOmUubmFtZSxzaWduYXR1cmU6cixpbnB1dHM6ZS5pbnB1dHMsdG9waWM6aC5pZChyKSxhbm9ueW1vdXM6ISFlLmFub255bW91c30pO2UubmFtZSYmbnVsbD09dGhpcy5ldmVudHNbZS5uYW1lXSYmcC5kZWZpbmVSZWFkT25seSh0aGlzLmV2ZW50cyxlLm5hbWUsdCksbnVsbD09dGhpcy5ldmVudHNbdC5zaWduYXR1cmVdJiZwLmRlZmluZVJlYWRPbmx5KHRoaXMuZXZlbnRzLHQuc2lnbmF0dXJlLHQpO2JyZWFrO2Nhc2VcInJlY2VpdmVcIjpjYXNlXCJmYWxsYmFja1wiOmJyZWFrO2RlZmF1bHQ6di53YXJuKFwiV0FSTklORzogdW5zdXBwb3J0ZWQgQUJJIHR5cGUgLSBcIitlLnR5cGUpfX12YXIgTD0oQi5wcm90b3R5cGUucGFyc2VUcmFuc2FjdGlvbj1mdW5jdGlvbihlKXt2YXIgdD1lLmRhdGEuc3Vic3RyaW5nKDAsMTApLnRvTG93ZXJDYXNlKCk7Zm9yKHZhciByIGluIHRoaXMuZnVuY3Rpb25zKWlmKC0xIT09ci5pbmRleE9mKFwiKFwiKSl7dmFyIG49dGhpcy5mdW5jdGlvbnNbcl07aWYobi5zaWdoYXNoPT09dCl7dmFyIGk9Zi5kZWZhdWx0QWJpQ29kZXIuZGVjb2RlKG4uaW5wdXRzLFwiMHhcIitlLmRhdGEuc3Vic3RyaW5nKDEwKSk7cmV0dXJuIG5ldyBQKHthcmdzOmksZGVjb2RlOm4uZGVjb2RlLG5hbWU6bi5uYW1lLHNpZ25hdHVyZTpuLnNpZ25hdHVyZSxzaWdoYXNoOm4uc2lnaGFzaCx2YWx1ZTpsLmJpZ051bWJlcmlmeShlLnZhbHVlfHxcIjBcIil9KX19cmV0dXJuIG51bGx9LEIucHJvdG90eXBlLnBhcnNlTG9nPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLmV2ZW50cylpZigtMSE9PXQuaW5kZXhPZihcIihcIikpe3ZhciByPXRoaXMuZXZlbnRzW3RdO2lmKCFyLmFub255bW91cyYmci50b3BpYz09PWUudG9waWNzWzBdKXJldHVybiBuZXcgUih7ZGVjb2RlOnIuZGVjb2RlLG5hbWU6ci5uYW1lLHNpZ25hdHVyZTpyLnNpZ25hdHVyZSx0b3BpYzpyLnRvcGljLHZhbHVlczpyLmRlY29kZShlLmRhdGEsZS50b3BpY3MpfSl9cmV0dXJuIG51bGx9LEIuaXNJbnRlcmZhY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHAuaXNUeXBlKGUsXCJJbnRlcmZhY2VcIil9LEIuaXNJbmRleGVkPWZ1bmN0aW9uKGUpe3JldHVybiBwLmlzVHlwZShlLFwiSW5kZXhlZFwiKX0sQik7ZnVuY3Rpb24gQih0KXtpZih2LmNoZWNrTmV3KHRoaXMsQiksXCJzdHJpbmdcIj09dHlwZW9mIHQpe3RyeXt0PUpTT04ucGFyc2UodCl9Y2F0Y2goZSl7di50aHJvd0Vycm9yKFwiY291bGQgbm90IHBhcnNlIEFCSSBKU09OXCIsdi5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJhYmlcIixlcnJvck1lc3NhZ2U6ZS5tZXNzYWdlLHZhbHVlOnR9KX1pZighQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdi50aHJvd0Vycm9yKFwiaW52YWxpZCBhYmlcIix2LklOVkFMSURfQVJHVU1FTlQse2FyZzpcImFiaVwiLHZhbHVlOnR9KSxudWxsfXAuZGVmaW5lUmVhZE9ubHkodGhpcyxcImZ1bmN0aW9uc1wiLHt9KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJldmVudHNcIix7fSk7dmFyIHI9W107dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1mLnBhcnNlU2lnbmF0dXJlKGUpKSxyLnB1c2goZSl9KSxwLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJhYmlcIixwLmRlZXBDb3B5KHIsITApKSxyLmZvckVhY2goQyx0aGlzKSx0aGlzLmRlcGxveUZ1bmN0aW9ufHxDLmNhbGwodGhpcyx7dHlwZTpcImNvbnN0cnVjdG9yXCIsaW5wdXRzOltdfSkscC5zZXRUeXBlKHRoaXMsXCJJbnRlcmZhY2VcIil9ci5JbnRlcmZhY2U9TH0se1wiLi4vZXJyb3JzXCI6NSxcIi4vYWJpLWNvZGVyXCI6NTksXCIuL2FkZHJlc3NcIjo2MCxcIi4vYmlnbnVtYmVyXCI6NjMsXCIuL2J5dGVzXCI6NjQsXCIuL2hhc2hcIjo2NSxcIi4va2VjY2FrMjU2XCI6NzEsXCIuL3Byb3BlcnRpZXNcIjo3NH1dLDcwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49ZShcIi4vYWRkcmVzc1wiKTtmdW5jdGlvbiBpKGUpe3RyeXt2YXIgdD1KU09OLnBhcnNlKGUpfWNhdGNoKGUpe3JldHVybiExfXJldHVybiB0LmVuY3NlZWQmJnQuZXRoYWRkcn1mdW5jdGlvbiBvKGUpe3RyeXt2YXIgdD1KU09OLnBhcnNlKGUpfWNhdGNoKGUpe3JldHVybiExfXJldHVybiEoIXQudmVyc2lvbnx8cGFyc2VJbnQodC52ZXJzaW9uKSE9PXQudmVyc2lvbnx8MyE9PXBhcnNlSW50KHQudmVyc2lvbikpfXIuaXNDcm93ZHNhbGVXYWxsZXQ9aSxyLmlzU2VjcmV0U3RvcmFnZVdhbGxldD1vLHIuZ2V0SnNvbldhbGxldEFkZHJlc3M9ZnVuY3Rpb24oZSl7aWYoaShlKSl0cnl7cmV0dXJuIG4uZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGUpLmV0aGFkZHIpfWNhdGNoKGUpe3JldHVybiBudWxsfWlmKG8oZSkpdHJ5e3JldHVybiBuLmdldEFkZHJlc3MoSlNPTi5wYXJzZShlKS5hZGRyZXNzKX1jYXRjaChlKXtyZXR1cm4gbnVsbH1yZXR1cm4gbnVsbH19LHtcIi4vYWRkcmVzc1wiOjYwfV0sNzE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1lKFwianMtc2hhM1wiKSxpPWUoXCIuL2J5dGVzXCIpO3Iua2VjY2FrMjU2PWZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIituLmtlY2Nha18yNTYoaS5hcnJheWlmeShlKSl9fSx7XCIuL2J5dGVzXCI6NjQsXCJqcy1zaGEzXCI6NDB9XSw3MjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bihlKFwiLi4vZXJyb3JzXCIpKTtmdW5jdGlvbiBpKHIpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1bXTtyZXR1cm4gZS5JbmZ1cmFQcm92aWRlciYmdC5wdXNoKG5ldyBlLkluZnVyYVByb3ZpZGVyKHIpKSxlLkV0aGVyc2NhblByb3ZpZGVyJiZ0LnB1c2gobmV3IGUuRXRoZXJzY2FuUHJvdmlkZXIocikpLDA9PT10Lmxlbmd0aD9udWxsOmUuRmFsbGJhY2tQcm92aWRlcj9uZXcgZS5GYWxsYmFja1Byb3ZpZGVyKHQpOnRbMF19fWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGUuSnNvblJwY1Byb3ZpZGVyP25ldyBlLkpzb25ScGNQcm92aWRlcih0LHIpOm51bGx9fXZhciBhPXtjaGFpbklkOjEsZW5zQWRkcmVzczpcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLG5hbWU6XCJob21lc3RlYWRcIixfZGVmYXVsdFByb3ZpZGVyOmkoXCJob21lc3RlYWRcIil9LHU9e2NoYWluSWQ6MyxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcInJvcHN0ZW5cIixfZGVmYXVsdFByb3ZpZGVyOmkoXCJyb3BzdGVuXCIpfSxsPXt1bnNwZWNpZmllZDp7Y2hhaW5JZDowLG5hbWU6XCJ1bnNwZWNpZmllZFwifSxob21lc3RlYWQ6YSxtYWlubmV0OmEsbW9yZGVuOntjaGFpbklkOjIsbmFtZTpcIm1vcmRlblwifSxyb3BzdGVuOnUsdGVzdG5ldDp1LHJpbmtlYnk6e2NoYWluSWQ6NCxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcInJpbmtlYnlcIixfZGVmYXVsdFByb3ZpZGVyOmkoXCJyaW5rZWJ5XCIpfSxnb2VybGk6e2NoYWluSWQ6NSxlbnNBZGRyZXNzOlwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsbmFtZTpcImdvZXJsaVwiLF9kZWZhdWx0UHJvdmlkZXI6aShcImdvZXJsaVwiKX0sa292YW46e2NoYWluSWQ6NDIsbmFtZTpcImtvdmFuXCIsX2RlZmF1bHRQcm92aWRlcjppKFwia292YW5cIil9LGNsYXNzaWM6e2NoYWluSWQ6NjEsbmFtZTpcImNsYXNzaWNcIixfZGVmYXVsdFByb3ZpZGVyOnMoXCJodHRwczovL3dlYjMuZ2FzdHJhY2tlci5pb1wiLFwiY2xhc3NpY1wiKX0sY2xhc3NpY1Rlc3RuZXQ6e2NoYWluSWQ6NjIsbmFtZTpcImNsYXNzaWNUZXN0bmV0XCIsX2RlZmF1bHRQcm92aWRlcjpzKFwiaHR0cHM6Ly93ZWIzLmdhc3RyYWNrZXIuaW8vbW9yZGVuXCIsXCJjbGFzc2ljVGVzdG5ldFwiKX19O3IuZ2V0TmV0d29yaz1mdW5jdGlvbihlKXtpZihudWxsPT1lKXJldHVybiBudWxsO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXtmb3IodmFyIHQgaW4gbCl7dmFyIHI9bFt0XTtpZihyLmNoYWluSWQ9PT1lKXJldHVybntuYW1lOnIubmFtZSxjaGFpbklkOnIuY2hhaW5JZCxlbnNBZGRyZXNzOnIuZW5zQWRkcmVzc3x8bnVsbCxfZGVmYXVsdFByb3ZpZGVyOnIuX2RlZmF1bHRQcm92aWRlcnx8bnVsbH19cmV0dXJue2NoYWluSWQ6ZSxuYW1lOlwidW5rbm93blwifX1pZihcInN0cmluZ1wiPT10eXBlb2YgZSl7dmFyIG49bFtlXTtyZXR1cm4gbnVsbD09bj9udWxsOntuYW1lOm4ubmFtZSxjaGFpbklkOm4uY2hhaW5JZCxlbnNBZGRyZXNzOm4uZW5zQWRkcmVzcyxfZGVmYXVsdFByb3ZpZGVyOm4uX2RlZmF1bHRQcm92aWRlcnx8bnVsbH19dmFyIGk9bFtlLm5hbWVdO3JldHVybiBpPygwIT09ZS5jaGFpbklkJiZlLmNoYWluSWQhPT1pLmNoYWluSWQmJm8udGhyb3dFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLG8uSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwibmV0d29ya1wiLHZhbHVlOmV9KSx7bmFtZTplLm5hbWUsY2hhaW5JZDppLmNoYWluSWQsZW5zQWRkcmVzczplLmVuc0FkZHJlc3N8fGkuZW5zQWRkcmVzc3x8bnVsbCxfZGVmYXVsdFByb3ZpZGVyOmUuX2RlZmF1bHRQcm92aWRlcnx8aS5fZGVmYXVsdFByb3ZpZGVyfHxudWxsfSk6KFwibnVtYmVyXCIhPXR5cGVvZiBlLmNoYWluSWQmJm8udGhyb3dFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsby5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJuZXR3b3JrXCIsdmFsdWU6ZX0pLGUpfX0se1wiLi4vZXJyb3JzXCI6NX1dLDczOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG09ZShcIi4uL3V0aWxzL2J5dGVzXCIpLGc9ZShcIi4vaG1hY1wiKTtyLnBia2RmMj1mdW5jdGlvbihlLHQscixuLGkpe3ZhciBvO2U9bS5hcnJheWlmeShlKSx0PW0uYXJyYXlpZnkodCk7dmFyIHMsYSx1PTEsbD1uZXcgVWludDhBcnJheShuKSxoPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKzQpO2guc2V0KHQpO2Zvcih2YXIgZj0xO2Y8PXU7ZisrKXtoW3QubGVuZ3RoXT1mPj4yNCYyNTUsaFt0Lmxlbmd0aCsxXT1mPj4xNiYyNTUsaFt0Lmxlbmd0aCsyXT1mPj44JjI1NSxoW3QubGVuZ3RoKzNdPTI1NSZmO3ZhciBjPWcuY29tcHV0ZUhtYWMoaSxlLGgpO298fChvPWMubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkobykscz1uLSgodT1NYXRoLmNlaWwobi9vKSktMSkqbyksYS5zZXQoYyk7Zm9yKHZhciBkPTE7ZDxyO2QrKyl7Yz1nLmNvbXB1dGVIbWFjKGksZSxjKTtmb3IodmFyIHA9MDtwPG87cCsrKWFbcF1ePWNbcF19dmFyIHY9KGYtMSkqbyx5PWY9PT11P3M6bztsLnNldChtLmFycmF5aWZ5KGEpLnNsaWNlKDAseSksdil9cmV0dXJuIG0uYXJyYXlpZnkobCl9fSx7XCIuLi91dGlscy9ieXRlc1wiOjY0LFwiLi9obWFjXCI6Njd9XSw3NDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9bihlKFwiLi4vZXJyb3JzXCIpKTtmdW5jdGlvbiBzKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLHZhbHVlOnIsd3JpdGFibGU6ITF9KX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUmJmUuX2V0aGVyc1R5cGU9PT10fXIuZGVmaW5lUmVhZE9ubHk9cyxyLnNldFR5cGU9ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9ldGhlcnNUeXBlXCIse2NvbmZpZ3VyYWJsZTohMSx2YWx1ZTp0LHdyaXRhYmxlOiExfSl9LHIuaXNUeXBlPWEsci5yZXNvbHZlUHJvcGVydGllcz1mdW5jdGlvbihyKXt2YXIgbj17fSxpPVtdO3JldHVybiBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPXJbdF07ZSBpbnN0YW5jZW9mIFByb21pc2U/aS5wdXNoKGUudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gblt0XT1lLG51bGx9KSk6blt0XT1lfSksUHJvbWlzZS5hbGwoaSkudGhlbihmdW5jdGlvbigpe3JldHVybiBufSl9LHIuY2hlY2tQcm9wZXJ0aWVzPWZ1bmN0aW9uKHQscil7dCYmXCJvYmplY3RcIj09dHlwZW9mIHR8fGkudGhyb3dFcnJvcihcImludmFsaWQgb2JqZWN0XCIsaS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcIm9iamVjdFwiLHZhbHVlOnR9KSxPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JbZV18fGkudGhyb3dFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiK2UsaS5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInRyYW5zYWN0aW9uXCIsdmFsdWU6dCxrZXk6ZX0pfSl9LHIuc2hhbGxvd0NvcHk9ZnVuY3Rpb24oZSl7dmFyIHQ9e307Zm9yKHZhciByIGluIGUpdFtyXT1lW3JdO3JldHVybiB0fTt2YXIgdT17Ym9vbGVhbjohMCxudW1iZXI6ITAsc3RyaW5nOiEwfTtyLmRlZXBDb3B5PWZ1bmN0aW9uIHQoZSxyKXtpZihudWxsPT1lfHx1W3R5cGVvZiBlXSlyZXR1cm4gZTtpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdChlLHIpfSk7cmV0dXJuIHImJk9iamVjdC5mcmVlemUobiksbn1pZihcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYoYShlLFwiQmlnTnVtYmVyXCIpKXJldHVybiBlO2lmKGEoZSxcIkRlc2NyaXB0aW9uXCIpKXJldHVybiBlO2lmKGEoZSxcIkluZGV4ZWRcIikpcmV0dXJuIGU7Zm9yKHZhciBpIGluIG49e30sZSl7dmFyIG89ZVtpXTt2b2lkIDAhPT1vJiZzKG4saSx0KG8scikpfXJldHVybiByJiZPYmplY3QuZnJlZXplKG4pLG59aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSlyZXR1cm4gZTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIrdHlwZW9mIGUpfSxyLmluaGVyaXRhYmxlPWZ1bmN0aW9uIG4oaSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0LHI7cj1pLCh0PWUpLnN1cGVyXz1yLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHMoZSxcImluaGVyaXRzXCIsbihlKSl9fX0se1wiLi4vZXJyb3JzXCI6NX1dLDc1OltmdW5jdGlvbihvLGUscyl7KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW8oXCIuLi91dGlscy9ieXRlc1wiKSx0PW8oXCIuLi91dGlscy9wcm9wZXJ0aWVzXCIpLG49ZS5jcnlwdG98fGUubXNDcnlwdG87ZnVuY3Rpb24gaShlKXtpZihlPD0wfHwxMDI0PGV8fHBhcnNlSW50KFN0cmluZyhlKSkhPWUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBsZW5ndGhcIik7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoZSk7cmV0dXJuIG4uZ2V0UmFuZG9tVmFsdWVzKHQpLHIuYXJyYXlpZnkodCl9biYmbi5nZXRSYW5kb21WYWx1ZXN8fChjb25zb2xlLmxvZyhcIldBUk5JTkc6IE1pc3Npbmcgc3Ryb25nIHJhbmRvbSBudW1iZXIgc291cmNlOyB1c2luZyB3ZWFrIHJhbmRvbUJ5dGVzXCIpLG49e2dldFJhbmRvbVZhbHVlczpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PDIwO3QrKylmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl0P2Vbcl1ePU1hdGgudHJ1bmMoMjU2Kk1hdGgucmFuZG9tKCkpOmVbcl09TWF0aC50cnVuYygyNTYqTWF0aC5yYW5kb20oKSk7cmV0dXJuIGV9LF93ZWFrQ3J5cHRvOiEwfSkscy5yYW5kb21CeXRlcz1pLCEwPT09bi5fd2Vha0NyeXB0byYmdC5kZWZpbmVSZWFkT25seShpLFwiX3dlYWtDcnlwdG9cIiwhMCl9KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHtcIi4uL3V0aWxzL2J5dGVzXCI6NjQsXCIuLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSw3NjpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPWUoXCIuL2J5dGVzXCIpO2Z1bmN0aW9uIHMoZSl7Zm9yKHZhciB0PVtdO2U7KXQudW5zaGlmdCgyNTUmZSksZT4+PTg7cmV0dXJuIHR9ZnVuY3Rpb24gaShlLHQscil7Zm9yKHZhciBuPTAsaT0wO2k8cjtpKyspbj0yNTYqbitlW3QraV07cmV0dXJuIG59ZnVuY3Rpb24gYShlLHQscixuKXtmb3IodmFyIGk9W107cjx0KzErbjspe3ZhciBvPXUoZSxyKTtpZihpLnB1c2goby5yZXN1bHQpLHQrMStuPChyKz1vLmNvbnN1bWVkKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscFwiKX1yZXR1cm57Y29uc3VtZWQ6MStuLHJlc3VsdDppfX1mdW5jdGlvbiB1KGUsdCl7aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIik7aWYoMjQ4PD1lW3RdKXtpZih0KzErKHI9ZVt0XS0yNDcpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRvbyBzaG9ydFwiKTtpZih0KzErcisobj1pKGUsdCsxLHIpKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0byBzaG9ydFwiKTtyZXR1cm4gYShlLHQsdCsxK3IscituKX1pZigxOTI8PWVbdF0pe2lmKHQrMSsobj1lW3RdLTE5Mik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiKTtyZXR1cm4gYShlLHQsdCsxLG4pfWlmKDE4NDw9ZVt0XSl7dmFyIHI7aWYodCsxKyhyPWVbdF0tMTgzKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIpO2lmKHQrMStyKyhuPWkoZSx0KzEscikpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIik7cmV0dXJue2NvbnN1bWVkOjErcituLHJlc3VsdDpvLmhleGxpZnkoZS5zbGljZSh0KzErcix0KzErcituKSl9fWlmKDEyODw9ZVt0XSl7dmFyIG47aWYodCsxKyhuPWVbdF0tMTI4KT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIpO3JldHVybntjb25zdW1lZDoxK24scmVzdWx0Om8uaGV4bGlmeShlLnNsaWNlKHQrMSx0KzErbikpfX1yZXR1cm57Y29uc3VtZWQ6MSxyZXN1bHQ6by5oZXhsaWZ5KGVbdF0pfX1yLmVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gby5oZXhsaWZ5KGZ1bmN0aW9uIHQoZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIHI9W107cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXtyPXIuY29uY2F0KHQoZSkpfSksci5sZW5ndGg8PTU1PyhyLnVuc2hpZnQoMTkyK3IubGVuZ3RoKSxyKTooKG49cyhyLmxlbmd0aCkpLnVuc2hpZnQoMjQ3K24ubGVuZ3RoKSxuLmNvbmNhdChyKSl9dmFyIG4saT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvLmFycmF5aWZ5KGUpKTtyZXR1cm4gMT09PWkubGVuZ3RoJiZpWzBdPD0xMjc/aTppLmxlbmd0aDw9NTU/KGkudW5zaGlmdCgxMjgraS5sZW5ndGgpLGkpOigobj1zKGkubGVuZ3RoKSkudW5zaGlmdCgxODMrbi5sZW5ndGgpLG4uY29uY2F0KGkpKX0oZSkpfSxyLmRlY29kZT1mdW5jdGlvbihlKXt2YXIgdD1vLmFycmF5aWZ5KGUpLHI9dSh0LDApO2lmKHIuY29uc3VtZWQhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIpO3JldHVybiByLnJlc3VsdH19LHtcIi4vYnl0ZXNcIjo2NH1dLDc3OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1lKFwiZWxsaXB0aWNcIiksbz1lKFwiLi9hZGRyZXNzXCIpLHM9ZShcIi4vYnl0ZXNcIiksYT1lKFwiLi9oYXNoXCIpLHU9ZShcIi4va2VjY2FrMjU2XCIpLGw9ZShcIi4vcHJvcGVydGllc1wiKSxoPW4oZShcIi4uL2Vycm9yc1wiKSksZj1udWxsO2Z1bmN0aW9uIGMoKXtyZXR1cm4gZj1mfHxuZXcgaS5lYyhcInNlY3AyNTZrMVwiKX12YXIgZD0ocC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbihlKXt2YXIgdD1jKCkua2V5RnJvbVByaXZhdGUocy5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKS5zaWduKHMuYXJyYXlpZnkoZSkse2Nhbm9uaWNhbDohMH0pO3JldHVybntyZWNvdmVyeVBhcmFtOnQucmVjb3ZlcnlQYXJhbSxyOnMuaGV4WmVyb1BhZChcIjB4XCIrdC5yLnRvU3RyaW5nKDE2KSwzMiksczpzLmhleFplcm9QYWQoXCIweFwiK3Qucy50b1N0cmluZygxNiksMzIpLHY6MjcrdC5yZWNvdmVyeVBhcmFtfX0scC5wcm90b3R5cGUuY29tcHV0ZVNoYXJlZFNlY3JldD1mdW5jdGlvbihlKXt2YXIgdD1jKCkua2V5RnJvbVByaXZhdGUocy5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKSxyPWMoKS5rZXlGcm9tUHVibGljKHMuYXJyYXlpZnkodihlKSkpO3JldHVybiBzLmhleFplcm9QYWQoXCIweFwiK3QuZGVyaXZlKHIuZ2V0UHVibGljKCkpLnRvU3RyaW5nKDE2KSwzMil9LHAucHJvdG90eXBlLl9hZGRQb2ludD1mdW5jdGlvbihlKXt2YXIgdD1jKCkua2V5RnJvbVB1YmxpYyhzLmFycmF5aWZ5KHRoaXMucHVibGljS2V5KSkscj1jKCkua2V5RnJvbVB1YmxpYyhzLmFycmF5aWZ5KGUpKTtyZXR1cm5cIjB4XCIrdC5wdWIuYWRkKHIucHViKS5lbmNvZGVDb21wcmVzc2VkKFwiaGV4XCIpfSxwKTtmdW5jdGlvbiBwKGUpe3ZhciB0PWMoKS5rZXlGcm9tUHJpdmF0ZShzLmFycmF5aWZ5KGUpKTtsLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwcml2YXRlS2V5XCIscy5oZXhsaWZ5KHQucHJpdi50b0FycmF5KFwiYmVcIiwzMikpKSxsLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIixcIjB4XCIrdC5nZXRQdWJsaWMoITEsXCJoZXhcIikpLGwuZGVmaW5lUmVhZE9ubHkodGhpcyxcImNvbXByZXNzZWRQdWJsaWNLZXlcIixcIjB4XCIrdC5nZXRQdWJsaWMoITAsXCJoZXhcIikpLGwuZGVmaW5lUmVhZE9ubHkodGhpcyxcInB1YmxpY0tleUJ5dGVzXCIsdC5nZXRQdWJsaWMoKS5lbmNvZGUobnVsbCwhMCkpfWZ1bmN0aW9uIHYoZSx0KXt2YXIgcj1zLmFycmF5aWZ5KGUpO2lmKDMyIT09ci5sZW5ndGgpcmV0dXJuIDMzPT09ci5sZW5ndGg/dD9zLmhleGxpZnkocik6XCIweFwiK2MoKS5rZXlGcm9tUHVibGljKHIpLmdldFB1YmxpYyghMSxcImhleFwiKTo2NT09PXIubGVuZ3RoP3Q/XCIweFwiK2MoKS5rZXlGcm9tUHVibGljKHIpLmdldFB1YmxpYyghMCxcImhleFwiKTpzLmhleGxpZnkocik6KGgudGhyb3dFcnJvcihcImludmFsaWQgcHVibGljIG9yIHByaXZhdGUga2V5XCIsaC5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJrZXlcIix2YWx1ZTpcIltSRURBQ1RFRF1cIn0pLG51bGwpO3ZhciBuPW5ldyBkKHIpO3JldHVybiB0P24uY29tcHJlc3NlZFB1YmxpY0tleTpuLnB1YmxpY0tleX1mdW5jdGlvbiB5KGUpe3ZhciB0PVwiMHhcIit2KGUpLnNsaWNlKDQpO3JldHVybiBvLmdldEFkZHJlc3MoXCIweFwiK3Uua2VjY2FrMjU2KHQpLnN1YnN0cmluZygyNikpfWZ1bmN0aW9uIG0oZSx0KXt2YXIgcj1zLnNwbGl0U2lnbmF0dXJlKHQpLG49e3I6cy5hcnJheWlmeShyLnIpLHM6cy5hcnJheWlmeShyLnMpfTtyZXR1cm5cIjB4XCIrYygpLnJlY292ZXJQdWJLZXkocy5hcnJheWlmeShlKSxuLHIucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsITEpfWZ1bmN0aW9uIGcoZSx0KXtyZXR1cm4geShtKHMuYXJyYXlpZnkoZSksdCkpfXIuS2V5UGFpcj1kLHIuY29tcHV0ZVB1YmxpY0tleT12LHIuY29tcHV0ZUFkZHJlc3M9eSxyLnJlY292ZXJQdWJsaWNLZXk9bSxyLnJlY292ZXJBZGRyZXNzPWcsci52ZXJpZnlNZXNzYWdlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGcoYS5oYXNoTWVzc2FnZShlKSx0KX19LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2FkZHJlc3NcIjo2MCxcIi4vYnl0ZXNcIjo2NCxcIi4vaGFzaFwiOjY1LFwiLi9rZWNjYWsyNTZcIjo3MSxcIi4vcHJvcGVydGllc1wiOjc0LGVsbGlwdGljOjEyfV0sNzg6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fSxpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIFI9bihlKFwiYWVzLWpzXCIpKSx5PW4oZShcInNjcnlwdC1qc1wiKSksTz1uKGUoXCJ1dWlkXCIpKSxDPWUoXCIuL3NpZ25pbmcta2V5XCIpLGc9aShlKFwiLi9oZG5vZGVcIikpLGI9ZShcIi4vYWRkcmVzc1wiKSxMPWUoXCIuL2J5dGVzXCIpLHc9ZShcIi4vcGJrZGYyXCIpLEI9ZShcIi4va2VjY2FrMjU2XCIpLHA9ZShcIi4vdXRmOFwiKSxEPWUoXCIuL3JhbmRvbS1ieXRlc1wiKTtmdW5jdGlvbiBfKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiZcIjB4XCIhPT1lLnN1YnN0cmluZygwLDIpJiYoZT1cIjB4XCIrZSksTC5hcnJheWlmeShlKX1mdW5jdGlvbiBVKGUsdCl7Zm9yKGU9U3RyaW5nKGUpO2UubGVuZ3RoPHQ7KWU9XCIwXCIrZTtyZXR1cm4gZX1mdW5jdGlvbiBGKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP3AudG9VdGY4Qnl0ZXMoZSxwLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKTpMLmFycmF5aWZ5KGUpfWZ1bmN0aW9uIE0oZSx0KXtmb3IodmFyIHI9ZSxuPXQudG9Mb3dlckNhc2UoKS5zcGxpdChcIi9cIiksaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgbz1udWxsO2Zvcih2YXIgcyBpbiByKWlmKHMudG9Mb3dlckNhc2UoKT09PW5baV0pe289cltzXTticmVha31pZihudWxsPT09bylyZXR1cm4gbnVsbDtyPW99cmV0dXJuIHJ9ci5kZWNyeXB0Q3Jvd2RzYWxlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9SlNPTi5wYXJzZShlKTt0PUYodCk7dmFyIG49Yi5nZXRBZGRyZXNzKE0ocixcImV0aGFkZHJcIikpLGk9XyhNKHIsXCJlbmNzZWVkXCIpKTtpZighaXx8aS5sZW5ndGglMTYhPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmNzZWVkXCIpO2Zvcih2YXIgbz13LnBia2RmMih0LHQsMmUzLDMyLFwic2hhMjU2XCIpLnNsaWNlKDAsMTYpLHM9aS5zbGljZSgwLDE2KSxhPWkuc2xpY2UoMTYpLHU9bmV3IFIuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY2JjKG8scyksbD1MLmFycmF5aWZ5KHUuZGVjcnlwdChhKSksbD1SLmRlZmF1bHQucGFkZGluZy5wa2NzNy5zdHJpcChsKSxoPVwiXCIsZj0wO2Y8bC5sZW5ndGg7ZisrKWgrPVN0cmluZy5mcm9tQ2hhckNvZGUobFtmXSk7dmFyIGM9cC50b1V0ZjhCeXRlcyhoKSxkPW5ldyBDLlNpZ25pbmdLZXkoQi5rZWNjYWsyNTYoYykpO2lmKGQuYWRkcmVzcyE9PW4pdGhyb3cgbmV3IEVycm9yKFwiY29ycnVwdCBjcm93ZHNhbGUgd2FsbGV0XCIpO3JldHVybiBkfSxyLmRlY3J5cHQ9ZnVuY3Rpb24oZSx0LGQpe2Z1bmN0aW9uIHAoZSx0KXt2YXIgcixuLGk9XyhNKG0sXCJjcnlwdG8vY2lwaGVydGV4dFwiKSk7aWYoTC5oZXhsaWZ5KChyPWUuc2xpY2UoMTYsMzIpLG49aSxCLmtlY2NhazI1NihMLmNvbmNhdChbcixuXSkpKSkuc3Vic3RyaW5nKDIpIT09TShtLFwiY3J5cHRvL21hY1wiKS50b0xvd2VyQ2FzZSgpKXJldHVybiB0KG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIikpLG51bGw7dmFyIG89ZnVuY3Rpb24oZSx0KXtpZihcImFlcy0xMjgtY3RyXCIhPT1NKG0sXCJjcnlwdG8vY2lwaGVyXCIpKXJldHVybiBudWxsO3ZhciByPV8oTShtLFwiY3J5cHRvL2NpcGhlcnBhcmFtcy9pdlwiKSksbj1uZXcgUi5kZWZhdWx0LkNvdW50ZXIociksaT1uZXcgUi5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIoZSxuKTtyZXR1cm4gTC5hcnJheWlmeShpLmRlY3J5cHQodCkpfShlLnNsaWNlKDAsMTYpLGkpLHM9ZS5zbGljZSgzMiw2NCk7aWYoIW8pcmV0dXJuIHQobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgY2lwaGVyXCIpKSxudWxsO3ZhciBhPW5ldyBDLlNpZ25pbmdLZXkobyk7aWYobS5hZGRyZXNzJiZhLmFkZHJlc3MhPT1iLmdldEFkZHJlc3MobS5hZGRyZXNzKSlyZXR1cm4gdChuZXcgRXJyb3IoXCJhZGRyZXNzIG1pc21hdGNoXCIpKSxudWxsO3ZhciB1PU0obSxcIngtZXRoZXJzL2xvY2FsZVwiKTtpZihcIjAuMVwiPT09TShtLFwieC1ldGhlcnMvdmVyc2lvblwiKSYmKG51bGw9PXV8fFwiZW5cIj09PXUpKXt2YXIgbD1fKE0obSxcIngtZXRoZXJzL21uZW1vbmljQ2lwaGVydGV4dFwiKSksaD1fKE0obSxcIngtZXRoZXJzL21uZW1vbmljQ291bnRlclwiKSksZj1uZXcgUi5kZWZhdWx0LkNvdW50ZXIoaCksYz1uZXcgUi5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIocyxmKSxkPU0obSxcIngtZXRoZXJzL3BhdGhcIil8fGcuZGVmYXVsdFBhdGgscD1MLmFycmF5aWZ5KGMuZGVjcnlwdChsKSksdj1nLmVudHJvcHlUb01uZW1vbmljKHApLHk9Zy5mcm9tTW5lbW9uaWModikuZGVyaXZlUGF0aChkKTtpZih5LnByaXZhdGVLZXkhPUwuaGV4bGlmeShvKSlyZXR1cm4gdChuZXcgRXJyb3IoXCJtbmVtb25pYyBtaXNtYXRjaFwiKSksbnVsbDthPW5ldyBDLlNpZ25pbmdLZXkoeSl9cmV0dXJuIGF9dmFyIG09SlNPTi5wYXJzZShlKSx2PUYodCk7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGksbyl7dmFyIGU9TShtLFwiY3J5cHRvL2tkZlwiKTtpZihlJiZcInN0cmluZ1wiPT10eXBlb2YgZSlpZihcInNjcnlwdFwiPT09ZS50b0xvd2VyQ2FzZSgpKXt2YXIgdD1fKE0obSxcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSkscj1wYXJzZUludChNKG0sXCJjcnlwdG8va2RmcGFyYW1zL25cIikpLG49cGFyc2VJbnQoTShtLFwiY3J5cHRvL2tkZnBhcmFtcy9yXCIpKSxzPXBhcnNlSW50KE0obSxcImNyeXB0by9rZGZwYXJhbXMvcFwiKSk7aWYoIXJ8fCFufHwhcylyZXR1cm4gdm9pZCBvKG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIikpO2lmKDAhPShyJnItMSkpcmV0dXJuIHZvaWQgbyhuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXIgdmFsdWUgZm9yIE5cIikpO2lmKDMyIT09KGw9cGFyc2VJbnQoTShtLFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSkpKXJldHVybiB2b2lkIG8obmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZGVyaXZlZC1rZXkgbGVuZ3RoXCIpKTtkJiZkKDApLHkuZGVmYXVsdCh2LHQscixuLHMsNjQsZnVuY3Rpb24oZSx0LHIpe2lmKGUpZS5wcm9ncmVzcz10LG8oZSk7ZWxzZSBpZihyKXtyPUwuYXJyYXlpZnkocik7dmFyIG49cChyLG8pO2lmKCFuKXJldHVybjtkJiZkKDEpLGkobil9ZWxzZSBpZihkKXJldHVybiBkKHQpfSl9ZWxzZSBpZihcInBia2RmMlwiPT09ZS50b0xvd2VyQ2FzZSgpKXt2YXIgdD1fKE0obSxcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSksYT1udWxsLHU9TShtLFwiY3J5cHRvL2tkZnBhcmFtcy9wcmZcIik7aWYoXCJobWFjLXNoYTI1NlwiPT09dSlhPVwic2hhMjU2XCI7ZWxzZXtpZihcImhtYWMtc2hhNTEyXCIhPT11KXJldHVybiB2b2lkIG8obmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgcHJmXCIpKTthPVwic2hhNTEyXCJ9dmFyIGwsaD1wYXJzZUludChNKG0sXCJjcnlwdG8va2RmcGFyYW1zL2NcIikpO2lmKDMyIT09KGw9cGFyc2VJbnQoTShtLFwiY3J5cHRvL2tkZnBhcmFtcy9ka2xlblwiKSkpKXJldHVybiB2b2lkIG8obmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZGVyaXZlZC1rZXkgbGVuZ3RoXCIpKTt2YXIgZj13LnBia2RmMih2LHQsaCxsLGEpLGM9cChmLG8pO2lmKCFjKXJldHVybjtpKGMpfWVsc2UgbyhuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvblwiKSk7ZWxzZSBvKG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIpKX0pfSxyLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHcsXyl7XCJmdW5jdGlvblwiIT10eXBlb2Ygd3x8X3x8KF89dyx3PXt9KSx3PXd8fHt9O3ZhciBNPW51bGw7aWYoMzIhPT0oTT1DLlNpZ25pbmdLZXkuaXNTaWduaW5nS2V5KGUpP0wuYXJyYXlpZnkoZS5wcml2YXRlS2V5KTpMLmFycmF5aWZ5KGUpKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcml2YXRlIGtleVwiKTt2YXIgcj1GKHQpLEE9bnVsbDtpZih3LmVudHJvcHkmJihBPUwuYXJyYXlpZnkody5lbnRyb3B5KSksdy5tbmVtb25pYylpZihBKXtpZihnLmVudHJvcHlUb01uZW1vbmljKEEpIT09dy5tbmVtb25pYyl0aHJvdyBuZXcgRXJyb3IoXCJlbnRyb3B5IGFuZCBtbmVtb25pYyBtaXNtYXRjaFwiKX1lbHNlIEE9TC5hcnJheWlmeShnLm1uZW1vbmljVG9FbnRyb3B5KHcubW5lbW9uaWMsdy53b3JkbGlzdCkpO3ZhciBFPXcucGF0aDtBJiYhRSYmKEU9Zy5kZWZhdWx0UGF0aCk7dmFyIFM9KFM9dy5jbGllbnQpfHxcImV0aGVycy5qc1wiLGs9bnVsbCxrPXcuc2FsdD9MLmFycmF5aWZ5KHcuc2FsdCk6RC5yYW5kb21CeXRlcygzMiksTj1udWxsO2lmKHcuaXYpe2lmKDE2IT09KE49TC5hcnJheWlmeSh3Lml2KSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIil9ZWxzZSBOPUQucmFuZG9tQnl0ZXMoMTYpO3ZhciB4PW51bGw7aWYody51dWlkKXtpZigxNiE9PSh4PUwuYXJyYXlpZnkody51dWlkKSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXVpZFwiKX1lbHNlIHg9RC5yYW5kb21CeXRlcygxNik7dmFyIFA9MTw8MTcsST04LFQ9MTtyZXR1cm4gdy5zY3J5cHQmJih3LnNjcnlwdC5OJiYoUD13LnNjcnlwdC5OKSx3LnNjcnlwdC5yJiYoST13LnNjcnlwdC5yKSx3LnNjcnlwdC5wJiYoVD13LnNjcnlwdC5wKSksbmV3IFByb21pc2UoZnVuY3Rpb24oZyxiKXtfJiZfKDApLHkuZGVmYXVsdChyLGssUCxJLFQsNjQsZnVuY3Rpb24oZSx0LHIpe2lmKGUpZS5wcm9ncmVzcz10LGIoZSk7ZWxzZSBpZihyKXt2YXIgbixpLG8scyxhLHUsbD0ocj1MLmFycmF5aWZ5KHIpKS5zbGljZSgwLDE2KSxoPXIuc2xpY2UoMTYsMzIpLGY9ci5zbGljZSgzMiw2NCksYz1uZXcgQy5TaWduaW5nS2V5KE0pLmFkZHJlc3MsZD1uZXcgUi5kZWZhdWx0LkNvdW50ZXIoTikscD1uZXcgUi5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIobCxkKSx2PUwuYXJyYXlpZnkocC5lbmNyeXB0KE0pKSx5PUIua2VjY2FrMjU2KEwuY29uY2F0KFtoLHZdKSksbT17YWRkcmVzczpjLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLGlkOk8uZGVmYXVsdC52NCh7cmFuZG9tOnh9KSx2ZXJzaW9uOjMsQ3J5cHRvOntjaXBoZXI6XCJhZXMtMTI4LWN0clwiLGNpcGhlcnBhcmFtczp7aXY6TC5oZXhsaWZ5KE4pLnN1YnN0cmluZygyKX0sY2lwaGVydGV4dDpMLmhleGxpZnkodikuc3Vic3RyaW5nKDIpLGtkZjpcInNjcnlwdFwiLGtkZnBhcmFtczp7c2FsdDpMLmhleGxpZnkoaykuc3Vic3RyaW5nKDIpLG46UCxka2xlbjozMixwOlQscjpJfSxtYWM6eS5zdWJzdHJpbmcoMil9fTtBJiYobj1ELnJhbmRvbUJ5dGVzKDE2KSxpPW5ldyBSLmRlZmF1bHQuQ291bnRlcihuKSxvPW5ldyBSLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmN0cihmLGkpLHM9TC5hcnJheWlmeShvLmVuY3J5cHQoQSkpLHU9KGE9bmV3IERhdGUpLmdldFVUQ0Z1bGxZZWFyKCkrXCItXCIrVShhLmdldFVUQ01vbnRoKCkrMSwyKStcIi1cIitVKGEuZ2V0VVRDRGF0ZSgpLDIpK1wiVFwiK1UoYS5nZXRVVENIb3VycygpLDIpK1wiLVwiK1UoYS5nZXRVVENNaW51dGVzKCksMikrXCItXCIrVShhLmdldFVUQ1NlY29uZHMoKSwyKStcIi4wWlwiLG1bXCJ4LWV0aGVyc1wiXT17Y2xpZW50OlMsZ2V0aEZpbGVuYW1lOlwiVVRDLS1cIit1K1wiLS1cIittLmFkZHJlc3MsbW5lbW9uaWNDb3VudGVyOkwuaGV4bGlmeShuKS5zdWJzdHJpbmcoMiksbW5lbW9uaWNDaXBoZXJ0ZXh0OkwuaGV4bGlmeShzKS5zdWJzdHJpbmcoMikscGF0aDpFLHZlcnNpb246XCIwLjFcIn0sdy53b3JkbGlzdCYmXCJzdHJpbmdcIj09dHlwZW9mIHcud29yZGxpc3QubG9jYWxlJiYobVtcIngtZXRoZXJzXCJdLmxvY2FsZT13LndvcmRsaXN0LmxvY2FsZSkpLF8mJl8oMSksZyhKU09OLnN0cmluZ2lmeShtKSl9ZWxzZSBpZihfKXJldHVybiBfKHQpfSl9KX19LHtcIi4vYWRkcmVzc1wiOjYwLFwiLi9ieXRlc1wiOjY0LFwiLi9oZG5vZGVcIjo2NixcIi4va2VjY2FrMjU2XCI6NzEsXCIuL3Bia2RmMlwiOjczLFwiLi9yYW5kb20tYnl0ZXNcIjo3NSxcIi4vc2lnbmluZy1rZXlcIjo4MSxcIi4vdXRmOFwiOjg1LFwiYWVzLWpzXCI6OCxcInNjcnlwdC1qc1wiOjQ0LHV1aWQ6NDh9XSw3OTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4oZShcImhhc2guanNcIikpLG89ZShcIi4vYnl0ZXNcIik7ci5yaXBlbWQxNjA9ZnVuY3Rpb24oZSl7cmV0dXJuXCIweFwiK2kuZGVmYXVsdC5yaXBlbWQxNjAoKS51cGRhdGUoby5hcnJheWlmeShlKSkuZGlnZXN0KFwiaGV4XCIpfSxyLnNoYTI1Nj1mdW5jdGlvbihlKXtyZXR1cm5cIjB4XCIraS5kZWZhdWx0LnNoYTI1NigpLnVwZGF0ZShvLmFycmF5aWZ5KGUpKS5kaWdlc3QoXCJoZXhcIil9LHIuc2hhNTEyPWZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIitpLmRlZmF1bHQuc2hhNTEyKCkudXBkYXRlKG8uYXJyYXlpZnkoZSkpLmRpZ2VzdChcImhleFwiKX19LHtcIi4vYnl0ZXNcIjo2NCxcImhhc2guanNcIjoyNn1dLDgwOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZShcInNldGltbWVkaWF0ZVwiKSxyLnBsYXRmb3JtPVwiYnJvd3NlclwifSx7c2V0aW1tZWRpYXRlOjQ1fV0sODE6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSk7cmV0dXJuIHQuZGVmYXVsdD1lLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPWUoXCIuL2hkbm9kZVwiKSxvPWUoXCIuL2J5dGVzXCIpLHM9ZShcIi4vcHJvcGVydGllc1wiKSxhPWUoXCIuL3NlY3AyNTZrMVwiKSx1PW4oZShcIi4uL2Vycm9yc1wiKSksbD0oaC5wcm90b3R5cGUuc2lnbkRpZ2VzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5rZXlQYWlyLnNpZ24oZSl9LGgucHJvdG90eXBlLmNvbXB1dGVTaGFyZWRTZWNyZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMua2V5UGFpci5jb21wdXRlU2hhcmVkU2VjcmV0KG8uYXJyYXlpZnkoZSkpfSxoLmlzU2lnbmluZ0tleT1mdW5jdGlvbihlKXtyZXR1cm4gcy5pc1R5cGUoZSxcIlNpZ25pbmdLZXlcIil9LGgpO2Z1bmN0aW9uIGgoZSl7dS5jaGVja05ldyh0aGlzLGgpO3ZhciB0PW51bGwsdD1pLkhETm9kZS5pc0hETm9kZShlKT8ocy5kZWZpbmVSZWFkT25seSh0aGlzLFwibW5lbW9uaWNcIixlLm1uZW1vbmljKSxzLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwYXRoXCIsZS5wYXRoKSxvLmFycmF5aWZ5KGUucHJpdmF0ZUtleSkpOihcInN0cmluZ1wiPT10eXBlb2YgZSYmZS5tYXRjaCgvXlswLTlhLWZdKiQvaSkmJjY0PT09ZS5sZW5ndGgmJihlPVwiMHhcIitlKSxvLmFycmF5aWZ5KGUpKTt0cnl7MzIhPT10Lmxlbmd0aCYmdS50aHJvd0Vycm9yKFwiZXhhY3RseSAzMiBieXRlcyByZXF1aXJlZFwiLHUuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwicHJpdmF0ZUtleVwiLHZhbHVlOlwiW1JFREFDVEVEXVwifSl9Y2F0Y2goZSl7dmFyIHI9e2FyZzpcInByaXZhdGVLZXlcIixyZWFzb246ZS5yZWFzb24sdmFsdWU6XCJbUkVEQUNURURdXCJ9O2UudmFsdWUmJihcIm51bWJlclwiPT10eXBlb2YgZS52YWx1ZS5sZW5ndGgmJihyLmxlbmd0aD1lLnZhbHVlLmxlbmd0aCksci50eXBlPXR5cGVvZiBlLnZhbHVlKSx1LnRocm93RXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsZS5jb2RlLHIpfXMuZGVmaW5lUmVhZE9ubHkodGhpcyxcInByaXZhdGVLZXlcIixvLmhleGxpZnkodCkpLHMuZGVmaW5lUmVhZE9ubHkodGhpcyxcImtleVBhaXJcIixuZXcgYS5LZXlQYWlyKHQpKSxzLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJwdWJsaWNLZXlcIix0aGlzLmtleVBhaXIucHVibGljS2V5KSxzLmRlZmluZVJlYWRPbmx5KHRoaXMsXCJhZGRyZXNzXCIsYS5jb21wdXRlQWRkcmVzcyh0aGlzLmtleVBhaXIucHVibGljS2V5KSkscy5zZXRUeXBlKHRoaXMsXCJTaWduaW5nS2V5XCIpfXIuU2lnbmluZ0tleT1sfSx7XCIuLi9lcnJvcnNcIjo1LFwiLi9ieXRlc1wiOjY0LFwiLi9oZG5vZGVcIjo2NixcIi4vcHJvcGVydGllc1wiOjc0LFwiLi9zZWNwMjU2azFcIjo3N31dLDgyOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHU9ZShcIi4vYmlnbnVtYmVyXCIpLGw9ZShcIi4vYnl0ZXNcIiksaD1lKFwiLi91dGY4XCIpLG49ZShcIi4va2VjY2FrMjU2XCIpLGk9ZShcIi4vc2hhMlwiKSxmPW5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIiksYz1uZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIiksZD1uZXcgUmVnRXhwKFwiXiguKilcXFxcWyhbMC05XSopXFxcXF0kXCIpLHA9XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7ZnVuY3Rpb24gbyhlLHIpe2lmKGUubGVuZ3RoIT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlL3ZhbHVlIGNvdW50IG1pc21hdGNoXCIpO3ZhciBuPVtdO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSx0KXtuLnB1c2goZnVuY3Rpb24gdChlLHIsbil7c3dpdGNoKGUpe2Nhc2VcImFkZHJlc3NcIjpyZXR1cm4gbj9sLnBhZFplcm9zKHIsMzIpOmwuYXJyYXlpZnkocik7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGgudG9VdGY4Qnl0ZXMocik7Y2FzZVwiYnl0ZXNcIjpyZXR1cm4gbC5hcnJheWlmeShyKTtjYXNlXCJib29sXCI6cmV0dXJuIHI9cj9cIjB4MDFcIjpcIjB4MDBcIixuP2wucGFkWmVyb3MociwzMik6bC5hcnJheWlmeShyKX12YXIgaT1lLm1hdGNoKGMpO2lmKGkpe2lmKChvPXBhcnNlSW50KGlbMl18fFwiMjU2XCIpKSU4IT0wfHwwPT09b3x8MjU2PG8pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBudW1iZXIgdHlwZSAtIFwiK2UpO3JldHVybiBuJiYobz0yNTYpLHI9dS5iaWdOdW1iZXJpZnkocikudG9Ud29zKG8pLGwucGFkWmVyb3MocixvLzgpfWlmKGk9ZS5tYXRjaChmKSl7dmFyIG89cGFyc2VJbnQoaVsxXSk7aWYoU3RyaW5nKG8pIT1pWzFdfHwwPT09b3x8MzI8byl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG51bWJlciB0eXBlIC0gXCIrZSk7aWYobC5hcnJheWlmeShyKS5ieXRlTGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBcIitlKTtyZXR1cm4gbj9sLmFycmF5aWZ5KChyK3ApLnN1YnN0cmluZygwLDY2KSk6cn1pZigoaT1lLm1hdGNoKGQpKSYmQXJyYXkuaXNBcnJheShyKSl7dmFyIHM9aVsxXTtpZihwYXJzZUludChpWzJdfHxTdHJpbmcoci5sZW5ndGgpKSE9ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgXCIrZSk7dmFyIGE9W107cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbihlKXthLnB1c2godChzLGUsITApKX0pLGwuY29uY2F0KGEpfXRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZSAtIFwiK2UpfShlLHJbdF0pKX0pLGwuaGV4bGlmeShsLmNvbmNhdChuKSl9ci5wYWNrPW8sci5rZWNjYWsyNTY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbi5rZWNjYWsyNTYobyhlLHQpKX0sci5zaGEyNTY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaS5zaGEyNTYobyhlLHQpKX19LHtcIi4vYmlnbnVtYmVyXCI6NjMsXCIuL2J5dGVzXCI6NjQsXCIuL2tlY2NhazI1NlwiOjcxLFwiLi9zaGEyXCI6NzksXCIuL3V0ZjhcIjo4NX1dLDgzOltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1lKFwiLi4vY29uc3RhbnRzXCIpLGE9bihlKFwiLi4vZXJyb3JzXCIpKSx1PWUoXCIuL3NlY3AyNTZrMVwiKSxsPWUoXCIuL2FkZHJlc3NcIiksaD1lKFwiLi9iaWdudW1iZXJcIiksZj1lKFwiLi9ieXRlc1wiKSxjPWUoXCIuL2tlY2NhazI1NlwiKSxzPWUoXCIuL3Byb3BlcnRpZXNcIiksZD1uKGUoXCIuL3JscFwiKSksbz1lKFwiLi4vcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXCIpO2Z1bmN0aW9uIHAoZSl7cmV0dXJuXCIweFwiPT09ZT9pLlplcm86aC5iaWdOdW1iZXJpZnkoZSl9dmFyIHY9W3tuYW1lOlwibm9uY2VcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwiZ2FzUHJpY2VcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwiZ2FzTGltaXRcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwidG9cIixsZW5ndGg6MjB9LHtuYW1lOlwidmFsdWVcIixtYXhMZW5ndGg6MzJ9LHtuYW1lOlwiZGF0YVwifV0seT17Y2hhaW5JZDohMCxkYXRhOiEwLGdhc0xpbWl0OiEwLGdhc1ByaWNlOiEwLG5vbmNlOiEwLHRvOiEwLHZhbHVlOiEwfTtyLnNlcmlhbGl6ZT1mdW5jdGlvbihyLGUpe3MuY2hlY2tQcm9wZXJ0aWVzKHIseSk7dmFyIG49W107di5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXJbZS5uYW1lXXx8W10sdD1mLmFycmF5aWZ5KGYuaGV4bGlmeSh0KSk7ZS5sZW5ndGgmJnQubGVuZ3RoIT09ZS5sZW5ndGgmJjA8dC5sZW5ndGgmJmEudGhyb3dFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIitlLm5hbWUsYS5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ0cmFuc2FjdGlvblwiK2UubmFtZSx2YWx1ZTp0fSksZS5tYXhMZW5ndGgmJih0PWYuc3RyaXBaZXJvcyh0KSkubGVuZ3RoPmUubWF4TGVuZ3RoJiZhLnRocm93RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIrZS5uYW1lLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwidHJhbnNhY3Rpb25cIitlLm5hbWUsdmFsdWU6dH0pLG4ucHVzaChmLmhleGxpZnkodCkpfSksbnVsbCE9ci5jaGFpbklkJiYwIT09ci5jaGFpbklkJiYobi5wdXNoKGYuaGV4bGlmeShyLmNoYWluSWQpKSxuLnB1c2goXCIweFwiKSxuLnB1c2goXCIweFwiKSk7dmFyIHQ9ZC5lbmNvZGUobik7aWYoIWUpcmV0dXJuIHQ7dmFyIGk9Zi5zcGxpdFNpZ25hdHVyZShlKSxvPTI3K2kucmVjb3ZlcnlQYXJhbTtyZXR1cm4gOT09PW4ubGVuZ3RoJiYobi5wb3AoKSxuLnBvcCgpLG4ucG9wKCksbys9MipyLmNoYWluSWQrOCksbi5wdXNoKGYuaGV4bGlmeShvKSksbi5wdXNoKGYuc3RyaXBaZXJvcyhmLmFycmF5aWZ5KGkucikpKSxuLnB1c2goZi5zdHJpcFplcm9zKGYuYXJyYXlpZnkoaS5zKSkpLGQuZW5jb2RlKG4pfSxyLnBhcnNlPWZ1bmN0aW9uKGUpe3ZhciB0PWQuZGVjb2RlKGUpOzkhPT10Lmxlbmd0aCYmNiE9PXQubGVuZ3RoJiZhLnRocm93RXJyb3IoXCJpbnZhbGlkIHJhdyB0cmFuc2FjdGlvblwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJnOlwicmF3VHJhbnNhY3RpblwiLHZhbHVlOmV9KTt2YXIgcixuPXtub25jZTpwKHRbMF0pLnRvTnVtYmVyKCksZ2FzUHJpY2U6cCh0WzFdKSxnYXNMaW1pdDpwKHRbMl0pLHRvOlwiMHhcIj09PShyPXRbM10pP251bGw6bC5nZXRBZGRyZXNzKHIpLHZhbHVlOnAodFs0XSksZGF0YTp0WzVdLGNoYWluSWQ6MH07aWYoNj09PXQubGVuZ3RoKXJldHVybiBuO3RyeXtuLnY9aC5iaWdOdW1iZXJpZnkodFs2XSkudG9OdW1iZXIoKX1jYXRjaChlKXtyZXR1cm4gYS5pbmZvKGUpLG59aWYobi5yPWYuaGV4WmVyb1BhZCh0WzddLDMyKSxuLnM9Zi5oZXhaZXJvUGFkKHRbOF0sMzIpLGguYmlnTnVtYmVyaWZ5KG4ucikuaXNaZXJvKCkmJmguYmlnTnVtYmVyaWZ5KG4ucykuaXNaZXJvKCkpbi5jaGFpbklkPW4udixuLnY9MDtlbHNle24uY2hhaW5JZD1NYXRoLmZsb29yKChuLnYtMzUpLzIpLG4uY2hhaW5JZDwwJiYobi5jaGFpbklkPTApO3ZhciBpPW4udi0yNyxvPXQuc2xpY2UoMCw2KTswIT09bi5jaGFpbklkJiYoby5wdXNoKGYuaGV4bGlmeShuLmNoYWluSWQpKSxvLnB1c2goXCIweFwiKSxvLnB1c2goXCIweFwiKSxpLT0yKm4uY2hhaW5JZCs4KTt2YXIgcz1jLmtlY2NhazI1NihkLmVuY29kZShvKSk7dHJ5e24uZnJvbT11LnJlY292ZXJBZGRyZXNzKHMse3I6Zi5oZXhsaWZ5KG4uciksczpmLmhleGxpZnkobi5zKSxyZWNvdmVyeVBhcmFtOml9KX1jYXRjaChlKXthLmluZm8oZSl9bi5oYXNoPWMua2VjY2FrMjU2KGUpfXJldHVybiBufSxyLnBvcHVsYXRlVHJhbnNhY3Rpb249ZnVuY3Rpb24oZSx0LHIpe28uUHJvdmlkZXIuaXNQcm92aWRlcih0KXx8YS50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLGEuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJwcm92aWRlclwiLHZhbHVlOnR9KSxzLmNoZWNrUHJvcGVydGllcyhlLHkpO3ZhciBuLGk9cy5zaGFsbG93Q29weShlKTtyZXR1cm4gbnVsbCE9aS50byYmKGkudG89dC5yZXNvbHZlTmFtZShpLnRvKSksbnVsbD09aS5nYXNQcmljZSYmKGkuZ2FzUHJpY2U9dC5nZXRHYXNQcmljZSgpKSxudWxsPT1pLm5vbmNlJiYoaS5ub25jZT10LmdldFRyYW5zYWN0aW9uQ291bnQocikpLG51bGw9PWkuZ2FzTGltaXQmJigobj1zLnNoYWxsb3dDb3B5KGkpKS5mcm9tPXIsaS5nYXNMaW1pdD10LmVzdGltYXRlR2FzKG4pKSxudWxsPT1pLmNoYWluSWQmJihpLmNoYWluSWQ9dC5nZXROZXR3b3JrKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFpbklkfSkpLHMucmVzb2x2ZVByb3BlcnRpZXMoaSl9fSx7XCIuLi9jb25zdGFudHNcIjozLFwiLi4vZXJyb3JzXCI6NSxcIi4uL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclwiOjUwLFwiLi9hZGRyZXNzXCI6NjAsXCIuL2JpZ251bWJlclwiOjYzLFwiLi9ieXRlc1wiOjY0LFwiLi9rZWNjYWsyNTZcIjo3MSxcIi4vcHJvcGVydGllc1wiOjc0LFwiLi9ybHBcIjo3NixcIi4vc2VjcDI1NmsxXCI6Nzd9XSw4NDpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGksaD1lKFwiLi4vY29uc3RhbnRzXCIpLGY9bihlKFwiLi4vZXJyb3JzXCIpKSxjPWUoXCIuL2JpZ251bWJlclwiKSxvPXt9O2Z1bmN0aW9uIHMoZSl7cmV0dXJue2RlY2ltYWxzOmUubGVuZ3RoLTEsdGVuUG93ZXI6Yy5iaWdOdW1iZXJpZnkoZSl9fWZ1bmN0aW9uIGQoZSl7dmFyIHQ9b1tTdHJpbmcoZSkudG9Mb3dlckNhc2UoKV07aWYoIXQmJlwibnVtYmVyXCI9PXR5cGVvZiBlJiZwYXJzZUludChTdHJpbmcoZSkpPT1lJiYwPD1lJiZlPD0yNTYpe2Zvcih2YXIgcj1cIjFcIixuPTA7bjxlO24rKylyKz1cIjBcIjt0PXMocil9cmV0dXJuIHR8fGYudGhyb3dFcnJvcihcImludmFsaWQgdW5pdFR5cGVcIixmLklOVkFMSURfQVJHVU1FTlQse2FyZ3VtZW50OlwibmFtZVwiLHZhbHVlOmV9KSx0fWZ1bmN0aW9uIGEoZSx0KXt2YXIgcj1kKHQpLG49KGU9Yy5iaWdOdW1iZXJpZnkoZSkpLmx0KGguWmVybyk7biYmKGU9ZS5tdWwoaC5OZWdhdGl2ZU9uZSkpO2Zvcih2YXIgaT1lLm1vZChyLnRlblBvd2VyKS50b1N0cmluZygpO2kubGVuZ3RoPHIuZGVjaW1hbHM7KWk9XCIwXCIraTtyZXR1cm4gaT1pLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdLGU9ZS5kaXYoci50ZW5Qb3dlcikudG9TdHJpbmcoKStcIi5cIitpLG4mJihlPVwiLVwiK2UpLGV9ZnVuY3Rpb24gdShlLHQpe251bGw9PXQmJih0PTE4KTt2YXIgcj1kKHQpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiZlLm1hdGNoKC9eLT9bMC05LixdKyQvKXx8Zi50aHJvd0Vycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KSwwPT09ci5kZWNpbWFscylyZXR1cm4gYy5iaWdOdW1iZXJpZnkoZSk7dmFyIG49XCItXCI9PT1lLnN1YnN0cmluZygwLDEpO24mJihlPWUuc3Vic3RyaW5nKDEpKSxcIi5cIj09PWUmJmYudGhyb3dFcnJvcihcIm1pc3NpbmcgdmFsdWVcIixmLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInZhbHVlXCIsdmFsdWU6ZX0pO3ZhciBpPWUuc3BsaXQoXCIuXCIpOzI8aS5sZW5ndGgmJmYudGhyb3dFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmc6XCJ2YWx1ZVwiLHZhbHVlOmV9KTt2YXIgbz1pWzBdLHM9aVsxXSxvPW98fFwiMFwiO2Zvcigocz1zfHxcIjBcIikubGVuZ3RoPnIuZGVjaW1hbHMmJmYudGhyb3dFcnJvcihcInVuZGVyZmxvdyBvY2N1cnJlZFwiLGYuTlVNRVJJQ19GQVVMVCx7b3BlcmF0aW9uOlwiZGl2aXNpb25cIixmYXVsdDpcInVuZGVyZmxvd1wifSk7cy5sZW5ndGg8ci5kZWNpbWFsczspcys9XCIwXCI7dmFyIGE9Yy5iaWdOdW1iZXJpZnkobyksdT1jLmJpZ051bWJlcmlmeShzKSxsPWEubXVsKHIudGVuUG93ZXIpLmFkZCh1KTtyZXR1cm4gbiYmKGw9bC5tdWwoaC5OZWdhdGl2ZU9uZSkpLGx9aT1cIjFcIixbXCJ3ZWlcIixcImt3ZWlcIixcIk13ZWlcIixcIkd3ZWlcIixcInN6YWJvXCIsXCJmaW5uZXlcIixcImV0aGVyXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9cyhpKTtvW2UudG9Mb3dlckNhc2UoKV09dCxvW1N0cmluZyh0LmRlY2ltYWxzKV09dCxpKz1cIjAwMFwifSksci5jb21taWZ5PWZ1bmN0aW9uKGUpe3ZhciB0PVN0cmluZyhlKS5zcGxpdChcIi5cIik7KDI8dC5sZW5ndGh8fCF0WzBdLm1hdGNoKC9eLT9bMC05XSokLyl8fHRbMV0mJiF0WzFdLm1hdGNoKC9eWzAtOV0qJC8pfHxcIi5cIj09PWV8fFwiLS5cIj09PWUpJiZmLnRocm93RXJyb3IoXCJpbnZhbGlkIHZhbHVlXCIsZi5JTlZBTElEX0FSR1VNRU5ULHthcmd1bWVudDpcInZhbHVlXCIsdmFsdWU6ZX0pO3ZhciByPXRbMF0sbj1cIlwiO2ZvcihcIi1cIj09PXIuc3Vic3RyaW5nKDAsMSkmJihuPVwiLVwiLHI9ci5zdWJzdHJpbmcoMSkpO1wiMFwiPT09ci5zdWJzdHJpbmcoMCwxKTspcj1yLnN1YnN0cmluZygxKTtcIlwiPT09ciYmKHI9XCIwXCIpO3ZhciBpPVwiXCI7Mj09PXQubGVuZ3RoJiYoaT1cIi5cIisodFsxXXx8XCIwXCIpKTtmb3IodmFyIG89W107ci5sZW5ndGg7KXtpZihyLmxlbmd0aDw9Myl7by51bnNoaWZ0KHIpO2JyZWFrfXZhciBzPXIubGVuZ3RoLTM7by51bnNoaWZ0KHIuc3Vic3RyaW5nKHMpKSxyPXIuc3Vic3RyaW5nKDAscyl9cmV0dXJuIG4rby5qb2luKFwiLFwiKStpfSxyLmZvcm1hdFVuaXRzPWEsci5wYXJzZVVuaXRzPXUsci5mb3JtYXRFdGhlcj1mdW5jdGlvbihlKXtyZXR1cm4gYShlLDE4KX0sci5wYXJzZUV0aGVyPWZ1bmN0aW9uKGUpe3JldHVybiB1KGUsMTgpfX0se1wiLi4vY29uc3RhbnRzXCI6MyxcIi4uL2Vycm9yc1wiOjUsXCIuL2JpZ251bWJlclwiOjYzfV0sODU6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxuLGk9ZShcIi4uL2NvbnN0YW50c1wiKSxhPWUoXCIuLi9lcnJvcnNcIiksaD1lKFwiLi9ieXRlc1wiKTtmdW5jdGlvbiBvKGUsdCl7dm9pZCAwPT09dCYmKHQ9cy5jdXJyZW50KSx0IT1zLmN1cnJlbnQmJihhLmNoZWNrTm9ybWFsaXplKCksZT1lLm5vcm1hbGl6ZSh0KSk7Zm9yKHZhciByPVtdLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZS5jaGFyQ29kZUF0KG4pO2lmKGk8MTI4KXIucHVzaChpKTtlbHNlIGlmKGk8MjA0OClyLnB1c2goaT4+NnwxOTIpLHIucHVzaCg2MyZpfDEyOCk7ZWxzZSBpZig1NTI5Nj09KDY0NTEyJmkpKXtuKys7dmFyIG89ZS5jaGFyQ29kZUF0KG4pO2lmKG4+PWUubGVuZ3RofHw1NjMyMCE9KDY0NTEyJm8pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO2k9NjU1MzYrKCgxMDIzJmkpPDwxMCkrKDEwMjMmbyksci5wdXNoKGk+PjE4fDI0MCksci5wdXNoKGk+PjEyJjYzfDEyOCksci5wdXNoKGk+PjYmNjN8MTI4KSxyLnB1c2goNjMmaXwxMjgpfWVsc2Ugci5wdXNoKGk+PjEyfDIyNCksci5wdXNoKGk+PjYmNjN8MTI4KSxyLnB1c2goNjMmaXwxMjgpfXJldHVybiBoLmFycmF5aWZ5KHIpfWZ1bmN0aW9uIHUoZSx0KXtlPWguYXJyYXlpZnkoZSk7Zm9yKHZhciByPVwiXCIsbj0wO248ZS5sZW5ndGg7KXt2YXIgaT1lW24rK107aWYoaT4+NyE9MCl7dmFyIG89bnVsbCxzPW51bGw7aWYoMTkyPT0oMjI0JmkpKW89MSxzPTEyNztlbHNlIGlmKDIyND09KDI0MCZpKSlvPTIscz0yMDQ3O2Vsc2V7aWYoMjQwIT0oMjQ4JmkpKXtpZih0KWNvbnRpbnVlO2lmKDEyOD09KDE5MiZpKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgdW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiKTt0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgaW52YWxpZCBwcmVmaXhcIil9bz0zLHM9NjU1MzV9aWYobitvPmUubGVuZ3RoKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgdG9vIHNob3J0XCIpO2Zvcig7bjxlLmxlbmd0aCYmZVtuXT4+Nj09MjtuKyspO31lbHNle2Zvcih2YXIgYT1pJigxPDw4LW8tMSktMSx1PTA7dTxvO3UrKyl7dmFyIGw9ZVtuXTtpZigxMjghPSgxOTImbCkpe2E9bnVsbDticmVha31hPWE8PDZ8NjMmbCxuKyt9aWYobnVsbCE9PWEpaWYoYTw9cyl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGY4IGJ5dGUgc2VxdWVuY2U7IG92ZXJsb25nXCIpfWVsc2UgaWYoMTExNDExMTxhKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgb3V0LW9mLXJhbmdlXCIpfWVsc2UgaWYoNTUyOTY8PWEmJmE8PTU3MzQzKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgdXRmLTE2IHN1cnJvZ2F0ZVwiKX1lbHNlIGE8PTY1NTM1P3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGE+PjEwJjEwMjMpLDU2MzIwKygxMDIzJmEpKSk7ZWxzZSBpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0ZjggYnl0ZSBzZXF1ZW5jZTsgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVwiKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpfXJldHVybiByfShuPXM9ci5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm18fChyLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybT17fSkpLmN1cnJlbnQ9XCJcIixuLk5GQz1cIk5GQ1wiLG4uTkZEPVwiTkZEXCIsbi5ORktDPVwiTkZLQ1wiLG4uTkZLRD1cIk5GS0RcIixyLnRvVXRmOEJ5dGVzPW8sci50b1V0ZjhTdHJpbmc9dSxyLmZvcm1hdEJ5dGVzMzJTdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9byhlKTtpZigzMTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJieXRlczMyIHN0cmluZyBtdXN0IGJlIGxlc3MgdGhhbiAzMiBieXRlc1wiKTtyZXR1cm4gaC5oZXhsaWZ5KGguY29uY2F0KFt0LGkuSGFzaFplcm9dKS5zbGljZSgwLDMyKSl9LHIucGFyc2VCeXRlczMyU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PWguYXJyYXlpZnkoZSk7aWYoMzIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgLSBub3QgMzIgYnl0ZXMgbG9uZ1wiKTtpZigwIT09dFszMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIHN0cmluZyAtIG5vIG51bGwgdGVybWluYXRvclwiKTtmb3IodmFyIHI9MzE7MD09PXRbci0xXTspci0tO3JldHVybiB1KHQuc2xpY2UoMCxyKSl9fSx7XCIuLi9jb25zdGFudHNcIjozLFwiLi4vZXJyb3JzXCI6NSxcIi4vYnl0ZXNcIjo2NH1dLDg2OltmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZj1lKFwieG1saHR0cHJlcXVlc3RcIiksaT1lKFwiLi9iYXNlNjRcIiksbz1lKFwiLi9wcm9wZXJ0aWVzXCIpLHM9ZShcIi4vdXRmOFwiKSxjPW4oZShcIi4uL2Vycm9yc1wiKSk7ci5mZXRjaEpzb249ZnVuY3Rpb24oZSxhLHUpe3ZhciB0LHI9e30sbD1udWxsLGg9MTJlNDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlsPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSl7aWYobnVsbD09ZS51cmwmJmMudGhyb3dFcnJvcihcIm1pc3NpbmcgVVJMXCIsYy5NSVNTSU5HX0FSR1VNRU5ULHthcmc6XCJ1cmxcIn0pLGw9ZS51cmwsXCJudW1iZXJcIj09dHlwZW9mIGUudGltZW91dCYmMDxlLnRpbWVvdXQmJihoPWUudGltZW91dCksZS5oZWFkZXJzKWZvcih2YXIgbiBpbiBlLmhlYWRlcnMpcltuLnRvTG93ZXJDYXNlKCldPXtrZXk6bix2YWx1ZTpTdHJpbmcoZS5oZWFkZXJzW25dKX07bnVsbCE9ZS51c2VyJiZudWxsIT1lLnBhc3N3b3JkJiYoXCJodHRwczpcIiE9PWwuc3Vic3RyaW5nKDAsNikmJiEwIT09ZS5hbGxvd0luc2VjdXJlJiZjLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIixjLklOVkFMSURfQVJHVU1FTlQse2FyZzpcInVybFwiLHVybDpsLHVzZXI6ZS51c2VyLHBhc3N3b3JkOlwiW1JFREFDVEVEXVwifSksdD1lLnVzZXIrXCI6XCIrZS5wYXNzd29yZCxyLmF1dGhvcml6YXRpb249e2tleTpcIkF1dGhvcml6YXRpb25cIix2YWx1ZTpcIkJhc2ljIFwiK2kuZW5jb2RlKHMudG9VdGY4Qnl0ZXModCkpfSl9cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4saSl7ZnVuY3Rpb24gbygpe251bGwhPWUmJihjbGVhclRpbWVvdXQoZSksZT1udWxsKX12YXIgcz1uZXcgZi5YTUxIdHRwUmVxdWVzdCxlPW51bGwsZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bnVsbCE9ZSYmKGU9bnVsbCxpKG5ldyBFcnJvcihcInRpbWVvdXRcIikpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzLmFib3J0KCl9LDApKX0saCk7YT8ocy5vcGVuKFwiUE9TVFwiLGwsITApLHJbXCJjb250ZW50LXR5cGVcIl09e2tleTpcIkNvbnRlbnQtVHlwZVwiLHZhbHVlOlwiYXBwbGljYXRpb24vanNvblwifSk6cy5vcGVuKFwiR0VUXCIsbCwhMCksT2JqZWN0LmtleXMocikuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yW2VdO3Muc2V0UmVxdWVzdEhlYWRlcih0LmtleSx0LnZhbHVlKX0pLHMub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoND09PXMucmVhZHlTdGF0ZSl7aWYoMjAwIT1zLnN0YXR1cyl7bygpO3ZhciBlPW5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2UgLSBcIitzLnN0YXR1cyk7cmV0dXJuIGUuc3RhdHVzQ29kZT1zLnN0YXR1cyxzLnJlc3BvbnNlVGV4dCYmKGUucmVzcG9uc2VUZXh0PXMucmVzcG9uc2VUZXh0KSx2b2lkIGkoZSl9dmFyIHQ9bnVsbDt0cnl7dD1KU09OLnBhcnNlKHMucmVzcG9uc2VUZXh0KX1jYXRjaChlKXtvKCk7dmFyIHI9bmV3IEVycm9yKFwiaW52YWxpZCBqc29uIHJlc3BvbnNlXCIpO3JldHVybiByLm9yZ2luaWFsRXJyb3I9ZSxyLnJlc3BvbnNlVGV4dD1zLnJlc3BvbnNlVGV4dCxudWxsIT1hJiYoci5yZXF1ZXN0Qm9keT1hKSxyLnVybD1sLHZvaWQgaShyKX1pZih1KXRyeXt0PXUodCl9Y2F0Y2goZSl7cmV0dXJuIG8oKSxlLnVybD1sLGUuYm9keT1hLGUucmVzcG9uc2VUZXh0PXMucmVzcG9uc2VUZXh0LHZvaWQgaShlKX1vKCksbih0KX19LHMub25lcnJvcj1mdW5jdGlvbihlKXtvKCksaShlKX07dHJ5e251bGwhPWE/cy5zZW5kKGEpOnMuc2VuZCgpfWNhdGNoKGUpe28oKTt2YXIgdD1uZXcgRXJyb3IoXCJjb25uZWN0aW9uIGVycm9yXCIpO3QuZXJyb3I9ZSxpKHQpfX0pfSxyLnBvbGw9ZnVuY3Rpb24odSxsKXtyZXR1cm4gbD1sfHx7fSxudWxsPT0obD1vLnNoYWxsb3dDb3B5KGwpKS5mbG9vciYmKGwuZmxvb3I9MCksbnVsbD09bC5jZWlsaW5nJiYobC5jZWlsaW5nPTFlNCksbnVsbD09bC5pbnRlcnZhbCYmKGwuaW50ZXJ2YWw9MjUwKSxuZXcgUHJvbWlzZShmdW5jdGlvbihuLHQpe3ZhciBlPW51bGwsaT0hMSxvPWZ1bmN0aW9uKCl7cmV0dXJuIWkmJihpPSEwLGUmJmNsZWFyVGltZW91dChlKSwhMCl9O2wudGltZW91dCYmKGU9c2V0VGltZW91dChmdW5jdGlvbigpe28oKSYmdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKX0sbC50aW1lb3V0KSk7dmFyIHM9bC5mYXN0UmV0cnl8fG51bGwsYT0wOyFmdW5jdGlvbiByKCl7cmV0dXJuIHUoKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiB2b2lkIDAhPT1lP28oKSYmbihlKTpsLm9uY2VCbG9jaz9sLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIixyKTppfHwoYSsrLCh0PWwuaW50ZXJ2YWwqcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMixhKSkpKTxsLmZsb29yJiYodD1sLmZsb29yKSx0PmwuY2VpbGluZyYmKHQ9bC5jZWlsaW5nKSxzJiYoYS0tLHQ9cyxzPW51bGwpLHNldFRpbWVvdXQocix0KSksbnVsbH0sZnVuY3Rpb24oZSl7bygpJiZ0KGUpfSl9KCl9KX19LHtcIi4uL2Vycm9yc1wiOjUsXCIuL2Jhc2U2NFwiOjYxLFwiLi9wcm9wZXJ0aWVzXCI6NzQsXCIuL3V0ZjhcIjo4NSx4bWxodHRwcmVxdWVzdDo0OX1dLDg3OltmdW5jdGlvbihvLGUscyl7KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW8oXCIuLi91dGlscy9oYXNoXCIpLHQ9byhcIi4uL3V0aWxzL3Byb3BlcnRpZXNcIik7cy5jaGVjaz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8MjA0ODtyKyspe3ZhciBuPWUuZ2V0V29yZChyKTtpZihyIT09ZS5nZXRXb3JkSW5kZXgobikpcmV0dXJuXCIweFwiO3QucHVzaChuKX1yZXR1cm4gaS5pZCh0LmpvaW4oXCJcXG5cIikrXCJcXG5cIil9O3ZhciByPShuLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlKXtyZXR1cm4gZS50b0xvd2VyQ2FzZSgpLnNwbGl0KC8gKy9nKX0sbi5wcm90b3R5cGUuam9pbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5qb2luKFwiIFwiKX0sbik7ZnVuY3Rpb24gbihlKXt0LmRlZmluZVJlYWRPbmx5KHRoaXMsXCJsb2NhbGVcIixlKX1zLldvcmRsaXN0PXIscy5yZWdpc3Rlcj1mdW5jdGlvbihlLHQpe3Q9dHx8ZS5sb2NhbGV9fSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30pfSx7XCIuLi91dGlscy9oYXNoXCI6NjUsXCIuLi91dGlscy9wcm9wZXJ0aWVzXCI6NzR9XSw4ODpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJihlW3JdPXRbcl0pfSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KHIucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyByKX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcyxhPWUoXCIuL3V0aWxzL2J5dGVzXCIpLHU9ZShcIi4vdXRpbHMvaGFzaFwiKSxsPWUoXCIuL3V0aWxzL2hkbm9kZVwiKSxoPWUoXCIuL3V0aWxzL2pzb24td2FsbGV0XCIpLGY9ZShcIi4vdXRpbHMva2VjY2FrMjU2XCIpLGM9ZShcIi4vdXRpbHMvcHJvcGVydGllc1wiKSxkPWUoXCIuL3V0aWxzL3JhbmRvbS1ieXRlc1wiKSxwPW8oZShcIi4vdXRpbHMvc2VjcmV0LXN0b3JhZ2VcIikpLHY9ZShcIi4vdXRpbHMvc2lnbmluZy1rZXlcIikseT1lKFwiLi91dGlscy90cmFuc2FjdGlvblwiKSxtPWUoXCIuL2Fic3RyYWN0LXNpZ25lclwiKSxnPWUoXCIuL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclwiKSxiPW8oZShcIi4vZXJyb3JzXCIpKSx3PShzPW0uU2lnbmVyLGkoXyxzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsXCJhZGRyZXNzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpZ25pbmdLZXkuYWRkcmVzc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsXCJtbmVtb25pY1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaWduaW5nS2V5Lm1uZW1vbmljfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLnByb3RvdHlwZSxcInBhdGhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wYXRofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLnByb3RvdHlwZSxcInByaXZhdGVLZXlcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2lnbmluZ0tleS5wcml2YXRlS2V5fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLF8ucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGcuUHJvdmlkZXIuaXNQcm92aWRlcihlKXx8Yi50aHJvd0Vycm9yKFwiaW52YWxpZCBwcm92aWRlclwiLGIuSU5WQUxJRF9BUkdVTUVOVCx7YXJndW1lbnQ6XCJwcm92aWRlclwiLHZhbHVlOmV9KSxuZXcgXyh0aGlzLnNpZ25pbmdLZXksZSl9LF8ucHJvdG90eXBlLmdldEFkZHJlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyl9LF8ucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oZSl7dmFyIG49dGhpcztyZXR1cm4gYy5yZXNvbHZlUHJvcGVydGllcyhlKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciB0PXkuc2VyaWFsaXplKGUpLHI9bi5zaWduaW5nS2V5LnNpZ25EaWdlc3QoZi5rZWNjYWsyNTYodCkpO3JldHVybiB5LnNlcmlhbGl6ZShlLHIpfSl9LF8ucHJvdG90eXBlLnNpZ25NZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoYS5qb2luU2lnbmF0dXJlKHRoaXMuc2lnbmluZ0tleS5zaWduRGlnZXN0KHUuaGFzaE1lc3NhZ2UoZSkpKSl9LF8ucHJvdG90eXBlLmdldEJhbGFuY2U9ZnVuY3Rpb24oZSl7aWYoIXRoaXMucHJvdmlkZXIpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwcm92aWRlclwiKTtyZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuYWRkcmVzcyxlKX0sXy5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25Db3VudD1mdW5jdGlvbihlKXtpZighdGhpcy5wcm92aWRlcil0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIpO3JldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5hZGRyZXNzLGUpfSxfLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdGhpcy5wcm92aWRlcil0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIpO3JldHVybiBudWxsPT1lLm5vbmNlJiYoKGU9Yy5zaGFsbG93Q29weShlKSkubm9uY2U9dGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50KFwicGVuZGluZ1wiKSkseS5wb3B1bGF0ZVRyYW5zYWN0aW9uKGUsdGhpcy5wcm92aWRlcix0aGlzLmFkZHJlc3MpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHQuc2lnbihlKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB0LnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihlKX0pfSl9LF8ucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHR8fHJ8fChyPXQsdD17fSksciYmXCJmdW5jdGlvblwiIT10eXBlb2Ygcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO3JldHVybiB0PXR8fHt9LHRoaXMubW5lbW9uaWMmJigodD1jLnNoYWxsb3dDb3B5KHQpKS5tbmVtb25pYz10aGlzLm1uZW1vbmljLHQucGF0aD10aGlzLnBhdGgpLHAuZW5jcnlwdCh0aGlzLnByaXZhdGVLZXksZSx0LHIpfSxfLmNyZWF0ZVJhbmRvbT1mdW5jdGlvbihlKXt2YXIgdD1kLnJhbmRvbUJ5dGVzKDE2KTsoZT1lfHx7fSkuZXh0cmFFbnRyb3B5JiYodD1hLmFycmF5aWZ5KGYua2VjY2FrMjU2KGEuY29uY2F0KFt0LGUuZXh0cmFFbnRyb3B5XSkpLnN1YnN0cmluZygwLDM0KSkpO3ZhciByPWwuZW50cm9weVRvTW5lbW9uaWModCxlLmxvY2FsZSk7cmV0dXJuIF8uZnJvbU1uZW1vbmljKHIsZS5wYXRoLGUubG9jYWxlKX0sXy5mcm9tRW5jcnlwdGVkSnNvbj1mdW5jdGlvbihlLHQscil7aWYoaC5pc0Nyb3dkc2FsZVdhbGxldChlKSl0cnl7ciYmcigwKTt2YXIgbj1wLmRlY3J5cHRDcm93ZHNhbGUoZSx0KTtyZXR1cm4gciYmcigxKSxQcm9taXNlLnJlc29sdmUobmV3IF8obikpfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX1lbHNlIGlmKGguaXNTZWNyZXRTdG9yYWdlV2FsbGV0KGUpKXJldHVybiBwLmRlY3J5cHQoZSx0LHIpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBfKGUpfSk7cmV0dXJuIFByb21pc2UucmVqZWN0KFwiaW52YWxpZCB3YWxsZXQgSlNPTlwiKX0sXy5mcm9tTW5lbW9uaWM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0PXR8fGwuZGVmYXVsdFBhdGgsbmV3IF8obC5mcm9tTW5lbW9uaWMoZSxyKS5kZXJpdmVQYXRoKHQpKX0sXyk7ZnVuY3Rpb24gXyhlLHQpe3ZhciByPXMuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gYi5jaGVja05ldyhyLF8pLHYuU2lnbmluZ0tleS5pc1NpZ25pbmdLZXkoZSk/Yy5kZWZpbmVSZWFkT25seShyLFwic2lnbmluZ0tleVwiLGUpOmMuZGVmaW5lUmVhZE9ubHkocixcInNpZ25pbmdLZXlcIixuZXcgdi5TaWduaW5nS2V5KGUpKSxjLmRlZmluZVJlYWRPbmx5KHIsXCJwcm92aWRlclwiLHQpLHJ9ci5XYWxsZXQ9d30se1wiLi9hYnN0cmFjdC1zaWduZXJcIjoyLFwiLi9lcnJvcnNcIjo1LFwiLi9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcIjo1MCxcIi4vdXRpbHMvYnl0ZXNcIjo2NCxcIi4vdXRpbHMvaGFzaFwiOjY1LFwiLi91dGlscy9oZG5vZGVcIjo2NixcIi4vdXRpbHMvanNvbi13YWxsZXRcIjo3MCxcIi4vdXRpbHMva2VjY2FrMjU2XCI6NzEsXCIuL3V0aWxzL3Byb3BlcnRpZXNcIjo3NCxcIi4vdXRpbHMvcmFuZG9tLWJ5dGVzXCI6NzUsXCIuL3V0aWxzL3NlY3JldC1zdG9yYWdlXCI6NzgsXCIuL3V0aWxzL3NpZ25pbmcta2V5XCI6ODEsXCIuL3V0aWxzL3RyYW5zYWN0aW9uXCI6ODN9XSw4OTpbZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPWUoXCIuLi93b3JkbGlzdHMvbGFuZy1lblwiKS5sYW5nRW47ci5lbj1ufSx7XCIuLi93b3JkbGlzdHMvbGFuZy1lblwiOjkwfV0sOTA6W2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwobj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoZVtyXT10W3JdKX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihyLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgcil9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbyxzPWUoXCIuLi91dGlscy93b3JkbGlzdFwiKSxhPVwiQWJhbmRvbkFiaWxpdHlBYmxlQWJvdXRBYm92ZUFic2VudEFic29yYkFic3RyYWN0QWJzdXJkQWJ1c2VBY2Nlc3NBY2NpZGVudEFjY291bnRBY2N1c2VBY2hpZXZlQWNpZEFjb3VzdGljQWNxdWlyZUFjcm9zc0FjdEFjdGlvbkFjdG9yQWN0cmVzc0FjdHVhbEFkYXB0QWRkQWRkaWN0QWRkcmVzc0FkanVzdEFkbWl0QWR1bHRBZHZhbmNlQWR2aWNlQWVyb2JpY0FmZmFpckFmZm9yZEFmcmFpZEFnYWluQWdlQWdlbnRBZ3JlZUFoZWFkQWltQWlyQWlycG9ydEFpc2xlQWxhcm1BbGJ1bUFsY29ob2xBbGVydEFsaWVuQWxsQWxsZXlBbGxvd0FsbW9zdEFsb25lQWxwaGFBbHJlYWR5QWxzb0FsdGVyQWx3YXlzQW1hdGV1ckFtYXppbmdBbW9uZ0Ftb3VudEFtdXNlZEFuYWx5c3RBbmNob3JBbmNpZW50QW5nZXJBbmdsZUFuZ3J5QW5pbWFsQW5rbGVBbm5vdW5jZUFubnVhbEFub3RoZXJBbnN3ZXJBbnRlbm5hQW50aXF1ZUFueGlldHlBbnlBcGFydEFwb2xvZ3lBcHBlYXJBcHBsZUFwcHJvdmVBcHJpbEFyY2hBcmN0aWNBcmVhQXJlbmFBcmd1ZUFybUFybWVkQXJtb3JBcm15QXJvdW5kQXJyYW5nZUFycmVzdEFycml2ZUFycm93QXJ0QXJ0ZWZhY3RBcnRpc3RBcnR3b3JrQXNrQXNwZWN0QXNzYXVsdEFzc2V0QXNzaXN0QXNzdW1lQXN0aG1hQXRobGV0ZUF0b21BdHRhY2tBdHRlbmRBdHRpdHVkZUF0dHJhY3RBdWN0aW9uQXVkaXRBdWd1c3RBdW50QXV0aG9yQXV0b0F1dHVtbkF2ZXJhZ2VBdm9jYWRvQXZvaWRBd2FrZUF3YXJlQXdheUF3ZXNvbWVBd2Z1bEF3a3dhcmRBeGlzQmFieUJhY2hlbG9yQmFjb25CYWRnZUJhZ0JhbGFuY2VCYWxjb255QmFsbEJhbWJvb0JhbmFuYUJhbm5lckJhckJhcmVseUJhcmdhaW5CYXJyZWxCYXNlQmFzaWNCYXNrZXRCYXR0bGVCZWFjaEJlYW5CZWF1dHlCZWNhdXNlQmVjb21lQmVlZkJlZm9yZUJlZ2luQmVoYXZlQmVoaW5kQmVsaWV2ZUJlbG93QmVsdEJlbmNoQmVuZWZpdEJlc3RCZXRyYXlCZXR0ZXJCZXR3ZWVuQmV5b25kQmljeWNsZUJpZEJpa2VCaW5kQmlvbG9neUJpcmRCaXJ0aEJpdHRlckJsYWNrQmxhZGVCbGFtZUJsYW5rZXRCbGFzdEJsZWFrQmxlc3NCbGluZEJsb29kQmxvc3NvbUJsb3VzZUJsdWVCbHVyQmx1c2hCb2FyZEJvYXRCb2R5Qm9pbEJvbWJCb25lQm9udXNCb29rQm9vc3RCb3JkZXJCb3JpbmdCb3Jyb3dCb3NzQm90dG9tQm91bmNlQm94Qm95QnJhY2tldEJyYWluQnJhbmRCcmFzc0JyYXZlQnJlYWRCcmVlemVCcmlja0JyaWRnZUJyaWVmQnJpZ2h0QnJpbmdCcmlza0Jyb2Njb2xpQnJva2VuQnJvbnplQnJvb21Ccm90aGVyQnJvd25CcnVzaEJ1YmJsZUJ1ZGR5QnVkZ2V0QnVmZmFsb0J1aWxkQnVsYkJ1bGtCdWxsZXRCdW5kbGVCdW5rZXJCdXJkZW5CdXJnZXJCdXJzdEJ1c0J1c2luZXNzQnVzeUJ1dHRlckJ1eWVyQnV6ekNhYmJhZ2VDYWJpbkNhYmxlQ2FjdHVzQ2FnZUNha2VDYWxsQ2FsbUNhbWVyYUNhbXBDYW5DYW5hbENhbmNlbENhbmR5Q2Fubm9uQ2Fub2VDYW52YXNDYW55b25DYXBhYmxlQ2FwaXRhbENhcHRhaW5DYXJDYXJib25DYXJkQ2FyZ29DYXJwZXRDYXJyeUNhcnRDYXNlQ2FzaENhc2lub0Nhc3RsZUNhc3VhbENhdENhdGFsb2dDYXRjaENhdGVnb3J5Q2F0dGxlQ2F1Z2h0Q2F1c2VDYXV0aW9uQ2F2ZUNlaWxpbmdDZWxlcnlDZW1lbnRDZW5zdXNDZW50dXJ5Q2VyZWFsQ2VydGFpbkNoYWlyQ2hhbGtDaGFtcGlvbkNoYW5nZUNoYW9zQ2hhcHRlckNoYXJnZUNoYXNlQ2hhdENoZWFwQ2hlY2tDaGVlc2VDaGVmQ2hlcnJ5Q2hlc3RDaGlja2VuQ2hpZWZDaGlsZENoaW1uZXlDaG9pY2VDaG9vc2VDaHJvbmljQ2h1Y2tsZUNodW5rQ2h1cm5DaWdhckNpbm5hbW9uQ2lyY2xlQ2l0aXplbkNpdHlDaXZpbENsYWltQ2xhcENsYXJpZnlDbGF3Q2xheUNsZWFuQ2xlcmtDbGV2ZXJDbGlja0NsaWVudENsaWZmQ2xpbWJDbGluaWNDbGlwQ2xvY2tDbG9nQ2xvc2VDbG90aENsb3VkQ2xvd25DbHViQ2x1bXBDbHVzdGVyQ2x1dGNoQ29hY2hDb2FzdENvY29udXRDb2RlQ29mZmVlQ29pbENvaW5Db2xsZWN0Q29sb3JDb2x1bW5Db21iaW5lQ29tZUNvbWZvcnRDb21pY0NvbW1vbkNvbXBhbnlDb25jZXJ0Q29uZHVjdENvbmZpcm1Db25ncmVzc0Nvbm5lY3RDb25zaWRlckNvbnRyb2xDb252aW5jZUNvb2tDb29sQ29wcGVyQ29weUNvcmFsQ29yZUNvcm5Db3JyZWN0Q29zdENvdHRvbkNvdWNoQ291bnRyeUNvdXBsZUNvdXJzZUNvdXNpbkNvdmVyQ295b3RlQ3JhY2tDcmFkbGVDcmFmdENyYW1DcmFuZUNyYXNoQ3JhdGVyQ3Jhd2xDcmF6eUNyZWFtQ3JlZGl0Q3JlZWtDcmV3Q3JpY2tldENyaW1lQ3Jpc3BDcml0aWNDcm9wQ3Jvc3NDcm91Y2hDcm93ZENydWNpYWxDcnVlbENydWlzZUNydW1ibGVDcnVuY2hDcnVzaENyeUNyeXN0YWxDdWJlQ3VsdHVyZUN1cEN1cGJvYXJkQ3VyaW91c0N1cnJlbnRDdXJ0YWluQ3VydmVDdXNoaW9uQ3VzdG9tQ3V0ZUN5Y2xlRGFkRGFtYWdlRGFtcERhbmNlRGFuZ2VyRGFyaW5nRGFzaERhdWdodGVyRGF3bkRheURlYWxEZWJhdGVEZWJyaXNEZWNhZGVEZWNlbWJlckRlY2lkZURlY2xpbmVEZWNvcmF0ZURlY3JlYXNlRGVlckRlZmVuc2VEZWZpbmVEZWZ5RGVncmVlRGVsYXlEZWxpdmVyRGVtYW5kRGVtaXNlRGVuaWFsRGVudGlzdERlbnlEZXBhcnREZXBlbmREZXBvc2l0RGVwdGhEZXB1dHlEZXJpdmVEZXNjcmliZURlc2VydERlc2lnbkRlc2tEZXNwYWlyRGVzdHJveURldGFpbERldGVjdERldmVsb3BEZXZpY2VEZXZvdGVEaWFncmFtRGlhbERpYW1vbmREaWFyeURpY2VEaWVzZWxEaWV0RGlmZmVyRGlnaXRhbERpZ25pdHlEaWxlbW1hRGlubmVyRGlub3NhdXJEaXJlY3REaXJ0RGlzYWdyZWVEaXNjb3ZlckRpc2Vhc2VEaXNoRGlzbWlzc0Rpc29yZGVyRGlzcGxheURpc3RhbmNlRGl2ZXJ0RGl2aWRlRGl2b3JjZURpenp5RG9jdG9yRG9jdW1lbnREb2dEb2xsRG9scGhpbkRvbWFpbkRvbmF0ZURvbmtleURvbm9yRG9vckRvc2VEb3VibGVEb3ZlRHJhZnREcmFnb25EcmFtYURyYXN0aWNEcmF3RHJlYW1EcmVzc0RyaWZ0RHJpbGxEcmlua0RyaXBEcml2ZURyb3BEcnVtRHJ5RHVja0R1bWJEdW5lRHVyaW5nRHVzdER1dGNoRHV0eUR3YXJmRHluYW1pY0VhZ2VyRWFnbGVFYXJseUVhcm5FYXJ0aEVhc2lseUVhc3RFYXN5RWNob0Vjb2xvZ3lFY29ub215RWRnZUVkaXRFZHVjYXRlRWZmb3J0RWdnRWlnaHRFaXRoZXJFbGJvd0VsZGVyRWxlY3RyaWNFbGVnYW50RWxlbWVudEVsZXBoYW50RWxldmF0b3JFbGl0ZUVsc2VFbWJhcmtFbWJvZHlFbWJyYWNlRW1lcmdlRW1vdGlvbkVtcGxveUVtcG93ZXJFbXB0eUVuYWJsZUVuYWN0RW5kRW5kbGVzc0VuZG9yc2VFbmVteUVuZXJneUVuZm9yY2VFbmdhZ2VFbmdpbmVFbmhhbmNlRW5qb3lFbmxpc3RFbm91Z2hFbnJpY2hFbnJvbGxFbnN1cmVFbnRlckVudGlyZUVudHJ5RW52ZWxvcGVFcGlzb2RlRXF1YWxFcXVpcEVyYUVyYXNlRXJvZGVFcm9zaW9uRXJyb3JFcnVwdEVzY2FwZUVzc2F5RXNzZW5jZUVzdGF0ZUV0ZXJuYWxFdGhpY3NFdmlkZW5jZUV2aWxFdm9rZUV2b2x2ZUV4YWN0RXhhbXBsZUV4Y2Vzc0V4Y2hhbmdlRXhjaXRlRXhjbHVkZUV4Y3VzZUV4ZWN1dGVFeGVyY2lzZUV4aGF1c3RFeGhpYml0RXhpbGVFeGlzdEV4aXRFeG90aWNFeHBhbmRFeHBlY3RFeHBpcmVFeHBsYWluRXhwb3NlRXhwcmVzc0V4dGVuZEV4dHJhRXllRXllYnJvd0ZhYnJpY0ZhY2VGYWN1bHR5RmFkZUZhaW50RmFpdGhGYWxsRmFsc2VGYW1lRmFtaWx5RmFtb3VzRmFuRmFuY3lGYW50YXN5RmFybUZhc2hpb25GYXRGYXRhbEZhdGhlckZhdGlndWVGYXVsdEZhdm9yaXRlRmVhdHVyZUZlYnJ1YXJ5RmVkZXJhbEZlZUZlZWRGZWVsRmVtYWxlRmVuY2VGZXN0aXZhbEZldGNoRmV2ZXJGZXdGaWJlckZpY3Rpb25GaWVsZEZpZ3VyZUZpbGVGaWxtRmlsdGVyRmluYWxGaW5kRmluZUZpbmdlckZpbmlzaEZpcmVGaXJtRmlyc3RGaXNjYWxGaXNoRml0Rml0bmVzc0ZpeEZsYWdGbGFtZUZsYXNoRmxhdEZsYXZvckZsZWVGbGlnaHRGbGlwRmxvYXRGbG9ja0Zsb29yRmxvd2VyRmx1aWRGbHVzaEZseUZvYW1Gb2N1c0ZvZ0ZvaWxGb2xkRm9sbG93Rm9vZEZvb3RGb3JjZUZvcmVzdEZvcmdldEZvcmtGb3J0dW5lRm9ydW1Gb3J3YXJkRm9zc2lsRm9zdGVyRm91bmRGb3hGcmFnaWxlRnJhbWVGcmVxdWVudEZyZXNoRnJpZW5kRnJpbmdlRnJvZ0Zyb250RnJvc3RGcm93bkZyb3plbkZydWl0RnVlbEZ1bkZ1bm55RnVybmFjZUZ1cnlGdXR1cmVHYWRnZXRHYWluR2FsYXh5R2FsbGVyeUdhbWVHYXBHYXJhZ2VHYXJiYWdlR2FyZGVuR2FybGljR2FybWVudEdhc0dhc3BHYXRlR2F0aGVyR2F1Z2VHYXplR2VuZXJhbEdlbml1c0dlbnJlR2VudGxlR2VudWluZUdlc3R1cmVHaG9zdEdpYW50R2lmdEdpZ2dsZUdpbmdlckdpcmFmZmVHaXJsR2l2ZUdsYWRHbGFuY2VHbGFyZUdsYXNzR2xpZGVHbGltcHNlR2xvYmVHbG9vbUdsb3J5R2xvdmVHbG93R2x1ZUdvYXRHb2RkZXNzR29sZEdvb2RHb29zZUdvcmlsbGFHb3NwZWxHb3NzaXBHb3Zlcm5Hb3duR3JhYkdyYWNlR3JhaW5HcmFudEdyYXBlR3Jhc3NHcmF2aXR5R3JlYXRHcmVlbkdyaWRHcmllZkdyaXRHcm9jZXJ5R3JvdXBHcm93R3J1bnRHdWFyZEd1ZXNzR3VpZGVHdWlsdEd1aXRhckd1bkd5bUhhYml0SGFpckhhbGZIYW1tZXJIYW1zdGVySGFuZEhhcHB5SGFyYm9ySGFyZEhhcnNoSGFydmVzdEhhdEhhdmVIYXdrSGF6YXJkSGVhZEhlYWx0aEhlYXJ0SGVhdnlIZWRnZWhvZ0hlaWdodEhlbGxvSGVsbWV0SGVscEhlbkhlcm9IaWRkZW5IaWdoSGlsbEhpbnRIaXBIaXJlSGlzdG9yeUhvYmJ5SG9ja2V5SG9sZEhvbGVIb2xpZGF5SG9sbG93SG9tZUhvbmV5SG9vZEhvcGVIb3JuSG9ycm9ySG9yc2VIb3NwaXRhbEhvc3RIb3RlbEhvdXJIb3Zlckh1Ykh1Z2VIdW1hbkh1bWJsZUh1bW9ySHVuZHJlZEh1bmdyeUh1bnRIdXJkbGVIdXJyeUh1cnRIdXNiYW5kSHlicmlkSWNlSWNvbklkZWFJZGVudGlmeUlkbGVJZ25vcmVJbGxJbGxlZ2FsSWxsbmVzc0ltYWdlSW1pdGF0ZUltbWVuc2VJbW11bmVJbXBhY3RJbXBvc2VJbXByb3ZlSW1wdWxzZUluY2hJbmNsdWRlSW5jb21lSW5jcmVhc2VJbmRleEluZGljYXRlSW5kb29ySW5kdXN0cnlJbmZhbnRJbmZsaWN0SW5mb3JtSW5oYWxlSW5oZXJpdEluaXRpYWxJbmplY3RJbmp1cnlJbm1hdGVJbm5lcklubm9jZW50SW5wdXRJbnF1aXJ5SW5zYW5lSW5zZWN0SW5zaWRlSW5zcGlyZUluc3RhbGxJbnRhY3RJbnRlcmVzdEludG9JbnZlc3RJbnZpdGVJbnZvbHZlSXJvbklzbGFuZElzb2xhdGVJc3N1ZUl0ZW1Jdm9yeUphY2tldEphZ3VhckphckphenpKZWFsb3VzSmVhbnNKZWxseUpld2VsSm9iSm9pbkpva2VKb3VybmV5Sm95SnVkZ2VKdWljZUp1bXBKdW5nbGVKdW5pb3JKdW5rSnVzdEthbmdhcm9vS2VlbktlZXBLZXRjaHVwS2V5S2lja0tpZEtpZG5leUtpbmRLaW5nZG9tS2lzc0tpdEtpdGNoZW5LaXRlS2l0dGVuS2l3aUtuZWVLbmlmZUtub2NrS25vd0xhYkxhYmVsTGFib3JMYWRkZXJMYWR5TGFrZUxhbXBMYW5ndWFnZUxhcHRvcExhcmdlTGF0ZXJMYXRpbkxhdWdoTGF1bmRyeUxhdmFMYXdMYXduTGF3c3VpdExheWVyTGF6eUxlYWRlckxlYWZMZWFybkxlYXZlTGVjdHVyZUxlZnRMZWdMZWdhbExlZ2VuZExlaXN1cmVMZW1vbkxlbmRMZW5ndGhMZW5zTGVvcGFyZExlc3NvbkxldHRlckxldmVsTGlhckxpYmVydHlMaWJyYXJ5TGljZW5zZUxpZmVMaWZ0TGlnaHRMaWtlTGltYkxpbWl0TGlua0xpb25MaXF1aWRMaXN0TGl0dGxlTGl2ZUxpemFyZExvYWRMb2FuTG9ic3RlckxvY2FsTG9ja0xvZ2ljTG9uZWx5TG9uZ0xvb3BMb3R0ZXJ5TG91ZExvdW5nZUxvdmVMb3lhbEx1Y2t5THVnZ2FnZUx1bWJlckx1bmFyTHVuY2hMdXh1cnlMeXJpY3NNYWNoaW5lTWFkTWFnaWNNYWduZXRNYWlkTWFpbE1haW5NYWpvck1ha2VNYW1tYWxNYW5NYW5hZ2VNYW5kYXRlTWFuZ29NYW5zaW9uTWFudWFsTWFwbGVNYXJibGVNYXJjaE1hcmdpbk1hcmluZU1hcmtldE1hcnJpYWdlTWFza01hc3NNYXN0ZXJNYXRjaE1hdGVyaWFsTWF0aE1hdHJpeE1hdHRlck1heGltdW1NYXplTWVhZG93TWVhbk1lYXN1cmVNZWF0TWVjaGFuaWNNZWRhbE1lZGlhTWVsb2R5TWVsdE1lbWJlck1lbW9yeU1lbnRpb25NZW51TWVyY3lNZXJnZU1lcml0TWVycnlNZXNoTWVzc2FnZU1ldGFsTWV0aG9kTWlkZGxlTWlkbmlnaHRNaWxrTWlsbGlvbk1pbWljTWluZE1pbmltdW1NaW5vck1pbnV0ZU1pcmFjbGVNaXJyb3JNaXNlcnlNaXNzTWlzdGFrZU1peE1peGVkTWl4dHVyZU1vYmlsZU1vZGVsTW9kaWZ5TW9tTW9tZW50TW9uaXRvck1vbmtleU1vbnN0ZXJNb250aE1vb25Nb3JhbE1vcmVNb3JuaW5nTW9zcXVpdG9Nb3RoZXJNb3Rpb25Nb3Rvck1vdW50YWluTW91c2VNb3ZlTW92aWVNdWNoTXVmZmluTXVsZU11bHRpcGx5TXVzY2xlTXVzZXVtTXVzaHJvb21NdXNpY011c3RNdXR1YWxNeXNlbGZNeXN0ZXJ5TXl0aE5haXZlTmFtZU5hcGtpbk5hcnJvd05hc3R5TmF0aW9uTmF0dXJlTmVhck5lY2tOZWVkTmVnYXRpdmVOZWdsZWN0TmVpdGhlck5lcGhld05lcnZlTmVzdE5ldE5ldHdvcmtOZXV0cmFsTmV2ZXJOZXdzTmV4dE5pY2VOaWdodE5vYmxlTm9pc2VOb21pbmVlTm9vZGxlTm9ybWFsTm9ydGhOb3NlTm90YWJsZU5vdGVOb3RoaW5nTm90aWNlTm92ZWxOb3dOdWNsZWFyTnVtYmVyTnVyc2VOdXRPYWtPYmV5T2JqZWN0T2JsaWdlT2JzY3VyZU9ic2VydmVPYnRhaW5PYnZpb3VzT2NjdXJPY2Vhbk9jdG9iZXJPZG9yT2ZmT2ZmZXJPZmZpY2VPZnRlbk9pbE9rYXlPbGRPbGl2ZU9seW1waWNPbWl0T25jZU9uZU9uaW9uT25saW5lT25seU9wZW5PcGVyYU9waW5pb25PcHBvc2VPcHRpb25PcmFuZ2VPcmJpdE9yY2hhcmRPcmRlck9yZGluYXJ5T3JnYW5PcmllbnRPcmlnaW5hbE9ycGhhbk9zdHJpY2hPdGhlck91dGRvb3JPdXRlck91dHB1dE91dHNpZGVPdmFsT3Zlbk92ZXJPd25Pd25lck94eWdlbk95c3Rlck96b25lUGFjdFBhZGRsZVBhZ2VQYWlyUGFsYWNlUGFsbVBhbmRhUGFuZWxQYW5pY1BhbnRoZXJQYXBlclBhcmFkZVBhcmVudFBhcmtQYXJyb3RQYXJ0eVBhc3NQYXRjaFBhdGhQYXRpZW50UGF0cm9sUGF0dGVyblBhdXNlUGF2ZVBheW1lbnRQZWFjZVBlYW51dFBlYXJQZWFzYW50UGVsaWNhblBlblBlbmFsdHlQZW5jaWxQZW9wbGVQZXBwZXJQZXJmZWN0UGVybWl0UGVyc29uUGV0UGhvbmVQaG90b1BocmFzZVBoeXNpY2FsUGlhbm9QaWNuaWNQaWN0dXJlUGllY2VQaWdQaWdlb25QaWxsUGlsb3RQaW5rUGlvbmVlclBpcGVQaXN0b2xQaXRjaFBpenphUGxhY2VQbGFuZXRQbGFzdGljUGxhdGVQbGF5UGxlYXNlUGxlZGdlUGx1Y2tQbHVnUGx1bmdlUG9lbVBvZXRQb2ludFBvbGFyUG9sZVBvbGljZVBvbmRQb255UG9vbFBvcHVsYXJQb3J0aW9uUG9zaXRpb25Qb3NzaWJsZVBvc3RQb3RhdG9Qb3R0ZXJ5UG92ZXJ0eVBvd2RlclBvd2VyUHJhY3RpY2VQcmFpc2VQcmVkaWN0UHJlZmVyUHJlcGFyZVByZXNlbnRQcmV0dHlQcmV2ZW50UHJpY2VQcmlkZVByaW1hcnlQcmludFByaW9yaXR5UHJpc29uUHJpdmF0ZVByaXplUHJvYmxlbVByb2Nlc3NQcm9kdWNlUHJvZml0UHJvZ3JhbVByb2plY3RQcm9tb3RlUHJvb2ZQcm9wZXJ0eVByb3NwZXJQcm90ZWN0UHJvdWRQcm92aWRlUHVibGljUHVkZGluZ1B1bGxQdWxwUHVsc2VQdW1wa2luUHVuY2hQdXBpbFB1cHB5UHVyY2hhc2VQdXJpdHlQdXJwb3NlUHVyc2VQdXNoUHV0UHV6emxlUHlyYW1pZFF1YWxpdHlRdWFudHVtUXVhcnRlclF1ZXN0aW9uUXVpY2tRdWl0UXVpelF1b3RlUmFiYml0UmFjY29vblJhY2VSYWNrUmFkYXJSYWRpb1JhaWxSYWluUmFpc2VSYWxseVJhbXBSYW5jaFJhbmRvbVJhbmdlUmFwaWRSYXJlUmF0ZVJhdGhlclJhdmVuUmF3UmF6b3JSZWFkeVJlYWxSZWFzb25SZWJlbFJlYnVpbGRSZWNhbGxSZWNlaXZlUmVjaXBlUmVjb3JkUmVjeWNsZVJlZHVjZVJlZmxlY3RSZWZvcm1SZWZ1c2VSZWdpb25SZWdyZXRSZWd1bGFyUmVqZWN0UmVsYXhSZWxlYXNlUmVsaWVmUmVseVJlbWFpblJlbWVtYmVyUmVtaW5kUmVtb3ZlUmVuZGVyUmVuZXdSZW50UmVvcGVuUmVwYWlyUmVwZWF0UmVwbGFjZVJlcG9ydFJlcXVpcmVSZXNjdWVSZXNlbWJsZVJlc2lzdFJlc291cmNlUmVzcG9uc2VSZXN1bHRSZXRpcmVSZXRyZWF0UmV0dXJuUmV1bmlvblJldmVhbFJldmlld1Jld2FyZFJoeXRobVJpYlJpYmJvblJpY2VSaWNoUmlkZVJpZGdlUmlmbGVSaWdodFJpZ2lkUmluZ1Jpb3RSaXBwbGVSaXNrUml0dWFsUml2YWxSaXZlclJvYWRSb2FzdFJvYm90Um9idXN0Um9ja2V0Um9tYW5jZVJvb2ZSb29raWVSb29tUm9zZVJvdGF0ZVJvdWdoUm91bmRSb3V0ZVJveWFsUnViYmVyUnVkZVJ1Z1J1bGVSdW5SdW53YXlSdXJhbFNhZFNhZGRsZVNhZG5lc3NTYWZlU2FpbFNhbGFkU2FsbW9uU2Fsb25TYWx0U2FsdXRlU2FtZVNhbXBsZVNhbmRTYXRpc2Z5U2F0b3NoaVNhdWNlU2F1c2FnZVNhdmVTYXlTY2FsZVNjYW5TY2FyZVNjYXR0ZXJTY2VuZVNjaGVtZVNjaG9vbFNjaWVuY2VTY2lzc29yc1Njb3JwaW9uU2NvdXRTY3JhcFNjcmVlblNjcmlwdFNjcnViU2VhU2VhcmNoU2Vhc29uU2VhdFNlY29uZFNlY3JldFNlY3Rpb25TZWN1cml0eVNlZWRTZWVrU2VnbWVudFNlbGVjdFNlbGxTZW1pbmFyU2VuaW9yU2Vuc2VTZW50ZW5jZVNlcmllc1NlcnZpY2VTZXNzaW9uU2V0dGxlU2V0dXBTZXZlblNoYWRvd1NoYWZ0U2hhbGxvd1NoYXJlU2hlZFNoZWxsU2hlcmlmZlNoaWVsZFNoaWZ0U2hpbmVTaGlwU2hpdmVyU2hvY2tTaG9lU2hvb3RTaG9wU2hvcnRTaG91bGRlclNob3ZlU2hyaW1wU2hydWdTaHVmZmxlU2h5U2libGluZ1NpY2tTaWRlU2llZ2VTaWdodFNpZ25TaWxlbnRTaWxrU2lsbHlTaWx2ZXJTaW1pbGFyU2ltcGxlU2luY2VTaW5nU2lyZW5TaXN0ZXJTaXR1YXRlU2l4U2l6ZVNrYXRlU2tldGNoU2tpU2tpbGxTa2luU2tpcnRTa3VsbFNsYWJTbGFtU2xlZXBTbGVuZGVyU2xpY2VTbGlkZVNsaWdodFNsaW1TbG9nYW5TbG90U2xvd1NsdXNoU21hbGxTbWFydFNtaWxlU21va2VTbW9vdGhTbmFja1NuYWtlU25hcFNuaWZmU25vd1NvYXBTb2NjZXJTb2NpYWxTb2NrU29kYVNvZnRTb2xhclNvbGRpZXJTb2xpZFNvbHV0aW9uU29sdmVTb21lb25lU29uZ1Nvb25Tb3JyeVNvcnRTb3VsU291bmRTb3VwU291cmNlU291dGhTcGFjZVNwYXJlU3BhdGlhbFNwYXduU3BlYWtTcGVjaWFsU3BlZWRTcGVsbFNwZW5kU3BoZXJlU3BpY2VTcGlkZXJTcGlrZVNwaW5TcGlyaXRTcGxpdFNwb2lsU3BvbnNvclNwb29uU3BvcnRTcG90U3ByYXlTcHJlYWRTcHJpbmdTcHlTcXVhcmVTcXVlZXplU3F1aXJyZWxTdGFibGVTdGFkaXVtU3RhZmZTdGFnZVN0YWlyc1N0YW1wU3RhbmRTdGFydFN0YXRlU3RheVN0ZWFrU3RlZWxTdGVtU3RlcFN0ZXJlb1N0aWNrU3RpbGxTdGluZ1N0b2NrU3RvbWFjaFN0b25lU3Rvb2xTdG9yeVN0b3ZlU3RyYXRlZ3lTdHJlZXRTdHJpa2VTdHJvbmdTdHJ1Z2dsZVN0dWRlbnRTdHVmZlN0dW1ibGVTdHlsZVN1YmplY3RTdWJtaXRTdWJ3YXlTdWNjZXNzU3VjaFN1ZGRlblN1ZmZlclN1Z2FyU3VnZ2VzdFN1aXRTdW1tZXJTdW5TdW5ueVN1bnNldFN1cGVyU3VwcGx5U3VwcmVtZVN1cmVTdXJmYWNlU3VyZ2VTdXJwcmlzZVN1cnJvdW5kU3VydmV5U3VzcGVjdFN1c3RhaW5Td2FsbG93U3dhbXBTd2FwU3dhcm1Td2VhclN3ZWV0U3dpZnRTd2ltU3dpbmdTd2l0Y2hTd29yZFN5bWJvbFN5bXB0b21TeXJ1cFN5c3RlbVRhYmxlVGFja2xlVGFnVGFpbFRhbGVudFRhbGtUYW5rVGFwZVRhcmdldFRhc2tUYXN0ZVRhdHRvb1RheGlUZWFjaFRlYW1UZWxsVGVuVGVuYW50VGVubmlzVGVudFRlcm1UZXN0VGV4dFRoYW5rVGhhdFRoZW1lVGhlblRoZW9yeVRoZXJlVGhleVRoaW5nVGhpc1Rob3VnaHRUaHJlZVRocml2ZVRocm93VGh1bWJUaHVuZGVyVGlja2V0VGlkZVRpZ2VyVGlsdFRpbWJlclRpbWVUaW55VGlwVGlyZWRUaXNzdWVUaXRsZVRvYXN0VG9iYWNjb1RvZGF5VG9kZGxlclRvZVRvZ2V0aGVyVG9pbGV0VG9rZW5Ub21hdG9Ub21vcnJvd1RvbmVUb25ndWVUb25pZ2h0VG9vbFRvb3RoVG9wVG9waWNUb3BwbGVUb3JjaFRvcm5hZG9Ub3J0b2lzZVRvc3NUb3RhbFRvdXJpc3RUb3dhcmRUb3dlclRvd25Ub3lUcmFja1RyYWRlVHJhZmZpY1RyYWdpY1RyYWluVHJhbnNmZXJUcmFwVHJhc2hUcmF2ZWxUcmF5VHJlYXRUcmVlVHJlbmRUcmlhbFRyaWJlVHJpY2tUcmlnZ2VyVHJpbVRyaXBUcm9waHlUcm91YmxlVHJ1Y2tUcnVlVHJ1bHlUcnVtcGV0VHJ1c3RUcnV0aFRyeVR1YmVUdWl0aW9uVHVtYmxlVHVuYVR1bm5lbFR1cmtleVR1cm5UdXJ0bGVUd2VsdmVUd2VudHlUd2ljZVR3aW5Ud2lzdFR3b1R5cGVUeXBpY2FsVWdseVVtYnJlbGxhVW5hYmxlVW5hd2FyZVVuY2xlVW5jb3ZlclVuZGVyVW5kb1VuZmFpclVuZm9sZFVuaGFwcHlVbmlmb3JtVW5pcXVlVW5pdFVuaXZlcnNlVW5rbm93blVubG9ja1VudGlsVW51c3VhbFVudmVpbFVwZGF0ZVVwZ3JhZGVVcGhvbGRVcG9uVXBwZXJVcHNldFVyYmFuVXJnZVVzYWdlVXNlVXNlZFVzZWZ1bFVzZWxlc3NVc3VhbFV0aWxpdHlWYWNhbnRWYWN1dW1WYWd1ZVZhbGlkVmFsbGV5VmFsdmVWYW5WYW5pc2hWYXBvclZhcmlvdXNWYXN0VmF1bHRWZWhpY2xlVmVsdmV0VmVuZG9yVmVudHVyZVZlbnVlVmVyYlZlcmlmeVZlcnNpb25WZXJ5VmVzc2VsVmV0ZXJhblZpYWJsZVZpYnJhbnRWaWNpb3VzVmljdG9yeVZpZGVvVmlld1ZpbGxhZ2VWaW50YWdlVmlvbGluVmlydHVhbFZpcnVzVmlzYVZpc2l0VmlzdWFsVml0YWxWaXZpZFZvY2FsVm9pY2VWb2lkVm9sY2Fub1ZvbHVtZVZvdGVWb3lhZ2VXYWdlV2Fnb25XYWl0V2Fsa1dhbGxXYWxudXRXYW50V2FyZmFyZVdhcm1XYXJyaW9yV2FzaFdhc3BXYXN0ZVdhdGVyV2F2ZVdheVdlYWx0aFdlYXBvbldlYXJXZWFzZWxXZWF0aGVyV2ViV2VkZGluZ1dlZWtlbmRXZWlyZFdlbGNvbWVXZXN0V2V0V2hhbGVXaGF0V2hlYXRXaGVlbFdoZW5XaGVyZVdoaXBXaGlzcGVyV2lkZVdpZHRoV2lmZVdpbGRXaWxsV2luV2luZG93V2luZVdpbmdXaW5rV2lubmVyV2ludGVyV2lyZVdpc2RvbVdpc2VXaXNoV2l0bmVzc1dvbGZXb21hbldvbmRlcldvb2RXb29sV29yZFdvcmtXb3JsZFdvcnJ5V29ydGhXcmFwV3JlY2tXcmVzdGxlV3Jpc3RXcml0ZVdyb25nWWFyZFllYXJZZWxsb3dZb3VZb3VuZ1lvdXRoWmVicmFaZXJvWm9uZVpvb1wiLHU9bnVsbDtmdW5jdGlvbiBsKGUpe2lmKG51bGw9PXUmJih1PWEucmVwbGFjZSgvKFtBLVpdKS9nLFwiICQxXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDEpLnNwbGl0KFwiIFwiKSxcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiIT09cy5jaGVjayhlKSkpdGhyb3cgdT1udWxsLG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBlbiAoRW5nbGlzaCkgRkFJTEVEXCIpfWZ1bmN0aW9uIGgoKXtyZXR1cm4gby5jYWxsKHRoaXMsXCJlblwiKXx8dGhpc312YXIgZj1uZXcobz1zLldvcmRsaXN0LGkoaCxvKSxoLnByb3RvdHlwZS5nZXRXb3JkPWZ1bmN0aW9uKGUpe3JldHVybiBsKHRoaXMpLHVbZV19LGgucHJvdG90eXBlLmdldFdvcmRJbmRleD1mdW5jdGlvbihlKXtyZXR1cm4gbCh0aGlzKSx1LmluZGV4T2YoZSl9LGgpO3IubGFuZ0VuPWYscy5yZWdpc3RlcihmKX0se1wiLi4vdXRpbHMvd29yZGxpc3RcIjo4N31dfSx7fSxbN10pKDcpfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMubWluLmpzLm1hcFxuIiwiLyoqXG4gKiBbanMtc2hhMjU2XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTI1Nn1cbiAqXG4gKiBAdmVyc2lvbiAwLjkuMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE3XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBFUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTI1Nl9OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTI1Nl9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHtcbiAgICByb290ID0gc2VsZjtcbiAgfVxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBMjU2X05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG4gIHZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xuICB2YXIgSyA9IFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbiAgXTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2FycmF5JywgJ2RpZ2VzdCcsICdhcnJheUJ1ZmZlciddO1xuXG4gIHZhciBibG9ja3MgPSBbXTtcblxuICBpZiAocm9vdC5KU19TSEEyNTZfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBMjU2X05PX0FSUkFZX0JVRkZFUl9JU19WSUVXIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgaXMyMjQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMjU2KGlzMjI0LCB0cnVlKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoaXMyMjQpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKCdoZXgnLCBpczIyNCk7XG4gICAgaWYgKE5PREVfSlMpIHtcbiAgICAgIG1ldGhvZCA9IG5vZGVXcmFwKG1ldGhvZCwgaXMyMjQpO1xuICAgIH1cbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGEyNTYoaXMyMjQpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZCh0eXBlLCBpczIyNCk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIG5vZGVXcmFwID0gZnVuY3Rpb24gKG1ldGhvZCwgaXMyMjQpIHtcbiAgICB2YXIgY3J5cHRvID0gKDAsZXZhbCkoXCJyZXF1aXJlKCdjcnlwdG8nKVwiKTtcbiAgICB2YXIgQnVmZmVyID0gKDAsZXZhbCkoXCJyZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcIik7XG4gICAgdmFyIGFsZ29yaXRobSA9IGlzMjI0ID8gJ3NoYTIyNCcgOiAnc2hhMjU2JztcbiAgICB2YXIgbm9kZU1ldGhvZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShtZXNzYWdlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkgfHxcbiAgICAgICAgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pLnVwZGF0ZShuZXcgQnVmZmVyKG1lc3NhZ2UpKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBub2RlTWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKG91dHB1dFR5cGUsIGlzMjI0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgSG1hY1NoYTI1NihrZXksIGlzMjI0LCB0cnVlKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVIbWFjTWV0aG9kID0gZnVuY3Rpb24gKGlzMjI0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QoJ2hleCcsIGlzMjI0KTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG5ldyBIbWFjU2hhMjU2KGtleSwgaXMyMjQpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSkudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlSG1hY091dHB1dE1ldGhvZCh0eXBlLCBpczIyNCk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgZnVuY3Rpb24gU2hhMjU2KGlzMjI0LCBzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJsb2NrcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB9XG5cbiAgICBpZiAoaXMyMjQpIHtcbiAgICAgIHRoaXMuaDAgPSAweGMxMDU5ZWQ4O1xuICAgICAgdGhpcy5oMSA9IDB4MzY3Y2Q1MDc7XG4gICAgICB0aGlzLmgyID0gMHgzMDcwZGQxNztcbiAgICAgIHRoaXMuaDMgPSAweGY3MGU1OTM5O1xuICAgICAgdGhpcy5oNCA9IDB4ZmZjMDBiMzE7XG4gICAgICB0aGlzLmg1ID0gMHg2ODU4MTUxMTtcbiAgICAgIHRoaXMuaDYgPSAweDY0Zjk4ZmE3O1xuICAgICAgdGhpcy5oNyA9IDB4YmVmYTRmYTQ7XG4gICAgfSBlbHNlIHsgLy8gMjU2XG4gICAgICB0aGlzLmgwID0gMHg2YTA5ZTY2NztcbiAgICAgIHRoaXMuaDEgPSAweGJiNjdhZTg1O1xuICAgICAgdGhpcy5oMiA9IDB4M2M2ZWYzNzI7XG4gICAgICB0aGlzLmgzID0gMHhhNTRmZjUzYTtcbiAgICAgIHRoaXMuaDQgPSAweDUxMGU1MjdmO1xuICAgICAgdGhpcy5oNSA9IDB4OWIwNTY4OGM7XG4gICAgICB0aGlzLmg2ID0gMHgxZjgzZDlhYjtcbiAgICAgIHRoaXMuaDcgPSAweDViZTBjZDE5O1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2sgPSB0aGlzLnN0YXJ0ID0gdGhpcy5ieXRlcyA9IHRoaXMuaEJ5dGVzID0gMDtcbiAgICB0aGlzLmZpbmFsaXplZCA9IHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5maXJzdCA9IHRydWU7XG4gICAgdGhpcy5pczIyNCA9IGlzMjI0O1xuICB9XG5cbiAgU2hhMjU2LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNvZGUsIGluZGV4ID0gMCwgaSwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5oYXNoZWQpIHtcbiAgICAgICAgdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgYmxvY2tzWzE2XSA9IGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9XG4gICAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgICAgYmxvY2tzWzEyXSA9IGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKGkgPj0gNjQpIHtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gNjQ7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICB0aGlzLmhhc2hlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYnl0ZXMgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICB0aGlzLmhCeXRlcyArPSB0aGlzLmJ5dGVzIC8gNDI5NDk2NzI5NiA8PCAwO1xuICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgJSA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4O1xuICAgIGJsb2Nrc1sxNl0gPSB0aGlzLmJsb2NrO1xuICAgIGJsb2Nrc1tpID4+IDJdIHw9IEVYVFJBW2kgJiAzXTtcbiAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICBpZiAoaSA+PSA1Nikge1xuICAgICAgaWYgKCF0aGlzLmhhc2hlZCkge1xuICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgIH1cbiAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgYmxvY2tzWzRdID0gYmxvY2tzWzVdID0gYmxvY2tzWzZdID0gYmxvY2tzWzddID1cbiAgICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICB9XG4gICAgYmxvY2tzWzE0XSA9IHRoaXMuaEJ5dGVzIDw8IDMgfCB0aGlzLmJ5dGVzID4+PiAyOTtcbiAgICBibG9ja3NbMTVdID0gdGhpcy5ieXRlcyA8PCAzO1xuICAgIHRoaXMuaGFzaCgpO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IHRoaXMuaDAsIGIgPSB0aGlzLmgxLCBjID0gdGhpcy5oMiwgZCA9IHRoaXMuaDMsIGUgPSB0aGlzLmg0LCBmID0gdGhpcy5oNSwgZyA9IHRoaXMuaDYsXG4gICAgICBoID0gdGhpcy5oNywgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGosIHMwLCBzMSwgbWFqLCB0MSwgdDIsIGNoLCBhYiwgZGEsIGNkLCBiYztcblxuICAgIGZvciAoaiA9IDE2OyBqIDwgNjQ7ICsraikge1xuICAgICAgLy8gcmlnaHRyb3RhdGVcbiAgICAgIHQxID0gYmxvY2tzW2ogLSAxNV07XG4gICAgICBzMCA9ICgodDEgPj4+IDcpIHwgKHQxIDw8IDI1KSkgXiAoKHQxID4+PiAxOCkgfCAodDEgPDwgMTQpKSBeICh0MSA+Pj4gMyk7XG4gICAgICB0MSA9IGJsb2Nrc1tqIC0gMl07XG4gICAgICBzMSA9ICgodDEgPj4+IDE3KSB8ICh0MSA8PCAxNSkpIF4gKCh0MSA+Pj4gMTkpIHwgKHQxIDw8IDEzKSkgXiAodDEgPj4+IDEwKTtcbiAgICAgIGJsb2Nrc1tqXSA9IGJsb2Nrc1tqIC0gMTZdICsgczAgKyBibG9ja3NbaiAtIDddICsgczEgPDwgMDtcbiAgICB9XG5cbiAgICBiYyA9IGIgJiBjO1xuICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaiArPSA0KSB7XG4gICAgICBpZiAodGhpcy5maXJzdCkge1xuICAgICAgICBpZiAodGhpcy5pczIyNCkge1xuICAgICAgICAgIGFiID0gMzAwMDMyO1xuICAgICAgICAgIHQxID0gYmxvY2tzWzBdIC0gMTQxMzI1NzgxOTtcbiAgICAgICAgICBoID0gdDEgLSAxNTAwNTQ1OTkgPDwgMDtcbiAgICAgICAgICBkID0gdDEgKyAyNDE3NzA3NyA8PCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFiID0gNzA0NzUxMTA5O1xuICAgICAgICAgIHQxID0gYmxvY2tzWzBdIC0gMjEwMjQ0MjQ4O1xuICAgICAgICAgIGggPSB0MSAtIDE1MjE0ODY1MzQgPDwgMDtcbiAgICAgICAgICBkID0gdDEgKyAxNDM2OTQ1NjUgPDwgMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9ICgoYSA+Pj4gMikgfCAoYSA8PCAzMCkpIF4gKChhID4+PiAxMykgfCAoYSA8PCAxOSkpIF4gKChhID4+PiAyMikgfCAoYSA8PCAxMCkpO1xuICAgICAgICBzMSA9ICgoZSA+Pj4gNikgfCAoZSA8PCAyNikpIF4gKChlID4+PiAxMSkgfCAoZSA8PCAyMSkpIF4gKChlID4+PiAyNSkgfCAoZSA8PCA3KSk7XG4gICAgICAgIGFiID0gYSAmIGI7XG4gICAgICAgIG1haiA9IGFiIF4gKGEgJiBjKSBeIGJjO1xuICAgICAgICBjaCA9IChlICYgZikgXiAofmUgJiBnKTtcbiAgICAgICAgdDEgPSBoICsgczEgKyBjaCArIEtbal0gKyBibG9ja3Nbal07XG4gICAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICAgIGggPSBkICsgdDEgPDwgMDtcbiAgICAgICAgZCA9IHQxICsgdDIgPDwgMDtcbiAgICAgIH1cbiAgICAgIHMwID0gKChkID4+PiAyKSB8IChkIDw8IDMwKSkgXiAoKGQgPj4+IDEzKSB8IChkIDw8IDE5KSkgXiAoKGQgPj4+IDIyKSB8IChkIDw8IDEwKSk7XG4gICAgICBzMSA9ICgoaCA+Pj4gNikgfCAoaCA8PCAyNikpIF4gKChoID4+PiAxMSkgfCAoaCA8PCAyMSkpIF4gKChoID4+PiAyNSkgfCAoaCA8PCA3KSk7XG4gICAgICBkYSA9IGQgJiBhO1xuICAgICAgbWFqID0gZGEgXiAoZCAmIGIpIF4gYWI7XG4gICAgICBjaCA9IChoICYgZSkgXiAofmggJiBmKTtcbiAgICAgIHQxID0gZyArIHMxICsgY2ggKyBLW2ogKyAxXSArIGJsb2Nrc1tqICsgMV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgZyA9IGMgKyB0MSA8PCAwO1xuICAgICAgYyA9IHQxICsgdDIgPDwgMDtcbiAgICAgIHMwID0gKChjID4+PiAyKSB8IChjIDw8IDMwKSkgXiAoKGMgPj4+IDEzKSB8IChjIDw8IDE5KSkgXiAoKGMgPj4+IDIyKSB8IChjIDw8IDEwKSk7XG4gICAgICBzMSA9ICgoZyA+Pj4gNikgfCAoZyA8PCAyNikpIF4gKChnID4+PiAxMSkgfCAoZyA8PCAyMSkpIF4gKChnID4+PiAyNSkgfCAoZyA8PCA3KSk7XG4gICAgICBjZCA9IGMgJiBkO1xuICAgICAgbWFqID0gY2QgXiAoYyAmIGEpIF4gZGE7XG4gICAgICBjaCA9IChnICYgaCkgXiAofmcgJiBlKTtcbiAgICAgIHQxID0gZiArIHMxICsgY2ggKyBLW2ogKyAyXSArIGJsb2Nrc1tqICsgMl07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgZiA9IGIgKyB0MSA8PCAwO1xuICAgICAgYiA9IHQxICsgdDIgPDwgMDtcbiAgICAgIHMwID0gKChiID4+PiAyKSB8IChiIDw8IDMwKSkgXiAoKGIgPj4+IDEzKSB8IChiIDw8IDE5KSkgXiAoKGIgPj4+IDIyKSB8IChiIDw8IDEwKSk7XG4gICAgICBzMSA9ICgoZiA+Pj4gNikgfCAoZiA8PCAyNikpIF4gKChmID4+PiAxMSkgfCAoZiA8PCAyMSkpIF4gKChmID4+PiAyNSkgfCAoZiA8PCA3KSk7XG4gICAgICBiYyA9IGIgJiBjO1xuICAgICAgbWFqID0gYmMgXiAoYiAmIGQpIF4gY2Q7XG4gICAgICBjaCA9IChmICYgZykgXiAofmYgJiBoKTtcbiAgICAgIHQxID0gZSArIHMxICsgY2ggKyBLW2ogKyAzXSArIGJsb2Nrc1tqICsgM107XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgZSA9IGEgKyB0MSA8PCAwO1xuICAgICAgYSA9IHQxICsgdDIgPDwgMDtcbiAgICB9XG5cbiAgICB0aGlzLmgwID0gdGhpcy5oMCArIGEgPDwgMDtcbiAgICB0aGlzLmgxID0gdGhpcy5oMSArIGIgPDwgMDtcbiAgICB0aGlzLmgyID0gdGhpcy5oMiArIGMgPDwgMDtcbiAgICB0aGlzLmgzID0gdGhpcy5oMyArIGQgPDwgMDtcbiAgICB0aGlzLmg0ID0gdGhpcy5oNCArIGUgPDwgMDtcbiAgICB0aGlzLmg1ID0gdGhpcy5oNSArIGYgPDwgMDtcbiAgICB0aGlzLmg2ID0gdGhpcy5oNiArIGcgPDwgMDtcbiAgICB0aGlzLmg3ID0gdGhpcy5oNyArIGggPDwgMDtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQsIGg1ID0gdGhpcy5oNSxcbiAgICAgIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuXG4gICAgdmFyIGhleCA9IEhFWF9DSEFSU1soaDAgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDAgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgwID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gwICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDEgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDEgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMiA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMiAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgzID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gzICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDQgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDQgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNSA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNSA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNSA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg2ID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g2ICYgMHgwRl07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICBoZXggKz0gSEVYX0NIQVJTWyhoNyA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDcgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNyA+PiAxNikgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3ID4+IDgpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDcgJiAweDBGXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLnRvU3RyaW5nID0gU2hhMjU2LnByb3RvdHlwZS5oZXg7XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0LCBoNSA9IHRoaXMuaDUsXG4gICAgICBoNiA9IHRoaXMuaDYsIGg3ID0gdGhpcy5oNztcblxuICAgIHZhciBhcnIgPSBbXG4gICAgICAoaDAgPj4gMjQpICYgMHhGRiwgKGgwID4+IDE2KSAmIDB4RkYsIChoMCA+PiA4KSAmIDB4RkYsIGgwICYgMHhGRixcbiAgICAgIChoMSA+PiAyNCkgJiAweEZGLCAoaDEgPj4gMTYpICYgMHhGRiwgKGgxID4+IDgpICYgMHhGRiwgaDEgJiAweEZGLFxuICAgICAgKGgyID4+IDI0KSAmIDB4RkYsIChoMiA+PiAxNikgJiAweEZGLCAoaDIgPj4gOCkgJiAweEZGLCBoMiAmIDB4RkYsXG4gICAgICAoaDMgPj4gMjQpICYgMHhGRiwgKGgzID4+IDE2KSAmIDB4RkYsIChoMyA+PiA4KSAmIDB4RkYsIGgzICYgMHhGRixcbiAgICAgIChoNCA+PiAyNCkgJiAweEZGLCAoaDQgPj4gMTYpICYgMHhGRiwgKGg0ID4+IDgpICYgMHhGRiwgaDQgJiAweEZGLFxuICAgICAgKGg1ID4+IDI0KSAmIDB4RkYsIChoNSA+PiAxNikgJiAweEZGLCAoaDUgPj4gOCkgJiAweEZGLCBoNSAmIDB4RkYsXG4gICAgICAoaDYgPj4gMjQpICYgMHhGRiwgKGg2ID4+IDE2KSAmIDB4RkYsIChoNiA+PiA4KSAmIDB4RkYsIGg2ICYgMHhGRlxuICAgIF07XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICBhcnIucHVzaCgoaDcgPj4gMjQpICYgMHhGRiwgKGg3ID4+IDE2KSAmIDB4RkYsIChoNyA+PiA4KSAmIDB4RkYsIGg3ICYgMHhGRik7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5hcnJheSA9IFNoYTI1Ni5wcm90b3R5cGUuZGlnZXN0O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmlzMjI0ID8gMjggOiAzMik7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDAsIHRoaXMuaDApO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig0LCB0aGlzLmgxKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoOCwgdGhpcy5oMik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDEyLCB0aGlzLmgzKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTYsIHRoaXMuaDQpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigyMCwgdGhpcy5oNSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDI0LCB0aGlzLmg2KTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMigyOCwgdGhpcy5oNyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgZnVuY3Rpb24gSG1hY1NoYTI1NihrZXksIGlzMjI0LCBzaGFyZWRNZW1vcnkpIHtcbiAgICB2YXIgaSwgdHlwZSA9IHR5cGVvZiBrZXk7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBbXSwgbGVuZ3RoID0ga2V5Lmxlbmd0aCwgaW5kZXggPSAwLCBjb2RlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4YzAgfCAoY29kZSA+PiA2KSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweGUwIHwgKGNvZGUgPj4gMTIpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrZXkgPSBieXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBrZXkuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAga2V5ID0gbmV3IFVpbnQ4QXJyYXkoa2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5Lmxlbmd0aCA+IDY0KSB7XG4gICAgICBrZXkgPSAobmV3IFNoYTI1NihpczIyNCwgdHJ1ZSkpLnVwZGF0ZShrZXkpLmFycmF5KCk7XG4gICAgfVxuXG4gICAgdmFyIG9LZXlQYWQgPSBbXSwgaUtleVBhZCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICB2YXIgYiA9IGtleVtpXSB8fCAwO1xuICAgICAgb0tleVBhZFtpXSA9IDB4NWMgXiBiO1xuICAgICAgaUtleVBhZFtpXSA9IDB4MzYgXiBiO1xuICAgIH1cblxuICAgIFNoYTI1Ni5jYWxsKHRoaXMsIGlzMjI0LCBzaGFyZWRNZW1vcnkpO1xuXG4gICAgdGhpcy51cGRhdGUoaUtleVBhZCk7XG4gICAgdGhpcy5vS2V5UGFkID0gb0tleVBhZDtcbiAgICB0aGlzLmlubmVyID0gdHJ1ZTtcbiAgICB0aGlzLnNoYXJlZE1lbW9yeSA9IHNoYXJlZE1lbW9yeTtcbiAgfVxuICBIbWFjU2hhMjU2LnByb3RvdHlwZSA9IG5ldyBTaGEyNTYoKTtcblxuICBIbWFjU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuaW5uZXIpIHtcbiAgICAgIHRoaXMuaW5uZXIgPSBmYWxzZTtcbiAgICAgIHZhciBpbm5lckhhc2ggPSB0aGlzLmFycmF5KCk7XG4gICAgICBTaGEyNTYuY2FsbCh0aGlzLCB0aGlzLmlzMjI0LCB0aGlzLnNoYXJlZE1lbW9yeSk7XG4gICAgICB0aGlzLnVwZGF0ZSh0aGlzLm9LZXlQYWQpO1xuICAgICAgdGhpcy51cGRhdGUoaW5uZXJIYXNoKTtcbiAgICAgIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGV4cG9ydHMgPSBjcmVhdGVNZXRob2QoKTtcbiAgZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzO1xuICBleHBvcnRzLnNoYTIyNCA9IGNyZWF0ZU1ldGhvZCh0cnVlKTtcbiAgZXhwb3J0cy5zaGEyNTYuaG1hYyA9IGNyZWF0ZUhtYWNNZXRob2QoKTtcbiAgZXhwb3J0cy5zaGEyMjQuaG1hYyA9IGNyZWF0ZUhtYWNNZXRob2QodHJ1ZSk7XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICByb290LnNoYTI1NiA9IGV4cG9ydHMuc2hhMjU2O1xuICAgIHJvb3Quc2hhMjI0ID0gZXhwb3J0cy5zaGEyMjQ7XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iXSwicHJlRXhpc3RpbmdDb21tZW50IjoiLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJBc01pZGRsZXdhcmUuanMubWFwIn0=
